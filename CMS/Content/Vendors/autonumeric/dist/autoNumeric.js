(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["AutoNumeric"] = factory();
	else
		root["AutoNumeric"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(8);
	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *               AutoNumeric.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @version      4.1.0-beta.1\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @date         2017-08-11 UTC 21:45\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @authors      Bob Knothe, Alexandre Bonneau\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @contributors Sokolov Yura and others, cf. AUTHORS\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @copyright    2009 Robert J. Knothe http://www.decorplanit.com/plugin/\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @since        2009-08-09\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @summary      autoNumeric is a standalone Javascript library\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *               that provides live *as-you-type* formatting for\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *               international numbers and currencies.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *               Note : Some functions are borrowed from big.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @link         https://github.com/MikeMcl/big.js/\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Please report any bugs to https://github.com/autoNumeric/autoNumeric\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @license      Released under the MIT License\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @link         http://www.opensource.org/licenses/mit-license.php\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * obtaining a copy of this software and associated documentation\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * files (the \"Software\"), to deal in the Software without\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * restriction, including without limitation the rights to use,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copy, modify, merge, publish, distribute, sub license, and/or sell\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Software is furnished to do so, subject to the following\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * conditions:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * included in all copies or substantial portions of the Software.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OTHER DEALINGS IN THE SOFTWARE.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n/* global module */\n\n//TODO Prevent having to enter relative path in the js files (ie. using `./AutoNumericHelper` instead of just `AutoNumericHelper`) (cf. http://moduscreate.com/es6-es2015-import-no-relative-path-webpack/)\n\n\nvar _AutoNumericHelper = __webpack_require__(3);\n\nvar _AutoNumericHelper2 = _interopRequireDefault(_AutoNumericHelper);\n\nvar _AutoNumericEnum = __webpack_require__(2);\n\nvar _AutoNumericEnum2 = _interopRequireDefault(_AutoNumericEnum);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Class declaration for the AutoNumeric object.\n *\n * An AutoNumeric element is an object wrapper that keeps a reference to the DOM element it manages (usually an <input> one), and provides autoNumeric-specific variables and functions.\n */\nvar AutoNumeric = function () {\n    //TODO Use the better notation `export default class` when webpack and babel will allow it (cf. https://github.com/webpack/webpack/issues/706)\n    /**\n     * Initialize the AutoNumeric object onto the given DOM element, and attach the settings and related event listeners to it.\n     * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: '€ '})\n     *\n     * @example\n     * anElement = new AutoNumeric(domElement); // With the default options\n     * anElement = new AutoNumeric(domElement, { options }); // With one option object\n     * anElement = new AutoNumeric(domElement, 'euroPos'); // With a named pre-defined string\n     * anElement = new AutoNumeric(domElement, [{ options1 }, 'euroPos', { options2 }]); // With multiple option objects (the latest option overwriting the previous ones)\n     * anElement = new AutoNumeric(domElement, null, { options }); // With one option object, and a failed initial value\n     * anElement = new AutoNumeric(domElement).french(); // With one pre-defined language object\n     * anElement = new AutoNumeric(domElement).french({ options });// With one pre-defined language object and additional options that will override the defaults\n     *\n     * // ...or init and set the value in one call :\n     * anElement = new AutoNumeric(domElement, 12345.789); // With the default options, and an initial value\n     * anElement = new AutoNumeric(domElement, 12345.789, { options });\n     * anElement = new AutoNumeric(domElement, '12345.789', { options });\n     * anElement = new AutoNumeric(domElement, 12345.789, 'euroPos');\n     * anElement = new AutoNumeric(domElement, 12345.789, [{ options1 }, 'euroPos', { options2 }]);\n     * anElement = new AutoNumeric(domElement, 12345.789).french({ options });\n     * anElement = new AutoNumeric(domElement, 12345.789, { options }).french({ options }); // Not really helpful, but possible\n     *\n     * // The AutoNumeric constructor class can also accept a string as a css selector. Under the hood this use `QuerySelector` and limit itself to only the first element it finds.\n     * anElement = new AutoNumeric('.myCssClass > input');\n     * anElement = new AutoNumeric('.myCssClass > input', { options });\n     * anElement = new AutoNumeric('.myCssClass > input', 'euroPos');\n     * anElement = new AutoNumeric('.myCssClass > input', [{ options1 }, 'euroPos', { options2 }]);\n     * anElement = new AutoNumeric('.myCssClass > input', 12345.789);\n     * anElement = new AutoNumeric('.myCssClass > input', 12345.789, { options });\n     * anElement = new AutoNumeric('.myCssClass > input', 12345.789, 'euroPos');\n     * anElement = new AutoNumeric('.myCssClass > input', 12345.789, [{ options1 }, 'euroPos', { options2 }]);\n     * anElement = new AutoNumeric('.myCssClass > input', null, { options }); // With a failed initial value\n     * anElement = new AutoNumeric('.myCssClass > input', 12345.789).french({ options });\n     *\n     * @param {object|Array|number|string} arg1\n     * @param {object|Array|number|string|null} arg2\n     * @param {object|Array|number|string|null} arg3\n     * @throws\n     */\n    function AutoNumeric() {\n        var arg1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n        var _this = this;\n\n        var arg2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var arg3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        _classCallCheck(this, AutoNumeric);\n\n        // --------------------------------------------------------\n        // -------------- Initialization\n        // Initialize the arguments\n        var _AutoNumeric$_setArgu = AutoNumeric._setArgumentsValues(arg1, arg2, arg3),\n            domElement = _AutoNumeric$_setArgu.domElement,\n            initialValue = _AutoNumeric$_setArgu.initialValue,\n            userOptions = _AutoNumeric$_setArgu.userOptions;\n\n        // Initialize the element\n\n\n        this.domElement = domElement;\n\n        // Generate the settings\n        this.defaultRawValue = ''; // The default raw value to set when initializing an AutoNumeric object\n        this._setSettings(userOptions, false);\n        //TODO If `styleRules` is not null, add by default a class 'autoNumeric' that adds transition to color, background-color, border-color properties\n        // Check if the DOM element is supported\n        this._checkElement();\n\n        // Store the additional attributes inside the AutoNumeric object\n        // Note: This variable is needed and not a duplicate of `initialValueOnKeydown` nor `valueOnFocus` since it serves a different purpose and has a different lifecycle\n        this.savedCancellableValue = null;\n\n        // Initialize the undo/redo variables\n        this.historyTable = []; // Keep track of *all* valid states of the element value\n        this.historyTableIndex = -1; // Pointer to the current undo/redo state. This will be set to '0' during initialization since it first adds itself.\n        this.onGoingRedo = false; // Variable that keeps track if a 'redo' is ongoing (in order to prevent an 'undo' to be launch when releasing the shift key before the ctrl key after a 'redo' shortcut)\n\n        // Initialize the parent form element, if any\n        this.parentForm = this._getParentForm();\n\n        // Set the initial value if it exists and if the `formatOnPageLoad` option will allow it\n        if (!this.runOnce && this.settings.formatOnPageLoad) {\n            // Format the element value if needed\n            this._formatDefaultValueOnPageLoad(initialValue);\n        }\n\n        this.runOnce = true;\n\n        // Add the events listeners only on input elements\n        if (this.isInputElement || this.isContentEditable) {\n            if (!this.settings.noEventListeners) {\n                //XXX Here we make sure the global list is created after creating the event listeners, to only create the event listeners on `document` once\n                this._createEventListeners();\n            }\n\n            this._setReadOnly();\n        }\n\n        // Save the initial values (html attribute + element.value) for the pristine test\n        this._saveInitialValues(initialValue);\n\n        // Setup the data for the persistent storage solution (ie. sessionStorage or cookies)\n        this.sessionStorageAvailable = this.constructor._storageTest();\n        this.storageNamePrefix = 'AUTO_'; // The prefix for the raw value storage name variable can be modified here\n        this._setPersistentStorageName();\n\n        // --------------------------------------------------------\n        // -------------- Tracking\n        // Keep track if the element is currently focused\n        this.isFocused = false;\n        // Keep track if a mouse wheel event is currently ongoing\n        this.isWheelEvent = false;\n        // Keep track if a drop event is currently ongoing\n        this.isDropEvent = false;\n        // Keep track if the user is currently editing the element\n        this.isEditing = false;\n\n        if (this.settings.createLocalList) {\n            // Keep track of every AutoNumeric elements that this object initialized\n            this._createLocalList();\n        }\n\n        // Keep track of all AutoNumeric elements in the current web page\n        this.constructor._addToGlobalList(this);\n\n        // --------------------------------------------------------\n        // -------------- Methods\n        // Create the global functions\n        this.global = {\n            /**\n             * Set the same given element value for each elements in the local AutoNumeric element list, and format those elements immediately\n             *\n             * @param {number|string} newValue The value must be a number or a numeric string\n             * @param {object} options A settings object that will override the current settings. Note: the update is done only if the `newValue` is defined.\n             */\n            set: function set(newValue) {\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    aNObject.set(newValue, options);\n                });\n            },\n\n            /**\n             * Set the value given value directly as the DOM element value, without formatting it beforehand.\n             * This sets the same unformatted value for each elements in the local AutoNumeric element list.\n             *\n             * @param {number|string} value\n             * @param {object} options\n             */\n            setUnformatted: function setUnformatted(value) {\n                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    aNObject.setUnformatted(value, options);\n                });\n            },\n\n            /**\n             * This is an alias of the `getNumericString()` function, and should not be used anymore.\n             *\n             * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second\n             * @returns {Array<string>}\n             * @deprecated\n             */\n            get: function get() {\n                var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n                var result = [];\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    result.push(aNObject.get());\n                });\n                _this._executeCallback(result, callback);\n\n                return result;\n            },\n\n            /**\n             * Return an array of the unformatted values (as a string) of each AutoNumeric element of the local AutoNumeric element list\n             *\n             * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second\n             * @returns {Array<string>}\n             */\n            getNumericString: function getNumericString() {\n                var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n                var result = [];\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    result.push(aNObject.getNumericString());\n                });\n                _this._executeCallback(result, callback);\n\n                return result;\n            },\n\n            /**\n             * Return an array of the current formatted values (as a string) of each AutoNumeric element of the local AutoNumeric element list\n             *\n             * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second\n             * @returns {Array<string>}\n             */\n            getFormatted: function getFormatted() {\n                var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n                var result = [];\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    result.push(aNObject.getFormatted());\n                });\n                _this._executeCallback(result, callback);\n\n                return result;\n            },\n\n            /**\n             * Return an array of the element unformatted values (as a real Javascript number), for each element of the local AutoNumeric element list\n             *\n             * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second\n             * @returns {Array<number>}\n             */\n            getNumber: function getNumber() {\n                var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n                var result = [];\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    result.push(aNObject.getNumber());\n                });\n                _this._executeCallback(result, callback);\n\n                return result;\n            },\n\n            /**\n             * Returns the unformatted values (following the `outputFormat` setting) of each element of the local AutoNumeric element list into an array\n             *\n             * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second\n             * @returns {Array<string>}\n             */\n            getLocalized: function getLocalized() {\n                var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n                var result = [];\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    result.push(aNObject.getLocalized());\n                });\n                _this._executeCallback(result, callback);\n\n                return result;\n            },\n\n            /**\n             * Force each element of the local AutoNumeric element list to reformat its value\n             */\n            reformat: function reformat() {\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    aNObject.reformat();\n                });\n            },\n\n            /**\n             * Remove the formatting and keep only the raw unformatted value (as a numericString) in each elements of the local AutoNumeric element list\n             */\n            unformat: function unformat() {\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    aNObject.unformat();\n                });\n            },\n\n            /**\n             * Remove the formatting and keep only the localized unformatted value in the element, with the option to override the default outputFormat if needed\n             *\n             * @param {null|string} forcedOutputFormat If set to something different than `null`, then this is used as an overriding outputFormat option\n             */\n            unformatLocalized: function unformatLocalized() {\n                var forcedOutputFormat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    aNObject.unformatLocalized(forcedOutputFormat);\n                });\n            },\n\n            /**\n             * Updates the AutoNumeric settings, and immediately format the elements accordingly, for each elements of the local AutoNumeric element list\n             *\n             * @param {object} newOptions This can be either one or more option objects\n             */\n            update: function update() {\n                for (var _len = arguments.length, newOptions = Array(_len), _key = 0; _key < _len; _key++) {\n                    newOptions[_key] = arguments[_key];\n                }\n\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    aNObject.update.apply(aNObject, newOptions);\n                });\n            },\n\n            /**\n             * Return `true` if *all* the autoNumeric-managed elements are pristine, if their raw value hasn't changed.\n             * By default, this returns `true` if the raw unformatted value is still the same even if the formatted one has changed (due to a configuration update for instance).\n             *\n             * @param {boolean} checkOnlyRawValue If set to `true`, the pristine value is done on the raw unformatted value, not the formatted one. If set to `false`, this also checks that the formatted value hasn't changed.\n             * @returns {boolean}\n             */\n            isPristine: function isPristine() {\n                var checkOnlyRawValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n                var isPristine = true;\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    if (isPristine && !aNObject.isPristine(checkOnlyRawValue)) {\n                        isPristine = false;\n                    }\n                });\n\n                return isPristine;\n            },\n\n            /**\n             * Execute the `clear()` method on each AutoNumeric object in the local AutoNumeric element list\n             *\n             * @param {boolean} forceClearAll\n             */\n            clear: function clear() {\n                var forceClearAll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    aNObject.clear(forceClearAll);\n                });\n            },\n\n            /**\n             * Execute the `remove()` method on each AutoNumeric object in the local AutoNumeric element list\n             */\n            remove: function remove() {\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    aNObject.remove();\n                });\n            },\n\n            /**\n             * Execute the `wipe()` method on each AutoNumeric object in the local AutoNumeric element list\n             */\n            wipe: function wipe() {\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    aNObject.wipe();\n                });\n            },\n\n            /**\n             * Execute the `nuke()` method on each AutoNumeric object in the local AutoNumeric element list\n             */\n            nuke: function nuke() {\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    aNObject.nuke();\n                });\n            },\n\n            /**\n             * Return `true` if the given AutoNumeric object (or DOM element) is in the local AutoNumeric element list\n             *\n             * @param {HTMLElement|HTMLInputElement|AutoNumeric} domElementOrAutoNumericObject\n             * @returns {*}\n             */\n            has: function has(domElementOrAutoNumericObject) {\n                var result = void 0;\n                if (domElementOrAutoNumericObject instanceof AutoNumeric) {\n                    result = _this.autoNumericLocalList.has(domElementOrAutoNumericObject.node());\n                } else {\n                    result = _this.autoNumericLocalList.has(domElementOrAutoNumericObject);\n                }\n\n                return result;\n            },\n\n            /**\n             * Add an existing AutoNumeric object (or DOM element) to the local AutoNumeric element list, using the DOM element as the key.\n             * This manages the case where `addObject` is used on an AutoNumeric object that already has multiple elements in its local list.\n             *\n             * @param {HTMLElement|HTMLInputElement|AutoNumeric} domElementOrAutoNumericObject\n             */\n            addObject: function addObject(domElementOrAutoNumericObject) {\n                // Start with the same data, whatever the user passed as arguments\n                var domElement = void 0;\n                var otherAutoNumericObject = void 0;\n                if (domElementOrAutoNumericObject instanceof AutoNumeric) {\n                    domElement = domElementOrAutoNumericObject.node();\n                    otherAutoNumericObject = domElementOrAutoNumericObject;\n                } else {\n                    domElement = domElementOrAutoNumericObject;\n                    otherAutoNumericObject = AutoNumeric.getAutoNumericElement(domElementOrAutoNumericObject);\n                }\n\n                // Check if the current autoNumeric object has a local list\n                if (!_this._hasLocalList()) {\n                    _this._createLocalList();\n                }\n\n                // Check if the other autoNumeric object has a local list...\n                var otherANLocalList = otherAutoNumericObject._getLocalList();\n                if (otherANLocalList.size === 0) {\n                    // Special case if the other AutoNumeric object has an empty local list, then populate itself to it\n                    otherAutoNumericObject._createLocalList();\n                    otherANLocalList = otherAutoNumericObject._getLocalList(); // Update the other local list\n                }\n\n                var mergedLocalLists = void 0;\n                if (otherANLocalList instanceof Map) {\n                    // ...If it does, merge the local lists together\n                    mergedLocalLists = _AutoNumericHelper2.default.mergeMaps(_this._getLocalList(), otherANLocalList);\n                } else {\n                    // ...If not, just set the current local list onto the other AutoNumeric object\n                    // We need to specify the AutoNumeric object, otherwise the `_addToLocalList` function would not correctly add the AutoNumeric object since we would not have a reference to it, but a reference to the current AutoNumeric object on which is called this method.\n                    _this._addToLocalList(domElement, otherAutoNumericObject);\n                    mergedLocalLists = _this._getLocalList();\n                }\n\n                // Update the resulting list, on all the objects of that local list (so that we can indifferently use `init()` on any object belonging to that list)\n                mergedLocalLists.forEach(function (aNObject) {\n                    aNObject._setLocalList(mergedLocalLists);\n                });\n            },\n\n            /**\n             * Remove the given AutoNumeric object (or DOM element) from the local AutoNumeric element list, using the DOM element as the key.\n             * If this function attempts to remove the current AutoNumeric object from the local list, a warning is shown, but the deletion is still done.\n             *\n             * Special cases :\n             * - If the current object removes itself, then it's removed from the shared local list, then a new empty local list is used/created\n             * - If another object remove this object, then a local list with only this object is used/created\n             *\n             * @param {HTMLElement|HTMLInputElement|AutoNumeric} domElementOrAutoNumericObject\n             * @param {boolean} keepCurrentANObject If set to `false`, then the function will also remove the current AutoNumeric object if asked, otherwise it will ignore it and print a warning message\n             */\n            removeObject: function removeObject(domElementOrAutoNumericObject) {\n                var keepCurrentANObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n                // Start with the same data, whatever the user passed as arguments\n                var domElement = void 0;\n                var otherAutoNumericObject = void 0;\n                if (domElementOrAutoNumericObject instanceof AutoNumeric) {\n                    domElement = domElementOrAutoNumericObject.node();\n                    otherAutoNumericObject = domElementOrAutoNumericObject;\n                } else {\n                    domElement = domElementOrAutoNumericObject;\n                    otherAutoNumericObject = AutoNumeric.getAutoNumericElement(domElementOrAutoNumericObject);\n                }\n\n                // Remove the other object from the local list\n                var initialCompleteLocalList = _this.autoNumericLocalList;\n                _this.autoNumericLocalList.delete(domElement);\n\n                // Update the local list for all objects in it\n                initialCompleteLocalList.forEach(function (aNObject) {\n                    aNObject._setLocalList(_this.autoNumericLocalList);\n                });\n\n                if (!keepCurrentANObject && domElement === _this.node()) {\n                    // This object is removed by itself\n                    // Empty the object local list\n                    otherAutoNumericObject._setLocalList(new Map());\n                } else {\n                    // This object is removed by another object\n                    // Set the local list for the removed object, with only this object in it\n                    otherAutoNumericObject._createLocalList();\n                }\n            },\n\n            /**\n             * Remove all elements from the shared list, effectively emptying it.\n             * This is the equivalent of calling `detach()` on each of its elements.\n             *\n             * @param {boolean} keepEachANObjectInItsOwnList If set to `true`, then instead of completely emptying the local list of each AutoNumeric objects, each one of those keeps itself in its own local list\n             */\n            empty: function empty() {\n                var keepEachANObjectInItsOwnList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n                var initialCompleteLocalList = _this.autoNumericLocalList;\n\n                // Update the local list for all objects in it\n                initialCompleteLocalList.forEach(function (aNObject) {\n                    if (keepEachANObjectInItsOwnList) {\n                        aNObject._createLocalList();\n                    } else {\n                        aNObject._setLocalList(new Map());\n                    }\n                });\n            },\n\n            /**\n             * Return an array containing all the AutoNumeric DOM elements that have been initialized by each other\n             *\n             * @returns {Array<HTMLElement>}\n             */\n            elements: function elements() {\n                var result = [];\n                _this.autoNumericLocalList.forEach(function (aNObject) {\n                    result.push(aNObject.node());\n                });\n\n                return result;\n            },\n\n            /**\n             * Return the `Map` object directly\n             * @returns {Map}\n             */\n            getList: function getList() {\n                return _this.autoNumericLocalList;\n            },\n\n            /**\n             * Return the number of element in the local AutoNumeric element list\n             * @returns {number}\n             */\n            size: function size() {\n                return _this.autoNumericLocalList.size;\n            }\n        };\n\n        // Create the functions that will allow to change each setting one by one\n        /**\n         * For each options, we define if we need to reformat the element content (does changing the options should change the way its value is displayed?).\n         * If yes, then we use the `update()` for force a reformat, otherwise, we just update the `settings` object.\n         */\n        this.options = {\n            /**\n             * Reset any options set previously, by overwriting them with the default settings\n             *\n             * @returns {AutoNumeric}\n             */\n            reset: function reset() {\n                //TODO Add a `settings` parameter so that the user can reset to a specific set of settings. This is different than update since it drops any non-default settings before using those new settings.\n                _this.settings = { rawValue: _this.defaultRawValue }; // Here we pass the default rawValue in order to prevent showing a warning that we try to set an `undefined` value\n                _this.update(AutoNumeric.defaultSettings);\n\n                return _this;\n            },\n            allowDecimalPadding: function allowDecimalPadding(_allowDecimalPadding) {\n                _this.update({ allowDecimalPadding: _allowDecimalPadding });\n\n                return _this;\n            },\n            caretPositionOnFocus: function caretPositionOnFocus(_caretPositionOnFocus) {\n                //FIXME test this\n                _this.settings.caretPositionOnFocus = _caretPositionOnFocus;\n\n                return _this;\n            },\n            createLocalList: function createLocalList(_createLocalList2) {\n                _this.settings.createLocalList = _createLocalList2;\n\n                // Delete the local list when this is set to `false`, create it if this is set to `true` and there is not pre-existing list\n                if (_this.settings.createLocalList) {\n                    if (!_this._hasLocalList()) {\n                        _this._createLocalList();\n                    }\n                } else {\n                    _this._deleteLocalList();\n                }\n\n                return _this;\n            },\n            currencySymbol: function currencySymbol(_currencySymbol) {\n                _this.update({ currencySymbol: _currencySymbol });\n\n                return _this;\n            },\n            currencySymbolPlacement: function currencySymbolPlacement(_currencySymbolPlacement) {\n                _this.update({ currencySymbolPlacement: _currencySymbolPlacement });\n\n                return _this;\n            },\n            decimalCharacter: function decimalCharacter(_decimalCharacter) {\n                _this.update({ decimalCharacter: _decimalCharacter });\n\n                return _this;\n            },\n            decimalCharacterAlternative: function decimalCharacterAlternative(_decimalCharacterAlternative) {\n                _this.settings.decimalCharacterAlternative = _decimalCharacterAlternative;\n\n                return _this;\n            },\n            /**\n             * Update the decimal places globally, which means this override any previously set number of decimal shown on focus, on blur, or in the raw value.\n             *\n             * @param {int} decimalPlaces\n             * @returns {AutoNumeric}\n             */\n            decimalPlaces: function decimalPlaces(_decimalPlaces) {\n                _AutoNumericHelper2.default.warning('Using `options.decimalPlaces()` instead of calling the specific `options.decimalPlacesRawValue()`, `options.decimalPlacesShownOnFocus()` and `options.decimalPlacesShownOnBlur()` methods will reset those options.\\nPlease call the specific methods if you do not want to reset those.', _this.settings.showWarnings);\n                _this.update({ decimalPlaces: _decimalPlaces });\n\n                return _this;\n            },\n            decimalPlacesRawValue: function decimalPlacesRawValue(_decimalPlacesRawValue) {\n                //FIXME test this\n                _this.update({ decimalPlacesRawValue: _decimalPlacesRawValue });\n\n                return _this;\n            },\n            decimalPlacesShownOnBlur: function decimalPlacesShownOnBlur(_decimalPlacesShownOnBlur) {\n                _this.update({ decimalPlacesShownOnBlur: _decimalPlacesShownOnBlur });\n\n                return _this;\n            },\n            decimalPlacesShownOnFocus: function decimalPlacesShownOnFocus(_decimalPlacesShownOnFocus) {\n                _this.update({ decimalPlacesShownOnFocus: _decimalPlacesShownOnFocus });\n\n                return _this;\n            },\n            defaultValueOverride: function defaultValueOverride(_defaultValueOverride) {\n                _this.update({ defaultValueOverride: _defaultValueOverride });\n\n                return _this;\n            },\n            digitalGroupSpacing: function digitalGroupSpacing(_digitalGroupSpacing) {\n                _this.update({ digitalGroupSpacing: _digitalGroupSpacing });\n\n                return _this;\n            },\n            digitGroupSeparator: function digitGroupSeparator(_digitGroupSeparator) {\n                _this.update({ digitGroupSeparator: _digitGroupSeparator });\n\n                return _this;\n            },\n            divisorWhenUnfocused: function divisorWhenUnfocused(_divisorWhenUnfocused) {\n                _this.update({ divisorWhenUnfocused: _divisorWhenUnfocused });\n\n                return _this;\n            },\n            emptyInputBehavior: function emptyInputBehavior(_emptyInputBehavior) {\n                if (_this.rawValue === null && _emptyInputBehavior !== AutoNumeric.options.emptyInputBehavior.null) {\n                    // Special case : if the current `rawValue` is `null` and the `emptyInputBehavior` is changed to something else than `'null'`, then it makes that `rawValue` invalid.\n                    // Here we can either prevent the option update and throw an error, or still accept the option update and update the value from `null` to `''`.\n                    // We cannot keep `rawValue` to `null` since if `emptyInputBehavior` is not set to `null`, lots of function assume `rawValue` is a string.\n                    _AutoNumericHelper2.default.warning('You are trying to modify the `emptyInputBehavior` option to something different than `\\'null\\'` (' + _emptyInputBehavior + '), but the element raw value is currently set to `null`. This would result in an invalid `rawValue`. In order to fix that, the element value has been changed to the empty string `\\'\\'`.', _this.settings.showWarnings);\n                    _this.rawValue = '';\n                }\n\n                _this.update({ emptyInputBehavior: _emptyInputBehavior });\n\n                return _this;\n            },\n            failOnUnknownOption: function failOnUnknownOption(_failOnUnknownOption) {\n                _this.settings.failOnUnknownOption = _failOnUnknownOption; //FIXME test this\n\n                return _this;\n            },\n            formatOnPageLoad: function formatOnPageLoad(_formatOnPageLoad) {\n                _this.settings.formatOnPageLoad = _formatOnPageLoad; //FIXME test this\n\n                return _this;\n            },\n            historySize: function historySize(_historySize) {\n                _this.settings.historySize = _historySize;\n\n                return _this;\n            },\n            isCancellable: function isCancellable(_isCancellable) {\n                _this.settings.isCancellable = _isCancellable; //FIXME test this\n\n                return _this;\n            },\n            leadingZero: function leadingZero(_leadingZero) {\n                _this.update({ leadingZero: _leadingZero });\n\n                return _this;\n            },\n            maximumValue: function maximumValue(_maximumValue) {\n                _this.update({ maximumValue: _maximumValue });\n\n                return _this;\n            },\n            minimumValue: function minimumValue(_minimumValue) {\n                _this.update({ minimumValue: _minimumValue });\n\n                return _this;\n            },\n            modifyValueOnWheel: function modifyValueOnWheel(_modifyValueOnWheel) {\n                _this.settings.modifyValueOnWheel = _modifyValueOnWheel; //FIXME test this\n\n                return _this;\n            },\n            negativeBracketsTypeOnBlur: function negativeBracketsTypeOnBlur(_negativeBracketsTypeOnBlur) {\n                _this.update({ negativeBracketsTypeOnBlur: _negativeBracketsTypeOnBlur });\n\n                return _this;\n            },\n            negativePositiveSignPlacement: function negativePositiveSignPlacement(_negativePositiveSignPlacement) {\n                _this.update({ negativePositiveSignPlacement: _negativePositiveSignPlacement });\n\n                return _this;\n            },\n            noEventListeners: function noEventListeners(_noEventListeners) {\n                //FIXME test this\n                if (_noEventListeners === AutoNumeric.options.noEventListeners.noEvents && _this.settings.noEventListeners === AutoNumeric.options.noEventListeners.addEvents) {\n                    // Remove the events once\n                    _this._removeEventListeners();\n                }\n\n                _this.update({ noEventListeners: _noEventListeners });\n\n                return _this;\n            },\n            onInvalidPaste: function onInvalidPaste(_onInvalidPaste) {\n                _this.settings.onInvalidPaste = _onInvalidPaste; //FIXME test this\n\n                return _this;\n            },\n            outputFormat: function outputFormat(_outputFormat) {\n                _this.settings.outputFormat = _outputFormat;\n\n                return _this;\n            },\n            overrideMinMaxLimits: function overrideMinMaxLimits(_overrideMinMaxLimits) {\n                _this.update({ overrideMinMaxLimits: _overrideMinMaxLimits });\n\n                return _this;\n            },\n            rawValueDivisor: function rawValueDivisor(_rawValueDivisor) {\n                _this.update({ rawValueDivisor: _rawValueDivisor });\n\n                return _this;\n            },\n            readOnly: function readOnly(_readOnly) {\n                //FIXME test this\n                _this.settings.readOnly = _readOnly;\n                _this._setReadOnly();\n\n                return _this;\n            },\n            roundingMethod: function roundingMethod(_roundingMethod) {\n                _this.update({ roundingMethod: _roundingMethod });\n\n                return _this;\n            },\n            saveValueToSessionStorage: function saveValueToSessionStorage(_saveValueToSessionStorage) {\n                _this.update({ saveValueToSessionStorage: _saveValueToSessionStorage });\n\n                return _this;\n            },\n            symbolWhenUnfocused: function symbolWhenUnfocused(_symbolWhenUnfocused) {\n                _this.update({ symbolWhenUnfocused: _symbolWhenUnfocused });\n\n                return _this;\n            },\n            selectNumberOnly: function selectNumberOnly(_selectNumberOnly) {\n                _this.settings.selectNumberOnly = _selectNumberOnly; //FIXME test this\n\n                return _this;\n            },\n            selectOnFocus: function selectOnFocus(_selectOnFocus) {\n                _this.settings.selectOnFocus = _selectOnFocus; //FIXME test this\n\n                return _this;\n            },\n            serializeSpaces: function serializeSpaces(_serializeSpaces) {\n                _this.settings.serializeSpaces = _serializeSpaces; //FIXME test this\n\n                return _this;\n            },\n            showOnlyNumbersOnFocus: function showOnlyNumbersOnFocus(_showOnlyNumbersOnFocus) {\n                _this.update({ showOnlyNumbersOnFocus: _showOnlyNumbersOnFocus });\n\n                return _this;\n            },\n            showPositiveSign: function showPositiveSign(_showPositiveSign) {\n                _this.update({ showPositiveSign: _showPositiveSign });\n\n                return _this;\n            },\n            showWarnings: function showWarnings(_showWarnings) {\n                _this.settings.showWarnings = _showWarnings; //FIXME test this\n\n                return _this;\n            },\n            styleRules: function styleRules(_styleRules) {\n                _this.update({ styleRules: _styleRules });\n\n                return _this;\n            },\n            suffixText: function suffixText(_suffixText) {\n                _this.update({ suffixText: _suffixText });\n\n                return _this;\n            },\n            unformatOnHover: function unformatOnHover(_unformatOnHover) {\n                _this.settings.unformatOnHover = _unformatOnHover; //FIXME test this\n\n                return _this;\n            },\n            unformatOnSubmit: function unformatOnSubmit(_unformatOnSubmit) {\n                _this.settings.unformatOnSubmit = _unformatOnSubmit; //FIXME test this\n\n                return _this;\n            },\n            valuesToStrings: function valuesToStrings(_valuesToStrings) {\n                _this.update({ valuesToStrings: _valuesToStrings });\n\n                return _this;\n            },\n            wheelStep: function wheelStep(_wheelStep) {\n                _this.settings.wheelStep = _wheelStep; //FIXME test this\n\n                return _this;\n            }\n        };\n    }\n\n    /**\n     * Return the autoNumeric version number (for debugging purpose)\n     *\n     * @returns {string}\n     */\n\n\n    _createClass(AutoNumeric, [{\n        key: '_saveInitialValues',\n\n\n        /**\n         * Save the initial element values for later use in the pristine test.\n         * Those values are :\n         * - the html attribute (ie. <input value='42'>), and\n         * - the script `value` (ie. `let domElement.value`)\n         *\n         * @param {null|number|string} initialValue\n         * @private\n         */\n        value: function _saveInitialValues(initialValue) {\n            // Keep the very first initial values (in the html attribute and set by the script). This is needed to check if the element is pristine.\n            // Save the html attribute 'value'\n            this.initialValueHtmlAttribute = this.domElement.getAttribute('value');\n            if (_AutoNumericHelper2.default.isNull(this.initialValueHtmlAttribute)) {\n                // Set the default empty value attribute instead of `null`, since if the initial value is null, the empty string is used\n                this.initialValueHtmlAttribute = '';\n            }\n\n            // Save the 'script' value\n            this.initialValue = initialValue;\n            if (_AutoNumericHelper2.default.isNull(this.initialValue)) {\n                // Same as above\n                this.initialValue = '';\n            }\n        }\n\n        /**\n         * Generate all the event listeners for the given DOM element\n         * @private\n         */\n\n    }, {\n        key: '_createEventListeners',\n        value: function _createEventListeners() {\n            var _this2 = this;\n\n            // Create references to the event handler functions, so we can then cleanly removes those listeners if needed\n            // That would not be possible if we used closures directly in the event handler declarations\n            this._onFocusInFunc = function (e) {\n                _this2._onFocusIn(e);\n            };\n            this._onFocusInAndMouseEnterFunc = function (e) {\n                _this2._onFocusInAndMouseEnter(e);\n            };\n            this._onFocusFunc = function () {\n                _this2._onFocus();\n            };\n            this._onKeydownFunc = function (e) {\n                _this2._onKeydown(e);\n            };\n            this._onKeypressFunc = function (e) {\n                _this2._onKeypress(e);\n            };\n            this._onInputFunc = function (e) {\n                _this2._onInput(e);\n            };\n            this._onKeyupFunc = function (e) {\n                _this2._onKeyup(e);\n            };\n            this._onFocusOutAndMouseLeaveFunc = function (e) {\n                _this2._onFocusOutAndMouseLeave(e);\n            };\n            this._onPasteFunc = function (e) {\n                _this2._onPaste(e);\n            };\n            this._onWheelFunc = function (e) {\n                _this2._onWheel(e);\n            };\n            this._onFormSubmitFunc = function () {\n                _this2._onFormSubmit();\n            };\n            this._onKeydownGlobalFunc = function (e) {\n                _this2._onKeydownGlobal(e);\n            };\n            this._onKeyupGlobalFunc = function (e) {\n                _this2._onKeyupGlobal(e);\n            };\n            this._onDropFunc = function (e) {\n                _this2._onDrop(e);\n            };\n\n            // Add the event listeners\n            this.domElement.addEventListener('focusin', this._onFocusInFunc, false);\n            this.domElement.addEventListener('focus', this._onFocusInAndMouseEnterFunc, false);\n            this.domElement.addEventListener('focus', this._onFocusFunc, false);\n            this.domElement.addEventListener('mouseenter', this._onFocusInAndMouseEnterFunc, false);\n            this.domElement.addEventListener('keydown', this._onKeydownFunc, false);\n            this.domElement.addEventListener('keypress', this._onKeypressFunc, false);\n            this.domElement.addEventListener('input', this._onInputFunc, false);\n            this.domElement.addEventListener('keyup', this._onKeyupFunc, false);\n            this.domElement.addEventListener('blur', this._onFocusOutAndMouseLeaveFunc, false);\n            this.domElement.addEventListener('mouseleave', this._onFocusOutAndMouseLeaveFunc, false);\n            this.domElement.addEventListener('paste', this._onPasteFunc, false);\n            this.domElement.addEventListener('wheel', this._onWheelFunc, false);\n            this.domElement.addEventListener('drop', this._onDropFunc, false);\n\n            if (!_AutoNumericHelper2.default.isNull(this.parentForm)) {\n                this.parentForm.addEventListener('submit', this._onFormSubmitFunc, false);\n            }\n\n            // Create one global event listener for the keyup event on the document object, which will be shared by all the autoNumeric elements\n            if (!AutoNumeric._doesGlobalListExists()) {\n                document.addEventListener('keydown', this._onKeydownGlobalFunc, false);\n                document.addEventListener('keyup', this._onKeyupGlobalFunc, false);\n            }\n        }\n\n        /**\n         * Remove all the autoNumeric-related event listeners for the given DOM element\n         * @private\n         */\n\n    }, {\n        key: '_removeEventListeners',\n        value: function _removeEventListeners() {\n            //FIXME test this\n            this.domElement.removeEventListener('focusin', this._onFocusInFunc, false);\n            this.domElement.removeEventListener('focus', this._onFocusInAndMouseEnterFunc, false);\n            this.domElement.removeEventListener('focus', this._onFocusFunc, false);\n            this.domElement.removeEventListener('mouseenter', this._onFocusInAndMouseEnterFunc, false);\n            this.domElement.removeEventListener('blur', this._onFocusOutAndMouseLeaveFunc, false);\n            this.domElement.removeEventListener('mouseleave', this._onFocusOutAndMouseLeaveFunc, false);\n            this.domElement.removeEventListener('keydown', this._onKeydownFunc, false);\n            this.domElement.removeEventListener('keypress', this._onKeypressFunc, false);\n            this.domElement.removeEventListener('input', this._onInputFunc, false);\n            this.domElement.removeEventListener('keyup', this._onKeyupFunc, false);\n            this.domElement.removeEventListener('paste', this._onPasteFunc, false);\n            this.domElement.removeEventListener('wheel', this._onWheelFunc, false);\n\n            document.removeEventListener('keydown', this._onKeydownGlobalFunc, false);\n            document.removeEventListener('keyup', this._onKeyupGlobalFunc, false);\n\n            if (!_AutoNumericHelper2.default.isNull(this.parentForm)) {\n                this.parentForm.removeEventListener('submit', this._onFormSubmitFunc, false);\n            }\n        }\n\n        /**\n         * Set the element attribute 'readonly' according to the current settings.\n         *\n         * @private\n         */\n\n    }, {\n        key: '_setReadOnly',\n        value: function _setReadOnly() {\n            if (this.isInputElement && this.settings.readOnly) {\n                this.domElement.readOnly = true;\n            }\n        }\n\n        /**\n         * Save the current raw value into the history table, along with the selection information.\n         *\n         * If the user has done some undos and tries to enter:\n         * - a new and different number than the 'next' state, this drops the rest of the history table\n         * - the very same number that result in the same rawValue than the 'next' state, we only move the history table pointer to the next state\n         *\n         * @private\n         */\n\n    }, {\n        key: '_historyTableAdd',\n        value: function _historyTableAdd() {\n            //TODO Add a `this.settings.saveSelectionsIntoHistory` option to prevent saving the selections (in order to gain performance)\n            var isEmptyHistoryTable = this.historyTable.length === 0;\n            // Only add a new value if it's different than the previous one (to prevent infinitely adding values on mouseover for instance)\n            if (isEmptyHistoryTable || this.rawValue !== this._historyTableCurrentValueUsed()) {\n                // Trim the history table if the user changed the value of an intermediary state\n                var addNewHistoryState = true;\n                if (!isEmptyHistoryTable) {\n                    // If some undo has been done and the user type the exact same data than the next entry after the current history pointer, do no drop the rest of the 'redo' list, and just advance the historyTableIndex\n                    var nextHistoryStateIndex = this.historyTableIndex + 1;\n                    if (nextHistoryStateIndex < this.historyTable.length && this.rawValue === this.historyTable[nextHistoryStateIndex].value) {\n                        // If the character input result in the same state than the next one, do not remove the next history states nor add a new one\n                        addNewHistoryState = false;\n                    } else {\n                        // First remove anything that is after the current index\n                        _AutoNumericHelper2.default.arrayTrim(this.historyTable, this.historyTableIndex + 1);\n                    }\n                }\n\n                // Update the history pointer\n                this.historyTableIndex++;\n\n                // Add the new history state, if needed\n                if (addNewHistoryState) {\n                    // Save the selection info\n                    var selection = _AutoNumericHelper2.default.getElementSelection(this.domElement);\n                    this.selectionStart = selection.start;\n                    this.selectionEnd = selection.end;\n\n                    // Then add the new raw value\n                    this.historyTable.push({\n                        // Save the rawValue and selection start/end\n                        value: this.rawValue,\n                        // The selection for this element is temporary, and will be updated when the next history state will be recorded.\n                        // That way, we are always sure we save the last caret or selection positions just before the value is changed. Otherwise we would only save those positions when the value is first changed, and would not take into account that the user could move the caret around afterward.\n                        // For instance, this is needed if the user change the element value, and immediately undo it ; if he then does a redo, he'll see the value and the right selection\n                        // To sum up; The selection position are not always +1 character, since it could also be '2' if a group separator is added when entering one character. That's why the current history state caret/selection position is updated on each `keyup` event.\n                        start: this.selectionStart + 1, // Here we add one since the user added one character too\n                        end: this.selectionEnd + 1\n                    });\n\n                    // Update the selection in the previous entry, in order to keep track of the updated caret/selection positions\n                    if (this.historyTable.length > 1) {\n                        this.historyTable[this.historyTableIndex - 1].start = this.selectionStart;\n                        this.historyTable[this.historyTableIndex - 1].end = this.selectionEnd;\n                    }\n                }\n\n                // Limit the history table size according to the `historySize` option\n                if (this.historyTable.length > this.settings.historySize) {\n                    this._historyTableForget();\n                }\n            }\n        }\n\n        /**\n         * Debug function for the history table\n         * @private\n         */\n        /*\n        _debugHistoryTable() {\n            let i = 0;\n            let mark;\n            this.historyTable.forEach(history => {\n                if (this.historyTableIndex === i) {\n                    mark = '> ';\n                } else {\n                    mark = '';\n                }\n                console.log(`${mark}${i++}: ${history.value} ${history.start}|${history.end} [onGoingRedo: ${this.onGoingRedo}]`); //DEBUG\n            });\n        }\n        */\n\n        /**\n         * 'Undo' or 'Redo' the last/next user entry in the history table.\n         * This does not modify the history table, only the pointer to the current state.\n         *\n         * @param {boolean} undo If set to `true`, then this function does an 'Undo', otherwise it does a 'Redo'\n         * @private\n         */\n\n    }, {\n        key: '_historyTableUndoOrRedo',\n        value: function _historyTableUndoOrRedo() {\n            var undo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n            var check = void 0;\n            if (undo) {\n                // Only 'undo' if there are some info to undo\n                check = this.historyTableIndex > 0;\n                if (check) {\n                    this.historyTableIndex--;\n                }\n            } else {\n                // Only 'redo' if there are some info to redo at the end of the history table\n                check = this.historyTableIndex + 1 < this.historyTable.length;\n                if (check) {\n                    this.historyTableIndex++;\n                }\n            }\n\n            if (check) {\n                // Set the value back\n                var undoInfo = this.historyTable[this.historyTableIndex];\n                this.set(undoInfo.value, null, false); // next or previous raw value\n\n                // Set the selection back\n                _AutoNumericHelper2.default.setElementSelection(this.domElement, undoInfo.start, undoInfo.end);\n            }\n        }\n\n        /**\n         * 'Undo' the last user entry by going back one entry in the history table.\n         * This keeps the following entries in order to allow for a 'redo'.\n         * This does not modify the history table, only the pointer to the current state.\n         * @private\n         */\n\n    }, {\n        key: '_historyTableUndo',\n        value: function _historyTableUndo() {\n            this._historyTableUndoOrRedo(true);\n        }\n\n        /**\n         * 'Redo' the next user entry in the history table.\n         * This does not modify the history table, only the pointer to the current state.\n         * @private\n         */\n\n    }, {\n        key: '_historyTableRedo',\n        value: function _historyTableRedo() {\n            this._historyTableUndoOrRedo(false);\n        }\n\n        /**\n         * Reset the history table to its initial state, and select the value.\n         * @private\n         */\n        /*\n        resetHistoryTable() { //FIXME Test this\n            this.set(this.rawValue, null, false);\n            this.select();\n            const selection = AutoNumericHelper.getElementSelection(this.domElement);\n            this.historyTableIndex = 0;\n            this.historyTable = [{\n                // Save the rawValue and selection start/end\n                value: this.rawValue,\n                start: selection.start,\n                end  : selection.end,\n            }];\n        }\n        */\n\n        /**\n         * Make the history table forget its first N elements, shifting its indexes in the process.\n         * `N` being given as the `numberOfEntriesToForget` parameter.\n         *\n         * @param {Number} numberOfEntriesToForget\n         * @returns {object|Array<object>} The discarded objects, in an Array.\n         * @private\n         */\n\n    }, {\n        key: '_historyTableForget',\n        value: function _historyTableForget() {\n            var numberOfEntriesToForget = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n            var shiftedAway = [];\n            for (var i = 0; i < numberOfEntriesToForget; i++) {\n                shiftedAway.push(this.historyTable.shift());\n                // Update the history table index accordingly\n                this.historyTableIndex--;\n                if (this.historyTableIndex < 0) {\n                    // In case this function is called more times than there is states in the history table\n                    this.historyTableIndex = 0;\n                }\n            }\n\n            if (shiftedAway.length === 1) {\n                return shiftedAway[0];\n            }\n\n            return shiftedAway;\n        }\n\n        /**\n         * Return the currently used value from the history table.\n         *\n         * @returns {string|number}\n         * @private\n         */\n\n    }, {\n        key: '_historyTableCurrentValueUsed',\n        value: function _historyTableCurrentValueUsed() {\n            var indexToUse = this.historyTableIndex;\n            if (indexToUse < 0) {\n                indexToUse = 0;\n            }\n\n            var result = void 0;\n            if (_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(this.historyTable[indexToUse])) {\n                result = '';\n            } else {\n                result = this.historyTable[indexToUse].value;\n            }\n\n            return result;\n        }\n\n        /**\n         * Parse the `styleRules` option and run the test for each given rules, either pre-defined ones like `positive`, `negative` and `ranges`, or user defined callbacks within the `userDefined` attribute.\n         * @private\n         */\n\n    }, {\n        key: '_parseStyleRules',\n        value: function _parseStyleRules() {\n            var _this3 = this;\n\n            if (_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(this.settings.styleRules) || this.rawValue === '') {\n                return;\n            }\n\n            // 'positive' attribute\n            if (!_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(this.settings.styleRules.positive)) {\n                if (this.rawValue >= 0) {\n                    this._addCSSClass(this.settings.styleRules.positive);\n                } else {\n                    this._removeCSSClass(this.settings.styleRules.positive);\n                }\n            }\n\n            // 'negative' attribute\n            if (!_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(this.settings.styleRules.negative)) {\n                if (this.rawValue < 0) {\n                    this._addCSSClass(this.settings.styleRules.negative);\n                } else {\n                    this._removeCSSClass(this.settings.styleRules.negative);\n                }\n            }\n\n            // 'ranges' attribute\n            if (!_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(this.settings.styleRules.ranges) && this.settings.styleRules.ranges.length !== 0) {\n                this.settings.styleRules.ranges.forEach(function (range) {\n                    if (_this3.rawValue >= range.min && _this3.rawValue < range.max) {\n                        _this3._addCSSClass(range.class);\n                    } else {\n                        _this3._removeCSSClass(range.class);\n                    }\n                });\n            }\n\n            // 'userDefined' attribute\n            //TODO Also pass the old raw value as a parameter, and not only the new raw value\n            if (!_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(this.settings.styleRules.userDefined) && this.settings.styleRules.userDefined.length !== 0) {\n                this.settings.styleRules.userDefined.forEach(function (userObject) {\n                    if (_AutoNumericHelper2.default.isFunction(userObject.callback)) {\n                        // Test for the type of the `classes` attribute, which changes the function behavior\n                        if (_AutoNumericHelper2.default.isString(userObject.classes)) {\n                            // If 'classes' is a string, set it if `true`, remove it if `false`\n                            if (userObject.callback(_this3.rawValue)) {\n                                _this3._addCSSClass(userObject.classes);\n                            } else {\n                                _this3._removeCSSClass(userObject.classes);\n                            }\n                        } else if (_AutoNumericHelper2.default.isArray(userObject.classes)) {\n                            if (userObject.classes.length === 2) {\n                                // If 'classes' is an array with only 2 elements, set the first class if `true`, the second if `false`\n                                if (userObject.callback(_this3.rawValue)) {\n                                    _this3._addCSSClass(userObject.classes[0]);\n                                    _this3._removeCSSClass(userObject.classes[1]);\n                                } else {\n                                    _this3._removeCSSClass(userObject.classes[0]);\n                                    _this3._addCSSClass(userObject.classes[1]);\n                                }\n                            } else if (userObject.classes.length > 2) {\n                                // The callback returns an array of indexes to use on the `classes` array\n                                var callbackResult = userObject.callback(_this3.rawValue);\n                                if (_AutoNumericHelper2.default.isArray(callbackResult)) {\n                                    // If multiple indexes are returned\n                                    userObject.classes.forEach(function (userClass, index) {\n                                        if (_AutoNumericHelper2.default.isInArray(index, callbackResult)) {\n                                            _this3._addCSSClass(userClass);\n                                        } else {\n                                            _this3._removeCSSClass(userClass);\n                                        }\n                                    });\n                                } else if (_AutoNumericHelper2.default.isInt(callbackResult)) {\n                                    // If only one index is returned\n                                    userObject.classes.forEach(function (userClass, index) {\n                                        if (index === callbackResult) {\n                                            _this3._addCSSClass(userClass);\n                                        } else {\n                                            _this3._removeCSSClass(userClass);\n                                        }\n                                    });\n                                } else if (_AutoNumericHelper2.default.isNull(callbackResult)) {\n                                    // Remove all the classes\n                                    userObject.classes.forEach(function (userClass) {\n                                        _this3._removeCSSClass(userClass);\n                                    });\n                                } else {\n                                    _AutoNumericHelper2.default.throwError('The callback result is not an array nor a valid array index, ' + (typeof callbackResult === 'undefined' ? 'undefined' : _typeof(callbackResult)) + ' given.');\n                                }\n                            } else {\n                                _AutoNumericHelper2.default.throwError('The classes attribute is not valid for the `styleRules` option.');\n                            }\n                        } else if (_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(userObject.classes)) {\n                            // If 'classes' is `undefined` or `null`, then the callback is called with the AutoNumeric object passed as a parameter\n                            userObject.callback(_this3);\n                        } else {\n                            _AutoNumericHelper2.default.throwError('The callback/classes structure is not valid for the `styleRules` option.');\n                        }\n                    } else {\n                        _AutoNumericHelper2.default.warning('The given `styleRules` callback is not a function, ' + (typeof callback === 'undefined' ? 'undefined' : _typeof(callback)) + ' given.', _this3.settings.showWarnings);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Add the given CSS class to the DOM element.\n         *\n         * @param {string} cssClassName\n         * @private\n         */\n\n    }, {\n        key: '_addCSSClass',\n        value: function _addCSSClass(cssClassName) {\n            this.domElement.classList.add(cssClassName);\n        }\n\n        /**\n         * Remove the given CSS class from the DOM element.\n         *\n         * @param {string} cssClassName\n         * @private\n         */\n\n    }, {\n        key: '_removeCSSClass',\n        value: function _removeCSSClass(cssClassName) {\n            this.domElement.classList.remove(cssClassName);\n        }\n\n        // This are the public function available on each autoNumeric-managed element\n\n        /**\n         * Method that updates the AutoNumeric settings, and immediately format the element accordingly.\n         * The options passed as parameter(s) is either one or many objects that each contains some settings, ie. :\n         * {\n         *     digitGroupSeparator: \".\",\n         *     decimalCharacter: \",\",\n         *     currencySymbol: '€ ',\n         * }\n         * If multiple options are passed, the latter overwrite the previous ones.\n         *\n         * Note: If the new settings are not validated, or the call to `set()` fails, then the previous valid settings are reverted back to.\n         *\n         * @example anElement.update({ options }) // Updates the settings\n         * @example anElement.update({ options1 }, { options2 }) // Updates the settings with multiple option objects\n         *\n         * @param {object} newOptions\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'update',\n        value: function update() {\n            // Keep a copy of the original settings before changing them, in case they do not validate correctly, so we can switch back to them\n            var originalSettings = _AutoNumericHelper2.default.cloneObject(this.settings); //TODO Check that the `styleRules` option is correctly cloned (due to depth cloning limitation)\n\n            // Store the current unformatted input value\n            var numericString = this.rawValue;\n\n            // Generate a single option object with the settings from the latter overwriting those from the former\n            var optionsToUse = {};\n\n            for (var _len2 = arguments.length, newOptions = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                newOptions[_key2] = arguments[_key2];\n            }\n\n            if (_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(newOptions) || newOptions.length === 0) {\n                optionsToUse = null;\n            } else if (newOptions.length >= 1) {\n                newOptions.forEach(function (optionObject) {\n                    _extends(optionsToUse, optionObject);\n                });\n            }\n\n            // Update the settings\n            try {\n                this._setSettings(optionsToUse, true);\n\n                // Reformat the input value with the new settings\n                // Note: we always `set`, even when `numericString` is the empty string '', since `emptyInputBehavior` (set to `always` or `zero`) can change how the empty input is formatted\n                this.set(numericString);\n            } catch (error) {\n                // If the settings validation fails, then we switch back to the previous valid settings\n                this._setSettings(originalSettings, true); // `_setSettings()` is used here instead of directly doing `this.settings = originalSettings;` since lots of side variables are calculated from the settings, and we need to get those back to their previous state. Note: `_setSettings()` is called in the 'update' mode in order to correctly set back the `originalDecimalPlacesRawValue` value.\n                _AutoNumericHelper2.default.throwError('Unable to update the settings, those are invalid: [' + error + ']');\n\n                return this;\n            }\n\n            return this;\n        }\n\n        /**\n         * Return the options object containing all the current autoNumeric settings in effect.\n         * You can then directly access each option by using its name : `anElement.getSettings().optionNameAutoCompleted`.\n         *\n         * @example\n         * anElement.getSettings()\n         * anElement.getSettings().decimalCharacter // Return the decimalCharacter setting as a string - any valid option name can be used\n         *\n         * @returns {object}\n         */\n\n    }, {\n        key: 'getSettings',\n        value: function getSettings() {\n            return this.settings;\n        }\n\n        /**\n         * Set the given element value, and format it immediately.\n         * Additionally, this `set()` method can accept options that will be merged into the current AutoNumeric element, taking precedence over any previous settings.\n         *\n         * @example anElement.set('12345.67') // Formats the value\n         * @example anElement.set(12345.67) // Formats the value\n         * @example anElement.set(12345.67, { decimalCharacter : ',' }) // Update the settings and formats the value in one go\n         * @example anElement.northAmerican().set('$12,345.67') // Set an already formatted value (this does not _exactly_ respect the currency symbol/negative placements, but only remove all non-numbers characters, according to the ones given in the settings)\n         * @example anElement.set(null) // Set the rawValue and element value to `null`\n         *\n         * @param {number|string|null} newValue The value must be a Number, a numeric string or `null` (if `emptyInputBehavior` is set to `'null'`)\n         * @param {object} options A settings object that will override the current settings. Note: the update is done only if the `newValue` is defined.\n         * @param {boolean} saveChangeToHistory If set to `true`, then the change is recorded in the history table\n         * @returns {AutoNumeric}\n         * @throws\n         */\n\n    }, {\n        key: 'set',\n        value: function set(newValue) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            var saveChangeToHistory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n            //TODO Add the `saveSettings` options. If `true`, then when `options` is passed, then it overwrite the current `this.settings`. If `false` the `options` are only used once and `this.settings` is not modified\n            if (_AutoNumericHelper2.default.isUndefined(newValue)) {\n                _AutoNumericHelper2.default.warning('You are trying to set an \\'undefined\\' value ; an error could have occurred.', this.settings.showWarnings);\n                return this;\n            }\n\n            // The options update is done only if the `newValue` is not `undefined`\n            if (!_AutoNumericHelper2.default.isNull(options)) {\n                this._setSettings(options, true); // We do not call `update` here since this would call `set` too\n            }\n\n            if (newValue === null && this.settings.emptyInputBehavior !== AutoNumeric.options.emptyInputBehavior.null) {\n                _AutoNumericHelper2.default.warning('You are trying to set the `null` value while the `emptyInputBehavior` option is set to ' + this.settings.emptyInputBehavior + '. If you want to be able to set the `null` value, you need to change the \\'emptyInputBehavior\\' option to `\\'null\\'`.', this.settings.showWarnings);\n                return this;\n            }\n\n            var value = void 0;\n            if (newValue === null) {\n                //TODO Merge this into a global `if (newValue === null) {` test, with the test above\n                // Here this.settings.emptyInputBehavior === AutoNumeric.options.emptyInputBehavior.null\n                this._setElementAndRawValue(null, null, saveChangeToHistory);\n                this._saveValueToPersistentStorage();\n\n                return this;\n            }\n\n            value = this.constructor._toNumericValue(newValue, this.settings);\n            if (isNaN(Number(value))) {\n                //TODO Do not modify the element value if the newValue results in `NaN`. Make sure the settings, if modified, are revert back too.\n                _AutoNumericHelper2.default.warning('The value you are trying to set results in `NaN`. The element value is set to the empty string instead.', this.settings.showWarnings);\n                this.setValue('', saveChangeToHistory);\n\n                return this;\n            }\n\n            if (value === '' && this.settings.emptyInputBehavior === AutoNumeric.options.emptyInputBehavior.zero) {\n                // Keep the value zero inside the element\n                value = 0;\n            }\n\n            if (value !== '') {\n                var _constructor$_checkIf = this.constructor._checkIfInRangeWithOverrideOption(value, this.settings),\n                    _constructor$_checkIf2 = _slicedToArray(_constructor$_checkIf, 2),\n                    minTest = _constructor$_checkIf2[0],\n                    maxTest = _constructor$_checkIf2[1];\n\n                // Modify the formatted value if the rawValue is found in the `valuesToStrings` option\n\n\n                if (minTest && maxTest && this.settings.valuesToStrings && this._checkValuesToStrings(value)) {\n                    // Set the raw value normally, and the formatted value with the corresponding string\n                    this._setElementAndRawValue(this.settings.valuesToStrings[value], value, saveChangeToHistory);\n                    this._saveValueToPersistentStorage();\n\n                    return this;\n                }\n\n                // This test is needed by the `showPositiveSign` option\n                var isZero = _AutoNumericHelper2.default.isZeroOrHasNoValue(value);\n                if (isZero) {\n                    value = '0';\n                }\n\n                if (minTest && maxTest) {\n                    var forcedRawValue = this.constructor._roundRawValue(value, this.settings);\n                    forcedRawValue = this._trimLeadingAndTrailingZeros(forcedRawValue.replace(this.settings.decimalCharacter, '.')); // Move the `setRawValue` call after the `setElementValue` one\n                    value = this._getRawValueToFormat(value); // Multiply the raw value to obtain the formatted value\n\n                    // Round the given value according to the object state (focused/unfocused)\n                    if (this.isFocused) {\n                        value = this.constructor._roundFormattedValueShownOnFocus(value, this.settings);\n                    } else {\n                        if (this.settings.divisorWhenUnfocused) {\n                            value = value / this.settings.divisorWhenUnfocused;\n                            value = value.toString();\n                        }\n\n                        value = this.constructor._roundFormattedValueShownOnBlur(value, this.settings);\n                    }\n\n                    value = this.constructor._modifyNegativeSignAndDecimalCharacterForFormattedValue(value, this.settings);\n                    value = this.constructor._addGroupSeparators(value, this.settings, this.isFocused, this.rawValue, forcedRawValue);\n                    if (!this.isFocused && this.settings.symbolWhenUnfocused) {\n                        value = '' + value + this.settings.symbolWhenUnfocused;\n                    }\n\n                    if (this.settings.decimalPlacesShownOnFocus || this.settings.divisorWhenUnfocused) {\n                        this._saveValueToPersistentStorage();\n                    }\n\n                    this._setElementAndRawValue(value, forcedRawValue, saveChangeToHistory);\n\n                    return this;\n                } else {\n                    if (!minTest) {\n                        _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.minRangeExceeded, this.domElement);\n                    }\n\n                    if (!maxTest) {\n                        _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.maxRangeExceeded, this.domElement);\n                    }\n\n                    _AutoNumericHelper2.default.throwError('The value [' + value + '] being set falls outside of the minimumValue [' + this.settings.minimumValue + '] and maximumValue [' + this.settings.maximumValue + '] range set for this element');\n\n                    this._removeValueFromPersistentStorage();\n                    this.setValue('', saveChangeToHistory); //TODO Shouldn't we just drop that faulty newValue and keep the previous one? This is behind a `throwError()` call anyway..\n\n                    return this;\n                }\n            } else {\n                // Here, `value` equal the empty string `''`\n                var result = void 0;\n                if (this.settings.emptyInputBehavior === AutoNumeric.options.emptyInputBehavior.always) {\n                    // Keep the currency symbol as per emptyInputBehavior\n                    result = this.settings.currencySymbol;\n                } else {\n                    result = '';\n                }\n\n                this._setElementAndRawValue(result, '', saveChangeToHistory);\n\n                return this;\n            }\n        }\n\n        /**\n         * Set the given value directly as the DOM element value, without formatting it beforehand.\n         * You can also set the value and update the setting in one go (the value will again not be formatted immediately).\n         *\n         * @param {number|string} value\n         * @param {object} options\n         * @returns {AutoNumeric}\n         * @throws\n         */\n\n    }, {\n        key: 'setUnformatted',\n        value: function setUnformatted(value) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            //TODO Should we use `AutoNumeric.unformat()` here and set the unformatted result in case `value` is formatted?\n            if (value === null || _AutoNumericHelper2.default.isUndefined(value)) {\n                return this;\n            }\n\n            // The options update is done only if the `value` is not null\n            if (!_AutoNumericHelper2.default.isNull(options)) {\n                this._setSettings(options, true); // We do not call `update` here since this would call `set` too\n            }\n\n            var strippedValue = this.constructor._removeBrackets(value, this.settings);\n            var normalizedValue = this.constructor._stripAllNonNumberCharacters(strippedValue, this.settings, true, this.isFocused);\n            normalizedValue = normalizedValue.replace(this.settings.decimalCharacter, '.');\n            if (!_AutoNumericHelper2.default.isNumber(normalizedValue)) {\n                _AutoNumericHelper2.default.throwError('The value is not a valid one, it\\'s not a numeric string nor a recognized currency.');\n            }\n\n            var _constructor$_checkIf3 = this.constructor._checkIfInRangeWithOverrideOption(normalizedValue, this.settings),\n                _constructor$_checkIf4 = _slicedToArray(_constructor$_checkIf3, 2),\n                minTest = _constructor$_checkIf4[0],\n                maxTest = _constructor$_checkIf4[1];\n\n            if (minTest && maxTest) {\n                // If the `normalizedValue` is in the range\n                this.setValue(value);\n            } else {\n                _AutoNumericHelper2.default.throwError('The value is out of the range limits [' + this.settings.minimumValue + ', ' + this.settings.maximumValue + '].');\n            }\n\n            return this;\n        }\n\n        /**\n         * Set the given value directly as the DOM element value, without formatting it beforehand, and without checking its validity.\n         * This also updates the `rawValue` with the given `newValue`, without checking it too ; if it's not formatted like a number recognized by Javascript, this *will* likely make other AutoNumeric methods fail.\n         *\n         * @param {string|number|null} newValue The new value to set on the element\n         * @param {boolean} saveChangeToHistory If set to `true`, then the change is recorded in the history array, otherwise it is not\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'setValue',\n        value: function setValue(newValue) {\n            var saveChangeToHistory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n            this._setElementAndRawValue(newValue, saveChangeToHistory);\n\n            return this;\n        }\n\n        /**\n         * Save the raw value inside the AutoNumeric object.\n         *\n         * @param {number|string|null} rawValue The numeric value as understood by Javascript like a `Number`\n         * @param {boolean} saveChangeToHistory If set to `true`, then the change is recorded in the history array, otherwise it is not\n         * @private\n         */\n\n    }, {\n        key: '_setRawValue',\n        value: function _setRawValue(rawValue) {\n            var saveChangeToHistory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n            // Only set the raw value if the given value is different than the current one\n            if (this.rawValue !== rawValue) {\n                //TODO Manage the case where one value is a string while the other is a number?\n                // Update the raw value\n                this.rawValue = rawValue; // By default, if the `rawValue` is changed programmatically\n\n                if (!_AutoNumericHelper2.default.isNull(this.settings.rawValueDivisor) && this.settings.rawValueDivisor !== 0 && // Only divide if the `rawValueDivisor` option is set\n                rawValue !== '' && rawValue !== null && // Do not modify the `rawValue` if it's an empty string or null\n                this._isUserManuallyEditingTheValue()) {\n                    // If the user is manually changing the element value\n                    this.rawValue /= this.settings.rawValueDivisor;\n                }\n\n                // Change the element style or use the relevant callbacks\n                this._parseStyleRules();\n\n                if (saveChangeToHistory) {\n                    // Save in the history the last known raw value and formatted result selection\n                    this._historyTableAdd();\n                }\n            }\n        }\n\n        /**\n         * Set the given value on the DOM element, without affecting the `rawValue`.\n         * This send an 'autoNumeric:formatted' event if the new value is different than the old one.\n         *\n         * @param {number|string} newElementValue\n         * @returns {AutoNumeric}\n         * @private\n         */\n\n    }, {\n        key: '_setElementValue',\n        value: function _setElementValue(newElementValue) {\n            //TODO Use an internal attribute to track the current value of the element `formattedValue` (like its counterpart `rawValue`). This would allow us to avoid calling `getElementValue` many times\n            // `oldElementValue` is the previous value that will be overwritten. This is used to decide if an event should be sent or not.\n            var oldElementValue = _AutoNumericHelper2.default.getElementValue(this.domElement);\n\n            if (newElementValue !== oldElementValue) {\n                // Only update the value if it's different from the current one\n                _AutoNumericHelper2.default.setElementValue(this.domElement, newElementValue);\n                _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.formatted, this.domElement, { oldValue: oldElementValue, newValue: newElementValue });\n            }\n\n            return this;\n        }\n\n        /**\n         * Set the given value on the DOM element, and the raw value on `this.rawValue`, if both are given.\n         * If only one value is given, then both the DOM element value and the raw value are set with that value.\n         * The third argument `saveChangeToHistory` defines if the change should be recorded in the history array.\n         * Note: if the second argument `rawValue` is a boolean, we consider that is really is the `saveChangeToHistory` argument.\n         *\n         * @param {number|string|null} newElementValue\n         * @param {number|string|null|boolean} rawValue\n         * @param {boolean} saveChangeToHistory\n         * @returns {AutoNumeric}\n         * @private\n         */\n\n    }, {\n        key: '_setElementAndRawValue',\n        value: function _setElementAndRawValue(newElementValue) {\n            var rawValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            var saveChangeToHistory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n            if (_AutoNumericHelper2.default.isNull(rawValue)) {\n                rawValue = newElementValue;\n            } else if (_AutoNumericHelper2.default.isBoolean(rawValue)) {\n                saveChangeToHistory = rawValue;\n                rawValue = newElementValue;\n            }\n\n            //XXX The order here is important ; the value should first be set on the element, then and only then we should update the raw value\n            // In the `set()` function, we make sure to call `_setRawValue` *after* `setElementValue` so that if `_setRawValue` calls a callback that modify the `rawValue`, then the new value is set correctly (after `setElementValue` briefly set its value first)\n            this._setElementValue(newElementValue);\n            this._setRawValue(rawValue, saveChangeToHistory);\n\n            return this;\n        }\n\n        /**\n         * Return the multiplied raw value with the `rawValueDivisor`.\n         * This is used to display different values between the raw and formatted values.\n         *\n         * @param {number|string|null} rawValue The numeric value as understood by Javascript like a `Number`\n         * @returns {number|string|null}\n         * @private\n         */\n\n    }, {\n        key: '_getRawValueToFormat',\n        value: function _getRawValueToFormat(rawValue) {\n            var rawValueForTheElementValue = void 0;\n            if (!_AutoNumericHelper2.default.isNull(this.settings.rawValueDivisor) && this.settings.rawValueDivisor !== 0 && // Only multiply if the `rawValueDivisor` option is set\n            rawValue !== '' && rawValue !== null) {\n                // Do not modify the `rawValue` if it's an empty string or null\n                // !this._isUserManuallyEditingTheValue()) { // If the user is NOT manually changing the element value, but that is done programmatically\n                rawValueForTheElementValue = rawValue * this.settings.rawValueDivisor;\n            } else {\n                rawValueForTheElementValue = rawValue;\n            }\n\n            return rawValueForTheElementValue;\n        }\n\n        /**\n         * Check if the given value has a corresponding key in the `valuesToStrings` option object.\n         *\n         * @param {number|string} value\n         * @returns {boolean} Returns `true` if such a key is found.\n         * @private\n         */\n\n    }, {\n        key: '_checkValuesToStrings',\n        value: function _checkValuesToStrings(value) {\n            return _AutoNumericHelper2.default.isInArray(String(value), this.valuesToStringsKeys);\n        }\n\n        /**\n         * Return `true` if the user is currently modifying the element value manually.\n         *\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_isUserManuallyEditingTheValue',\n        value: function _isUserManuallyEditingTheValue() {\n            // return (this.isFocused && this.isEditing) || this.isWheelEvent || this.isDropEvent;\n            return this.isFocused && this.isEditing || this.isDropEvent;\n        }\n\n        /**\n         * Execute the given callback function using the given result as its first parameter, and the AutoNumeric object as its second.\n         *\n         * @param {number|string|Array|null} result\n         * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second\n         * @private\n         */\n\n    }, {\n        key: '_executeCallback',\n        value: function _executeCallback(result, callback) {\n            if (!_AutoNumericHelper2.default.isNull(callback) && _AutoNumericHelper2.default.isFunction(callback)) {\n                callback(result, this);\n            }\n        }\n\n        /**\n         * Alias of the `getNumericString()` function.\n         * Developers should use one of the more explicit function names to get what they want :\n         * - a numeric string : `getNumericString()`\n         * - a formatted string : `getFormatted()`\n         * - a number : `getNumber()`, or\n         * - a localized numeric string : `getLocalized()`\n         *\n         * @usage anElement.get();\n         *\n         * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second\n         *\n         * @deprecated\n         * @returns {string|null}\n         */\n\n    }, {\n        key: 'get',\n        value: function get() {\n            var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            return this.getNumericString(callback);\n        }\n\n        /**\n         * Return the unformatted value as a string.\n         * This can also return `null` if `rawValue` is null.\n         *\n         * @usage anElement.getNumericString();\n         *\n         * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second\n         *\n         * @returns {string|null}\n         */\n\n    }, {\n        key: 'getNumericString',\n        value: function getNumericString() {\n            var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            var result = void 0;\n            if (_AutoNumericHelper2.default.isNull(this.rawValue)) {\n                result = null;\n            } else {\n                // Always return a numeric string\n                // The following statement gets rid of the trailing zeros in the decimal places since the current method does not pad decimals\n                result = _AutoNumericHelper2.default.trimPaddedZerosFromDecimalPlaces(this.rawValue);\n            }\n\n            this._executeCallback(result, callback);\n\n            return result;\n        }\n\n        /**\n         * Return the current formatted value of the AutoNumeric element as a string\n         *\n         * @usage anElement.getFormatted()\n         *\n         * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second\n         *\n         * @returns {string}\n         */\n\n    }, {\n        key: 'getFormatted',\n        value: function getFormatted() {\n            var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            if (!('value' in this.domElement || 'textContent' in this.domElement)) {\n                // Make sure `.value` or `.textContent' exists before trying to access those properties\n                _AutoNumericHelper2.default.throwError('Unable to get the formatted string from the element.');\n            }\n\n            var result = _AutoNumericHelper2.default.getElementValue(this.domElement);\n            this._executeCallback(result, callback);\n\n            return result;\n        }\n\n        /**\n         * Return the element unformatted value as a real Javascript number.\n         * Warning: This can lead to precision problems with big numbers that should be stored as strings.\n         *\n         * @usage anElement.getNumber()\n         *\n         * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second\n         *\n         * @returns {number|null}\n         */\n\n    }, {\n        key: 'getNumber',\n        value: function getNumber() {\n            var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            var result = void 0;\n            if (this.rawValue === null) {\n                result = null;\n            } else {\n                result = this.constructor._toLocale(this.getNumericString(), 'number');\n            }\n\n            this._executeCallback(result, callback);\n\n            return result;\n        }\n\n        /**\n         * Returns the unformatted value, but following the `outputFormat` setting, which means the output can either be :\n         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\n         * - a plain number (if the setting 'number' is used).\n         *\n         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\n         * Check the \"outputFormat\" option definition for more details.\n         *\n         * @usage anElement.getLocalized();\n         *\n         * @param {null|string|function} forcedOutputFormat If set to something different than `null`, then this is used as an overriding outputFormat option\n         * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second\n         *\n         * @returns {*}\n         */\n\n    }, {\n        key: 'getLocalized',\n        value: function getLocalized() {\n            var forcedOutputFormat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n            var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            // First, check if only a callback has been passed, and if so, sanitize the parameters\n            if (_AutoNumericHelper2.default.isFunction(forcedOutputFormat) && _AutoNumericHelper2.default.isNull(callback)) {\n                callback = forcedOutputFormat;\n                forcedOutputFormat = null;\n            }\n\n            // Then get the localized value\n            var value = void 0;\n            if (_AutoNumericHelper2.default.isEmptyString(this.rawValue)) {\n                value = '';\n            } else {\n                // Here I use `this.rawValue` instead of `this.getNumericString()` since the current input value could be unformatted with a localization (ie. '1234567,89-').\n                // I also convert the rawValue to a number, then back to a string in order to drop the decimal part if the rawValue is an integer.\n                value = '' + Number(this.rawValue);\n            }\n\n            if (value !== '' && Number(value) === 0 && this.settings.leadingZero !== AutoNumeric.options.leadingZero.keep) {\n                value = '0';\n            }\n\n            var outputFormatToUse = void 0;\n            if (_AutoNumericHelper2.default.isNull(forcedOutputFormat)) {\n                outputFormatToUse = this.settings.outputFormat;\n            } else {\n                outputFormatToUse = forcedOutputFormat;\n            }\n\n            var result = this.constructor._toLocale(value, outputFormatToUse);\n            this._executeCallback(result, callback);\n\n            return result;\n        }\n\n        /**\n         * Force the element to reformat its value again (just in case the formatting has been lost).\n         * This can be used right after a form submission for instance (after a previous call to `unformat`).\n         *\n         * @example anElement.reformat()\n         *\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'reformat',\n        value: function reformat() {\n            // `this.rawValue` is used instead of `this.domElement.value` because when the content is `unformatLocalized`, it can become a string that cannot be converted to a number easily\n            this.set(this.rawValue);\n\n            return this;\n        }\n\n        /**\n         * Remove the formatting and keep only the raw unformatted value in the element (as a numericString)\n         * Note: this is loosely based on the previous 'unSet()' function\n         *\n         * By default, values are returned as ISO numeric strings (ie. \"1234.56\" or \"-1234.56\"), where the decimal character is a period.\n         * @example anElement.unformat()\n         *\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'unformat',\n        value: function unformat() {\n            this._setElementValue(this.getNumericString());\n\n            return this;\n        }\n\n        /**\n         * Remove the formatting and keep only the localized unformatted value in the element, with the option to override the default outputFormat if needed\n         *\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers.\n         * Take a look at the `outputFormat` option definition in the default settings for more details.\n         *\n         * @param {null|string} forcedOutputFormat If set to something different than `null`, then this is used as an overriding outputFormat option\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'unformatLocalized',\n        value: function unformatLocalized() {\n            var forcedOutputFormat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            this._setElementValue(this.getLocalized(forcedOutputFormat));\n\n            return this;\n        }\n\n        /**\n         * Return `true` if the current value is the same as when the element got initialized.\n         * Note: By default, this returns `true` if the raw unformatted value is still the same even if the formatted one has changed (due to a configuration update for instance).\n         * In order to test if the formatted value is the same (which means neither the raw value nor the settings have been changed), then you must pass `false` as its argument.\n         *\n         * @param {boolean} checkOnlyRawValue If set to `true`, the pristine value is done on the raw unformatted value, not the formatted one.  If set to `false`, this also checks that the formatted value hasn't changed.\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isPristine',\n        value: function isPristine() {\n            var checkOnlyRawValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n            var result = void 0;\n            if (checkOnlyRawValue) {\n                result = this.initialValue === this.getNumericString();\n            } else {\n                result = this.initialValueHtmlAttribute === this.getFormatted();\n            }\n\n            return result;\n        }\n\n        /**\n         * Select the formatted element content, based on the `selectNumberOnly` option\n         *\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'select',\n        value: function select() {\n            if (this.settings.selectNumberOnly) {\n                this.selectNumber();\n            } else {\n                this._defaultSelectAll();\n            }\n\n            return this;\n        }\n\n        /**\n         * Select the whole element content (including the currency symbol).\n         * @private\n         */\n\n    }, {\n        key: '_defaultSelectAll',\n        value: function _defaultSelectAll() {\n            _AutoNumericHelper2.default.setElementSelection(this.domElement, 0, _AutoNumericHelper2.default.getElementValue(this.domElement).length);\n        }\n\n        /**\n         * Select only the numbers in the formatted element content, leaving out the currency symbol, whatever the value of the `selectNumberOnly` option\n         *\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'selectNumber',\n        value: function selectNumber() {\n            //TODO Make sure the selection is ok when showPositiveSign is set to `true` (select the negative sign, but not the positive one)\n            var unformattedValue = _AutoNumericHelper2.default.getElementValue(this.domElement);\n            var valueLen = unformattedValue.length;\n            var currencySymbolSize = this.settings.currencySymbol.length;\n            var currencySymbolPlacement = this.settings.currencySymbolPlacement;\n            var negLen = !_AutoNumericHelper2.default.isNegative(unformattedValue) ? 0 : 1;\n            var suffixTextLen = this.settings.suffixText.length;\n\n            var start = void 0;\n            if (currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) {\n                start = 0;\n            } else if (this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.left && negLen === 1 && currencySymbolSize > 0) {\n                start = currencySymbolSize + 1;\n            } else {\n                start = currencySymbolSize;\n            }\n\n            var end = void 0;\n            if (currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix) {\n                end = valueLen - suffixTextLen;\n            } else {\n                switch (this.settings.negativePositiveSignPlacement) {\n                    case AutoNumeric.options.negativePositiveSignPlacement.left:\n                        end = valueLen - (suffixTextLen + currencySymbolSize);\n                        break;\n                    case AutoNumeric.options.negativePositiveSignPlacement.right:\n                        if (currencySymbolSize > 0) {\n                            end = valueLen - (currencySymbolSize + negLen + suffixTextLen);\n                        } else {\n                            end = valueLen - (currencySymbolSize + suffixTextLen);\n                        }\n                        break;\n                    default:\n                        end = valueLen - (currencySymbolSize + suffixTextLen);\n                }\n            }\n\n            _AutoNumericHelper2.default.setElementSelection(this.domElement, start, end);\n\n            return this;\n        }\n\n        /**\n         * Select only the integer part in the formatted element content, whatever the value of `selectNumberOnly`\n         *\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'selectInteger',\n        value: function selectInteger() {\n            var start = 0;\n            var isPositive = this.rawValue >= 0;\n\n            // Negative or positive sign, if any\n            if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix || this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix && (this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.prefix || this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.none)) {\n                if (this.settings.showPositiveSign && isPositive || // This only exclude the positive sign from being selected\n                !isPositive && this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix && this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.left) {\n                    // And this exclude the negative sign from being selected in this special case : '-€ 1.234,57suffixText'\n                    start = start + 1;\n                }\n            }\n\n            // Currency symbol\n            if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix) {\n                start = start + this.settings.currencySymbol.length;\n            }\n\n            // Calculate the selection end position\n            var elementValue = _AutoNumericHelper2.default.getElementValue(this.domElement);\n            var end = elementValue.indexOf(this.settings.decimalCharacter);\n            if (end === -1) {\n                // No decimal character found\n                if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) {\n                    end = elementValue.length - this.settings.currencySymbol.length;\n                } else {\n                    end = elementValue.length;\n                }\n\n                // Trailing negative sign\n                if (!isPositive && (this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.suffix || this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix)) {\n                    end = end - 1;\n                }\n\n                // Avoid selecting the suffix test\n                end = end - this.settings.suffixText.length;\n            }\n\n            _AutoNumericHelper2.default.setElementSelection(this.domElement, start, end);\n\n            return this;\n        }\n\n        /**\n         * Select only the decimal part in the formatted element content, whatever the value of `selectNumberOnly`\n         * Multiple cases are possible :\n         * +1.234,57suffixText\n         *\n         * € +1.234,57suffixText\n         * +€ 1.234,57suffixText\n         * € 1.234,57+suffixText\n         *\n         * 1.234,57+ €suffixText\n         * 1.234,57 €+suffixText\n         * +1.234,57 €suffixText\n         *\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'selectDecimal',\n        value: function selectDecimal() {\n            var start = _AutoNumericHelper2.default.getElementValue(this.domElement).indexOf(this.settings.decimalCharacter);\n            var end = void 0;\n\n            if (start === -1) {\n                // The decimal character has not been found, we deselect all\n                start = 0;\n                end = 0;\n            } else {\n                // A decimal character has been found\n                start = start + 1; // We add 1 to exclude the decimal character from the selection\n\n                var decimalCount = void 0;\n                if (this.isFocused) {\n                    decimalCount = this.settings.decimalPlacesShownOnFocus;\n                } else {\n                    decimalCount = this.settings.decimalPlacesShownOnBlur;\n                }\n\n                end = start + Number(decimalCount);\n            }\n\n            _AutoNumericHelper2.default.setElementSelection(this.domElement, start, end);\n\n            return this;\n        }\n\n        /**\n         * Return the DOM element reference of the autoNumeric-managed element\n         *\n         * @returns {HTMLElement|HTMLInputElement}\n         */\n\n    }, {\n        key: 'node',\n        value: function node() {\n            return this.domElement;\n        }\n\n        /**\n         * Return the DOM element reference of the parent node of the autoNumeric-managed element\n         *\n         * @returns {HTMLElement|HTMLInputElement|Node}\n         */\n\n    }, {\n        key: 'parent',\n        value: function parent() {\n            return this.domElement.parentNode;\n        }\n\n        /**\n         * Detach the current AutoNumeric element from the shared local 'init' list.\n         * This means any changes made on that local shared list will not be transmitted to that element anymore.\n         * Note : The user can provide another AutoNumeric element, and detach this one instead of the current one.\n         *\n         * @param {AutoNumeric} otherAnElement\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'detach',\n        value: function detach() {\n            var otherAnElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n            //FIXME test this\n            var domElementToDetach = void 0;\n            if (!_AutoNumericHelper2.default.isNull(otherAnElement)) {\n                domElementToDetach = otherAnElement.node();\n            } else {\n                domElementToDetach = this.domElement;\n            }\n\n            this._removeFromLocalList(domElementToDetach); //FIXME What happens if the selected dom element does not exist in the list?\n\n            return this;\n        }\n\n        /**\n         * Attach the given AutoNumeric element to the shared local 'init' list.\n         * When doing that, by default the DOM content is left untouched.\n         * The user can force a reformat with the new shared list options by passing a second argument to `true`.\n         *\n         * @param {AutoNumeric} otherAnElement\n         * @param {boolean} reFormat\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'attach',\n        value: function attach(otherAnElement) {\n            var reFormat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            //FIXME test this\n            this._addToLocalList(otherAnElement.node()); //FIXME Should we make sure the element is not already in the list?\n            if (reFormat) {\n                otherAnElement.update(this.settings);\n            }\n\n            return this;\n        }\n\n        /**\n         * Format and return the given value, or set the formatted value into the given DOM element if one is passed as an argument.\n         * By default, this use the current element settings.\n         * The user can override any option of its choosing by passing an option object.\n         *\n         * @param {number|HTMLElement|HTMLInputElement} valueOrElement\n         * @param {null|object} optionOverride\n         * @returns {string|null}\n         */\n\n    }, {\n        key: 'formatOther',\n        value: function formatOther(valueOrElement) {\n            var optionOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            //FIXME test this\n            return this._formatOrUnformatOther(true, valueOrElement, optionOverride);\n        }\n\n        /**\n         * Unformat and return the raw numeric string corresponding to the given value, or directly set the unformatted value into the given DOM element if one is passed as an argument.\n         * By default, this use the current element settings.\n         * The user can override any option of its choosing by passing an option object.\n          * @param {string|HTMLElement|HTMLInputElement} stringOrElement\n         * @param {null|object} optionOverride\n         * @returns {string|null}\n         */\n\n    }, {\n        key: 'unformatOther',\n        value: function unformatOther(stringOrElement) {\n            var optionOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            //FIXME test this\n            return this._formatOrUnformatOther(false, stringOrElement, optionOverride);\n        }\n\n        /**\n         * Method that either format or unformat the value of another element.\n         *\n         * - Format and return the given value, or set the formatted value into the given DOM element if one is passed as an argument.\n         * - Unformat and return the raw numeric string corresponding to the given value, or directly set the unformatted value into the given DOM element if one is passed as an argument.\n         *\n         * By default, this use the current element settings.\n         * The user can override any option of its choosing by passing an option object.\n         *\n         * @param {boolean} isFormatting If set to `true`, then the method formats, otherwise if set to `false`, it unformats\n         * @param {number|string|HTMLElement|HTMLInputElement} valueOrStringOrElement\n         * @param {null|object} optionOverride\n         * @returns {string|null}\n         * @private\n         */\n\n    }, {\n        key: '_formatOrUnformatOther',\n        value: function _formatOrUnformatOther(isFormatting, valueOrStringOrElement) {\n            var optionOverride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n            //FIXME test this\n            // If the user wants to override the current element settings temporarily\n            var settingsToUse = void 0;\n            if (!_AutoNumericHelper2.default.isNull(optionOverride)) {\n                settingsToUse = this._cloneAndMergeSettings(optionOverride);\n            } else {\n                settingsToUse = this.settings;\n            }\n\n            // Then the unformatting is done...\n            var result = void 0;\n            if (_AutoNumericHelper2.default.isElement(valueOrStringOrElement)) {\n                // ...either directly on the DOM element value\n                var elementValue = _AutoNumericHelper2.default.getElementValue(valueOrStringOrElement);\n                if (isFormatting) {\n                    result = AutoNumeric.format(elementValue, settingsToUse);\n                } else {\n                    result = AutoNumeric.unformat(elementValue, settingsToUse);\n                }\n\n                _AutoNumericHelper2.default.setElementValue(valueOrStringOrElement, result); //TODO Use `unformatAndSet` and `formatAndSet`instead\n\n                return null;\n            }\n\n            // ...or on the given value\n            if (isFormatting) {\n                result = AutoNumeric.format(valueOrStringOrElement, settingsToUse);\n            } else {\n                result = AutoNumeric.unformat(valueOrStringOrElement, settingsToUse);\n            }\n\n            return result;\n        }\n\n        /**\n         * Use the current AutoNumeric element settings to initialize the DOM element(s) given as a parameter.\n         * Doing so will *link* the AutoNumeric elements together since they will share the same local AutoNumeric element list.\n         * (cf. prototype pattern : https://en.wikipedia.org/wiki/Prototype_pattern)\n         *\n         * You can `init` either a single DOM element (in that case an AutoNumeric object will be returned), or an array of DOM elements or a string that will be used as a CSS selector. In the latter cases, an array of AutoNumeric objects will then be returned (or an empty array if nothing gets selected by the CSS selector).\n         *\n         * Use case : Once you have an AutoNumeric element already setup correctly with the right options, you can use it as many times you want to initialize as many other DOM elements as needed.\n         * Note : this works only on elements that can be managed by autoNumeric.\n         *\n         * @param {HTMLElement|HTMLInputElement|Array<HTMLElement|HTMLInputElement>|string} domElementOrArrayOrString\n         * @param {boolean} attached If set to `false`, then the newly generated AutoNumeric element will not share the same local element list\n         * @returns {AutoNumeric|[AutoNumeric]}\n         */\n\n    }, {\n        key: 'init',\n        value: function init(domElementOrArrayOrString) {\n            var _this4 = this;\n\n            var attached = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n            var returnASingleAutoNumericObject = false; // By default, this function returns an array of AutoNumeric objects\n            var domElementsArray = [];\n            if (_AutoNumericHelper2.default.isString(domElementOrArrayOrString)) {\n                domElementsArray = [].concat(_toConsumableArray(document.querySelectorAll(domElementOrArrayOrString))); // Convert a NodeList to an Array\n            } else if (_AutoNumericHelper2.default.isElement(domElementOrArrayOrString)) {\n                domElementsArray.push(domElementOrArrayOrString);\n                returnASingleAutoNumericObject = true; // Special case when only one DOM element is passed as a parameter\n            } else if (_AutoNumericHelper2.default.isArray(domElementOrArrayOrString)) {\n                domElementsArray = domElementOrArrayOrString;\n            } else {\n                _AutoNumericHelper2.default.throwError('The given parameters to the \\'init\\' function are invalid.');\n            }\n\n            if (domElementsArray.length === 0) {\n                _AutoNumericHelper2.default.warning('No valid DOM elements were given hence no AutoNumeric object were instantiated.', true);\n\n                return [];\n            }\n\n            var currentLocalList = this._getLocalList();\n            var autoNumericObjectsArray = [];\n\n            // Instantiate (and link depending on `attached`) each AutoNumeric objects\n            domElementsArray.forEach(function (domElement) {\n                // Initialize the new AutoNumeric element\n                var originalCreateLocalListSetting = _this4.settings.createLocalList;\n                if (attached) {\n                    // Temporary variable to know if we should create the local list during the initialization (since we'll remove it afterwards)\n                    _this4.settings.createLocalList = false;\n                }\n\n                var newAutoNumericElement = new AutoNumeric(domElement, _AutoNumericHelper2.default.getElementValue(domElement), _this4.settings);\n\n                // Set the common shared local list if needed\n                // If the user wants to create a detached new AutoNumeric element, then skip the following step that bind the two elements together by default\n                if (attached) {\n                    // 1) Set the local list reference to point to the initializer's one\n                    newAutoNumericElement._setLocalList(currentLocalList);\n\n                    // 2) Add the new element to that existing list\n                    _this4._addToLocalList(domElement, newAutoNumericElement); // Here we use the *new* AutoNumeric object reference to add to the local list, since we'll need the reference to `this` in the methods to points to that new AutoNumeric object.\n                    _this4.settings.createLocalList = originalCreateLocalListSetting;\n                }\n\n                autoNumericObjectsArray.push(newAutoNumericElement);\n            });\n\n            if (returnASingleAutoNumericObject) {\n                // If a single DOM element was used as the parameter, then we return an AutoNumeric object directly\n                return autoNumericObjectsArray[0];\n            }\n\n            // ...otherwise we return an Array of AutoNumeric objects\n            return autoNumericObjectsArray;\n        }\n\n        /**\n         * Reset the element value either to the empty string '', or the currency sign, depending on the `emptyInputBehavior` option value.\n         * If you set the `forceClearAll` argument to `true`, then the `emptyInputBehavior` option is overridden and the whole input is clear, including any currency sign.\n         *\n         * @param {boolean} forceClearAll\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'clear',\n        value: function clear() {\n            var forceClearAll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            if (forceClearAll) {\n                var temporaryForcedOptions = {\n                    emptyInputBehavior: AutoNumeric.options.emptyInputBehavior.focus\n                };\n                this.set('', temporaryForcedOptions);\n            } else {\n                this.set('');\n            }\n\n            return this;\n        }\n\n        /**\n         * Remove the autoNumeric data and event listeners from the element, but keep the element content intact.\n         * This also clears the value from sessionStorage (or cookie, depending on browser supports).\n         * Note: this does not remove the formatting.\n         *\n         * @example anElement.remove()\n         */\n\n    }, {\n        key: 'remove',\n        value: function remove() {\n            this._removeValueFromPersistentStorage();\n            this._removeEventListeners();\n\n            // Also remove the element from the local AutoNumeric list\n            this._removeFromLocalList(this.domElement);\n            // Also remove the element from the global AutoNumeric list\n            this.constructor._removeFromGlobalList(this);\n        }\n\n        /**\n         * Remove the autoNumeric data and event listeners from the element, and reset its value to the empty string ''.\n         * This also clears the value from sessionStorage (or cookie, depending on browser supports).\n         *\n         * @example anElement.wipe()\n         */\n\n    }, {\n        key: 'wipe',\n        value: function wipe() {\n            this._setElementValue('');\n            this.remove();\n        }\n\n        /**\n         * Remove the autoNumeric data and event listeners from the element, and delete the DOM element altogether\n         */\n\n    }, {\n        key: 'nuke',\n        value: function nuke() {\n            this.remove();\n            // Remove the element from the DOM\n            this.domElement.parentNode.removeChild(this.domElement);\n        }\n\n        // Special functions that really work on the parent <form> element, instead of the <input> element itself\n\n        /**\n         * Return a reference to the parent <form> element if it exists, otherwise return `null`.\n         * If the parent form element as already been found, this directly return a reference to it.\n         * However, you can force AutoNumeric to search again for its reference by passing `true` as a parameter to this method.\n         * This method updates the `this.parentForm` attribute.\n         *\n         * @param {boolean} forceSearch If set to `true`, the parent form is searched again, even if `this.parentForm` is already set.\n         * @returns {HTMLFormElement|null}\n         */\n\n    }, {\n        key: 'form',\n        value: function form() {\n            var forceSearch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            if (forceSearch || _AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(this.parentForm)) {\n                this.parentForm = this._getParentForm();\n            }\n\n            return this.parentForm;\n        }\n\n        /**\n         * Return a reference to the parent <form> element if it exists, otherwise return `null`.\n         *\n         * @returns {HTMLFormElement|null}\n         * @private\n         */\n\n    }, {\n        key: '_getParentForm',\n        value: function _getParentForm() {\n            if (this.domElement.tagName.toLowerCase() === 'body') {\n                return null;\n            }\n\n            var node = this.domElement;\n            var tagName = void 0;\n            do {\n                node = node.parentNode;\n                if (_AutoNumericHelper2.default.isNull(node)) {\n                    // Special case when using templates with frameworks like Vue.js, where the input element can be 'detached' when initializing the DOM structure\n                    return null;\n                }\n\n                if (node.tagName) {\n                    tagName = node.tagName.toLowerCase();\n                } else {\n                    tagName = '';\n                }\n\n                if (tagName === 'body') {\n                    // Get out of the loop if we get up to the `<body>` element\n                    break;\n                }\n            } while (tagName !== 'form');\n\n            if (tagName === 'form') {\n                return node;\n            } else {\n                return null;\n            }\n        }\n\n        /**\n         * Return a string in standard URL-encoded notation with the form input values being unformatted.\n         * This string can be used as a query for instance.\n         *\n         * @returns {string}\n         */\n\n    }, {\n        key: 'formNumericString',\n        value: function formNumericString() {\n            return this.constructor._serializeNumericString(this.form(), this.settings.serializeSpaces);\n        }\n\n        /**\n         * Return a string in standard URL-encoded notation with the form input values being formatted.\n         *\n         * @returns {string}\n         */\n\n    }, {\n        key: 'formFormatted',\n        value: function formFormatted() {\n            return this.constructor._serializeFormatted(this.form(), this.settings.serializeSpaces);\n        }\n\n        /**\n         * Return a string in standard URL-encoded notation with the form input values, with localized values.\n         * The default output format can be overridden by passing the option as a parameter.\n         *\n         * @param {null|string} forcedOutputFormat If set to something different than `null`, then this is used as an overriding outputFormat option\n         * @returns {string}\n         */\n\n    }, {\n        key: 'formLocalized',\n        value: function formLocalized() {\n            var forcedOutputFormat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            var outputFormatToUse = void 0;\n            if (_AutoNumericHelper2.default.isNull(forcedOutputFormat)) {\n                outputFormatToUse = this.settings.outputFormat;\n            } else {\n                outputFormatToUse = forcedOutputFormat;\n            }\n\n            return this.constructor._serializeLocalized(this.form(), this.settings.serializeSpaces, outputFormatToUse);\n        }\n\n        /**\n         * Return an array containing an object for each form <input> element.\n         * Those objects are of the following structure `{ name: foo, value: '42' }`, where the `name` is the DOM element name, and the `value` is an unformatted numeric string.\n         *\n         * @returns {Array}\n         */\n\n    }, {\n        key: 'formArrayNumericString',\n        value: function formArrayNumericString() {\n            return this.constructor._serializeNumericStringArray(this.form(), this.settings.serializeSpaces);\n        }\n\n        /**\n         * Return an array containing an object for each form <input> element.\n         * Those objects are of the following structure `{ name: foo, value: '42' }`, where the `name` is the DOM element name, and the `value` is the formatted string.\n         *\n         * @returns {Array}\n         */\n\n    }, {\n        key: 'formArrayFormatted',\n        value: function formArrayFormatted() {\n            return this.constructor._serializeFormattedArray(this.form(), this.settings.serializeSpaces);\n        }\n\n        /**\n         * Return an array containing an object for each form <input> element.\n         * Those objects are of the following structure `{ name: foo, value: '42' }`, where the `name` is the DOM element name, and the `value` is the localized numeric string.\n         *\n         * @param {null|string} forcedOutputFormat If set to something different than `null`, then this is used as an overriding outputFormat option\n         * @returns {Array}\n         */\n\n    }, {\n        key: 'formArrayLocalized',\n        value: function formArrayLocalized() {\n            var forcedOutputFormat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            var outputFormatToUse = void 0;\n            if (_AutoNumericHelper2.default.isNull(forcedOutputFormat)) {\n                outputFormatToUse = this.settings.outputFormat;\n            } else {\n                outputFormatToUse = forcedOutputFormat;\n            }\n\n            return this.constructor._serializeLocalizedArray(this.form(), this.settings.serializeSpaces, outputFormatToUse);\n        }\n\n        /**\n         * Return a JSON string containing an object representing the form input values.\n         * This is based on the result of the `formArrayNumericString()` function.\n         *\n         * @returns {string}\n         */\n\n    }, {\n        key: 'formJsonNumericString',\n        value: function formJsonNumericString() {\n            return JSON.stringify(this.formArrayNumericString());\n        }\n\n        /**\n         * Return a JSON string containing an object representing the form input values.\n         * This is based on the result of the `formArrayFormatted()` function.\n         *\n         * @returns {string}\n         */\n\n    }, {\n        key: 'formJsonFormatted',\n        value: function formJsonFormatted() {\n            return JSON.stringify(this.formArrayFormatted());\n        }\n\n        /**\n         * Return a JSON string containing an object representing the form input values.\n         * This is based on the result of the `formArrayLocalized()` function.\n         *\n         * @param {null|string} forcedOutputFormat If set to something different than `null`, then this is used as an overriding outputFormat option\n         * @returns {string}\n         */\n\n    }, {\n        key: 'formJsonLocalized',\n        value: function formJsonLocalized() {\n            var forcedOutputFormat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            return JSON.stringify(this.formArrayLocalized(forcedOutputFormat));\n        }\n\n        /**\n         * Unformat all the autoNumeric-managed elements that are a child of the parent <form> element of this DOM element, to numeric strings\n         *\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formUnformat',\n        value: function formUnformat() {\n            //FIXME test this\n            var inputs = this.constructor._getChildANInputElement(this.form());\n            inputs.forEach(function (input) {\n                AutoNumeric.getAutoNumericElement(input).unformat();\n            });\n\n            return this;\n        }\n\n        /**\n         * Unformat all the autoNumeric-managed elements that are a child of the parent <form> element of this DOM element, to localized strings\n         *\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formUnformatLocalized',\n        value: function formUnformatLocalized() {\n            //FIXME test this\n            var inputs = this.constructor._getChildANInputElement(this.form());\n            inputs.forEach(function (input) {\n                AutoNumeric.getAutoNumericElement(input).unformatLocalized();\n            });\n\n            return this;\n        }\n\n        /**\n         * Reformat all the autoNumeric-managed elements that are a child of the parent <form> element of this DOM element\n         *\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formReformat',\n        value: function formReformat() {\n            //FIXME test this\n            var inputs = this.constructor._getChildANInputElement(this.form());\n            inputs.forEach(function (input) {\n                AutoNumeric.getAutoNumericElement(input).reformat();\n            });\n\n            return this;\n        }\n\n        /**\n         * Convert the input values to numeric strings, submit the form, then reformat those back.\n         * The function can either take a callback, or not. If it doesn't, the default `form.submit()` function will be called.\n         * Otherwise, it runs `callback(value)` with `value` being equal to the result of `formNumericString()`.\n         *\n         * @param {function|null} callback\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formSubmitNumericString',\n        value: function formSubmitNumericString() {\n            var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n            //FIXME test this\n            if (_AutoNumericHelper2.default.isNull(callback)) {\n                this.formUnformat();\n                this.form().submit();\n                this.formReformat();\n            } else if (_AutoNumericHelper2.default.isFunction(callback)) {\n                callback(this.formNumericString());\n            } else {\n                _AutoNumericHelper2.default.throwError('The given callback is not a function.');\n            }\n\n            return this;\n        }\n\n        /**\n         * Submit the form with the current formatted values.\n         * The function can either take a callback, or not. If it doesn't, the default `form.submit()` function will be called.\n         * Otherwise, it runs `callback(value)` with `value` being equal to the result of `formFormatted()`.\n         *\n         * @param {function|null} callback\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formSubmitFormatted',\n        value: function formSubmitFormatted() {\n            var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n            //FIXME test this\n            if (_AutoNumericHelper2.default.isNull(callback)) {\n                this.form().submit();\n            } else if (_AutoNumericHelper2.default.isFunction(callback)) {\n                callback(this.formFormatted());\n            } else {\n                _AutoNumericHelper2.default.throwError('The given callback is not a function.');\n            }\n\n            return this;\n        }\n\n        /**\n         * Convert the input values to localized strings, submit the form, then reformat those back.\n         * The function can either take a callback, or not. If it doesn't, the default `form.submit()` function will be called.\n         * Otherwise, it runs `callback(value)` with `value` being equal to the result of `formLocalized()`.\n         *\n         * @param {null|string} forcedOutputFormat If set to something different than `null`, then this is used as an overriding outputFormat option\n         * @param {function|null} callback\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formSubmitLocalized',\n        value: function formSubmitLocalized() {\n            var forcedOutputFormat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n            var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            //FIXME test this\n            if (_AutoNumericHelper2.default.isNull(callback)) {\n                this.formUnformatLocalized();\n                this.form().submit();\n                this.formReformat();\n            } else if (_AutoNumericHelper2.default.isFunction(callback)) {\n                callback(this.formLocalized(forcedOutputFormat));\n            } else {\n                _AutoNumericHelper2.default.throwError('The given callback is not a function.');\n            }\n\n            return this;\n        }\n\n        /**\n         * Generate an array of numeric strings from the `<input>` elements, and pass it to the given callback.\n         * Under the hood, the array is generated via a call to `formArrayNumericString()`.\n         *\n         * @param {function} callback\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formSubmitArrayNumericString',\n        value: function formSubmitArrayNumericString(callback) {\n            //FIXME test this\n            if (_AutoNumericHelper2.default.isFunction(callback)) {\n                callback(this.formArrayNumericString());\n            } else {\n                _AutoNumericHelper2.default.throwError('The given callback is not a function.');\n            }\n\n            return this;\n        }\n\n        /**\n         * Generate an array of the current formatted values from the `<input>` elements, and pass it to the given callback.\n         * Under the hood, the array is generated via a call to `formArrayFormatted()`.\n         *\n         * @param {function} callback\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formSubmitArrayFormatted',\n        value: function formSubmitArrayFormatted(callback) {\n            //FIXME test this\n            if (_AutoNumericHelper2.default.isFunction(callback)) {\n                callback(this.formArrayFormatted());\n            } else {\n                _AutoNumericHelper2.default.throwError('The given callback is not a function.');\n            }\n\n            return this;\n        }\n\n        /**\n         * Generate an array of localized strings from the `<input>` elements, and pass it to the given callback.\n         * Under the hood, the array is generated via a call to `formArrayLocalized()`.\n         *\n         * @param {function} callback\n         * @param {null|string} forcedOutputFormat If set to something different than `null`, then this is used as an overriding outputFormat option\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formSubmitArrayLocalized',\n        value: function formSubmitArrayLocalized(callback) {\n            var forcedOutputFormat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            //FIXME test this\n            if (_AutoNumericHelper2.default.isFunction(callback)) {\n                callback(this.formArrayLocalized(forcedOutputFormat));\n            } else {\n                _AutoNumericHelper2.default.throwError('The given callback is not a function.');\n            }\n\n            return this;\n        }\n\n        /**\n         * Generate a JSON string with the numeric strings values from the `<input>` elements, and pass it to the given callback.\n         * Under the hood, the array is generated via a call to `formJsonNumericString()`.\n         *\n         * @param {function} callback\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formSubmitJsonNumericString',\n        value: function formSubmitJsonNumericString(callback) {\n            //FIXME test this\n            if (_AutoNumericHelper2.default.isFunction(callback)) {\n                callback(this.formJsonNumericString());\n            } else {\n                _AutoNumericHelper2.default.throwError('The given callback is not a function.');\n            }\n\n            return this;\n        }\n\n        /**\n         * Generate a JSON string with the current formatted values from the `<input>` elements, and pass it to the given callback.\n         * Under the hood, the array is generated via a call to `formJsonFormatted()`.\n         *\n         * @param {function} callback\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formSubmitJsonFormatted',\n        value: function formSubmitJsonFormatted(callback) {\n            //FIXME test this\n            if (_AutoNumericHelper2.default.isFunction(callback)) {\n                callback(this.formJsonFormatted());\n            } else {\n                _AutoNumericHelper2.default.throwError('The given callback is not a function.');\n            }\n\n            return this;\n        }\n\n        /**\n         * Generate a JSON string with the localized strings values from the `<input>` elements, and pass it to the given callback.\n         * Under the hood, the array is generated via a call to `formJsonLocalized()`.\n         *\n         * @param {function} callback\n         * @param {null|string} forcedOutputFormat If set to something different than `null`, then this is used as an overriding outputFormat option\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'formSubmitJsonLocalized',\n        value: function formSubmitJsonLocalized(callback) {\n            var forcedOutputFormat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            //FIXME test this\n            if (_AutoNumericHelper2.default.isFunction(callback)) {\n                callback(this.formJsonLocalized(forcedOutputFormat));\n            } else {\n                _AutoNumericHelper2.default.throwError('The given callback is not a function.');\n            }\n\n            return this;\n        }\n\n        /**\n         * Unformat the given AutoNumeric element, and update the `hoveredWithAlt` variable.\n         *\n         * @param {AutoNumeric} anElement\n         * @private\n         */\n\n    }, {\n        key: '_createLocalList',\n\n\n        /**\n         * Create a `Map` that will stores all the autoNumeric elements that are initialized from this current element.\n         * @private\n         */\n        value: function _createLocalList() {\n            this.autoNumericLocalList = new Map();\n            this._addToLocalList(this.domElement);\n        }\n\n        /**\n         * In some rare cases, you could want to delete the local list generated during the element initialization (in order to use another one instead for instance).\n         * @private\n         */\n\n    }, {\n        key: '_deleteLocalList',\n        value: function _deleteLocalList() {\n            delete this.autoNumericLocalList;\n        }\n\n        /**\n         * Set the local list with the given Map object.\n         *\n         * @param {Map} localList\n         * @private\n         */\n\n    }, {\n        key: '_setLocalList',\n        value: function _setLocalList(localList) {\n            this.autoNumericLocalList = localList;\n        }\n\n        /**\n         * Return the local list Map object.\n         *\n         * @returns {*|Map}\n         * @private\n         */\n\n    }, {\n        key: '_getLocalList',\n        value: function _getLocalList() {\n            return this.autoNumericLocalList;\n        }\n\n        /**\n         * Return `true` if the AutoNumeric object has a local list defined already and has at least one element in it (itself usually).\n         *\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_hasLocalList',\n        value: function _hasLocalList() {\n            return this.autoNumericLocalList instanceof Map && this.autoNumericLocalList.size !== 0;\n        }\n\n        /**\n         * Add the given object to the local autoNumeric element list.\n         * Note: in order to keep a coherent list, we only add DOM elements in it, not the autoNumeric object.\n         *\n         * @param {HTMLElement|HTMLInputElement} domElement\n         * @param {AutoNumeric} autoNumericObject A reference to the AutoNumeric object that manage the given DOM element\n         * @throws\n         * @private\n         */\n\n    }, {\n        key: '_addToLocalList',\n        value: function _addToLocalList(domElement) {\n            var autoNumericObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            if (_AutoNumericHelper2.default.isNull(autoNumericObject)) {\n                autoNumericObject = this;\n            }\n\n            if (!_AutoNumericHelper2.default.isUndefined(this.autoNumericLocalList)) {\n                this.autoNumericLocalList.set(domElement, autoNumericObject); // Use the DOM element as key, and the AutoNumeric object as the value\n            } else {\n                _AutoNumericHelper2.default.throwError('The local list provided does not exists when trying to add an element. [' + this.autoNumericLocalList + '] given.');\n            }\n        }\n\n        /**\n         * Remove the given object from the local autoNumeric element list.\n         *\n         * @param {HTMLElement|HTMLInputElement} domElement\n         * @private\n         */\n\n    }, {\n        key: '_removeFromLocalList',\n        value: function _removeFromLocalList(domElement) {\n            if (!_AutoNumericHelper2.default.isUndefined(this.autoNumericLocalList)) {\n                this.autoNumericLocalList.delete(domElement);\n            } else if (this.settings.createLocalList) {\n                _AutoNumericHelper2.default.throwError('The local list provided does not exists when trying to remove an element. [' + this.autoNumericLocalList + '] given.');\n            }\n        }\n\n        /**\n         * Merge the `newSettings` given as parameters into the current element settings.\n         *\n         * WARNING: Using `Object.assign()` here means the merge is not recursive and only one depth is merged.\n         * cf. http://stackoverflow.com/a/39188108/2834898\n         * cf. tests on http://codepen.io/AnotherLinuxUser/pen/KaJORq?editors=0011\n         *\n         * @param {object} newSettings\n         * @private\n         */\n\n    }, {\n        key: '_mergeSettings',\n        value: function _mergeSettings() {\n            for (var _len3 = arguments.length, newSettings = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n                newSettings[_key3] = arguments[_key3];\n            }\n\n            _extends.apply(undefined, [this.settings].concat(newSettings));\n        }\n\n        /**\n         * Return a new object with the current element settings merged with the new settings.\n         *\n         * @param {object} newSettings\n         * @returns {object}\n         * @private\n         */\n\n    }, {\n        key: '_cloneAndMergeSettings',\n        value: function _cloneAndMergeSettings() {\n            var result = {};\n\n            for (var _len4 = arguments.length, newSettings = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n                newSettings[_key4] = arguments[_key4];\n            }\n\n            _extends.apply(undefined, [result, this.settings].concat(newSettings));\n\n            return result;\n        }\n\n        /**\n         * Validate the given option object.\n         * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\n         *\n         * This tests if the options are not conflicting and are well formatted.\n         * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\n         *\n         * @param {*} userOptions\n         * @param {Boolean} shouldExtendDefaultOptions If `true`, then this function will extends the `userOptions` passed by the user, with the default options.\n         * @param {object|null} originalOptions The user can pass the original options (and not the one that are generated from the default settings and the various usability corrections), in order to add compatibility and conflicts checks.\n         * @throws Error This throws if the `userOptions` are not valid\n         */\n\n    }, {\n        key: '_updatePredefinedOptions',\n\n\n        // Pre-defined options can be called to update the current default options with their specificities\n        //XXX A better way would be to not initialize first, but that's not possible since `new` is called first and we do not pass the language options (ie. `French`) to the constructor\n\n        /**\n         * Update the AutoNumeric object with the predefined options, and possibly some option overrides.\n         *\n         * @param {object} predefinedOption\n         * @param {object} optionOverride\n         * @private\n         * @returns {AutoNumeric}\n         */\n        value: function _updatePredefinedOptions(predefinedOption) {\n            var optionOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            if (!_AutoNumericHelper2.default.isNull(optionOverride)) {\n                this._mergeSettings(predefinedOption, optionOverride);\n                this.update(this.settings);\n            } else {\n                this.update(predefinedOption);\n            }\n\n            return this;\n        }\n\n        /**\n         * Update the settings to use the French pre-defined language options.\n         * Those pre-defined options can be overridden by passing an option object as a parameter.\n         *\n         * @param {object} optionOverride\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'french',\n        value: function french() {\n            var optionOverride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            this._updatePredefinedOptions(AutoNumeric.getPredefinedOptions().French, optionOverride);\n\n            return this;\n        }\n\n        /**\n         * Update the settings to use the North American pre-defined language options.\n         * Those pre-defined options can be overridden by passing an option object as a parameter.\n         *\n         * @param {object} optionOverride\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'northAmerican',\n        value: function northAmerican() {\n            var optionOverride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            this._updatePredefinedOptions(AutoNumeric.getPredefinedOptions().NorthAmerican, optionOverride);\n\n            return this;\n        }\n\n        /**\n         * Update the settings to use the British pre-defined language options.\n         * Those pre-defined options can be overridden by passing an option object as a parameter.\n         *\n         * @param {object} optionOverride\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'british',\n        value: function british() {\n            var optionOverride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            this._updatePredefinedOptions(AutoNumeric.getPredefinedOptions().British, optionOverride);\n\n            return this;\n        }\n\n        /**\n         * Update the settings to use the Swiss pre-defined language options.\n         * Those pre-defined options can be overridden by passing an option object as a parameter.\n         *\n         * @param {object} optionOverride\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'swiss',\n        value: function swiss() {\n            var optionOverride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            this._updatePredefinedOptions(AutoNumeric.getPredefinedOptions().Swiss, optionOverride);\n\n            return this;\n        }\n\n        /**\n         * Update the settings to use the Japanese pre-defined language options.\n         * Those pre-defined options can be overridden by passing an option object as a parameter.\n         *\n         * @param {object} optionOverride\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'japanese',\n        value: function japanese() {\n            var optionOverride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            this._updatePredefinedOptions(AutoNumeric.getPredefinedOptions().Japanese, optionOverride);\n\n            return this;\n        }\n\n        /**\n         * Update the settings to use the Spanish pre-defined language options.\n         * Those pre-defined options can be overridden by passing an option object as a parameter.\n         *\n         * @param {object} optionOverride\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'spanish',\n        value: function spanish() {\n            var optionOverride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            this._updatePredefinedOptions(AutoNumeric.getPredefinedOptions().Spanish, optionOverride);\n\n            return this;\n        }\n\n        /**\n         * Update the settings to use the Chinese pre-defined language options.\n         * Those pre-defined options can be overridden by passing an option object as a parameter.\n         *\n         * @param {object} optionOverride\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'chinese',\n        value: function chinese() {\n            var optionOverride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            this._updatePredefinedOptions(AutoNumeric.getPredefinedOptions().Chinese, optionOverride);\n\n            return this;\n        }\n\n        /**\n         * Update the settings to use the Brazilian pre-defined language options.\n         * Those pre-defined options can be overridden by passing an option object as a parameter.\n         *\n         * @param {object} optionOverride\n         * @returns {AutoNumeric}\n         */\n\n    }, {\n        key: 'brazilian',\n        value: function brazilian() {\n            var optionOverride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            this._updatePredefinedOptions(AutoNumeric.getPredefinedOptions().Brazilian, optionOverride);\n\n            return this;\n        }\n\n        // Internal private functions\n        /**\n         * Run any callbacks found in the settings object in order to set the settings value back.\n         * Any parameter can have a callback defined.\n         * The callback takes the current AutoNumeric element as the first argument, and the key name as the second.\n         * @example callback(this, 'currencySymbol')\n         */\n\n    }, {\n        key: '_runCallbacksFoundInTheSettingsObject',\n        value: function _runCallbacksFoundInTheSettingsObject() {\n            //FIXME test this\n            // Loops through the this.settings object (option array) to find the following\n            for (var key in this.settings) {\n                if (this.settings.hasOwnProperty(key)) {\n                    var value = this.settings[key];\n\n                    if (typeof value === 'function') {\n                        this.settings[key] = value(this, key);\n                    } else {\n                        // Calls the attached function from the html5 data. For instance: <tag data-currency-symbol=\"functionName\"></tag>\n                        var htmlAttribute = this.domElement.getAttribute(key); //TODO Use `dataset` instead of `getAttribute` when we won't need to support obsolete browsers\n                        htmlAttribute = _AutoNumericHelper2.default.camelize(htmlAttribute);\n                        if (typeof this.settings[htmlAttribute] === 'function') {\n                            this.settings[key] = htmlAttribute(this, key);\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Keep track if the settings configuration leads to a trailing negative sign (only when the raw value is negative), so we do not have to test the settings values every time we need to know that.\n         * `isTrailingNegative` is set to `true` if the settings result in a trailing negative character, `false` otherwise.\n         * Note: This returns `true` even if the raw value is positive.\n         * @private\n         */\n\n    }, {\n        key: '_setTrailingNegativeSignInfo',\n        value: function _setTrailingNegativeSignInfo() {\n            this.isTrailingNegative = this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix && this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.suffix || this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix && (this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.left || this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.right);\n        }\n\n        /**\n         * Strip all unwanted non-number characters.\n         * This keeps the numbers, the negative sign as well as the custom decimal character.\n         *\n         * @param {string} s\n         * @param {object} settings\n         * @param {boolean} stripZeros If set to `false`, then the leading zero(s) are not stripped, otherwise if set to `true`, the `leadingZero` option is followed\n         * @param {boolean} isFocused If the element is focused, then this is `true`\n         * @returns {string|*}\n         */\n\n    }, {\n        key: '_setBrackets',\n\n\n        /**\n         * Analyze the `negativeBracketsTypeOnBlur` options and keep track of the first and last bracket characters to use.\n         * @private\n         */\n        value: function _setBrackets() {\n            if (!_AutoNumericHelper2.default.isNull(this.settings.negativeBracketsTypeOnBlur)) {\n                var _settings$negativeBra = this.settings.negativeBracketsTypeOnBlur.split(',');\n\n                var _settings$negativeBra2 = _slicedToArray(_settings$negativeBra, 2);\n\n                this.settings.firstBracket = _settings$negativeBra2[0];\n                this.settings.lastBracket = _settings$negativeBra2[1];\n            } else {\n                this.settings.firstBracket = '';\n                this.settings.lastBracket = '';\n            }\n        }\n\n        /**\n         * Return a number as a numeric string that can be typecast to a Number that Javascript will understand.\n         *\n         * This function return the given string by stripping the currency sign (currencySymbol), the grouping separators (digitalGroupSpacing) and by replacing the decimal character (decimalCharacter) by a dot.\n         * Lastly, it also put the negative sign back to its normal position if needed.\n         *\n         * @param {string} s\n         * @param {object} settings\n         * @returns {string|void|XML|*}\n         */\n\n    }, {\n        key: '_modifyNegativeSignAndDecimalCharacterForRawValue',\n\n\n        /**\n         * Modify the negative sign and the decimal character of the given string value to an hyphen (-) and a dot (.) in order to make that value 'typecastable' to a real number.\n         *\n         * @param {string} s\n         * @returns {string}\n         */\n        value: function _modifyNegativeSignAndDecimalCharacterForRawValue(s) {\n            if (this.settings.decimalCharacter !== '.') {\n                s = s.replace(this.settings.decimalCharacter, '.');\n            }\n\n            if (this.settings.negativeSignCharacter !== '-' && this.settings.negativeSignCharacter !== '') {\n                s = s.replace(this.settings.negativeSignCharacter, '-');\n            }\n\n            if (!s.match(/\\d/)) {\n                // The default value returned by `get` is not formatted with decimals\n                s += '0';\n            }\n\n            return s;\n        }\n\n        /**\n         * Modify the negative sign and the decimal character to use those defined in the settings.\n         *\n         * @param {string} s\n         * @param {object} settings\n         * @returns {string}\n         */\n\n    }, {\n        key: '_initialCaretPosition',\n\n\n        /**\n         * Calculate where to put the caret position on focus if the element content is not selected.\n         * This calculation is affected by the `caretPositionOnFocus` option which can be either `null`, `'start'`, `'end'`, `'decimalLeft'` or 'decimalRight'`, and will decide where to put the caret (on the left or right of the value or the decimal character, respectively) :\n         * - `null` : the caret position is not forced\n         * - `'start'` : the caret is positioned on the left hand side of the value\n         * - `'end'` : the caret is positioned on the right hand side of the value\n         * - `'decimalLeft'` : the caret is positioned on the left side of the decimal character\n         * - `'decimalRight'` : the caret is positioned on the right side of the decimal character\n         *\n         * @param {string} value The formatted string stripped of the currency symbol and negative/positive sign\n         * @returns {number}\n         * @throws\n         * @private\n         */\n        value: function _initialCaretPosition(value) {\n            if (_AutoNumericHelper2.default.isNull(this.settings.caretPositionOnFocus)) {\n                _AutoNumericHelper2.default.throwError('`_initialCaretPosition()` should never be called when the `caretPositionOnFocus` option is `null`.');\n            }\n\n            var isValueNegative = this.rawValue < 0;\n            var isZeroOrHasNoValue = _AutoNumericHelper2.default.isZeroOrHasNoValue(value);\n            var totalLength = value.length;\n\n            var valueSize = 0;\n            var integerSize = 0;\n            var hasDecimalChar = false;\n            var offsetDecimalChar = 0;\n            if (this.settings.caretPositionOnFocus !== AutoNumeric.options.caretPositionOnFocus.start) {\n                value = value.replace('-', '');\n                value = value.replace('+', '');\n                value = value.replace(this.settings.currencySymbol, '');\n                valueSize = value.length;\n                hasDecimalChar = _AutoNumericHelper2.default.contains(value, this.settings.decimalCharacter);\n\n                if (this.settings.caretPositionOnFocus === AutoNumeric.options.caretPositionOnFocus.decimalLeft || this.settings.caretPositionOnFocus === AutoNumeric.options.caretPositionOnFocus.decimalRight) {\n                    if (hasDecimalChar) {\n                        integerSize = value.indexOf(this.settings.decimalCharacter);\n                        offsetDecimalChar = this.settings.decimalCharacter.length;\n                    } else {\n                        integerSize = valueSize;\n                        offsetDecimalChar = 0;\n                    }\n                }\n            }\n\n            var signToUse = '';\n            if (isValueNegative) {\n                signToUse = this.settings.negativeSignCharacter;\n            } else if (this.settings.showPositiveSign && !isZeroOrHasNoValue) {\n                signToUse = this.settings.positiveSignCharacter;\n            }\n\n            var positiveNegativeSignSize = signToUse.length;\n            var currencySymbolSize = this.settings.currencySymbol.length;\n\n            // Calculate the caret position based on `currencySymbolPlacement`, `negativePositiveSignPlacement` and `caretPositionOnFocus`\n            var caretPosition = void 0;\n            if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix) {\n                if (this.settings.caretPositionOnFocus === AutoNumeric.options.caretPositionOnFocus.start) {\n                    if (this.settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {\n                        switch (this.settings.negativePositiveSignPlacement) {\n                            case AutoNumeric.options.negativePositiveSignPlacement.prefix: // +€|12.34\n                            case AutoNumeric.options.negativePositiveSignPlacement.left: // +€|12.34\n                            case AutoNumeric.options.negativePositiveSignPlacement.right:\n                                // €+|12.34\n                                caretPosition = positiveNegativeSignSize + currencySymbolSize;\n                                break;\n                            case AutoNumeric.options.negativePositiveSignPlacement.suffix:\n                                // €|12.34+\n                                caretPosition = currencySymbolSize;\n                                break;\n                        }\n                    } else {\n                        // €|12.34\n                        caretPosition = currencySymbolSize;\n                    }\n                } else if (this.settings.caretPositionOnFocus === AutoNumeric.options.caretPositionOnFocus.end) {\n                    if (this.settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {\n                        switch (this.settings.negativePositiveSignPlacement) {\n                            case AutoNumeric.options.negativePositiveSignPlacement.prefix: // +€12.34|\n                            case AutoNumeric.options.negativePositiveSignPlacement.left: // +€12.34|\n                            case AutoNumeric.options.negativePositiveSignPlacement.right:\n                                // €+12.34|\n                                caretPosition = totalLength;\n                                break;\n                            case AutoNumeric.options.negativePositiveSignPlacement.suffix:\n                                // €12.34|+\n                                caretPosition = currencySymbolSize + valueSize;\n                                break;\n                        }\n                    } else {\n                        // €12.34|\n                        caretPosition = totalLength;\n                    }\n                } else if (this.settings.caretPositionOnFocus === AutoNumeric.options.caretPositionOnFocus.decimalLeft) {\n                    if (this.settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {\n                        switch (this.settings.negativePositiveSignPlacement) {\n                            case AutoNumeric.options.negativePositiveSignPlacement.prefix: // +€12|.34\n                            case AutoNumeric.options.negativePositiveSignPlacement.left: // +€12|.34\n                            case AutoNumeric.options.negativePositiveSignPlacement.right:\n                                // €+12|.34\n                                caretPosition = positiveNegativeSignSize + currencySymbolSize + integerSize;\n                                break;\n                            case AutoNumeric.options.negativePositiveSignPlacement.suffix:\n                                // €12|.34+\n                                caretPosition = currencySymbolSize + integerSize;\n                                break;\n                        }\n                    } else {\n                        // €12|.34\n                        caretPosition = currencySymbolSize + integerSize;\n                    }\n                } else if (this.settings.caretPositionOnFocus === AutoNumeric.options.caretPositionOnFocus.decimalRight) {\n                    if (this.settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {\n                        switch (this.settings.negativePositiveSignPlacement) {\n                            case AutoNumeric.options.negativePositiveSignPlacement.prefix: // +€12.|34\n                            case AutoNumeric.options.negativePositiveSignPlacement.left: // +€12.|34\n                            case AutoNumeric.options.negativePositiveSignPlacement.right:\n                                // €+12.|34\n                                caretPosition = positiveNegativeSignSize + currencySymbolSize + integerSize + offsetDecimalChar;\n                                break;\n                            case AutoNumeric.options.negativePositiveSignPlacement.suffix:\n                                // €12.|34+\n                                caretPosition = currencySymbolSize + integerSize + offsetDecimalChar;\n                                break;\n                        }\n                    } else {\n                        // €12.|34\n                        caretPosition = currencySymbolSize + integerSize + offsetDecimalChar;\n                    }\n                }\n            } else if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) {\n                if (this.settings.caretPositionOnFocus === AutoNumeric.options.caretPositionOnFocus.start) {\n                    if (this.settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {\n                        switch (this.settings.negativePositiveSignPlacement) {\n                            case AutoNumeric.options.negativePositiveSignPlacement.suffix: // |12.34€+\n                            case AutoNumeric.options.negativePositiveSignPlacement.right: // |12.34€+\n                            case AutoNumeric.options.negativePositiveSignPlacement.left:\n                                // |12.34+€\n                                caretPosition = 0;\n                                break;\n                            case AutoNumeric.options.negativePositiveSignPlacement.prefix:\n                                // +|12.34€\n                                caretPosition = positiveNegativeSignSize;\n                                break;\n                        }\n                    } else {\n                        // |12.34€\n                        caretPosition = 0;\n                    }\n                } else if (this.settings.caretPositionOnFocus === AutoNumeric.options.caretPositionOnFocus.end) {\n                    if (this.settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {\n                        switch (this.settings.negativePositiveSignPlacement) {\n                            case AutoNumeric.options.negativePositiveSignPlacement.suffix: // 12.34|€+\n                            case AutoNumeric.options.negativePositiveSignPlacement.right: // 12.34|€+\n                            case AutoNumeric.options.negativePositiveSignPlacement.left:\n                                // 12.34|+€\n                                caretPosition = valueSize;\n                                break;\n                            case AutoNumeric.options.negativePositiveSignPlacement.prefix:\n                                // +12.34|€\n                                caretPosition = positiveNegativeSignSize + valueSize;\n                                break;\n                        }\n                    } else {\n                        // 12.34|€\n                        caretPosition = valueSize;\n                    }\n                } else if (this.settings.caretPositionOnFocus === AutoNumeric.options.caretPositionOnFocus.decimalLeft) {\n                    if (this.settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {\n                        switch (this.settings.negativePositiveSignPlacement) {\n                            case AutoNumeric.options.negativePositiveSignPlacement.suffix: // 12|.34€+\n                            case AutoNumeric.options.negativePositiveSignPlacement.right: // 12|.34€+\n                            case AutoNumeric.options.negativePositiveSignPlacement.left:\n                                // 12|.34+€\n                                caretPosition = integerSize;\n                                break;\n                            case AutoNumeric.options.negativePositiveSignPlacement.prefix:\n                                // +12|.34€\n                                caretPosition = positiveNegativeSignSize + integerSize;\n                                break;\n                        }\n                    } else {\n                        // 12|.34€\n                        caretPosition = integerSize;\n                    }\n                } else if (this.settings.caretPositionOnFocus === AutoNumeric.options.caretPositionOnFocus.decimalRight) {\n                    if (this.settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {\n                        switch (this.settings.negativePositiveSignPlacement) {\n                            case AutoNumeric.options.negativePositiveSignPlacement.suffix: // 12.|34€+\n                            case AutoNumeric.options.negativePositiveSignPlacement.right: // 12.|34€+\n                            case AutoNumeric.options.negativePositiveSignPlacement.left:\n                                // 12.|34+€\n                                caretPosition = integerSize + offsetDecimalChar;\n                                break;\n                            case AutoNumeric.options.negativePositiveSignPlacement.prefix:\n                                // +12.|34€\n                                caretPosition = positiveNegativeSignSize + integerSize + offsetDecimalChar;\n                                break;\n                        }\n                    } else {\n                        // 12.|34€\n                        caretPosition = integerSize + offsetDecimalChar;\n                    }\n                }\n            }\n\n            return caretPosition;\n        }\n\n        /**\n         * Truncate the trailing zeroes to the given number of decimal places\n         *\n         * @param {string} roundedInputValue\n         * @param {int} decimalPlacesNeeded The number of decimal places to keep\n         * @returns {string}\n         */\n\n    }, {\n        key: '_keepAnOriginalSettingsCopy',\n\n\n        /**\n         * Original settings saved for use when the `decimalPlacesShownOnFocus` and `showOnlyNumbersOnFocus` options are used.\n         * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\n         */\n        value: function _keepAnOriginalSettingsCopy() {\n            this.originalDigitGroupSeparator = this.settings.digitGroupSeparator;\n            this.originalCurrencySymbol = this.settings.currencySymbol;\n            this.originalSuffixText = this.settings.suffixText;\n        }\n\n        /**\n         * Original settings saved for use when `decimalPlacesShownOnFocus` & `showOnlyNumbersOnFocus` options are being used.\n         * This is taken from Quirksmode.\n         *\n         * @param {string} name\n         * @returns {*}\n         */\n\n    }, {\n        key: '_trimLeadingAndTrailingZeros',\n\n\n        /**\n         * Removes any zeros in excess in the front and back of the given `value`, according to the `settings`.\n         * This also manages the cases where the decimal point is on the far left or far right of the `value`.\n         *\n         * @param {string} value\n         * @returns {string|null}\n         */\n        value: function _trimLeadingAndTrailingZeros(value) {\n            // Return the empty string is the value is already empty. This prevent converting that value to '0'.\n            if (value === '' || value === null) {\n                return value;\n            }\n\n            if (this.settings.leadingZero !== AutoNumeric.options.leadingZero.keep) {\n                if (Number(value) === 0) {\n                    // Return '0' if the value is zero\n                    return '0';\n                }\n\n                // Trim the leading zeros, while leaving one zero to the left of the decimal point if needed\n                value = value.replace(/^(-)?0+(?=\\d)/g, '$1');\n            }\n\n            //TODO remove this from that function and use `trimPaddedZerosFromDecimalPlaces()` instead\n            // Trim the trailing zeros after the last decimal place not being a zero (ie. 1.2300 -> 1.23)\n            if (_AutoNumericHelper2.default.contains(value, '.')) {\n                value = value.replace(/(\\.[0-9]*?)0+$/, '$1');\n            }\n\n            // Remove any trailing decimal point\n            value = value.replace(/\\.$/, '');\n\n            return value;\n        }\n\n        /**\n         * Generate the name for the persistent stored data variable\n         * @private\n         */\n\n    }, {\n        key: '_setPersistentStorageName',\n        value: function _setPersistentStorageName() {\n            if (this.settings.saveValueToSessionStorage) {\n                if (this.domElement.name !== '' && !_AutoNumericHelper2.default.isUndefined(this.domElement.name)) {\n                    this.rawValueStorageName = '' + this.storageNamePrefix + decodeURIComponent(this.domElement.name);\n                } else {\n                    this.rawValueStorageName = '' + this.storageNamePrefix + this.domElement.id;\n                }\n            }\n        }\n\n        /**\n         * Save the raw Value into sessionStorage or a cookie depending on what the browser is supporting.\n         * @private\n         */\n\n    }, {\n        key: '_saveValueToPersistentStorage',\n        value: function _saveValueToPersistentStorage() {\n            if (this.settings.saveValueToSessionStorage) {\n                if (this.sessionStorageAvailable) {\n                    sessionStorage.setItem(this.rawValueStorageName, this.rawValue);\n                } else {\n                    // Use cookies for obsolete browsers that do not support sessionStorage (ie. IE 6 & 7)\n                    document.cookie = this.rawValueStorageName + '=' + this.rawValue + '; expires= ; path=/';\n                }\n            }\n        }\n\n        /**\n         * Retrieve the raw value from sessionStorage or the cookie depending on what the browser is supporting.\n         *\n         * @returns {*}\n         * @private\n         */\n\n    }, {\n        key: '_getValueFromPersistentStorage',\n        value: function _getValueFromPersistentStorage() {\n            if (this.settings.saveValueToSessionStorage) {\n                var result = void 0;\n                if (this.sessionStorageAvailable) {\n                    result = sessionStorage.getItem(this.rawValueStorageName);\n                } else {\n                    result = this._readCookie(this.rawValueStorageName);\n                }\n\n                return result;\n            }\n\n            _AutoNumericHelper2.default.warning('`_getValueFromPersistentStorage()` is called but `settings.saveValueToSessionStorage` is false. There must be an error that needs fixing.', this.settings.showWarnings);\n\n            return null;\n        }\n\n        /**\n         * Remove the raw value data from sessionStorage or the cookie depending on what the browser is supporting.\n         * @private\n         */\n\n    }, {\n        key: '_removeValueFromPersistentStorage',\n        value: function _removeValueFromPersistentStorage() {\n            if (this.settings.saveValueToSessionStorage) {\n                if (this.sessionStorageAvailable) {\n                    sessionStorage.removeItem(this.rawValueStorageName);\n                } else {\n                    var date = new Date();\n                    date.setTime(date.getTime() - 86400000); // -86400000 === -1 * 24 * 60 * 60 * 1000\n                    var expires = '; expires=' + date.toUTCString();\n                    document.cookie = this.rawValueStorageName + '=\\'\\' ;' + expires + '; path=/';\n                }\n            }\n        }\n\n        /**\n         * Handler for 'focusin' and 'mouseenter' events\n         * On focusin, multiple things happens :\n         * - If `Alt` is pressed, unformat\n         * - Remove the separators if `showOnlyNumbersOnFocus` is set\n         * - Depending on `emptyInputBehavior`, reformat the empty formatted value\n         * - Display the correct number of decimal places (on focus/blur)\n         * - Place the caret correctly if the element is empty\n         *\n         * Note: On focusin, the `rawValue` is never changed. Only the formatted value can be modified.\n         *\n         * @param {Event} e\n         * @private\n         */\n\n    }, {\n        key: '_onFocusInAndMouseEnter',\n        value: function _onFocusInAndMouseEnter(e) {\n            this.isEditing = false; // Just in case no `keyUp` event have been sent (if the user lost the focus to the window while typing)\n\n            //TODO `AutoNumericHelper.setElementValue` is called 3 times sequentially here, fix that\n            //TODO Create separate handlers for the focus and mouseenter events\n            var initialElementValue = _AutoNumericHelper2.default.getElementValue(this.domElement);\n\n            if (this.settings.unformatOnHover && e.type === 'mouseenter' && e.altKey) {\n                this.constructor._unformatAltHovered(this);\n\n                return;\n            }\n\n            if (e.type === 'focus') {\n                //TODO Move that back to the 'focus' event handler when the separation between the 'focus' and 'mouseenter' handler will be done\n                // We keep track if the element is currently focused\n                this.isFocused = true;\n            }\n\n            if (e.type === 'focus' && this.settings.unformatOnHover && this.hoveredWithAlt) {\n                this.constructor._reformatAltHovered(this);\n            }\n\n            if (e.type === 'focus' || e.type === 'mouseenter' && !this.isFocused) {\n                if (this.settings.emptyInputBehavior === AutoNumeric.options.emptyInputBehavior.focus && this.rawValue < 0 && this.settings.negativeBracketsTypeOnBlur !== null && this.settings.negativeSignCharacter !== '') {\n                    //FIXME this is called a second time in _addGroupSeparators too. Prevent this, if possible.\n                    // Only remove the brackets if the value is negative\n                    _AutoNumericHelper2.default.setElementValue(this.domElement, this.constructor._removeBrackets(_AutoNumericHelper2.default.getElementValue(this.domElement), this.settings));\n                }\n\n                // Use the rawValue, multiplied by `rawValueDivisor` if defined\n                var rawValueToFormat = this._getRawValueToFormat(this.rawValue);\n\n                // Modify the element value according to the number of decimal places to show on focus or the `showOnlyNumbersOnFocus` option\n                if (rawValueToFormat !== '') {\n                    // Round the given value according to the object state (focus/unfocused)\n                    var roundedValue = void 0;\n                    if (this.isFocused) {\n                        roundedValue = this.constructor._roundFormattedValueShownOnFocus(rawValueToFormat, this.settings);\n                    } else {\n                        roundedValue = this.constructor._roundFormattedValueShownOnBlur(rawValueToFormat, this.settings);\n                    }\n\n                    if (this.settings.showOnlyNumbersOnFocus === AutoNumeric.options.showOnlyNumbersOnFocus.onlyNumbers) {\n                        //TODO Use a `this.settingsOverride` object instead of modifying the `this.settings` object\n                        this.settings.digitGroupSeparator = '';\n                        this.settings.currencySymbol = '';\n                        this.settings.suffixText = '';\n                        _AutoNumericHelper2.default.setElementValue(this.domElement, roundedValue.replace('.', this.settings.decimalCharacter));\n                    } else {\n                        var formattedValue = void 0;\n                        if (_AutoNumericHelper2.default.isNull(roundedValue)) {\n                            formattedValue = '';\n                        } else {\n                            formattedValue = this.constructor._addGroupSeparators(roundedValue.replace('.', this.settings.decimalCharacter), this.settings, this.isFocused, rawValueToFormat);\n                        }\n                        _AutoNumericHelper2.default.setElementValue(this.domElement, formattedValue);\n                    }\n                }\n\n                // In order to send a 'native' change event when blurring the input, we need to first store the initial input value on focus.\n                this.valueOnFocus = _AutoNumericHelper2.default.getElementValue(e.target);\n                this.lastVal = this.valueOnFocus;\n                var isEmptyValue = this.constructor._isElementValueEmptyOrOnlyTheNegativeSign(this.valueOnFocus, this.settings);\n                var orderedValue = this.constructor._orderValueCurrencySymbolAndSuffixText(this.valueOnFocus, this.settings, true); // This displays the currency sign on hover even if the rawValue is empty\n                if (isEmptyValue && orderedValue !== '' && this.settings.emptyInputBehavior === AutoNumeric.options.emptyInputBehavior.focus) {\n                    _AutoNumericHelper2.default.setElementValue(this.domElement, orderedValue);\n\n                    // If there is a currency symbol and its on the right hand side, then we place the caret accordingly on the far left side\n                    if (orderedValue === this.settings.currencySymbol && this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) {\n                        _AutoNumericHelper2.default.setElementSelection(e.target, 0);\n                    }\n                }\n            }\n\n            if (_AutoNumericHelper2.default.getElementValue(this.domElement) !== initialElementValue) {\n                _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.formatted, this.domElement, { oldValue: initialElementValue, newValue: _AutoNumericHelper2.default.getElementValue(this.domElement) });\n            }\n        }\n\n        /**\n         * Handler for the 'focus' event.\n         * We update the info of the focused state in the `this.isFocused` variable when the element gets focused.\n         * @private\n         */\n\n    }, {\n        key: '_onFocus',\n        value: function _onFocus() {\n            if (this.settings.isCancellable) {\n                // Save the current unformatted value for later use by the 'cancellable' feature\n                this._saveCancellableValue();\n            }\n        }\n\n        /**\n         * Handler for the 'focusin' event.\n         * This is called before the 'focus' event, and is necessary to change the selection on focus under Firefox for instance.\n         *\n         * @param {Event} e\n         * @private\n         */\n\n    }, {\n        key: '_onFocusIn',\n        value: function _onFocusIn(e) {\n            if (this.settings.selectOnFocus) {\n                // The whole input content is selected on focus (following the `selectOnFocus` and `selectNumberOnly` options)\n                //XXX Firefox <47 does not respect this selection...Oh well.\n                this.select();\n            } else {\n                // Or we decide where to put the caret using the `caretPositionOnFocus` option\n                _AutoNumericHelper2.default.setElementSelection(e.target, this._initialCaretPosition(_AutoNumericHelper2.default.getElementValue(this.domElement)));\n            }\n        }\n\n        /**\n         * Handler for 'keydown' events.\n         * The user just started pushing any key, hence one event is sent.\n         *\n         * Note :\n         * By default a 'normal' input output those events in the right order when inputting a character key (ie. 'a') :\n         * - keydown\n         * - keypress\n         * - input\n         * - keyup\n         *\n         * ...when inputting a modifier key (ie. 'ctrl') :\n         * - keydown\n         * - keyup\n         *\n         * If 'delete' or 'backspace' is entered, the following events are sent :\n         * - keydown\n         * - input\n         * - keyup\n         *\n         * If 'enter' is entered and the value has not changed, the following events are sent :\n         * - keydown\n         * - keypress\n         * - keyup\n         *\n         * If 'enter' is entered and the value has been changed, the following events are sent :\n         * - keydown\n         * - keypress\n         * - change\n         * - keyup\n         *\n         * When a paste is done, the following events are sent :\n         * - input (if paste is done with the mouse)\n         *\n         * - keydown (if paste is done with ctrl+v)\n         * - keydown\n         * - input\n         * - keyup\n         * - keyup\n         *\n         * @param {KeyboardEvent} e\n         */\n\n    }, {\n        key: '_onKeydown',\n        value: function _onKeydown(e) {\n            this.isEditing = true; // Keep track if the user is currently editing the element manually\n\n            if (!this.isFocused && this.settings.unformatOnHover && e.altKey && this.domElement === _AutoNumericHelper2.default.getHoveredElement()) {\n                // Here I prevent calling _unformatAltHovered if the element is already focused, since the global 'keydown' listener will pick it up as well\n                this.constructor._unformatAltHovered(this);\n\n                return;\n            }\n\n            this._updateEventKeyInfo(e);\n            this.initialValueOnKeydown = _AutoNumericHelper2.default.getElementValue(e.target); // This is needed in `onKeyup()` to check if the value as changed during the key press\n\n            if (this.domElement.readOnly) {\n                this.processed = true;\n\n                return;\n            }\n\n            if (this.eventKey === _AutoNumericEnum2.default.keyName.Esc) {\n                //XXX The default 'Escape' key behavior differs between Firefox and Chrome, Firefox already having a built-in 'cancellable-like' feature. This is why we call `e.preventDefault()` here instead of just when `isCancellable` is set to `true`. This allow us to keep the same behavior across browsers.\n                e.preventDefault();\n\n                if (this.settings.isCancellable) {\n                    // If the user wants to cancel its modifications :\n                    // We set back the saved value\n                    if (this.rawValue !== this.savedCancellableValue) {\n                        // Do not set the value again if it has not changed\n                        this.set(this.savedCancellableValue);\n                        // And we need to send an 'input' event when setting back the initial value in order to make other scripts aware of the value change...\n                        _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.native.input, e.target);\n                    }\n                }\n\n                // ..and lastly we update the caret selection, even if the option `isCancellable` is false\n                this.select();\n                //TODO Add an option to select either the integer or decimal part with `Esc`\n            }\n\n            // The \"enter\" key throws a `change` event if the value has changed since the `focus` event\n            var targetValue = _AutoNumericHelper2.default.getElementValue(e.target);\n            if (this.eventKey === _AutoNumericEnum2.default.keyName.Enter && this.valueOnFocus !== targetValue) {\n                _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.native.change, e.target);\n                this.valueOnFocus = targetValue;\n\n                if (this.settings.isCancellable) {\n                    // If the user activated the 'cancellable' feature, we save the validated value when 'Enter' is hit\n                    this._saveCancellableValue();\n                }\n            }\n\n            this._updateInternalProperties(e);\n\n            if (this._processNonPrintableKeysAndShortcuts(e)) {\n                this.processed = true;\n\n                return;\n            }\n\n            // Check if the key is a delete/backspace key\n            if (this.eventKey === _AutoNumericEnum2.default.keyName.Backspace || this.eventKey === _AutoNumericEnum2.default.keyName.Delete) {\n                this._processCharacterDeletion(); // Because backspace and delete only triggers keydown and keyup events, not keypress\n                this.processed = true;\n                this._formatValue(e);\n\n                // If and only if the resulting value has changed after that backspace/delete, then we have to send an 'input' event like browsers normally do.\n                targetValue = _AutoNumericHelper2.default.getElementValue(e.target); // Update the value since it could have been changed during the deletion\n                if (targetValue !== this.lastVal && this.throwInput) {\n                    // Throw an input event when a character deletion is detected\n                    _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.native.input, e.target);\n                    e.preventDefault(); // ...and immediately prevent the browser to delete a second character\n                }\n\n                this.lastVal = targetValue;\n                this.throwInput = true;\n\n                return;\n            }\n\n            this.formatted = false; //TODO Is this line needed? (I mean, _formatValue always set it to `true`, and this overwrite that info)\n        }\n\n        /**\n         * Handler for 'keypress' events.\n         * The user is still pressing the key, which will output a character (ie. '2') continuously until it releases the key.\n         * Note: 'keypress' events are not sent for delete keys like Backspace/Delete.\n         *\n         * @param {KeyboardEvent} e\n         */\n\n    }, {\n        key: '_onKeypress',\n        value: function _onKeypress(e) {\n            if (this.eventKey === _AutoNumericEnum2.default.keyName.Insert) {\n                return;\n            }\n\n            var processed = this.processed;\n            this._updateInternalProperties(e);\n\n            if (this._processNonPrintableKeysAndShortcuts(e)) {\n                return;\n            }\n\n            if (processed) {\n                e.preventDefault();\n\n                return;\n            }\n\n            var isCharacterInsertionAllowed = this._processCharacterInsertion();\n            if (isCharacterInsertionAllowed) {\n                this._formatValue(e);\n                var targetValue = _AutoNumericHelper2.default.getElementValue(e.target);\n                if (targetValue !== this.lastVal && this.throwInput) {\n                    // Throws input event on adding a character\n                    _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.native.input, e.target);\n                    e.preventDefault(); // ...and immediately prevent the browser to add a second character\n                } else {\n                    if ((this.eventKey === this.settings.decimalCharacter || this.eventKey === this.settings.decimalCharacterAlternative) && _AutoNumericHelper2.default.getElementSelection(e.target).start === _AutoNumericHelper2.default.getElementSelection(e.target).end && _AutoNumericHelper2.default.getElementSelection(e.target).start === targetValue.indexOf(this.settings.decimalCharacter)) {\n                        var position = _AutoNumericHelper2.default.getElementSelection(e.target).start + 1;\n                        _AutoNumericHelper2.default.setElementSelection(e.target, position);\n                    }\n\n                    e.preventDefault();\n                }\n\n                this.lastVal = _AutoNumericHelper2.default.getElementValue(e.target);\n                this.throwInput = true;\n\n                return;\n            }\n\n            e.preventDefault();\n\n            this.formatted = false; //TODO Is this line needed? (I mean, _formatValue always set it to `true`, and this overwrite that info)\n        }\n\n        /**\n         * Handler for 'input' events.\n         * Handling this event instead of `keypress` is needed in order to support android devices.\n         *\n         * @param {Event} e\n         */\n\n    }, {\n        key: '_onInput',\n        value: function _onInput(e) {\n            var value = _AutoNumericHelper2.default.getElementValue(this.domElement);\n\n            // Fix the caret position on keyup in the `_formatValue()` function\n            this.androidSelectionStart = null;\n\n            if (this.eventKey === _AutoNumericEnum2.default.keyName.AndroidDefault) {\n                var selection = _AutoNumericHelper2.default.getElementSelection(this.domElement);\n                // The keyCode is equal to the default Android Chrome one (which is always equal to `keyCode.AndroidDefault`)\n                if (value.length > this.lastVal.length || value.length >= this.lastVal.length - selection.length) {\n                    // Determine the keycode of the character that was entered, and overwrite the faulty `eventKeyCode` info with it\n                    this.eventKey = value.charCodeAt(selection.start);\n\n                    // Capture the actual character entered, and update the `eventKey` with it (instead of the Android default one)\n                    this.eventKey = value.charAt(selection.start);\n\n                    // Check if the given character should be inserted, and if so, do insert it into the current element value\n                    var isCharacterInsertionAllowed = this._processCharacterInsertion();\n\n                    if (isCharacterInsertionAllowed) {\n                        // Allowed character entered (number, decimal or plus/minus sign)\n                        this._formatValue(e);\n\n                        selection = _AutoNumericHelper2.default.getElementSelection(this.domElement); //TODO is this needed a second time?\n                        // Capture the new caret position. This is required because on keyup, `_updateAutoNumericHolderEventKeycode()` captures the old caret position\n                        //TODO Check if this is an Android bug or an autoNumeric one\n                        this.androidSelectionStart = selection.start;\n\n                        // Move the caret to the right if the `androidCharEntered` is the decimal character or if it's on the left of the caret position\n                        var decimalCharacterPosition = _AutoNumericHelper2.default.getElementValue(this.domElement).indexOf(this.settings.decimalCharacter);\n                        var hasDecimalCharacter = decimalCharacterPosition !== -1;\n                        if (this.eventKey === this.settings.decimalCharacter || hasDecimalCharacter && decimalCharacterPosition < this.androidSelectionStart) {\n                            this.androidSelectionStart += this.settings.decimalCharacter.length;\n                        }\n\n                        if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix && this.settings.currencySymbol.length) {\n                            this.androidSelectionStart += this.settings.currencySymbol.length;\n                        }\n\n                        if (selection.length > value.length) {\n                            // Position the caret right now before the 'keyup' event in order to prevent the caret from jumping around\n                            this._setCaretPosition(this.androidSelectionStart);\n                        }\n\n                        this.lastVal = _AutoNumericHelper2.default.getElementValue(this.domElement);\n\n                        return;\n                    } else {\n                        // The entered character is not allowed ; overwrite the new invalid value with the previous valid one, and set back the caret/selection\n                        _AutoNumericHelper2.default.setElementValue(this.lastVal); //TODO Update the rawValue here too via _setValue()?\n                        _AutoNumericHelper2.default.setElementSelection(this.domElement, selection.start, selection.end);\n                        this.androidSelectionStart = selection.start;\n                    }\n\n                    e.preventDefault(); //TODO Check how that is affecting the normal trigger of the input event\n\n                    this.formatted = false;\n                } else {\n                    // Character deleted\n                    //XXX The change in length could also be the result of the `Delete` key, but there usually are no such key in the Android virtual keyboards\n                    this.eventKey = _AutoNumericEnum2.default.keyName.Backspace;\n                }\n            }\n        }\n\n        /**\n         * Handler for 'keyup' events.\n         * The user just released any key, hence one event is sent.\n         *\n         * @param {KeyboardEvent} e\n         */\n\n    }, {\n        key: '_onKeyup',\n        value: function _onKeyup(e) {\n            this.isEditing = false;\n\n            if (this.settings.isCancellable && this.eventKey === _AutoNumericEnum2.default.keyName.Esc) {\n                // If the user wants to cancel its modifications, we drop the 'keyup' event for the Esc key\n                e.preventDefault();\n\n                return;\n            }\n\n            // Manage the undo/redo events\n            if (this.eventKey === _AutoNumericEnum2.default.keyName.Z || this.eventKey === _AutoNumericEnum2.default.keyName.z) {\n                if (e.ctrlKey && e.shiftKey) {\n                    // Redo\n                    e.preventDefault();\n                    this._historyTableRedo();\n                    this.onGoingRedo = true;\n\n                    return;\n                } else if (e.ctrlKey && !e.shiftKey) {\n                    if (this.onGoingRedo) {\n                        // Prevent an 'undo' to be launch when releasing the shift key before the ctrl key after a 'redo' shortcut\n                        this.onGoingRedo = false;\n                    } else {\n                        e.preventDefault();\n                        // Undo\n                        this._historyTableUndo();\n\n                        return;\n                    }\n                }\n            }\n\n            if (this.onGoingRedo && (e.ctrlKey || e.shiftKey)) {\n                // Special case where if the user has entered `Control+Shift+z`, then release `z`, keeping `Control` or `Shift` pressed, then `this.onGoingRedo` is never changed back to `false` when the user release `Control` or `Shift`\n                this.onGoingRedo = false;\n            }\n\n            // Manage the reformat when hovered with the Alt key pressed\n            if (this.eventKey === _AutoNumericEnum2.default.keyName.Alt && this.hoveredWithAlt) {\n                this.constructor._reformatAltHovered(this);\n\n                return;\n            }\n\n            this._updateInternalProperties(e);\n\n            var skip = this._processNonPrintableKeysAndShortcuts(e);\n            delete this.valuePartsBeforePaste;\n            var isOnAndroid = this.androidSelectionStart !== null;\n            var targetValue = _AutoNumericHelper2.default.getElementValue(e.target);\n            if (skip && !isOnAndroid || targetValue === '') {\n                return;\n            }\n\n            // Added to properly place the caret when only the currency sign is present\n            if (targetValue === this.settings.currencySymbol) {\n                if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) {\n                    _AutoNumericHelper2.default.setElementSelection(e.target, 0);\n                } else {\n                    _AutoNumericHelper2.default.setElementSelection(e.target, this.settings.currencySymbol.length);\n                }\n            } else if (this.eventKey === _AutoNumericEnum2.default.keyName.Tab) {\n                _AutoNumericHelper2.default.setElementSelection(e.target, 0, targetValue.length);\n            }\n\n            if (targetValue === this.settings.suffixText || this.rawValue === '' && this.settings.currencySymbol !== '' && this.settings.suffixText !== '') {\n                _AutoNumericHelper2.default.setElementSelection(e.target, 0);\n            }\n\n            // Saves the extended decimal to preserve the data when navigating away from the page\n            if (this.settings.decimalPlacesShownOnFocus !== null) {\n                this._saveValueToPersistentStorage();\n            }\n\n            if (!this.formatted) {\n                //TODO Is this line needed? Considering that onKeydown and onKeypress both finish by setting it to false...\n                this._formatValue(e);\n            }\n\n            // If the input value has changed during the key press event chain, an event is sent to alert that a formatting has been done (cf. Issue #187)\n            if (targetValue !== this.initialValueOnKeydown) {\n                _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.formatted, e.target, { oldValue: this.initialValueOnKeydown, newValue: targetValue }); //TODO Do I need to remove this since we now send this event on `set()`?\n            }\n\n            // Update the selection of the current element of the history table\n            if (this.historyTable.length > 1) {\n                var selection = _AutoNumericHelper2.default.getElementSelection(this.domElement);\n                this.selectionStart = selection.start;\n                this.selectionEnd = selection.end;\n                this.historyTable[this.historyTableIndex].start = this.selectionStart;\n                this.historyTable[this.historyTableIndex].end = this.selectionEnd;\n            }\n        }\n\n        /**\n         * Handler for 'focusout' events\n         * On focusout, multiple things happens :\n         * - The element value is formatted back if the `Alt` key was pressed,\n         * - The element value is formatted back if `showOnlyNumbersOnFocus` was set to only show numbers,\n         * - The element value is multiplied by `rawValueDivisor` on `blur`\n         *\n         * Note: On focusout, the `rawValue` is never changed. Only the formatted value can be modified.\n         *\n         * @param {Event} e\n         */\n\n    }, {\n        key: '_onFocusOutAndMouseLeave',\n        value: function _onFocusOutAndMouseLeave(e) {\n            this.isEditing = false; // Just in case no `keyUp` event have been sent (if the user lost the focus to the window while typing)\n\n            //TODO Create separate handlers for blur and mouseleave\n            //FIXME Do not call `set()` if the current raw value is the same as the one we are trying to set (currently, on focus out, `set()` is always called, even if the value has not changed\n            if (this.settings.unformatOnHover && e.type === 'mouseleave' && this.hoveredWithAlt) {\n                this.constructor._reformatAltHovered(this);\n\n                return;\n            }\n\n            if (e.type === 'mouseleave' && !this.isFocused || e.type === 'blur') {\n                this._saveValueToPersistentStorage();\n                if (this.settings.showOnlyNumbersOnFocus === AutoNumeric.options.showOnlyNumbersOnFocus.onlyNumbers) {\n                    this.settings.digitGroupSeparator = this.originalDigitGroupSeparator;\n                    this.settings.currencySymbol = this.originalCurrencySymbol;\n                    this.settings.suffixText = this.originalSuffixText;\n                }\n\n                // Use the rawValue, multiplied by `rawValueDivisor` if defined\n                var rawValueToFormat = this._getRawValueToFormat(this.rawValue);\n                var isRawValueNull = _AutoNumericHelper2.default.isNull(rawValueToFormat);\n\n                var _constructor$_checkIf5 = this.constructor._checkIfInRangeWithOverrideOption(rawValueToFormat, this.settings),\n                    _constructor$_checkIf6 = _slicedToArray(_constructor$_checkIf5, 2),\n                    minTest = _constructor$_checkIf6[0],\n                    maxTest = _constructor$_checkIf6[1];\n\n                // Directly set the formatted value if the `rawValue` is found in `valuesToStrings`\n\n\n                var elementValueIsAlreadySet = false;\n                if (rawValueToFormat !== '' && !isRawValueNull) {\n                    if (!minTest) {\n                        _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.minRangeExceeded, this.domElement);\n                    }\n\n                    if (!maxTest) {\n                        _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.maxRangeExceeded, this.domElement);\n                    }\n\n                    if (this.settings.valuesToStrings && this._checkValuesToStrings(rawValueToFormat)) {\n                        // Set the formatted value with the corresponding string\n                        this._setElementValue(this.settings.valuesToStrings[rawValueToFormat]);\n                        elementValueIsAlreadySet = true;\n                    }\n                }\n\n                // Only generate the formatted value if no `valuesToStrings` have been found\n                if (!elementValueIsAlreadySet) {\n                    var value = void 0;\n                    if (isRawValueNull || rawValueToFormat === '') {\n                        value = rawValueToFormat;\n                    } else {\n                        value = String(rawValueToFormat);\n                    }\n\n                    if (rawValueToFormat !== '' && !isRawValueNull) {\n                        if (minTest && maxTest && !this.constructor._isElementValueEmptyOrOnlyTheNegativeSign(rawValueToFormat, this.settings)) {\n                            value = this._modifyNegativeSignAndDecimalCharacterForRawValue(value);\n\n                            if (this.settings.divisorWhenUnfocused && !_AutoNumericHelper2.default.isNull(value)) {\n                                value = value / this.settings.divisorWhenUnfocused;\n                                value = value.toString();\n                            }\n\n                            value = this.constructor._roundFormattedValueShownOnBlur(value, this.settings);\n                            value = this.constructor._modifyNegativeSignAndDecimalCharacterForFormattedValue(value, this.settings);\n                        } else {\n                            if (!minTest) {\n                                _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.minRangeExceeded, this.domElement);\n                            }\n\n                            if (!maxTest) {\n                                _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.maxRangeExceeded, this.domElement);\n                            }\n                        }\n                    } else if (rawValueToFormat === '' && this.settings.emptyInputBehavior === AutoNumeric.options.emptyInputBehavior.zero) {\n                        this._setRawValue('0');\n                        value = this.constructor._roundValue('0', this.settings, 0);\n                    }\n\n                    var groupedValue = this.constructor._orderValueCurrencySymbolAndSuffixText(value, this.settings, false);\n                    if (!(this.constructor._isElementValueEmptyOrOnlyTheNegativeSign(value, this.settings) || isRawValueNull && this.settings.emptyInputBehavior === AutoNumeric.options.emptyInputBehavior.null)) {\n                        groupedValue = this.constructor._addGroupSeparators(value, this.settings, false, rawValueToFormat);\n                    }\n\n                    // Testing for `allowDecimalPadding.never` or `allowDecimalPadding.floats` is needed to make sure we do not keep a trailing decimalCharacter (like '500.') in the element, since the raw value would still be a correctly formatted integer ('500')\n                    if (groupedValue !== rawValueToFormat || rawValueToFormat === '' || // This make sure we get rid on any currency symbol or suffix that might have been added on focus\n                    this.settings.allowDecimalPadding === AutoNumeric.options.allowDecimalPadding.never || this.settings.allowDecimalPadding === AutoNumeric.options.allowDecimalPadding.floats) {\n                        if (this.settings.symbolWhenUnfocused && rawValueToFormat !== '' && rawValueToFormat !== null) {\n                            groupedValue = '' + groupedValue + this.settings.symbolWhenUnfocused;\n                        }\n\n                        this._setElementValue(groupedValue);\n                    }\n\n                    if (groupedValue !== this.valueOnFocus) {\n                        _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.native.change, this.domElement);\n                        delete this.valueOnFocus;\n                    }\n                }\n\n                this._onBlur(e);\n            }\n        }\n\n        /**\n         * Handler for 'paste' event\n         *\n         * @param {Event|ClipboardEvent} e\n         */\n\n    }, {\n        key: '_onPaste',\n        value: function _onPaste(e) {\n            //TODO Using ctrl+z after a paste should cancel it -> How would that affect other frameworks/component built with that feature in mind though?\n            //FIXME When pasting '000' on a thousand group selection, the whole selection gets deleted, and only one '0' is pasted (cf. issue #302)\n            // The event is prevented by default, since otherwise the user would be able to paste invalid characters into the input\n            e.preventDefault();\n\n            var rawPastedText = void 0;\n            if (window.clipboardData && window.clipboardData.getData) {\n                // Special case for the obsolete and non-standard IE browsers 10 and 11\n                rawPastedText = window.clipboardData.getData('Text');\n            } else if (e.clipboardData && e.clipboardData.getData) {\n                // Normal case with modern browsers\n                rawPastedText = e.clipboardData.getData('text/plain');\n            } else {\n                _AutoNumericHelper2.default.throwError('Unable to retrieve the pasted value. Please use a modern browser (ie. Firefox or Chromium).');\n            }\n\n            // 0. Special case if the user has selected all the input text before pasting\n            var initialFormattedValue = _AutoNumericHelper2.default.getElementValue(e.target);\n            var selectionStart = e.target.selectionStart || 0;\n            var selectionEnd = e.target.selectionEnd || 0;\n            var selectionSize = selectionEnd - selectionStart;\n            var isAllInputTextSelected = false;\n\n            if (selectionSize === initialFormattedValue.length) {\n                isAllInputTextSelected = true;\n            }\n\n            // 1. Check if the paste has a negative sign (only if it's the first character), and store that information for later use\n            var isPasteNegative = _AutoNumericHelper2.default.isNegativeStrict(rawPastedText);\n            if (isPasteNegative) {\n                // 1a. Remove the negative sign from the pasted text\n                rawPastedText = rawPastedText.slice(1, rawPastedText.length);\n            }\n\n            // 2. Strip all thousand separators, brackets and currency sign, and convert the decimal character to a dot\n            var untranslatedPastedText = this._preparePastedText(rawPastedText);\n\n            var pastedText = void 0;\n            if (untranslatedPastedText === '.') {\n                // Special case : If the user tries to paste a single decimal character (that has been translated to '.' already)\n                pastedText = '.';\n            } else {\n                // Normal case\n                // Allow pasting arabic numbers\n                pastedText = _AutoNumericHelper2.default.arabicToLatinNumbers(untranslatedPastedText, false, false, false);\n            }\n\n            // 3. Test if the paste is valid (only has numbers and eventually a decimal character). If it's not valid, stop here.\n            if (pastedText !== '.' && (!_AutoNumericHelper2.default.isNumber(pastedText) || pastedText === '')) {\n                if (this.settings.onInvalidPaste === AutoNumeric.options.onInvalidPaste.error) {\n                    //TODO Should we send a warning instead of throwing an error?\n                    _AutoNumericHelper2.default.throwError('The pasted value \\'' + rawPastedText + '\\' is not a valid paste content.');\n                }\n\n                return;\n            }\n\n            // 4. Calculate the paste result\n            var caretPositionOnInitialTextAfterPasting = void 0;\n            var initialUnformattedNumber = this.getNumericString();\n            var isInitialValueNegative = _AutoNumericHelper2.default.isNegativeStrict(initialUnformattedNumber);\n            var isPasteNegativeAndInitialValueIsPositive = void 0;\n            var result = void 0;\n\n            // If the pasted content is negative, then the result will be negative too\n            if (isPasteNegative && !isInitialValueNegative) {\n                initialUnformattedNumber = '-' + initialUnformattedNumber;\n                isInitialValueNegative = true;\n                isPasteNegativeAndInitialValueIsPositive = true;\n            } else {\n                isPasteNegativeAndInitialValueIsPositive = false;\n            }\n\n            var leftPartContainedADot = false;\n            var leftPart = void 0;\n            var rightPart = void 0;\n            switch (this.settings.onInvalidPaste) {\n                /* 4a. Truncate paste behavior:\n                 * Insert as many numbers as possible on the right hand side of the caret from the pasted text content, until the input reach its range limit.\n                 * If there is more characters in the clipboard once a limit is reached, drop the extraneous characters.\n                 * Otherwise paste all the numbers in the clipboard.\n                 * While doing so, we check if the result is within the minimum and maximum values allowed, and stop as soon as we encounter one of those.\n                 *\n                 * 4b. Replace paste behavior:\n                 * Idem than the 'truncate' paste behavior, except that when a range limit is hit, we try to replace the subsequent initial numbers with the pasted ones, until we hit the range limit a second (and last) time, or we run out of numbers to paste\n                 */\n                /* eslint no-case-declarations: 0 */\n                case AutoNumeric.options.onInvalidPaste.truncate:\n                case AutoNumeric.options.onInvalidPaste.replace:\n                    var leftFormattedPart = initialFormattedValue.slice(0, selectionStart);\n                    var rightFormattedPart = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\n                    if (selectionStart !== selectionEnd) {\n                        // a. If there is a selection, remove the selected part, and return the left and right part\n                        result = this._preparePastedText(leftFormattedPart + rightFormattedPart);\n                    } else {\n                        // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n                        result = this._preparePastedText(initialFormattedValue);\n                    }\n\n                    // Add back the negative sign if needed\n                    if (isInitialValueNegative) {\n                        result = _AutoNumericHelper2.default.setRawNegativeSign(result);\n                    }\n\n                    // Build the unformatted result string\n                    caretPositionOnInitialTextAfterPasting = _AutoNumericHelper2.default.convertCharacterCountToIndexPosition(_AutoNumericHelper2.default.countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, this.settings.decimalCharacter));\n                    if (isPasteNegativeAndInitialValueIsPositive) {\n                        // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n                        caretPositionOnInitialTextAfterPasting++;\n                        //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n                    }\n\n                    leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n                    rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n                    if (pastedText === '.') {\n                        if (_AutoNumericHelper2.default.contains(leftPart, '.')) {\n                            // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\n                            // To do so, we keep that info in order to modify the caret position later\n                            leftPartContainedADot = true;\n                            leftPart = leftPart.replace('.', '');\n                        }\n\n                        rightPart = rightPart.replace('.', '');\n                    }\n                    // -- Here, we are good to go to continue on the same basis\n\n                    // c. Add numbers one by one at the caret position, while testing if the result is valid and within the range of the minimum and maximum value\n                    //    Continue until you either run out of numbers to paste, or that you get out of the range limits\n                    var minParse = _AutoNumericHelper2.default.parseStr(this.settings.minimumValue);\n                    var maxParse = _AutoNumericHelper2.default.parseStr(this.settings.maximumValue);\n                    var lastGoodKnownResult = result; // This is set as the default, in case we do not add even one number\n                    var pastedTextIndex = 0;\n                    var modifiedLeftPart = leftPart;\n\n                    while (pastedTextIndex < pastedText.length) {\n                        // Modify the result with another pasted character\n                        modifiedLeftPart += pastedText[pastedTextIndex];\n                        result = modifiedLeftPart + rightPart;\n\n                        // Check the range limits\n                        if (!this.constructor._checkIfInRange(result, minParse, maxParse)) {\n                            // The result is out of the range limits, stop the loop here\n                            break;\n                        }\n\n                        // Save the last good known result\n                        lastGoodKnownResult = result;\n\n                        // Update the local variables for the next loop\n                        pastedTextIndex++;\n                    }\n\n                    // Update the last caret position where to insert a new number\n                    caretPositionOnInitialTextAfterPasting += pastedTextIndex;\n\n                    //XXX Here we have the result for the `truncate` option\n                    if (this.settings.onInvalidPaste === AutoNumeric.options.onInvalidPaste.truncate) {\n                        //TODO If the user as defined a truncate callback and there are still some numbers (that will be dropped), then call this callback with the initial paste as well as the remaining numbers\n                        result = lastGoodKnownResult;\n\n                        if (leftPartContainedADot) {\n                            // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                            caretPositionOnInitialTextAfterPasting--;\n                        }\n                        break;\n                    }\n                    //XXX ...else we need to continue modifying the result for the 'replace' option\n\n                    // d. Until there are numbers to paste, replace the initial numbers one by one, and still do the range test.\n                    //    Stop when you have no more numbers to paste, or if you are out of the range limits.\n                    //    If you do get to the range limits, use the previous known good value within those limits.\n                    //    Note: The numbers are replaced one by one, in the integer then decimal part, while ignoring the decimal character\n                    //TODO What should happen if the user try to paste a decimal number? Should we override the current initial decimal character in favor of this new one? If we do, then we have to recalculate the vMin/vMax from the start in order to take into account this new decimal character position..\n                    var lastGoodKnownResultIndex = caretPositionOnInitialTextAfterPasting;\n                    var lastGoodKnownResultSize = lastGoodKnownResult.length;\n\n                    while (pastedTextIndex < pastedText.length && lastGoodKnownResultIndex < lastGoodKnownResultSize) {\n                        if (lastGoodKnownResult[lastGoodKnownResultIndex] === '.') {\n                            // We skip the decimal character 'replacement'. That way, we do not change the decimal character position regarding the remaining numbers.\n                            lastGoodKnownResultIndex++;\n                            continue;\n                        }\n\n                        // This replace one character at a time\n                        result = _AutoNumericHelper2.default.replaceCharAt(lastGoodKnownResult, lastGoodKnownResultIndex, pastedText[pastedTextIndex]);\n\n                        // Check the range limits\n                        if (!this.constructor._checkIfInRange(result, minParse, maxParse)) {\n                            // The result is out of the range limits, stop the loop here\n                            break;\n                        }\n\n                        // Save the last good known result\n                        lastGoodKnownResult = result;\n\n                        // Update the local variables for the next loop\n                        pastedTextIndex++;\n                        lastGoodKnownResultIndex++;\n                    }\n\n                    // Update the last caret position where to insert a new number\n                    caretPositionOnInitialTextAfterPasting = lastGoodKnownResultIndex;\n\n                    if (leftPartContainedADot) {\n                        // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                        caretPositionOnInitialTextAfterPasting--;\n                    }\n\n                    result = lastGoodKnownResult;\n\n                    break;\n                /* 4c. Normal paste behavior:\n                 * Insert the pasted number inside the current unformatted text, at the right caret position or selection\n                 */\n                case AutoNumeric.options.onInvalidPaste.error:\n                case AutoNumeric.options.onInvalidPaste.ignore:\n                case AutoNumeric.options.onInvalidPaste.clamp:\n                default:\n                    // 1. Generate the unformatted result\n                    var leftFormattedPart2 = initialFormattedValue.slice(0, selectionStart);\n                    var rightFormattedPart2 = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\n                    if (selectionStart !== selectionEnd) {\n                        // a. If there is a selection, remove the selected part, and return the left and right part\n                        result = this._preparePastedText(leftFormattedPart2 + rightFormattedPart2);\n                    } else {\n                        // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n                        result = this._preparePastedText(initialFormattedValue);\n                    }\n\n                    // Add back the negative sign if needed\n                    if (isInitialValueNegative) {\n                        result = _AutoNumericHelper2.default.setRawNegativeSign(result);\n                    }\n\n                    // Build the unformatted result string\n                    caretPositionOnInitialTextAfterPasting = _AutoNumericHelper2.default.convertCharacterCountToIndexPosition(_AutoNumericHelper2.default.countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, this.settings.decimalCharacter));\n                    if (isPasteNegativeAndInitialValueIsPositive) {\n                        // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n                        caretPositionOnInitialTextAfterPasting++;\n                        //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n                    }\n\n                    leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n                    rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n                    if (pastedText === '.') {\n                        // If the user only paste a single decimal character, then we remove the previously existing one (if any)\n                        if (_AutoNumericHelper2.default.contains(leftPart, '.')) {\n                            // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\n                            // To do so, we keep that info in order to modify the caret position later\n                            leftPartContainedADot = true;\n                            leftPart = leftPart.replace('.', '');\n                        }\n                        rightPart = rightPart.replace('.', '');\n                    }\n                    // -- Here, we are good to go to continue on the same basis\n\n                    // Generate the unformatted result\n                    result = '' + leftPart + pastedText + rightPart;\n\n                    // 2. Calculate the caret position in the unformatted value, for later use\n                    if (selectionStart === selectionEnd) {\n                        // There is no selection, then the caret position is set after the pasted text\n                        var indexWherePastedTextHasBeenInserted = _AutoNumericHelper2.default.convertCharacterCountToIndexPosition(_AutoNumericHelper2.default.countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, this.settings.decimalCharacter));\n                        caretPositionOnInitialTextAfterPasting = indexWherePastedTextHasBeenInserted + pastedText.length; // I must not count the characters that have been removed from the pasted text (ie. '.')\n                    } else {\n                        if (isAllInputTextSelected) {\n                            // Special case when all the input text is selected before pasting, which means we'll completely erase its content and paste only the clipboard content\n                            caretPositionOnInitialTextAfterPasting = result.length;\n                        } else if (rightPart === '') {\n                            // If the user selected from the caret position to the end of the input (on the far right)\n                            caretPositionOnInitialTextAfterPasting = _AutoNumericHelper2.default.convertCharacterCountToIndexPosition(_AutoNumericHelper2.default.countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, this.settings.decimalCharacter)) + pastedText.length;\n                        } else {\n                            // Normal case\n                            var indexSelectionEndInRawValue = _AutoNumericHelper2.default.convertCharacterCountToIndexPosition(_AutoNumericHelper2.default.countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionEnd, this.settings.decimalCharacter));\n\n                            // Here I must not count the characters that have been removed from the pasted text (ie. '.'), or the thousand separators in the initial selected text\n                            var selectedText = _AutoNumericHelper2.default.getElementValue(e.target).slice(selectionStart, selectionEnd);\n                            caretPositionOnInitialTextAfterPasting = indexSelectionEndInRawValue - selectionSize + _AutoNumericHelper2.default.countCharInText(this.settings.digitGroupSeparator, selectedText) + pastedText.length;\n                        }\n                    }\n\n                    // Modify the caret position for special cases, only if the whole input has not been selected\n                    if (!isAllInputTextSelected) {\n                        if (isPasteNegativeAndInitialValueIsPositive) {\n                            // If the pasted value has a '-' sign, but the initial value does not, offset the index by one\n                            caretPositionOnInitialTextAfterPasting++;\n                        }\n\n                        if (leftPartContainedADot) {\n                            // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                            caretPositionOnInitialTextAfterPasting--;\n                        }\n                    }\n            }\n\n            // 5. Check if the result is a valid number, if not, drop the paste and do nothing.\n            if (!_AutoNumericHelper2.default.isNumber(result) || result === '') {\n                if (this.settings.onInvalidPaste === AutoNumeric.options.onInvalidPaste.error) {\n                    _AutoNumericHelper2.default.throwError('The pasted value \\'' + rawPastedText + '\\' would result into an invalid content \\'' + result + '\\'.'); //TODO Should we send a warning instead of throwing an error?\n                    //TODO This is not DRY ; refactor with above\n                }\n                return;\n            }\n\n            // 6. If it's a valid number, check if it falls inside the minimum and maximum value. If this fails, modify the value following this procedure :\n            /*\n             * If 'error' (this is the default) :\n             *      - Normal paste behavior.\n             *      - Try to set the new value, if it fails, then throw an error in the console.\n             *      - Do not change the input value, do not change the current selection.\n             * If 'ignore' :\n             *      - Normal paste behavior.\n             *      - Try to set the new value, if it fails, do nothing more.\n             *      - Do not change the input value, do not change the current selection.\n             * If 'clamp' :\n             *      - Normal paste behavior.\n             *      - Try to set the new value, if it fails, set the value to the minimum or maximum limit, whichever is closest to the\n             *        paste result.\n             *      - Change the caret position to be positioned on the left hand side of the decimal character.\n             * If 'truncate' :\n             *      - Truncate paste behavior.\n             *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\n             *      - Drop the remaining non-pasted numbers, and keep the last known non-failing result.\n             *      - Change the caret position to be positioned after the last pasted character.\n             * If 'replace' :\n             *      - Replace paste behavior.\n             *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\n             *     - Then try to replace as many numbers as possible with the pasted ones. Once it fails, keep the last known non-failing result.\n             *      - Change the caret position to be positioned after the last pasted character.\n             */\n            var valueHasBeenSet = false;\n            var valueHasBeenClamped = false;\n            try {\n                this.set(result);\n                valueHasBeenSet = true;\n            } catch (error) {\n                var clampedValue = void 0;\n                switch (this.settings.onInvalidPaste) {\n                    case AutoNumeric.options.onInvalidPaste.clamp:\n                        clampedValue = _AutoNumericHelper2.default.clampToRangeLimits(result, this.settings);\n                        try {\n                            this.set(clampedValue);\n                        } catch (error) {\n                            _AutoNumericHelper2.default.throwError('Fatal error: Unable to set the clamped value \\'' + clampedValue + '\\'.');\n                        }\n\n                        valueHasBeenClamped = true;\n                        valueHasBeenSet = true;\n                        result = clampedValue; // This is used only for setting the caret position later\n                        break;\n                    case AutoNumeric.options.onInvalidPaste.error:\n                    case AutoNumeric.options.onInvalidPaste.truncate:\n                    case AutoNumeric.options.onInvalidPaste.replace:\n                        // Throw an error message\n                        _AutoNumericHelper2.default.throwError('The pasted value \\'' + rawPastedText + '\\' results in a value \\'' + result + '\\' that is outside of the minimum [' + this.settings.minimumValue + '] and maximum [' + this.settings.maximumValue + '] value range.');\n                    // falls through\n                    case AutoNumeric.options.onInvalidPaste.ignore:\n                    // Do nothing\n                    // falls through\n                    default:\n                        return; // ...and nothing else should be changed\n                }\n            }\n\n            // 7. Then lastly, set the caret position at the right logical place\n            var targetValue = _AutoNumericHelper2.default.getElementValue(e.target);\n            var caretPositionInFormattedNumber = void 0;\n            if (valueHasBeenSet) {\n                switch (this.settings.onInvalidPaste) {\n                    case AutoNumeric.options.onInvalidPaste.clamp:\n                        if (valueHasBeenClamped) {\n                            if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) {\n                                _AutoNumericHelper2.default.setElementSelection(e.target, targetValue.length - this.settings.currencySymbol.length); // This puts the caret on the right of the last decimal place\n                            } else {\n                                _AutoNumericHelper2.default.setElementSelection(e.target, targetValue.length); // ..and this on the far right\n                            }\n\n                            break;\n                        } // else if the value has not been clamped, the default behavior is used...\n                    // falls through\n                    case AutoNumeric.options.onInvalidPaste.error:\n                    case AutoNumeric.options.onInvalidPaste.ignore:\n                    case AutoNumeric.options.onInvalidPaste.truncate:\n                    case AutoNumeric.options.onInvalidPaste.replace:\n                    default:\n                        // Whenever one or multiple characters are pasted, this means we have to manage the potential thousand separators that could be added by the formatting\n                        caretPositionInFormattedNumber = _AutoNumericHelper2.default.findCaretPositionInFormattedNumber(result, caretPositionOnInitialTextAfterPasting, targetValue, this.settings.decimalCharacter);\n                        _AutoNumericHelper2.default.setElementSelection(e.target, caretPositionInFormattedNumber);\n                }\n            }\n\n            // 8. We make sure we send an input event only if the result is different than the initial value before the paste\n            if (valueHasBeenSet && initialFormattedValue !== targetValue) {\n                // On a 'normal' non-autoNumeric input, an `input` event is sent when a paste is done. We mimic that.\n                _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.native.input, e.target);\n            }\n        }\n\n        /**\n         * When focusing out of the input, we check if the value has changed, and if it has, then we send a `change` event (since the native one would have been prevented by `e.preventDefault()` called in the other event listeners).\n         * We also update the info of the focused state in the `this.isFocused` variable.\n         *\n         * @param {Event} e\n         */\n\n    }, {\n        key: '_onBlur',\n        value: function _onBlur(e) {\n            // Keep track if the element is currently focused\n            this.isFocused = false;\n            // Keep track if the user is currently editing the element\n            this.isEditing = false;\n\n            if (_AutoNumericHelper2.default.getElementValue(e.target) !== this.valueOnFocus) {\n                _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.native.change, e.target);\n            }\n        }\n\n        /**\n         * Handler for 'wheel' event\n         *\n         * @param {WheelEvent} e\n         */\n\n    }, {\n        key: '_onWheel',\n        value: function _onWheel(e) {\n            // If the user is using the 'Shift' key modifier, then we ignore the wheel event\n            // This special behavior is applied in order to avoid preventing the user to scroll the page if the inputs are covering the whole available space.\n            // If that's the case, then he can use the 'Shift' modifier key while using the mouse wheel in order to bypass the increment/decrement feature\n            // This is useful on small screen where some badly configured inputs could use all the available space.\n            if (!e.shiftKey && this.settings.modifyValueOnWheel) {\n                this.isWheelEvent = true; // Keep the info that we are currently managing a mouse wheel event\n\n                // 0) First, save the caret position so we can set it back once the value has been changed\n                var selectionStart = e.target.selectionStart || 0;\n                var selectionEnd = e.target.selectionEnd || 0;\n\n                // 1) Get the unformatted value\n                var currentUnformattedValue = this.rawValue;\n\n                var result = void 0;\n                if (_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(currentUnformattedValue)) {\n                    // If by default the input is empty, start at '0'\n                    if (this.settings.minimumValue > 0 || this.settings.maximumValue < 0) {\n                        // or if '0' is not between min and max value, 'minimumValue' if the user does a wheelup, 'maximumValue' if the user does a wheeldown\n                        if (_AutoNumericHelper2.default.isWheelUpEvent(e)) {\n                            result = this.settings.minimumValue;\n                        } else if (_AutoNumericHelper2.default.isWheelDownEvent(e)) {\n                            result = this.settings.maximumValue;\n                        } else {\n                            _AutoNumericHelper2.default.throwError('The event is not a \\'wheel\\' event.');\n                        }\n                    } else {\n                        result = 0;\n                    }\n                } else {\n                    result = currentUnformattedValue;\n                }\n\n                result = +result; // Typecast to a number needed for the following addition/subtraction\n\n                // 2) Increment/Decrement the value\n                // But first, choose the increment/decrement method ; fixed or progressive\n                if (_AutoNumericHelper2.default.isNumber(this.settings.wheelStep)) {\n                    var step = +this.settings.wheelStep; // Typecast to a number needed for the following addition/subtraction\n                    // Fixed method\n                    // This is the simplest method, where a fixed offset in added/subtracted from the current value\n                    if (_AutoNumericHelper2.default.isWheelUpEvent(e)) {\n                        // Increment\n                        result += step;\n                    } else if (_AutoNumericHelper2.default.isWheelDownEvent(e)) {\n                        // Decrement\n                        result -= step;\n                    }\n                } else {\n                    // Progressive method\n                    // For this method, we calculate an offset that is in relation to the size of the current number (using only the integer part size).\n                    // The bigger the number, the bigger the offset (usually the number count in the integer part minus 3, except for small numbers where a different behavior is better for the user experience).\n                    //TODO Known limitation : The progressive method does not play well with numbers between 0 and 1 where to modify the decimal places the rawValue first has to go from '1' to '0'\n                    if (_AutoNumericHelper2.default.isWheelUpEvent(e)) {\n                        // Increment\n                        result = _AutoNumericHelper2.default.addAndRoundToNearestAuto(result, this.settings.decimalPlacesRawValue);\n                    } else if (_AutoNumericHelper2.default.isWheelDownEvent(e)) {\n                        // Decrement\n                        result = _AutoNumericHelper2.default.subtractAndRoundToNearestAuto(result, this.settings.decimalPlacesRawValue);\n                    }\n                }\n\n                // 3) Set the new value so it gets formatted\n                // First clamp the result if needed\n                result = _AutoNumericHelper2.default.clampToRangeLimits(result, this.settings);\n                if (result !== +currentUnformattedValue) {\n                    // Only 'set' the value if it has changed. For instance 'set' should not happen if the user hits a limit and continue to try to go past it since we clamp the value.\n                    this.set(result);\n                }\n\n                //XXX Do not prevent if the value is not modified? From a UX point of view, preventing the wheel event when the user use it on top of an autoNumeric element should always be done, even if the value does not change. Perhaps that could affect other scripts relying on this event to be sent though.\n                e.preventDefault(); // We prevent the page to scroll while we increment/decrement the value\n\n                // 4) Finally, we set back the caret position/selection\n                // There is no need to take into account the fact that the number count could be different at the end of the wheel event ; it would be too complex and most of the time unreliable\n                this._setSelection(selectionStart, selectionEnd);\n\n                this.isWheelEvent = false; // Set back the mouse wheel indicator to its default\n            }\n        }\n\n        /**\n         * Handler for 'drop' event\n         *\n         * @param {DragEvent} e\n         */\n\n    }, {\n        key: '_onDrop',\n        value: function _onDrop(e) {\n            this.isDropEvent = true;\n            e.preventDefault();\n            var droppedText = e.dataTransfer.getData('text/plain');\n            var cleanedValue = this.unformatOther(droppedText);\n            this.set(cleanedValue);\n            this.isDropEvent = false;\n        }\n\n        /**\n         * Handler for 'submit' events happening on the parent <form> element.\n         * If `unformatOnSubmit` is set to `true`, the element value is first unformatted before the form is submitted.\n         *\n         * @returns {boolean}\n         */\n\n    }, {\n        key: '_onFormSubmit',\n        value: function _onFormSubmit() {\n            if (this.settings.unformatOnSubmit) {\n                this._setElementValue(this.rawValue);\n            }\n\n            return true;\n        }\n\n        /**\n         * Listen for the `alt` key keydown event globally, and if the event is caught, unformat the AutoNumeric element that is hovered by the mouse.\n         *\n         * @param {KeyboardEvent} e\n         * @private\n         */\n\n    }, {\n        key: '_onKeydownGlobal',\n        value: function _onKeydownGlobal(e) {\n            //TODO Find a way to keep the caret position between the alt keyup/keydown states\n            if (_AutoNumericHelper2.default.character(e) === _AutoNumericEnum2.default.keyName.Alt) {\n                var hoveredElement = _AutoNumericHelper2.default.getHoveredElement();\n                if (AutoNumeric.isManagedByAutoNumeric(hoveredElement)) {\n                    var anElement = AutoNumeric.getAutoNumericElement(hoveredElement);\n                    this.constructor._unformatAltHovered(anElement);\n                }\n            }\n        }\n\n        /**\n         * Listen for the `alt` key keyup event globally, and if the event is caught, reformat the AutoNumeric element that is hovered by the mouse.\n         *\n         * @param {KeyboardEvent} e\n         * @private\n         */\n\n    }, {\n        key: '_onKeyupGlobal',\n        value: function _onKeyupGlobal(e) {\n            if (_AutoNumericHelper2.default.character(e) === _AutoNumericEnum2.default.keyName.Alt) {\n                var hoveredElement = _AutoNumericHelper2.default.getHoveredElement();\n                if (AutoNumeric.isManagedByAutoNumeric(hoveredElement)) {\n                    var anElement = AutoNumeric.getAutoNumericElement(hoveredElement);\n                    this.constructor._reformatAltHovered(anElement);\n                }\n            }\n        }\n\n        /**\n         * Return `true` if the DOM element is supported by autoNumeric.\n         * A supported element is an element whitelisted in the `allowedTagList`.\n         *\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_isElementTagSupported',\n        value: function _isElementTagSupported() {\n            if (!_AutoNumericHelper2.default.isElement(this.domElement)) {\n                _AutoNumericHelper2.default.throwError('The DOM element is not valid, ' + this.domElement + ' given.');\n            }\n\n            return _AutoNumericHelper2.default.isInArray(this.domElement.tagName.toLowerCase(), this.allowedTagList);\n        }\n\n        /**\n         * Return `true` in the DOM element is an <input>.\n         *\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_isInputElement',\n        value: function _isInputElement() {\n            return this.domElement.tagName.toLowerCase() === 'input';\n        }\n\n        /**\n         * Return `true` if the input type is supported by AutoNumeric\n         *\n         * @returns {boolean}\n         * @throws\n         */\n\n    }, {\n        key: '_isInputTypeSupported',\n        value: function _isInputTypeSupported() {\n            return this.domElement.type === 'text' || this.domElement.type === 'hidden' || this.domElement.type === 'tel' || _AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(this.domElement.type);\n        }\n\n        /**\n         * Check if the DOM element is supported by autoNumeric.\n         * A supported element is either an <input> element with the right 'type' attribute, or a tag whitelisted in the `allowedTagList`.\n         * If the check fails, this method throws.\n         * This function also set the info `this.isInputElement` which keep tracks if the DOM element is an <input> or not, and the `this.isContentEditable` if the element has the `contenteditable` attribute set to `true`.\n         *\n         * @throws\n         * @private\n         */\n\n    }, {\n        key: '_checkElement',\n        value: function _checkElement() {\n            var currentElementTag = this.domElement.tagName.toLowerCase();\n\n            if (!this._isElementTagSupported()) {\n                _AutoNumericHelper2.default.throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n            }\n\n            if (this._isInputElement()) {\n                if (!this._isInputTypeSupported()) {\n                    _AutoNumericHelper2.default.throwError('The input type \"' + this.domElement.type + '\" is not supported by autoNumeric');\n                }\n\n                this.isInputElement = true;\n            } else {\n                this.isInputElement = false;\n                this.isContentEditable = this.domElement.hasAttribute('contenteditable') && this.domElement.getAttribute('contenteditable') === 'true';\n            }\n        }\n\n        /**\n         * Formats the default value on page load.\n         * This is called only if the `formatOnPageLoad` option is set to `true`.\n         *\n         * @param {number|string|null} forcedInitialValue The value that should be used for initialization, in place on the eventual html one\n         */\n\n    }, {\n        key: '_formatDefaultValueOnPageLoad',\n        value: function _formatDefaultValueOnPageLoad() {\n            var forcedInitialValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            var setValue = true;\n            var currentValue = void 0;\n            if (!_AutoNumericHelper2.default.isNull(forcedInitialValue)) {\n                currentValue = forcedInitialValue;\n            } else {\n                currentValue = _AutoNumericHelper2.default.getElementValue(this.domElement);\n            }\n\n            if (this.isInputElement || this.isContentEditable) {\n                /*\n                 * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\n                 * precedence and should get formatted during the initialization (if this input value is a valid number and that the\n                 * developer wants it formatted on init (cf. the `settings.formatOnPageLoad` option)).\n                 * Note; this is true whatever the developer has set for `data-default-value-override` in the html (asp.net users).\n                 *\n                 * In other words : if `defaultValueOverride` is not null, it means the developer is trying to prevent postback problems.\n                 * But if `input.value` is set to a number, and the html `value` attribute is not set, then it means the dev has\n                 * changed the input value, and then it means we should not overwrite his own decision to do so.\n                 * Hence, if `defaultValueOverride` is not null, but `input.value` is a number and `this.domElement.hasAttribute('value')`\n                 * is false, we should ignore `defaultValueOverride` altogether.\n                 */\n                var unLocalizedCurrentValue = this.constructor._toNumericValue(currentValue, this.settings); // This allows to use a localized value on startup\n                if (!this.domElement.hasAttribute('value') || this.domElement.getAttribute('value') === '') {\n                    // Check if the `value` is valid or not\n                    if (!isNaN(Number(unLocalizedCurrentValue)) && Infinity !== unLocalizedCurrentValue) {\n                        this.set(unLocalizedCurrentValue);\n                        setValue = false;\n                    } else {\n                        // If not, inform the developer that nothing usable has been provided\n                        _AutoNumericHelper2.default.throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.');\n                    }\n                } else {\n                    /* Checks for :\n                     * - page reload from back button, and\n                     * - ASP.net form post back\n                     *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\n                     *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\n                     */\n                    if (this.settings.defaultValueOverride !== null && this.settings.defaultValueOverride.toString() !== currentValue || this.settings.defaultValueOverride === null && currentValue !== '' && currentValue !== this.domElement.getAttribute('value') || currentValue !== '' && this.domElement.getAttribute('type') === 'hidden' && !_AutoNumericHelper2.default.isNumber(unLocalizedCurrentValue)) {\n                        if (this.settings.saveValueToSessionStorage && (this.settings.decimalPlacesShownOnFocus !== null || this.settings.divisorWhenUnfocused)) {\n                            this._setRawValue(this._getValueFromPersistentStorage());\n                        }\n\n                        // If the decimalPlacesShownOnFocus value should NOT be saved in sessionStorage\n                        if (!this.settings.saveValueToSessionStorage) {\n                            var toStrip = void 0;\n\n                            if (this.settings.negativeBracketsTypeOnBlur !== null && this.settings.negativeSignCharacter !== '') {\n                                toStrip = this.constructor._removeBrackets(currentValue, this.settings);\n                            } else {\n                                toStrip = currentValue;\n                            }\n\n                            if ((this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.suffix || this.settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.prefix && this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) && this.settings.negativeSignCharacter !== '' && _AutoNumericHelper2.default.isNegative(currentValue)) {\n                                this._setRawValue(this.settings.negativeSignCharacter + this.constructor._stripAllNonNumberCharacters(toStrip, this.settings, true, this.isFocused));\n                            } else {\n                                this._setRawValue(this.constructor._stripAllNonNumberCharacters(toStrip, this.settings, true, this.isFocused));\n                            }\n                        }\n\n                        setValue = false;\n                    }\n                }\n\n                if (currentValue === '') {\n                    switch (this.settings.emptyInputBehavior) {\n                        case AutoNumeric.options.emptyInputBehavior.focus:\n                            setValue = false;\n                            break;\n                        //TODO What about the `AutoNumeric.options.emptyInputBehavior.press` value?\n                        case AutoNumeric.options.emptyInputBehavior.always:\n                            this._setElementValue(this.settings.currencySymbol);\n                            setValue = false;\n                            break;\n                        case AutoNumeric.options.emptyInputBehavior.zero:\n                            this.set('0');\n                            setValue = false;\n                            break;\n                        default:\n                        //\n                    }\n                } else if (setValue && currentValue === this.domElement.getAttribute('value')) {\n                    this.set(currentValue);\n                }\n            } else {\n                if (this.settings.defaultValueOverride === null) {\n                    this.set(currentValue);\n                } else {\n                    if (this.settings.defaultValueOverride === currentValue) {\n                        this.set(currentValue);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Enhance the user experience by modifying the default `negativePositiveSignPlacement` option depending on `currencySymbol` and `currencySymbolPlacement`.\n         *\n         * If the user has not set the placement of the negative sign (`negativePositiveSignPlacement`), but has set a currency symbol (`currencySymbol`),\n         * then we modify the default value of `negativePositiveSignPlacement` in order to keep the resulting output logical by default :\n         * - \"$-1,234.56\" instead of \"-$1,234.56\" ({currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"})\n         * - \"-1,234.56$\" instead of \"1,234.56-$\" ({currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"})\n         *\n         * @param {object} settings\n         */\n\n    }, {\n        key: '_calculateVMinAndVMaxIntegerSizes',\n\n\n        /**\n         * Analyze and save the minimumValue and maximumValue integer size for later uses\n         * @private\n         */\n        value: function _calculateVMinAndVMaxIntegerSizes() {\n            var _settings$maximumValu = this.settings.maximumValue.toString().split('.'),\n                _settings$maximumValu2 = _slicedToArray(_settings$maximumValu, 1),\n                maximumValueIntegerPart = _settings$maximumValu2[0];\n\n            var _ref = !this.settings.minimumValue && this.settings.minimumValue !== 0 ? [] : this.settings.minimumValue.toString().split('.'),\n                _ref2 = _slicedToArray(_ref, 1),\n                minimumValueIntegerPart = _ref2[0];\n\n            maximumValueIntegerPart = maximumValueIntegerPart.replace('-', '');\n            minimumValueIntegerPart = minimumValueIntegerPart.replace('-', '');\n\n            this.settings.mIntPos = Math.max(maximumValueIntegerPart.length, 1);\n            this.settings.mIntNeg = Math.max(minimumValueIntegerPart.length, 1);\n        }\n\n        /**\n         * Calculate once what are the `valuesToStrings` option keys.\n         * @private\n         */\n\n    }, {\n        key: '_calculateValuesToStringsKeys',\n        value: function _calculateValuesToStringsKeys() {\n            if (this.settings.valuesToStrings) {\n                this.valuesToStringsKeys = Object.keys(this.settings.valuesToStrings);\n            } else {\n                this.valuesToStringsKeys = [];\n            }\n        }\n\n        /**\n         * Sets the alternative decimal separator key.\n         * @private\n         */\n\n    }, {\n        key: '_setAlternativeDecimalSeparatorCharacter',\n        value: function _setAlternativeDecimalSeparatorCharacter() {\n            if (_AutoNumericHelper2.default.isNull(this.settings.decimalCharacterAlternative) && Number(this.settings.decimalPlaces) > 0) {\n                if (this.settings.decimalCharacter === '.' && this.settings.digitGroupSeparator !== ',') {\n                    this.settings.decimalCharacterAlternative = ',';\n                } else if (this.settings.decimalCharacter === ',' && this.settings.digitGroupSeparator !== '.') {\n                    this.settings.decimalCharacterAlternative = '.';\n                }\n            }\n        }\n\n        /**\n         * Caches regular expressions for _stripAllNonNumberCharacters\n         *\n         * @param {object} settings\n         * @param {object} regex\n         */\n\n    }, {\n        key: '_transformOptionsValuesToDefaultTypes',\n\n\n        /**\n         * Modify the user settings to make them 'exploitable' later.\n         */\n        value: function _transformOptionsValuesToDefaultTypes() {\n            for (var key in this.settings) {\n                if (this.settings.hasOwnProperty(key)) {\n                    var value = this.settings[key];\n\n                    // Convert the strings 'true' and 'false' to booleans\n                    if (value === 'true' || value === 'false') {\n                        this.settings[key] = value === 'true';\n                    }\n\n                    // Convert numbers in options to strings\n                    //TODO Only transform the values of type 'Number' to 'String' if it's a currency number (so that we can have big numbers). Do not convert other numbers (ie. `historySize`)\n                    if (typeof value === 'number') {\n                        this.settings[key] = value.toString();\n                    }\n                }\n            }\n        }\n\n        /**\n         * Convert the old settings options name to new ones.\n         *\n         * @param {object} options\n         */\n\n    }, {\n        key: '_setSettings',\n\n\n        /**\n         * Analyse the settings/options passed by the user, validate and clean them, then set them into `this.settings`.\n         * Note: This sets the settings to `null` if somehow the settings objet is undefined or empty\n         *       If only `decimalPlaces` is defined in the option, overwrite the other decimalPlaces* options, otherwise, use those options\n         *\n         * @param {object} options\n         * @param {boolean} update - If set to `true`, then the settings already exists and this function only updates them instead of recreating them from scratch\n         * @throws\n         */\n        value: function _setSettings(options) {\n            var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n            // If the user used old options, we convert them to new ones\n            if (update || !_AutoNumericHelper2.default.isNull(options)) {\n                this.constructor._convertOldOptionsToNewOnes(options);\n            }\n\n            if (update) {\n                // The settings are updated\n                // Update the original data, if it has changed\n                var decimalPlacesRawValueInOptions = 'decimalPlacesRawValue' in options;\n                if (decimalPlacesRawValueInOptions) {\n                    this.settings.originalDecimalPlacesRawValue = options.decimalPlacesRawValue;\n                }\n\n                var decimalPlacesInOptions = 'decimalPlaces' in options;\n                if (decimalPlacesInOptions) {\n                    this.settings.originalDecimalPlaces = options.decimalPlaces;\n                }\n\n                // Then update all the `decimalPlaces*` options\n                this.constructor._calculateDecimalPlacesOnUpdate(options, this.settings);\n\n                // Finally generate the updated settings object to use\n                this._mergeSettings(options); //TODO Check that the `styleRules` option is correctly cloned (due to depth cloning limitation)\n            } else {\n                // The settings are generated for the first time\n                this.settings = {};\n                // If we couldn't grab any settings, create them from the default ones and combine them with the options passed as a parameter as well as with the HTML5 `data-*` info (via `this.domElement.dataset`), if any.\n                this._mergeSettings(this.constructor.getDefaultConfig(), this.domElement.dataset, options, { rawValue: this.defaultRawValue });\n                this.caretFix = false;\n                this.throwInput = true; // Throw input event\n                this.allowedTagList = _AutoNumericEnum2.default.allowedTagList;\n                this.runOnce = false;\n                this.hoveredWithAlt = false; // Keep tracks if the current AutoNumeric element is hovered by the mouse cursor while `Alt` is pressed\n                this.androidSelectionStart = null; // If `null`, then we are not on an Android device (the keyCode is not always equal to 229)\n            }\n\n            // Modify the user settings to make them 'exploitable'\n            this._transformOptionsValuesToDefaultTypes();\n\n            // Immediately run the callbacks that could update the settings object\n            this._runCallbacksFoundInTheSettingsObject();\n\n            // Improve the `negativePositiveSignPlacement` option if needed\n            this.constructor._correctNegativePositiveSignPlacementOption(this.settings);\n\n            // Set the `caretPositionOnFocus` and `selectOnFocus` options so that they do not conflict, if one of those have been set manually by the user.\n            // If order to check that, we take a look at the original options the user passed as an argument, not `this.settings` that have been merged with the default settings. //TODO Check the validity of that comment\n            this.constructor._correctCaretPositionOnFocusAndSelectOnFocusOptions(this.settings);\n\n            // Set the negative and positive signs, as needed\n            this.settings.negativeSignCharacter = this.settings.minimumValue < 0 ? '-' : '';\n            this.settings.positiveSignCharacter = this.settings.maximumValue >= 0 ? '+' : '';\n\n            // Calculate the number of decimal places (during the element initialization)\n            if (!update) {\n                // Make sure the `originalDecimalPlaces` info is set\n                if (_AutoNumericHelper2.default.isNull(options) || !options.decimalPlaces) {\n                    this.settings.originalDecimalPlaces = null;\n                } else {\n                    this.settings.originalDecimalPlaces = options.decimalPlaces;\n                }\n\n                // Save the `originalDecimalPlacesRawValue` info\n                this.settings.originalDecimalPlacesRawValue = this.settings.decimalPlacesRawValue;\n\n                // Then update all the `decimalPlaces*` options\n                this.constructor._calculateDecimalPlacesOnInit(this.settings);\n            }\n\n            // Additional changes to the settings object\n            this._calculateVMinAndVMaxIntegerSizes();\n            this._setAlternativeDecimalSeparatorCharacter();\n            this._setTrailingNegativeSignInfo();\n            this.regex = {}; // Create the object that will store the regular expressions\n            this.constructor._cachesUsualRegularExpressions(this.settings, this.regex);\n            this._setBrackets();\n            this._calculateValuesToStringsKeys();\n\n            // Validate the settings. Both tests throws if necessary.\n            if (_AutoNumericHelper2.default.isEmptyObj(this.settings)) {\n                _AutoNumericHelper2.default.throwError('Unable to set the settings, those are invalid ; an empty object was given.');\n            }\n\n            this.constructor.validate(this.settings, false, options);\n\n            // Original settings saved for use when decimalPlacesShownOnFocus, divisorWhenUnfocused & showOnlyNumbersOnFocus options are being used\n            this._keepAnOriginalSettingsCopy();\n        }\n\n        /**\n         * Convert the `value` parameter that can either be :\n         * - a real number,\n         * - a string representing a real number, or\n         * - a string representing a localized number (with specific group separators and decimal character),\n         * ...to a string representing a real 'javascript' number (ie. '1234' or '1234.567').\n         *\n         * This function returns `NaN` if such conversion fails.\n         *\n         * @param {int|float|string} value\n         * @param {object} settings\n         * @returns {string|NaN}\n         */\n\n    }, {\n        key: '_preparePastedText',\n\n\n        /**\n         * Return the pasted text that will be used.\n         *\n         * @param {string} text\n         * @returns {string|void|XML|*}\n         */\n        value: function _preparePastedText(text) {\n            return this.constructor._stripAllNonNumberCharacters(text, this.settings, true, this.isFocused).replace(this.settings.decimalCharacter, '.');\n        }\n\n        /**\n         * Return TRUE if the given value (a number as a string) is within the range set in the settings `minimumValue` and `maximumValue`, FALSE otherwise.\n         *\n         * @param {string} value\n         * @param {object} parsedMinValue Parsed via the `parseStr()` function\n         * @param {object} parsedMaxValue Parsed via the `parseStr()` function\n         * @returns {boolean}\n         */\n\n    }, {\n        key: '_updateInternalProperties',\n\n\n        /**\n         * Update the selection values as well as resets the internal state of the current AutoNumeric object.\n         * This keeps tracks of the current selection and resets the 'processed' and 'formatted' state.\n         *\n         * Note : Those two can change between the keydown, keypress and keyup events, that's why\n         *        this function is called on each event handler.\n         *\n         * @private\n         */\n        value: function _updateInternalProperties() {\n            this.selection = _AutoNumericHelper2.default.getElementSelection(this.domElement);\n            this.processed = false;\n            this.formatted = false;\n        }\n\n        /**\n         * Update the `event.key` attribute that triggered the given event.\n         *\n         * `event.key` describes:\n         * - the key name (if a non-printable character),\n         * - or directly the character that result from the key press used to trigger the event.\n         *\n         * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n         * The key list is described here:\n         * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n         *\n         * @param {Event|KeyboardEvent} e\n         * @private\n         */\n\n    }, {\n        key: '_updateEventKeyInfo',\n        value: function _updateEventKeyInfo(e) {\n            this.eventKey = _AutoNumericHelper2.default.character(e);\n        }\n\n        /**\n         * Save the unformatted element value.\n         * This is used in the 'cancellable' feature where the element value is saved on focus and input validation, to be used if the user wants to cancel his modifications by hitting the 'Escape' key.\n         *\n         * @private\n         */\n\n    }, {\n        key: '_saveCancellableValue',\n        value: function _saveCancellableValue() {\n            this.savedCancellableValue = this.rawValue;\n        }\n\n        /**\n         * Set the text selection inside the input with the given start and end position.\n         *\n         * @param {int} start\n         * @param {int} end\n         * @private\n         */\n\n    }, {\n        key: '_setSelection',\n        value: function _setSelection(start, end) {\n            //TODO use this function to replace the direct calls to `setElementSelection()`, wherever possible\n            start = Math.max(start, 0);\n            end = Math.min(end, _AutoNumericHelper2.default.getElementValue(this.domElement).length);\n            this.selection = {\n                start: start,\n                end: end,\n                length: end - start\n            };\n\n            _AutoNumericHelper2.default.setElementSelection(this.domElement, start, end);\n        }\n\n        /**\n         * Set the caret position inside the input at the given position.\n         *\n         * @param {int} position\n         * @private\n         */\n\n    }, {\n        key: '_setCaretPosition',\n        value: function _setCaretPosition(position) {\n            this._setSelection(position, position);\n        }\n\n        /**\n         * Return an array containing the string parts located on the left and right side of the caret or selection.\n         * Those parts are left 'untouched', ie. formatted by autoNumeric.\n         *\n         * @returns {[string, string]} The parts on the left and right of the caret or selection\n         * @private\n         */\n\n    }, {\n        key: '_getLeftAndRightPartAroundTheSelection',\n        value: function _getLeftAndRightPartAroundTheSelection() {\n            var value = _AutoNumericHelper2.default.getElementValue(this.domElement);\n            var left = value.substring(0, this.selection.start);\n            var right = value.substring(this.selection.end, value.length);\n\n            return [left, right];\n        }\n\n        /**\n         * Return an array containing the string parts located on the left and right side of the caret or selection.\n         * Those parts are unformatted (stripped) of any non-numbers characters.\n         *\n         * @returns {[string, string]} The parts on the left and right of the caret or selection, unformatted.\n         * @private\n         */\n\n    }, {\n        key: '_getUnformattedLeftAndRightPartAroundTheSelection',\n        value: function _getUnformattedLeftAndRightPartAroundTheSelection() {\n            var _getLeftAndRightPartA = this._getLeftAndRightPartAroundTheSelection(),\n                _getLeftAndRightPartA2 = _slicedToArray(_getLeftAndRightPartA, 2),\n                left = _getLeftAndRightPartA2[0],\n                right = _getLeftAndRightPartA2[1];\n\n            if (left === '' && right === '') {\n                return ['', ''];\n            }\n\n            // If changing the sign and `left` is equal to the number zero, prevent stripping the leading zero(s)\n            var stripZeros = true;\n            if (this.eventKey === _AutoNumericEnum2.default.keyName.Hyphen && Number(left) === 0) {\n                stripZeros = false;\n            }\n\n            if (this.isTrailingNegative && _AutoNumericHelper2.default.isNegative(right) && !_AutoNumericHelper2.default.isNegative(left)) {\n                // Only set the negative sign if the value is negative\n                left = '-' + left;\n                right = right.replace(this.settings.negativeSignCharacter, '');\n            }\n\n            left = AutoNumeric._stripAllNonNumberCharacters(left, this.settings, stripZeros, this.isFocused);\n            right = AutoNumeric._stripAllNonNumberCharacters(right, this.settings, false, this.isFocused);\n\n            return [left, right];\n        }\n\n        /**\n         * Strip parts from excess characters and leading zeros.\n         *\n         * @param {string} left\n         * @param {string} right\n         * @returns {[*,*,*]}\n         * @private\n         */\n\n    }, {\n        key: '_normalizeParts',\n        value: function _normalizeParts(left, right) {\n            //TODO Refactor with `_getUnformattedLeftAndRightPartAroundTheSelection` which share a lot of similar code\n            // If changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n            var stripZeros = true;\n            if (this.eventKey === _AutoNumericEnum2.default.keyName.Hyphen && Number(left) === 0) {\n                stripZeros = false;\n            }\n\n            if (this.isTrailingNegative && _AutoNumericHelper2.default.isNegative(right) && !_AutoNumericHelper2.default.isNegative(left)) {\n                // Only set the negative sign if the value is negative\n                left = '-' + left;\n                right = right.replace(this.settings.negativeSignCharacter, '');\n            }\n\n            left = AutoNumeric._stripAllNonNumberCharacters(left, this.settings, stripZeros, this.isFocused);\n            right = AutoNumeric._stripAllNonNumberCharacters(right, this.settings, false, this.isFocused);\n\n            // Prevents multiple leading zeros from being entered\n            if (this.settings.leadingZero === AutoNumeric.options.leadingZero.deny && (this.eventKey === _AutoNumericEnum2.default.keyName.num0 || this.eventKey === _AutoNumericEnum2.default.keyName.numpad0) && Number(left) === 0 &&\n            // If `right` is not empty and the first character is not `decimalCharacter`\n            !_AutoNumericHelper2.default.contains(left, this.settings.decimalCharacter) && right !== '') {\n                left = left.substring(0, left.length - 1);\n            }\n\n            // Insert zero there is a leading dot\n            var newValue = left + right;\n            if (this.settings.decimalCharacter) {\n                var m = newValue.match(new RegExp('^' + this.regex.aNegRegAutoStrip + '\\\\' + this.settings.decimalCharacter));\n                if (m) {\n                    left = left.replace(m[1], m[1] + '0');\n                    newValue = left + right;\n                }\n            }\n\n            return [left, right, newValue];\n        }\n\n        /**\n         * Set the formatted element value as well as the `rawValue`.\n         * This returns `true` if the element and raw value have been modified, `false` otherwise.\n         * This method also adjust the caret position according to the `leadingZero` option and the normalized value. //TODO What about the cursor *selection*?\n         *\n         * @param {string} left\n         * @param {string} right\n         * @param {boolean} isPaste\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_setValueParts',\n        value: function _setValueParts(left, right) {\n            var isPaste = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n            var _normalizeParts2 = this._normalizeParts(left, right),\n                _normalizeParts3 = _slicedToArray(_normalizeParts2, 3),\n                normalizedLeft = _normalizeParts3[0],\n                normalizedRight = _normalizeParts3[1],\n                normalizedNewValue = _normalizeParts3[2];\n\n            var _AutoNumeric$_checkIf = AutoNumeric._checkIfInRangeWithOverrideOption(normalizedNewValue, this.settings),\n                _AutoNumeric$_checkIf2 = _slicedToArray(_AutoNumeric$_checkIf, 2),\n                minTest = _AutoNumeric$_checkIf2[0],\n                maxTest = _AutoNumeric$_checkIf2[1];\n\n            if (minTest && maxTest) {\n                // First, set the raw value\n                var roundedRawValue = AutoNumeric._truncateDecimalPlaces(normalizedNewValue, this.settings, isPaste, this.settings.decimalPlacesRawValue);\n                var testValue = roundedRawValue.replace(this.settings.decimalCharacter, '.');\n\n                if (testValue === '' || testValue === this.settings.negativeSignCharacter) {\n                    var valueToSetOnEmpty = void 0;\n                    switch (this.settings.emptyInputBehavior) {\n                        case AutoNumeric.options.emptyInputBehavior.zero:\n                            valueToSetOnEmpty = '0';\n                            break;\n                        case AutoNumeric.options.emptyInputBehavior.null:\n                            valueToSetOnEmpty = null;\n                            break;\n                        default:\n                            valueToSetOnEmpty = '';\n                    }\n\n                    this._setRawValue(valueToSetOnEmpty);\n                } else {\n                    this._setRawValue(this._trimLeadingAndTrailingZeros(testValue));\n                }\n\n                // Then set the formatted value\n                var roundedValueToShow = AutoNumeric._truncateDecimalPlaces(normalizedNewValue, this.settings, isPaste, this.settings.decimalPlacesShownOnFocus);\n                var position = normalizedLeft.length;\n                if (position > roundedValueToShow.length) {\n                    position = roundedValueToShow.length;\n                }\n\n                // Make sure when the user enter a '0' on the far left with a leading zero option set to 'deny', that the caret does not moves since the input is dropped (fix issue #283)\n                if (position === 1 && normalizedLeft === '0' && this.settings.leadingZero === AutoNumeric.options.leadingZero.deny) {\n                    // If the user enter `0`, then the caret is put on the right side of it (Fix issue #299)\n                    if (normalizedRight === '' || normalizedLeft === '0' && normalizedRight !== '') {\n                        position = 1;\n                    } else {\n                        position = 0;\n                    }\n                }\n\n                _AutoNumericHelper2.default.setElementValue(this.domElement, roundedValueToShow);\n                this._setCaretPosition(position);\n\n                return true;\n            }\n\n            if (!minTest) {\n                _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.minRangeExceeded, this.domElement);\n            } else if (!maxTest) {\n                _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.maxRangeExceeded, this.domElement);\n            }\n\n            return false;\n        }\n\n        /**\n         * Helper function for `_expandSelectionOnSign()`.\n         *\n         * @returns {Array} Array containing [signPosition, currencySymbolPosition] of a formatted value\n         * @private\n         */\n\n    }, {\n        key: '_getSignPosition',\n        value: function _getSignPosition() {\n            var result = void 0;\n            if (this.settings.currencySymbol) {\n                var currencySymbolLen = this.settings.currencySymbol.length;\n                var value = _AutoNumericHelper2.default.getElementValue(this.domElement);\n                if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix) {\n                    var hasNeg = this.settings.negativeSignCharacter && value && value.charAt(0) === this.settings.negativeSignCharacter;\n                    if (hasNeg) {\n                        result = [1, currencySymbolLen + 1];\n                    } else {\n                        result = [0, currencySymbolLen];\n                    }\n                } else {\n                    var valueLen = value.length;\n                    result = [valueLen - currencySymbolLen, valueLen];\n                }\n            } else {\n                result = [1000, -1];\n            }\n\n            return result;\n        }\n\n        /**\n         * Expands selection to cover whole sign\n         * Prevents partial deletion/copying/overwriting of a sign\n         * @private\n         */\n\n    }, {\n        key: '_expandSelectionOnSign',\n        value: function _expandSelectionOnSign() {\n            var _getSignPosition2 = this._getSignPosition(),\n                _getSignPosition3 = _slicedToArray(_getSignPosition2, 2),\n                signPosition = _getSignPosition3[0],\n                currencySymbolPosition = _getSignPosition3[1];\n\n            var selection = this.selection;\n\n            // If selection catches something except sign and catches only space from sign\n            if (selection.start < currencySymbolPosition && selection.end > signPosition) {\n                // Then select without empty space\n                if ((selection.start < signPosition || selection.end > currencySymbolPosition) && _AutoNumericHelper2.default.getElementValue(this.domElement).substring(Math.max(selection.start, signPosition), Math.min(selection.end, currencySymbolPosition)).match(/^\\s*$/)) {\n                    if (selection.start < signPosition) {\n                        this._setSelection(selection.start, signPosition);\n                    } else {\n                        this._setSelection(currencySymbolPosition, selection.end);\n                    }\n                } else {\n                    // Else select with whole sign\n                    this._setSelection(Math.min(selection.start, signPosition), Math.max(selection.end, currencySymbolPosition));\n                }\n            }\n        }\n\n        /**\n         * Try to strip pasted value to digits\n         */\n\n    }, {\n        key: '_checkPaste',\n        value: function _checkPaste() {\n            if (!_AutoNumericHelper2.default.isUndefined(this.valuePartsBeforePaste)) {\n                var oldParts = this.valuePartsBeforePaste;\n\n                var _getLeftAndRightPartA3 = this._getLeftAndRightPartAroundTheSelection(),\n                    _getLeftAndRightPartA4 = _slicedToArray(_getLeftAndRightPartA3, 2),\n                    left = _getLeftAndRightPartA4[0],\n                    right = _getLeftAndRightPartA4[1];\n\n                // Try to strip the pasted value first\n\n\n                delete this.valuePartsBeforePaste;\n\n                var modifiedLeftPart = left.substr(0, oldParts[0].length) + AutoNumeric._stripAllNonNumberCharacters(left.substr(oldParts[0].length), this.settings, true, this.isFocused);\n                if (!this._setValueParts(modifiedLeftPart, right, true)) {\n                    _AutoNumericHelper2.default.setElementValue(this.domElement, oldParts.join(''));\n                    this._setCaretPosition(oldParts[0].length);\n                }\n            }\n        }\n\n        /**\n         * Return `true` if the given key should be ignored or not.\n         *\n         * @param {string} eventKeyName\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_processNonPrintableKeysAndShortcuts',\n\n\n        /**\n         * Process copying, cutting and pasting, as well as undo/redoing and cursor moving.\n         * Return `true` if further processing should not be performed.\n         *\n         * @param {KeyboardEvent} e\n         * @returns {boolean}\n         * @private\n         */\n        value: function _processNonPrintableKeysAndShortcuts(e) {\n            // Catch the ctrl up on ctrl-v\n            if ((e.ctrlKey || e.metaKey) && e.type === 'keyup' && !_AutoNumericHelper2.default.isUndefined(this.valuePartsBeforePaste) || e.shiftKey && this.eventKey === _AutoNumericEnum2.default.keyName.Insert) {\n                //TODO Move this test inside the `onKeyup` handler\n                this._checkPaste();\n\n                return false;\n            }\n\n            // Skip all function keys (F1-F12), Windows keys, tab and other special keys\n            if (this.constructor._shouldSkipEventKey(this.eventKey)) {\n                return true;\n            }\n\n            // If a \"Select all\" keyboard shortcut is detected (ctrl + a)\n            if ((e.ctrlKey || e.metaKey) && this.eventKey === _AutoNumericEnum2.default.keyName.a) {\n                if (this.settings.selectNumberOnly) {\n                    // `preventDefault()` is used here to prevent the browser to first select all the input text (including the currency sign), otherwise we would see that whole selection first in a flash, then the selection with only the number part without the currency sign.\n                    e.preventDefault();\n                    //TODO replace `selectNumber` by `select`?\n                    this.selectNumber();\n                }\n\n                return true;\n            }\n\n            // If a \"Copy\", \"Paste\" or \"Cut\" keyboard shortcut is detected (respectively 'ctrl + c', 'ctrl + v' or 'ctrl + x')\n            if ((e.ctrlKey || e.metaKey) && (this.eventKey === _AutoNumericEnum2.default.keyName.c || this.eventKey === _AutoNumericEnum2.default.keyName.v || this.eventKey === _AutoNumericEnum2.default.keyName.x)) {\n                if (e.type === 'keydown') {\n                    this._expandSelectionOnSign();\n                }\n\n                // Try to prevent wrong paste\n                if (this.eventKey === _AutoNumericEnum2.default.keyName.v || this.eventKey === _AutoNumericEnum2.default.keyName.Insert) {\n                    if (e.type === 'keydown' || e.type === 'keypress') {\n                        if (_AutoNumericHelper2.default.isUndefined(this.valuePartsBeforePaste)) {\n                            this.valuePartsBeforePaste = this._getLeftAndRightPartAroundTheSelection();\n                        }\n                    } else {\n                        this._checkPaste();\n                    }\n                }\n\n                return e.type === 'keydown' || e.type === 'keypress' || this.eventKey === _AutoNumericEnum2.default.keyName.c;\n            }\n\n            if (e.ctrlKey || e.metaKey) {\n                if (this.eventKey === _AutoNumericEnum2.default.keyName.Z || this.eventKey === _AutoNumericEnum2.default.keyName.z) {\n                    return false;\n                } else {\n                    return true;\n                }\n            }\n\n            // Jump over the thousand separator\n            //TODO Move this test inside the `onKeydown` handler\n            if (this.eventKey === _AutoNumericEnum2.default.keyName.LeftArrow || this.eventKey === _AutoNumericEnum2.default.keyName.RightArrow) {\n                if (e.type === 'keydown' && !e.shiftKey) {\n                    var value = _AutoNumericHelper2.default.getElementValue(this.domElement);\n                    if (this.eventKey === _AutoNumericEnum2.default.keyName.LeftArrow && (value.charAt(this.selection.start - 2) === this.settings.digitGroupSeparator || value.charAt(this.selection.start - 2) === this.settings.decimalCharacter)) {\n                        this._setCaretPosition(this.selection.start - 1);\n                    } else if (this.eventKey === _AutoNumericEnum2.default.keyName.RightArrow && (value.charAt(this.selection.start + 1) === this.settings.digitGroupSeparator || value.charAt(this.selection.start + 1) === this.settings.decimalCharacter)) {\n                        this._setCaretPosition(this.selection.start + 1);\n                    }\n                }\n\n                return true;\n            }\n\n            return _AutoNumericHelper2.default.isInArray(this.eventKey, _AutoNumericEnum2.default.keyName._directionKeys);\n        }\n\n        /**\n         * Process deletion of characters when the minus sign is to the right of the numeric characters.\n         *\n         * @param {string} left The part on the left of the caret or selection\n         * @param {string} right The part on the right of the caret or selection\n         * @returns {[string, string]}\n         * @private\n         */\n\n    }, {\n        key: '_processCharacterDeletionIfTrailingNegativeSign',\n        value: function _processCharacterDeletionIfTrailingNegativeSign(_ref3) {\n            var _ref4 = _slicedToArray(_ref3, 2),\n                left = _ref4[0],\n                right = _ref4[1];\n\n            var value = _AutoNumericHelper2.default.getElementValue(this.domElement);\n\n            if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix && this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.suffix) {\n                if (this.eventKey === _AutoNumericEnum2.default.keyName.Backspace) {\n                    this.caretFix = this.selection.start >= value.indexOf(this.settings.suffixText) && this.settings.suffixText !== '';\n                    if (value.charAt(this.selection.start - 1) === '-') {\n                        left = left.substring(1);\n                    } else if (this.selection.start <= value.length - this.settings.suffixText.length) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    this.caretFix = this.selection.start >= value.indexOf(this.settings.suffixText) && this.settings.suffixText !== '';\n                    if (this.selection.start >= value.indexOf(this.settings.currencySymbol) + this.settings.currencySymbol.length) {\n                        right = right.substring(1, right.length);\n                    }\n                    if (_AutoNumericHelper2.default.isNegative(left) && value.charAt(this.selection.start) === '-') {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) {\n                switch (this.settings.negativePositiveSignPlacement) {\n                    case AutoNumeric.options.negativePositiveSignPlacement.left:\n                        this.caretFix = this.selection.start >= value.indexOf(this.settings.negativeSignCharacter) + this.settings.negativeSignCharacter.length;\n                        if (this.eventKey === _AutoNumericEnum2.default.keyName.Backspace) {\n                            if (this.selection.start === value.indexOf(this.settings.negativeSignCharacter) + this.settings.negativeSignCharacter.length && _AutoNumericHelper2.default.contains(value, this.settings.negativeSignCharacter)) {\n                                left = left.substring(1);\n                            } else if (left !== '-' && (this.selection.start <= value.indexOf(this.settings.negativeSignCharacter) || !_AutoNumericHelper2.default.contains(value, this.settings.negativeSignCharacter))) {\n                                left = left.substring(0, left.length - 1);\n                            }\n                        } else {\n                            if (left[0] === '-') {\n                                right = right.substring(1);\n                            }\n                            if (this.selection.start === value.indexOf(this.settings.negativeSignCharacter) && _AutoNumericHelper2.default.contains(value, this.settings.negativeSignCharacter)) {\n                                left = left.substring(1);\n                            }\n                        }\n                        break;\n                    case AutoNumeric.options.negativePositiveSignPlacement.right:\n                        this.caretFix = this.selection.start >= value.indexOf(this.settings.negativeSignCharacter) + this.settings.negativeSignCharacter.length;\n                        if (this.eventKey === _AutoNumericEnum2.default.keyName.Backspace) {\n                            if (this.selection.start === value.indexOf(this.settings.negativeSignCharacter) + this.settings.negativeSignCharacter.length) {\n                                left = left.substring(1);\n                            } else if (left !== '-' && this.selection.start <= value.indexOf(this.settings.negativeSignCharacter) - this.settings.currencySymbol.length) {\n                                left = left.substring(0, left.length - 1);\n                            } else if (left !== '' && !_AutoNumericHelper2.default.contains(value, this.settings.negativeSignCharacter)) {\n                                left = left.substring(0, left.length - 1);\n                            }\n                        } else {\n                            this.caretFix = this.selection.start >= value.indexOf(this.settings.currencySymbol) && this.settings.currencySymbol !== '';\n                            if (this.selection.start === value.indexOf(this.settings.negativeSignCharacter)) {\n                                left = left.substring(1);\n                            }\n\n                            right = right.substring(1);\n                        }\n                        break;\n                }\n            }\n\n            return [left, right];\n        }\n\n        /**\n         * Process the deletion of characters.\n         */\n\n    }, {\n        key: '_processCharacterDeletion',\n        value: function _processCharacterDeletion() {\n            var left = void 0;\n            var right = void 0;\n\n            if (!this.selection.length) {\n                var _getUnformattedLeftAn = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\n                var _getUnformattedLeftAn2 = _slicedToArray(_getUnformattedLeftAn, 2);\n\n                left = _getUnformattedLeftAn2[0];\n                right = _getUnformattedLeftAn2[1];\n\n                if (left === '' && right === '') {\n                    this.throwInput = false;\n                }\n\n                if (this.isTrailingNegative && _AutoNumericHelper2.default.isNegative(_AutoNumericHelper2.default.getElementValue(this.domElement))) {\n                    var _processCharacterDele = this._processCharacterDeletionIfTrailingNegativeSign([left, right]);\n\n                    var _processCharacterDele2 = _slicedToArray(_processCharacterDele, 2);\n\n                    left = _processCharacterDele2[0];\n                    right = _processCharacterDele2[1];\n                } else {\n                    if (this.eventKey === _AutoNumericEnum2.default.keyName.Backspace) {\n                        left = left.substring(0, left.length - 1);\n                    } else {\n                        right = right.substring(1, right.length);\n                    }\n                }\n            } else {\n                this._expandSelectionOnSign();\n\n                var _getUnformattedLeftAn3 = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\n                var _getUnformattedLeftAn4 = _slicedToArray(_getUnformattedLeftAn3, 2);\n\n                left = _getUnformattedLeftAn4[0];\n                right = _getUnformattedLeftAn4[1];\n            }\n\n            this._setValueParts(left, right);\n        }\n\n        /**\n         * Return `true` if a decimal character is allowed to be typed.\n         * If the number of decimal places shown on focus is zero, then the decimal character is not allowed.\n         *\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_isDecimalCharacterInsertionAllowed',\n        value: function _isDecimalCharacterInsertionAllowed() {\n            return this.settings.decimalPlacesShownOnFocus !== AutoNumeric.options.decimalPlacesShownOnFocus.none;\n        }\n\n        /**\n         * Return `true` if the key is allowed.\n         * This function decides if the key pressed should be dropped or accepted, and modify the value 'on-the-fly' accordingly.\n         * //TODO This should use another function in order to separate the test and the modification\n         *\n         * @returns {boolean}\n         */\n\n    }, {\n        key: '_processCharacterInsertion',\n        value: function _processCharacterInsertion() {\n            var _getUnformattedLeftAn5 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n                _getUnformattedLeftAn6 = _slicedToArray(_getUnformattedLeftAn5, 2),\n                left = _getUnformattedLeftAn6[0],\n                right = _getUnformattedLeftAn6[1];\n\n            if (this.eventKey !== _AutoNumericEnum2.default.keyName.AndroidDefault) {\n                this.throwInput = true;\n            }\n\n            // Start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n            // Do not allow decimal character if no decimal part allowed\n            if (this.eventKey === this.settings.decimalCharacter || this.settings.decimalCharacterAlternative && this.eventKey === this.settings.decimalCharacterAlternative || this.eventKey === '.' || this.eventKey === ',' || this.eventKey === _AutoNumericEnum2.default.keyName.NumpadDot) {\n                if (!this._isDecimalCharacterInsertionAllowed() || !this.settings.decimalCharacter) {\n                    return true;\n                }\n\n                // Do not allow decimal character before negativeSignCharacter character\n                if (this.settings.negativeSignCharacter && _AutoNumericHelper2.default.contains(right, this.settings.negativeSignCharacter)) {\n                    return true;\n                }\n\n                // Do not allow a decimal character if another decimal character is already present\n                if (_AutoNumericHelper2.default.contains(left, this.settings.decimalCharacter)) {\n                    return true;\n                }\n\n                if (right.indexOf(this.settings.decimalCharacter) > 0) {\n                    return true;\n                }\n\n                if (right.indexOf(this.settings.decimalCharacter) === 0) {\n                    right = right.substr(1);\n                }\n\n                this._setValueParts(left + this.settings.decimalCharacter, right);\n\n                return true;\n            }\n\n            // Prevent entering the minus sign if it's not allowed (Note: `this.settings.negativeSignCharacter` is only set if the minimumValue or maximumValue is lower than zero, allowing negative numbers to be entered)\n            if ((this.eventKey === '-' || this.eventKey === '+') && this.settings.negativeSignCharacter === '-') {\n                if (left === '' && _AutoNumericHelper2.default.contains(right, this.settings.negativeSignCharacter)) {\n                    // The value is originally negative (with a trailing negative sign)\n                    right = right.replace(this.settings.negativeSignCharacter, '');\n                } else if (_AutoNumericHelper2.default.isNegative(left)) {\n                    // The value is originally negative (with a leading negative sign)\n                    // Remove the negative sign, effectively converting the value to a positive one\n                    left = left.replace('-', ''); //TODO replace with '+' if `showPositiveSign`?\n                } else {\n                    // The value is originally positive\n                    left = this.settings.negativeSignCharacter + left;\n                }\n\n                this._setValueParts(left, right);\n\n                return true;\n            }\n\n            // If the user tries to insert a digit before the minus sign\n            var eventNumber = Number(this.eventKey);\n            if (eventNumber >= 0 && eventNumber <= 9) {\n                if (this.settings.negativeSignCharacter && left === '' && _AutoNumericHelper2.default.contains(right, this.settings.negativeSignCharacter)) {\n                    left = this.settings.negativeSignCharacter;\n                    right = right.substring(1, right.length);\n                }\n\n                if (this.settings.maximumValue <= 0 && this.settings.minimumValue < this.settings.maximumValue && !_AutoNumericHelper2.default.contains(_AutoNumericHelper2.default.getElementValue(this.domElement), this.settings.negativeSignCharacter) && this.eventKey !== '0') {\n                    left = this.settings.negativeSignCharacter + left;\n                }\n\n                this._setValueParts(left + this.eventKey, right);\n\n                return true;\n            }\n\n            // Prevent any other characters\n            this.throwInput = false;\n\n            return false;\n        }\n\n        /**\n         * Formatting of just processed value while keeping the cursor position\n         *\n         * @param {Event} e\n         * @private\n         */\n\n    }, {\n        key: '_formatValue',\n        value: function _formatValue(e) {\n            var elementValue = _AutoNumericHelper2.default.getElementValue(this.domElement);\n\n            var _getUnformattedLeftAn7 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n                _getUnformattedLeftAn8 = _slicedToArray(_getUnformattedLeftAn7, 1),\n                left = _getUnformattedLeftAn8[0];\n\n            // No grouping separator and no currency sign\n\n\n            if ((this.settings.digitGroupSeparator === '' || this.settings.digitGroupSeparator !== '' && !_AutoNumericHelper2.default.contains(elementValue, this.settings.digitGroupSeparator)) && (this.settings.currencySymbol === '' || this.settings.currencySymbol !== '' && !_AutoNumericHelper2.default.contains(elementValue, this.settings.currencySymbol))) {\n                var _elementValue$split = elementValue.split(this.settings.decimalCharacter),\n                    _elementValue$split2 = _slicedToArray(_elementValue$split, 1),\n                    subParts = _elementValue$split2[0];\n\n                var negativeSign = '';\n                if (_AutoNumericHelper2.default.isNegative(subParts)) {\n                    negativeSign = '-';\n                    subParts = subParts.replace('-', '');\n                    left = left.replace('-', '');\n                }\n\n                // Strip leading zero on positive value if needed\n                if (negativeSign === '' && subParts.length > this.settings.mIntPos && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n\n                // Strip leading zero on negative value if needed\n                if (negativeSign === '-' && subParts.length > this.settings.mIntNeg && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n\n                left = negativeSign + left;\n            }\n\n            var value = this.constructor._addGroupSeparators(elementValue, this.settings, this.isFocused, this.rawValue);\n            var position = value.length;\n            if (value) {\n                // Prepare regexp which searches for cursor position from unformatted left part\n                var leftAr = left.split('');\n\n                // Fixes caret position with trailing minus sign\n                if ((this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.suffix || this.settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.prefix && this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) && leftAr[0] === '-' && this.settings.negativeSignCharacter !== '') {\n                    leftAr.shift();\n\n                    if ((this.eventKey === _AutoNumericEnum2.default.keyName.Backspace || this.eventKey === _AutoNumericEnum2.default.keyName.Delete) && this.caretFix) {\n                        if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix && this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.left || this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix && this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.suffix) {\n                            leftAr.push('-');\n                            this.caretFix = e.type === 'keydown';\n                        }\n\n                        if (this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix && this.settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.right) {\n                            var signParts = this.settings.currencySymbol.split('');\n                            var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                            var escapedParts = [];\n                            signParts.forEach(function (i, miniParts) {\n                                miniParts = signParts[i];\n                                if (_AutoNumericHelper2.default.isInArray(miniParts, escapeChr)) {\n                                    escapedParts.push('\\\\' + miniParts);\n                                } else {\n                                    escapedParts.push(miniParts);\n                                }\n                            });\n\n                            if (this.eventKey === _AutoNumericEnum2.default.keyName.Backspace) {\n                                escapedParts.push('-');\n                            }\n\n                            // Pushing the escaped sign\n                            leftAr.push(escapedParts.join(''));\n                            this.caretFix = e.type === 'keydown';\n                        }\n                    }\n                }\n\n                for (var i = 0; i < leftAr.length; i++) {\n                    if (!leftAr[i].match('\\\\d')) {\n                        leftAr[i] = '\\\\' + leftAr[i];\n                    }\n                }\n\n                var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                // Search cursor position in formatted value\n                var newLeft = value.match(leftReg);\n                if (newLeft) {\n                    position = newLeft[0].length;\n\n                    // If the positive sign is shown, calculate the caret position accordingly\n                    if (this.settings.showPositiveSign) {\n                        if (position === 0 && newLeft.input.charAt(0) === this.settings.positiveSignCharacter) {\n                            position = newLeft.input.indexOf(this.settings.currencySymbol) === 1 ? this.settings.currencySymbol.length + 1 : 1;\n                        }\n\n                        if (position === 0 && newLeft.input.charAt(this.settings.currencySymbol.length) === this.settings.positiveSignCharacter) {\n                            position = this.settings.currencySymbol.length + 1;\n                        }\n                    }\n\n                    // If we are just before the sign which is in prefix position\n                    if ((position === 0 && value.charAt(0) !== this.settings.negativeSignCharacter || position === 1 && value.charAt(0) === this.settings.negativeSignCharacter) && this.settings.currencySymbol && this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix) {\n                        // Place caret after prefix sign\n                        //TODO Should the test be 'isNegative' instead of 'isNegativeStrict' in order to search for '-' everywhere in the string?\n                        position = this.settings.currencySymbol.length + (_AutoNumericHelper2.default.isNegativeStrict(value) ? 1 : 0);\n                    }\n                } else {\n                    if (this.settings.currencySymbol && this.settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) {\n                        // If we could not find a place for cursor and have a sign as a suffix\n                        // Place caret before suffix currency sign\n                        position -= this.settings.currencySymbol.length;\n                    }\n\n                    if (this.settings.suffixText) {\n                        // If we could not find a place for cursor and have a suffix\n                        // Place caret before suffix\n                        position -= this.settings.suffixText.length;\n                    }\n                }\n            }\n\n            // Only update the value if it has changed. This prevents modifying the selection, if any.\n            if (value !== elementValue || value === elementValue && (this.eventKey === _AutoNumericEnum2.default.keyName.num0 || this.eventKey === _AutoNumericEnum2.default.keyName.numpad0)) {\n                this._setElementValue(value);\n                this._setCaretPosition(position);\n            }\n\n            if (this.androidSelectionStart !== null) {\n                // If an Android browser is detected, fix the caret position\n                // Unfortunately this does not fix all android browsers, only Android Chrome currently.\n                // This is due to the fact those provide different order of events and/or keycodes thrown (this is a real mess :|).\n                this._setCaretPosition(this.androidSelectionStart);\n            }\n\n            this.formatted = true; //TODO Rename `this.formatted` to `this._formatExecuted`, since it's possible this function does not need to format anything (in the case where the keycode is dropped for instance)\n        }\n\n        /**\n         * Serialize the form child <input> element values to a string, or an Array.\n         * The output format is defined with the `formatType` argument.\n         * This is loosely based upon http://stackoverflow.com/a/40705993/2834898.\n         *\n         * @param {HTMLFormElement} form\n         * @param {boolean} intoAnArray If `true`, instead of generating a string, it generates an Array.\n         * @param {string} formatType If `'unformatted'`, then the AutoNumeric elements values are unformatted, if `'localized'`, then the AutoNumeric elements values are localized, and if `'formatted'`, then the AutoNumeric elements values are kept formatted. In either way, this function does not modify the value of each DOM element, but only affect the value that is returned by that serialize function.\n         * @param {string} serializedSpaceCharacter Can either be the '+' character, or the '%20' string.\n         * @param {string|null} forcedOutputFormat If set, then this is the format that is used for the localization, instead of the default `outputFormat` option.\n         * @returns {string|Array}\n         * @private\n         */\n\n    }], [{\n        key: 'version',\n        value: function version() {\n            return '4.1.0-beta.1';\n        }\n\n        /**\n         * Take the parameters given to the AutoNumeric object, and output the three variables that are needed to finish initializing it :\n         * - domElement : The target DOM element\n         * - initialValue : The initial value, or `null` if none is given\n         * - userOptions : The option object\n         *\n         * @param {object|Array|number|string} arg1\n         * @param {object|Array|number|string|null} arg2\n         * @param {object|Array|number|string|null} arg3\n         * @returns {{domElement: *, initialValue: *, userOptions: *}}\n         * @throws\n         * @private\n         */\n\n    }, {\n        key: '_setArgumentsValues',\n        value: function _setArgumentsValues(arg1, arg2, arg3) {\n            // Basic check on the argument count\n            if (_AutoNumericHelper2.default.isNull(arg1)) {\n                _AutoNumericHelper2.default.throwError('At least one valid parameter is needed in order to initialize an AutoNumeric object');\n            }\n\n            // Prepare the arguments in order to create the AutoNumeric object with the right values\n            // Test the argument types\n            var isArg1Element = _AutoNumericHelper2.default.isElement(arg1);\n            var isArg1String = _AutoNumericHelper2.default.isString(arg1);\n\n            var isArg2Object = _AutoNumericHelper2.default.isObject(arg2);\n            var isArg2Array = Array.isArray(arg2) && arg2.length > 0;\n            var isArg2Number = _AutoNumericHelper2.default.isNumberOrArabic(arg2) || arg2 === '';\n            var isArg2PreDefinedOptionName = this._isPreDefinedOptionValid(arg2);\n            var isArg2Null = _AutoNumericHelper2.default.isNull(arg2);\n            var isArg2EmptyString = _AutoNumericHelper2.default.isEmptyString(arg2);\n\n            var isArg3Object = _AutoNumericHelper2.default.isObject(arg3);\n            var isArg3Array = Array.isArray(arg3) && arg3.length > 0;\n            var isArg3Null = _AutoNumericHelper2.default.isNull(arg3);\n            var isArg3PreDefinedOptionName = this._isPreDefinedOptionValid(arg3);\n\n            // Given the parameters passed, sort the data and return a stable state before the initialization\n            var domElement = void 0;\n            var userOptions = void 0;\n            var initialValue = void 0;\n\n            //TODO Simplify those tests -->\n            if (isArg1Element && isArg2Null && isArg3Null) {\n                // new AutoNumeric(domElement); // With the default options\n                domElement = arg1;\n                initialValue = null;\n                userOptions = null;\n            } else if (isArg1Element && isArg2Number && isArg3Null) {\n                // new AutoNumeric(domElement, 12345.789); // With the default options, and an initial value\n                // new AutoNumeric(domElement, '12345.789');\n                domElement = arg1;\n                initialValue = arg2;\n                userOptions = null;\n            } else if (isArg1Element && isArg2Object && isArg3Null) {\n                // new AutoNumeric(domElement, { options }); // With one option object\n                domElement = arg1;\n                initialValue = null;\n                userOptions = arg2;\n            } else if (isArg1Element && isArg2PreDefinedOptionName && isArg3Null) {\n                // new AutoNumeric(domElement, 'euroPos'); // With one pre-defined option name\n                domElement = arg1;\n                initialValue = null;\n                userOptions = this._getOptionObject(arg2);\n            } else if (isArg1Element && isArg2Array && isArg3Null) {\n                // new AutoNumeric(domElement, [{ options1 }, { options2 }]); // With multiple option objects (the latest option overwriting the previous ones)\n                domElement = arg1;\n                initialValue = null;\n                userOptions = this.mergeOptions(arg2);\n            } else if (isArg1Element && (isArg2Null || isArg2EmptyString) && isArg3Object) {\n                // new AutoNumeric(domElement, null, { options }); // With one option object\n                domElement = arg1;\n                initialValue = null;\n                userOptions = arg3;\n            } else if (isArg1Element && (isArg2Null || isArg2EmptyString) && isArg3Array) {\n                // new AutoNumeric(domElement, null, [{ options1 }, { options2 }]); // With multiple option objects\n                domElement = arg1;\n                initialValue = null;\n                userOptions = this.mergeOptions(arg3);\n            } else if (isArg1String && isArg2Null && isArg3Null) {\n                // new AutoNumeric('.myCssClass > input');\n                domElement = document.querySelector(arg1);\n                initialValue = null;\n                userOptions = null;\n            } else if (isArg1String && isArg2Object && isArg3Null) {\n                // new AutoNumeric('.myCssClass > input', { options });\n                domElement = document.querySelector(arg1);\n                initialValue = null;\n                userOptions = arg2;\n            } else if (isArg1String && isArg2PreDefinedOptionName && isArg3Null) {\n                // new AutoNumeric('.myCssClass > input', 'euroPos');\n                domElement = document.querySelector(arg1);\n                initialValue = null;\n                userOptions = this._getOptionObject(arg2);\n            } else if (isArg1String && isArg2Array && isArg3Null) {\n                // new AutoNumeric('.myCssClass > input', [{ options1 }, { options2 }]); // With multiple option objects\n                domElement = document.querySelector(arg1);\n                initialValue = null;\n                userOptions = this.mergeOptions(arg2);\n            } else if (isArg1String && (isArg2Null || isArg2EmptyString) && isArg3Object) {\n                // new AutoNumeric('.myCssClass > input', null, { options });\n                domElement = document.querySelector(arg1);\n                initialValue = null;\n                userOptions = arg3;\n            } else if (isArg1String && (isArg2Null || isArg2EmptyString) && isArg3Array) {\n                // new AutoNumeric('.myCssClass > input', null, [{ options1 }, { options2 }]); // With multiple option objects\n                domElement = document.querySelector(arg1);\n                initialValue = null;\n                userOptions = this.mergeOptions(arg3);\n            } else if (isArg1String && isArg2Number && isArg3Null) {\n                // new AutoNumeric('.myCssClass > input', 12345.789);\n                // new AutoNumeric('.myCssClass > input', '12345.789');\n                // new AutoNumeric('.myCssClass > input', '');\n                domElement = document.querySelector(arg1);\n                initialValue = arg2;\n                userOptions = null;\n            } else if (isArg1String && isArg2Number && isArg3Object) {\n                // new AutoNumeric('.myCssClass > input', 12345.789, { options });\n                // new AutoNumeric('.myCssClass > input', '12345.789', { options });\n                // new AutoNumeric('.myCssClass > input', '', { options });\n                domElement = document.querySelector(arg1);\n                initialValue = arg2;\n                userOptions = arg3;\n            } else if (isArg1String && isArg2Number && isArg3PreDefinedOptionName) {\n                // new AutoNumeric('.myCssClass > input', 12345.789, 'euroPos');\n                // new AutoNumeric('.myCssClass > input', '12345.789', 'euroPos');\n                // new AutoNumeric('.myCssClass > input', '', 'euroPos');\n                domElement = document.querySelector(arg1);\n                initialValue = arg2;\n                userOptions = this._getOptionObject(arg3);\n            } else if (isArg1Element && isArg2Number && isArg3Object) {\n                // new AutoNumeric(domElement, 12345.789, { options });\n                // new AutoNumeric(domElement, '12345.789', { options });\n                // new AutoNumeric(domElement, '', { options });\n                domElement = arg1;\n                initialValue = arg2;\n                userOptions = arg3;\n            } else if (isArg1Element && isArg2Number && isArg3PreDefinedOptionName) {\n                // new AutoNumeric(domElement, 12345.789, 'euroPos');\n                // new AutoNumeric(domElement, '12345.789', 'euroPos');\n                // new AutoNumeric(domElement, '', 'euroPos');\n                domElement = arg1;\n                initialValue = arg2;\n                userOptions = this._getOptionObject(arg3);\n            } else if (isArg1Element && isArg2Number && isArg3Array) {\n                // new AutoNumeric(domElement, 12345.789, [{ options1 }, { options2 }]);\n                // new AutoNumeric(domElement, '12345.789', [{ options1 }, { options2 }]);\n                // new AutoNumeric(domElement, '', [{ options1 }, { options2 }]);\n                domElement = arg1;\n                initialValue = arg2;\n                userOptions = this.mergeOptions(arg3);\n            } else {\n                _AutoNumericHelper2.default.throwError('The parameters given to the AutoNumeric object are not valid, \\'' + arg1 + '\\', \\'' + arg2 + '\\' and \\'' + arg3 + '\\' given.');\n            }\n\n            if (_AutoNumericHelper2.default.isNull(domElement)) {\n                _AutoNumericHelper2.default.throwError('The selector \\'' + arg1 + '\\' did not select any valid DOM element. Please check on which element you called AutoNumeric.');\n            }\n\n            return { domElement: domElement, initialValue: initialValue, userOptions: userOptions };\n        }\n\n        /**\n         * Merge the option objects found in the given array `optionsArray`.\n         * If a `string` is found, then we try to get the related pre-defined option using that string as its name.\n         * When merging the options, the latest option overwrite any previously set. This allows to fine tune a pre-defined option for instance.\n         *\n         * @param {Array<object|string>} optionsArray\n         * @returns {{}}\n         */\n\n    }, {\n        key: 'mergeOptions',\n        value: function mergeOptions(optionsArray) {\n            var _this5 = this;\n\n            // This allows the user to use multiple options (strings or objects) in an array, and overwrite the previous one with the next option element ; this is useful to tune the wanted format\n            var mergedOptions = {};\n            optionsArray.forEach(function (optionObjectOrPredefinedOptionString) {\n                _extends(mergedOptions, _this5._getOptionObject(optionObjectOrPredefinedOptionString));\n            });\n\n            return mergedOptions;\n        }\n\n        /**\n         * Return `true` if the given pre-defined option name is an attribute of the `AutoNumeric.predefinedOptions` object\n         *\n         * @param {string} preDefinedOptionName\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_isPreDefinedOptionValid',\n        value: function _isPreDefinedOptionValid(preDefinedOptionName) {\n            return AutoNumeric.predefinedOptions.hasOwnProperty(preDefinedOptionName);\n        }\n\n        /**\n         * Return an option object based on the given parameter.\n         * If `optionObjectOrPredefinedName` is as string, then we retrieve the pre-defined option object, if it's an object, we use it as is.\n         *\n         * @param {object|string} optionObjectOrPredefinedName\n         * @returns {object}\n         */\n\n    }, {\n        key: '_getOptionObject',\n        value: function _getOptionObject(optionObjectOrPredefinedName) {\n            var options = void 0;\n            if (_AutoNumericHelper2.default.isString(optionObjectOrPredefinedName)) {\n                options = AutoNumeric.getPredefinedOptions()[optionObjectOrPredefinedName];\n                if (options === void 0 || options === null) {\n                    // If the given pre-defined name does not exist, warn that something is wrong, and continue the execution of the initialization\n                    _AutoNumericHelper2.default.warning('The given pre-defined option [' + optionObjectOrPredefinedName + '] is not recognized by autoNumeric. Please check that pre-defined option name.', true);\n                }\n            } else {\n                // A `settings` object\n                options = optionObjectOrPredefinedName;\n            }\n\n            return options;\n        }\n    }, {\n        key: '_unformatAltHovered',\n        value: function _unformatAltHovered(anElement) {\n            anElement.hoveredWithAlt = true;\n            anElement.unformat();\n        }\n\n        /**\n         * Reformat the given AutoNumeric element, and update the `hoveredWithAlt` variable.\n         *\n         * @param {AutoNumeric} anElement\n         * @private\n         */\n\n    }, {\n        key: '_reformatAltHovered',\n        value: function _reformatAltHovered(anElement) {\n            anElement.hoveredWithAlt = false;\n            anElement.reformat();\n        }\n\n        /**\n         * Return an array of autoNumeric elements, child of the <form> element passed as a parameter.\n         *\n         * @param {HTMLElement} formNode\n         * @returns {Array}\n         * @private\n         */\n\n    }, {\n        key: '_getChildANInputElement',\n        value: function _getChildANInputElement(formNode) {\n            var _this6 = this;\n\n            //FIXME test this\n            var inputList = formNode.getElementsByTagName('input');\n\n            // Loop this list and keep only the inputs that are managed by AutoNumeric\n            var autoNumericInputs = [];\n            var inputElements = Array.prototype.slice.call(inputList, 0);\n            inputElements.forEach(function (input) {\n                if (_this6.test(input)) {\n                    autoNumericInputs.push(input);\n                }\n            });\n\n            return autoNumericInputs;\n        }\n\n        // Static methods\n        /**\n         * Test if the given domElement is already managed by AutoNumeric (if it has been initialized on the current page).\n         *\n         * @param {HTMLElement} domElement\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'test',\n        value: function test(domElement) {\n            return this._isInGlobalList(domElement);\n        }\n\n        /**\n         * Create a WeakMap with the given name.\n         *\n         * @param {string} weakMapName\n         * @private\n         */\n\n    }, {\n        key: '_createWeakMap',\n        value: function _createWeakMap(weakMapName) {\n            window[weakMapName] = new WeakMap();\n        }\n\n        /**\n         * Create a list of all the AutoNumeric elements that are initialized on the current page.\n         * This is needed in order to determine if a given dom element is already managed by autoNumeric.\n         * This uses a WeakMap in order to limit potential garbage collection problems.\n         * (cf. my tests on http://codepen.io/AnotherLinuxUser/pen/pRQGaM?editors=1011)\n         * @private\n         */\n\n    }, {\n        key: '_createGlobalList',\n        value: function _createGlobalList() {\n            // The check that this global list does not exists already is done in the add and remove functions already\n            this.autoNumericGlobalListName = 'autoNumericGlobalList'; //XXX This looks weird to set a variable on `this.` in a static method, but that really declare that variable like a static property\n            // Note: I should not get any memory leaks for referencing the DOM element in the `value`, this DOM element also being the `key`, according to the spec : http://www.ecma-international.org/ecma-262/6.0/#sec-weakmap-objects\n            this._createWeakMap(this.autoNumericGlobalListName);\n        }\n\n        /**\n         * Return `true` if the global AutoNumeric element list exists.\n         *\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_doesGlobalListExists',\n        value: function _doesGlobalListExists() {\n            var type = _typeof(window[this.autoNumericGlobalListName]);\n            return type !== 'undefined' && type === 'object';\n        }\n\n        /**\n         * Add the given object to the global AutoNumeric element list.\n         *\n         * @param {AutoNumeric} autoNumericObject\n         * @private\n         */\n\n    }, {\n        key: '_addToGlobalList',\n        value: function _addToGlobalList(autoNumericObject) {\n            if (!this._doesGlobalListExists()) {\n                this._createGlobalList();\n            }\n\n            var domElement = autoNumericObject.node();\n            // This checks if the object is not already in the global list before adding it.\n            // This could happen if an AutoNumeric element is initialized, then the DOM element is removed directly via `removeChild` (hence the reference does not get removed from the global list), then it get recreated and initialized again\n            if (this._isInGlobalList(domElement)) {\n                if (this._getFromGlobalList(domElement) === this) {\n                    // Do not add this AutoNumeric object again since it's already in that global list\n                    return;\n                } else {\n                    // Print a warning to warn that the domElement already has a reference in the global map (but we cannot for sure starts deleting those old references since they could still be used by another AutoNumeric object)\n                    _AutoNumericHelper2.default.warning('A reference to the DOM element you just initialized already exists in the global AutoNumeric element list. Please make sure to not initialize the same DOM element multiple times.', autoNumericObject.getSettings().showWarnings);\n                }\n            }\n\n            window[this.autoNumericGlobalListName].set(domElement, autoNumericObject);\n        }\n\n        /**\n         * Remove the given object from the global AutoNumeric element list.\n         *\n         * @param {AutoNumeric} autoNumericObject\n         * @private\n         */\n\n    }, {\n        key: '_removeFromGlobalList',\n        value: function _removeFromGlobalList(autoNumericObject) {\n            //FIXME test this\n            if (this._doesGlobalListExists()) {\n                window[this.autoNumericGlobalListName].delete(autoNumericObject.node());\n            }\n        }\n\n        /**\n         * Return the value associated to the key `domElement` passed as a parameter.\n         * The value is the AutoNumeric object that manages the DOM element `domElement`.\n         *\n         * @param {HTMLElement|HTMLInputElement} domElement\n         * @returns {null|AutoNumeric}\n         * @private\n         */\n\n    }, {\n        key: '_getFromGlobalList',\n        value: function _getFromGlobalList(domElement) {\n            //FIXME test this\n            if (this._doesGlobalListExists()) {\n                return window[this.autoNumericGlobalListName].get(domElement);\n            }\n\n            return null;\n        }\n\n        /**\n         * Check if the given DOM element is in the global AutoNumeric element list.\n         *\n         * @param {HTMLElement|HTMLInputElement} domElement\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_isInGlobalList',\n        value: function _isInGlobalList(domElement) {\n            //FIXME test this\n            if (!this._doesGlobalListExists()) {\n                return false;\n            }\n\n            return window[this.autoNumericGlobalListName].has(domElement);\n        }\n    }, {\n        key: 'validate',\n        value: function validate(userOptions) {\n            var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            var originalOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n            if (_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(userOptions) || !_AutoNumericHelper2.default.isObject(userOptions)) {\n                _AutoNumericHelper2.default.throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.');\n            }\n\n            var isOriginalOptionAnObject = _AutoNumericHelper2.default.isObject(originalOptions);\n            if (!isOriginalOptionAnObject && !_AutoNumericHelper2.default.isNull(originalOptions)) {\n                _AutoNumericHelper2.default.throwError('The \\'originalOptions\\' parameter is invalid ; it should either be a valid option object or `null`, [' + userOptions + '] given.');\n            }\n\n            // If the user used old options, we convert them to new ones\n            if (!_AutoNumericHelper2.default.isNull(userOptions)) {\n                this._convertOldOptionsToNewOnes(userOptions);\n            }\n\n            // The user can choose if the `userOptions` has already been extended with the default options, or not\n            var options = void 0;\n            if (shouldExtendDefaultOptions) {\n                options = _extends({}, this.getDefaultConfig(), userOptions);\n            } else {\n                options = userOptions;\n            }\n\n            // First things first, we test that the `showWarnings` option is valid\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.showWarnings) && !_AutoNumericHelper2.default.isBoolean(options.showWarnings)) {\n                _AutoNumericHelper2.default.throwError('The debug option \\'showWarnings\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showWarnings + '] given.');\n            }\n\n            // Define the regular expressions needed for the following tests\n            var testPositiveInteger = /^[0-9]+$/;\n            var testNumericalCharacters = /[0-9]+/;\n            // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n            var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n            var testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\n            // Then tests the options individually\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.allowDecimalPadding) && !_AutoNumericHelper2.default.isBoolean(options.allowDecimalPadding) && options.allowDecimalPadding !== AutoNumeric.options.allowDecimalPadding.floats) {\n                _AutoNumericHelper2.default.throwError('The decimal padding option \\'allowDecimalPadding\\' is invalid ; it should either be `false`, `true` or `\\'floats\\'`, [' + options.allowDecimalPadding + '] given.');\n            }\n\n            if ((options.allowDecimalPadding === AutoNumeric.options.allowDecimalPadding.never || options.allowDecimalPadding === 'false' || //TODO Make sure for the other options that 'false' and 'true' are correctly taken into account\n            options.allowDecimalPadding === AutoNumeric.options.allowDecimalPadding.floats) && (options.decimalPlaces !== AutoNumeric.options.decimalPlaces.none || options.decimalPlacesShownOnBlur !== AutoNumeric.options.decimalPlacesShownOnBlur.none || options.decimalPlacesShownOnFocus !== AutoNumeric.options.decimalPlacesShownOnFocus.none)) {\n                _AutoNumericHelper2.default.warning('Setting \\'allowDecimalPadding\\' to [' + options.allowDecimalPadding + '] will override the current \\'decimalPlaces*\\' settings [' + options.decimalPlaces + ', ' + options.decimalPlacesShownOnBlur + ' and ' + options.decimalPlacesShownOnFocus + '].', options.showWarnings);\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.caretPositionOnFocus) && !_AutoNumericHelper2.default.isInArray(options.caretPositionOnFocus, [AutoNumeric.options.caretPositionOnFocus.start, AutoNumeric.options.caretPositionOnFocus.end, AutoNumeric.options.caretPositionOnFocus.decimalLeft, AutoNumeric.options.caretPositionOnFocus.decimalRight])) {\n                _AutoNumericHelper2.default.throwError('The display on empty string option \\'caretPositionOnFocus\\' is invalid ; it should either be `null`, \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.caretPositionOnFocus + '] given.');\n            }\n\n            // Special case here for `caretPositionOnFocus` and `selectOnFocus` where we need to check the original non-tempered version of the options in order to check for conflicts, since using the default settings remove those and would prevent us warning the user that his option object is not correct.\n            var optionsToUse = void 0;\n            if (isOriginalOptionAnObject) {\n                optionsToUse = originalOptions;\n            } else {\n                optionsToUse = this._correctCaretPositionOnFocusAndSelectOnFocusOptions(userOptions);\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(optionsToUse) && optionsToUse.caretPositionOnFocus !== AutoNumeric.options.caretPositionOnFocus.doNoForceCaretPosition && optionsToUse.selectOnFocus === AutoNumeric.options.selectOnFocus.select) {\n                _AutoNumericHelper2.default.warning('The \\'selectOnFocus\\' option is set to \\'select\\', which is in conflict with the \\'caretPositionOnFocus\\' which is set to \\'' + optionsToUse.caretPositionOnFocus + '\\'. As a result, if this has been called when instantiating an AutoNumeric object, the \\'selectOnFocus\\' option is forced to \\'doNotSelect\\'.', options.showWarnings);\n            }\n\n            if (!_AutoNumericHelper2.default.isInArray(options.digitGroupSeparator, [AutoNumeric.options.digitGroupSeparator.comma, AutoNumeric.options.digitGroupSeparator.dot, AutoNumeric.options.digitGroupSeparator.normalSpace, AutoNumeric.options.digitGroupSeparator.thinSpace, AutoNumeric.options.digitGroupSeparator.narrowNoBreakSpace, AutoNumeric.options.digitGroupSeparator.noBreakSpace, AutoNumeric.options.digitGroupSeparator.noSeparator, AutoNumeric.options.digitGroupSeparator.apostrophe, AutoNumeric.options.digitGroupSeparator.arabicThousandsSeparator, AutoNumeric.options.digitGroupSeparator.dotAbove])) {\n                _AutoNumericHelper2.default.throwError('The thousand separator character option \\'digitGroupSeparator\\' is invalid ; it should be \\',\\', \\'.\\', \\'\\u066C\\', \\'\\u02D9\\', \"\\'\", \\' \\', \\'\\u2009\\', \\'\\u202F\\', \\'\\xA0\\' or empty (\\'\\'), [' + options.digitGroupSeparator + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.showOnlyNumbersOnFocus) && !_AutoNumericHelper2.default.isBoolean(options.showOnlyNumbersOnFocus)) {\n                _AutoNumericHelper2.default.throwError('The \\'showOnlyNumbersOnFocus\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showOnlyNumbersOnFocus + '] given.');\n            }\n\n            if (!testPositiveInteger.test(options.digitalGroupSpacing)) {\n                _AutoNumericHelper2.default.throwError('The digital grouping for thousand separator option \\'digitalGroupSpacing\\' is invalid ; it should be a positive integer, [' + options.digitalGroupSpacing + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isInArray(options.decimalCharacter, [AutoNumeric.options.decimalCharacter.comma, AutoNumeric.options.decimalCharacter.dot, AutoNumeric.options.decimalCharacter.middleDot, AutoNumeric.options.decimalCharacter.arabicDecimalSeparator, AutoNumeric.options.decimalCharacter.decimalSeparatorKeySymbol])) {\n                _AutoNumericHelper2.default.throwError('The decimal separator character option \\'decimalCharacter\\' is invalid ; it should be \\'.\\', \\',\\', \\'\\xB7\\', \\'\\u2396\\' or \\'\\u066B\\', [' + options.decimalCharacter + '] given.');\n            }\n\n            // Checks if the decimal and thousand characters are the same\n            if (options.decimalCharacter === options.digitGroupSeparator) {\n                _AutoNumericHelper2.default.throwError('autoNumeric will not function properly when the decimal character \\'decimalCharacter\\' [' + options.decimalCharacter + '] and the thousand separator \\'digitGroupSeparator\\' [' + options.digitGroupSeparator + '] are the same character.');\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.decimalCharacterAlternative) && !_AutoNumericHelper2.default.isString(options.decimalCharacterAlternative)) {\n                _AutoNumericHelper2.default.throwError('The alternate decimal separator character option \\'decimalCharacterAlternative\\' is invalid ; it should be a string, [' + options.decimalCharacterAlternative + '] given.');\n            }\n\n            if (options.currencySymbol !== '' && !_AutoNumericHelper2.default.isString(options.currencySymbol)) {\n                _AutoNumericHelper2.default.throwError('The currency symbol option \\'currencySymbol\\' is invalid ; it should be a string, [' + options.currencySymbol + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isInArray(options.currencySymbolPlacement, [AutoNumeric.options.currencySymbolPlacement.prefix, AutoNumeric.options.currencySymbolPlacement.suffix])) {\n                _AutoNumericHelper2.default.throwError('The placement of the currency sign option \\'currencySymbolPlacement\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.currencySymbolPlacement + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isInArray(options.negativePositiveSignPlacement, [AutoNumeric.options.negativePositiveSignPlacement.prefix, AutoNumeric.options.negativePositiveSignPlacement.suffix, AutoNumeric.options.negativePositiveSignPlacement.left, AutoNumeric.options.negativePositiveSignPlacement.right, AutoNumeric.options.negativePositiveSignPlacement.none])) {\n                _AutoNumericHelper2.default.throwError('The placement of the negative sign option \\'negativePositiveSignPlacement\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left), \\'r\\' (right) or \\'null\\', [' + options.negativePositiveSignPlacement + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.showPositiveSign) && !_AutoNumericHelper2.default.isBoolean(options.showPositiveSign)) {\n                _AutoNumericHelper2.default.throwError('The show positive sign option \\'showPositiveSign\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showPositiveSign + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isString(options.suffixText) || options.suffixText !== '' && (_AutoNumericHelper2.default.isNegative(options.suffixText) || testNumericalCharacters.test(options.suffixText))) {\n                _AutoNumericHelper2.default.throwError('The additional suffix option \\'suffixText\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.suffixText + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.overrideMinMaxLimits) && !_AutoNumericHelper2.default.isInArray(options.overrideMinMaxLimits, [AutoNumeric.options.overrideMinMaxLimits.ceiling, AutoNumeric.options.overrideMinMaxLimits.floor, AutoNumeric.options.overrideMinMaxLimits.ignore])) {\n                _AutoNumericHelper2.default.throwError('The override min & max limits option \\'overrideMinMaxLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.overrideMinMaxLimits + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isString(options.maximumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.maximumValue)) {\n                _AutoNumericHelper2.default.throwError('The maximum possible value option \\'maximumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.maximumValue + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isString(options.minimumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.minimumValue)) {\n                _AutoNumericHelper2.default.throwError('The minimum possible value option \\'minimumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.minimumValue + '] given.');\n            }\n\n            if (parseFloat(options.minimumValue) > parseFloat(options.maximumValue)) {\n                _AutoNumericHelper2.default.throwError('The minimum possible value option is greater than the maximum possible value option ; \\'minimumValue\\' [' + options.minimumValue + '] should be smaller than \\'maximumValue\\' [' + options.maximumValue + '].');\n            }\n\n            if (!(_AutoNumericHelper2.default.isInt(options.decimalPlaces) && options.decimalPlaces >= 0 || // If integer option\n            _AutoNumericHelper2.default.isString(options.decimalPlaces) && testPositiveInteger.test(options.decimalPlaces)) // If string option\n            ) {\n                    _AutoNumericHelper2.default.throwError('The number of decimal places option \\'decimalPlaces\\' is invalid ; it should be a positive integer, [' + options.decimalPlaces + '] given.');\n                }\n\n            if (!(_AutoNumericHelper2.default.isNull(options.decimalPlacesRawValue) || _AutoNumericHelper2.default.isInt(options.decimalPlacesRawValue) && options.decimalPlacesRawValue >= 0 || // If integer option\n            _AutoNumericHelper2.default.isString(options.decimalPlacesRawValue) && testPositiveInteger.test(options.decimalPlacesRawValue)) // If string option\n            ) {\n                    _AutoNumericHelper2.default.throwError('The number of decimal places for the raw value option \\'decimalPlacesRawValue\\' is invalid ; it should be a positive integer or `null`, [' + options.decimalPlacesRawValue + '] given.');\n                }\n\n            // Checks if the number of decimal places for the raw value is lower than the `decimalPlaces`, `decimalPlacesShownOnFocus` and/or `decimalPlacesShownOnBlur` options\n            this._validateDecimalPlacesRawValue(options);\n\n            if (!_AutoNumericHelper2.default.isNull(options.decimalPlacesShownOnFocus) && !testPositiveInteger.test(String(options.decimalPlacesShownOnFocus))) {\n                _AutoNumericHelper2.default.throwError('The number of expanded decimal places option \\'decimalPlacesShownOnFocus\\' is invalid ; it should be a positive integer or `null`, [' + options.decimalPlacesShownOnFocus + '] given.');\n            }\n\n            // Checks if the extended decimal places \"decimalPlacesShownOnFocus\" is greater than the decimal places number `decimalPlaces`\n            if (!_AutoNumericHelper2.default.isNull(options.decimalPlacesShownOnFocus) && Number(options.decimalPlaces) > Number(options.decimalPlacesShownOnFocus)) {\n                _AutoNumericHelper2.default.warning('The extended decimal places \\'decimalPlacesShownOnFocus\\' [' + options.decimalPlacesShownOnFocus + '] should be greater than the \\'decimalPlaces\\' [' + options.decimalPlaces + '] value. Currently, this will limit the ability of your user to manually change some of the decimal places. Do you really want to do that?', options.showWarnings);\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.divisorWhenUnfocused) && !testPositiveFloatOrInteger.test(options.divisorWhenUnfocused) || options.divisorWhenUnfocused === 0 || options.divisorWhenUnfocused === '0' || options.divisorWhenUnfocused === 1 || options.divisorWhenUnfocused === '1') {\n                _AutoNumericHelper2.default.throwError('The divisor option \\'divisorWhenUnfocused\\' is invalid ; it should be a positive number higher than one, preferably an integer, [' + options.divisorWhenUnfocused + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.decimalPlacesShownOnBlur) && !testPositiveInteger.test(options.decimalPlacesShownOnBlur)) {\n                _AutoNumericHelper2.default.throwError('The number of decimals shown when unfocused option \\'decimalPlacesShownOnBlur\\' is invalid ; it should be a positive integer or `null`, [' + options.decimalPlacesShownOnBlur + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.symbolWhenUnfocused) && !_AutoNumericHelper2.default.isString(options.symbolWhenUnfocused)) {\n                _AutoNumericHelper2.default.throwError('The symbol to show when unfocused option \\'symbolWhenUnfocused\\' is invalid ; it should be a string, [' + options.symbolWhenUnfocused + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.saveValueToSessionStorage) && !_AutoNumericHelper2.default.isBoolean(options.saveValueToSessionStorage)) {\n                _AutoNumericHelper2.default.throwError('The save to session storage option \\'saveValueToSessionStorage\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.saveValueToSessionStorage + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isInArray(options.onInvalidPaste, [AutoNumeric.options.onInvalidPaste.error, AutoNumeric.options.onInvalidPaste.ignore, AutoNumeric.options.onInvalidPaste.clamp, AutoNumeric.options.onInvalidPaste.truncate, AutoNumeric.options.onInvalidPaste.replace])) {\n                _AutoNumericHelper2.default.throwError('The paste behavior option \\'onInvalidPaste\\' is invalid ; it should either be \\'error\\', \\'ignore\\', \\'clamp\\', \\'truncate\\' or \\'replace\\' (cf. documentation), [' + options.onInvalidPaste + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isInArray(options.roundingMethod, [AutoNumeric.options.roundingMethod.halfUpSymmetric, AutoNumeric.options.roundingMethod.halfUpAsymmetric, AutoNumeric.options.roundingMethod.halfDownSymmetric, AutoNumeric.options.roundingMethod.halfDownAsymmetric, AutoNumeric.options.roundingMethod.halfEvenBankersRounding, AutoNumeric.options.roundingMethod.upRoundAwayFromZero, AutoNumeric.options.roundingMethod.downRoundTowardZero, AutoNumeric.options.roundingMethod.toCeilingTowardPositiveInfinity, AutoNumeric.options.roundingMethod.toFloorTowardNegativeInfinity, AutoNumeric.options.roundingMethod.toNearest05, AutoNumeric.options.roundingMethod.toNearest05Alt, AutoNumeric.options.roundingMethod.upToNext05, AutoNumeric.options.roundingMethod.downToNext05])) {\n                _AutoNumericHelper2.default.throwError('The rounding method option \\'roundingMethod\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.roundingMethod + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.negativeBracketsTypeOnBlur) && !_AutoNumericHelper2.default.isInArray(options.negativeBracketsTypeOnBlur, [AutoNumeric.options.negativeBracketsTypeOnBlur.parentheses, AutoNumeric.options.negativeBracketsTypeOnBlur.brackets, AutoNumeric.options.negativeBracketsTypeOnBlur.chevrons, AutoNumeric.options.negativeBracketsTypeOnBlur.curlyBraces, AutoNumeric.options.negativeBracketsTypeOnBlur.angleBrackets, AutoNumeric.options.negativeBracketsTypeOnBlur.japaneseQuotationMarks, AutoNumeric.options.negativeBracketsTypeOnBlur.halfBrackets, AutoNumeric.options.negativeBracketsTypeOnBlur.whiteSquareBrackets, AutoNumeric.options.negativeBracketsTypeOnBlur.quotationMarks, AutoNumeric.options.negativeBracketsTypeOnBlur.guillemets])) {\n                _AutoNumericHelper2.default.throwError('The brackets for negative values option \\'negativeBracketsTypeOnBlur\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\', \\'{,}\\', \\'\\u3008,\\u3009\\', \\'\\uFF62,\\uFF63\\', \\'\\u2E24,\\u2E25\\', \\'\\u27E6,\\u27E7\\', \\'\\u2039,\\u203A\\' or \\'\\xAB,\\xBB\\', [' + options.negativeBracketsTypeOnBlur + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isInArray(options.emptyInputBehavior, [AutoNumeric.options.emptyInputBehavior.focus, AutoNumeric.options.emptyInputBehavior.press, AutoNumeric.options.emptyInputBehavior.always, AutoNumeric.options.emptyInputBehavior.zero, AutoNumeric.options.emptyInputBehavior.null])) {\n                _AutoNumericHelper2.default.throwError('The display on empty string option \\'emptyInputBehavior\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\', \\'zero\\' or \\'null\\', [' + options.emptyInputBehavior + '] given.');\n            }\n\n            if (options.emptyInputBehavior === AutoNumeric.options.emptyInputBehavior.zero && (options.minimumValue > 0 || options.maximumValue < 0)) {\n                _AutoNumericHelper2.default.throwError('The \\'emptyInputBehavior\\' option is set to \\'zero\\', but this value is outside of the range defined by \\'minimumValue\\' and \\'maximumValue\\' [' + options.minimumValue + ', ' + options.maximumValue + '].');\n            }\n\n            if (!_AutoNumericHelper2.default.isInArray(options.leadingZero, [AutoNumeric.options.leadingZero.allow, AutoNumeric.options.leadingZero.deny, AutoNumeric.options.leadingZero.keep])) {\n                _AutoNumericHelper2.default.throwError('The leading zero behavior option \\'leadingZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.leadingZero + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.formatOnPageLoad) && !_AutoNumericHelper2.default.isBoolean(options.formatOnPageLoad)) {\n                _AutoNumericHelper2.default.throwError('The format on initialization option \\'formatOnPageLoad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.formatOnPageLoad + '] given.');\n            }\n\n            if (!testPositiveInteger.test(options.historySize) || options.historySize === 0) {\n                _AutoNumericHelper2.default.throwError('The history size option \\'historySize\\' is invalid ; it should be a positive integer, [' + options.historySize + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.selectNumberOnly) && !_AutoNumericHelper2.default.isBoolean(options.selectNumberOnly)) {\n                _AutoNumericHelper2.default.throwError('The select number only option \\'selectNumberOnly\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.selectNumberOnly + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.selectOnFocus) && !_AutoNumericHelper2.default.isBoolean(options.selectOnFocus)) {\n                _AutoNumericHelper2.default.throwError('The select on focus option \\'selectOnFocus\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.selectOnFocus + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.defaultValueOverride) && options.defaultValueOverride !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.defaultValueOverride)) {\n                _AutoNumericHelper2.default.throwError('The unformatted default value option \\'defaultValueOverride\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.defaultValueOverride + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.unformatOnSubmit) && !_AutoNumericHelper2.default.isBoolean(options.unformatOnSubmit)) {\n                _AutoNumericHelper2.default.throwError('The remove formatting on submit option \\'unformatOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unformatOnSubmit + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.valuesToStrings) && !_AutoNumericHelper2.default.isObject(options.valuesToStrings)) {\n                _AutoNumericHelper2.default.throwError('The option \\'valuesToStrings\\' is invalid ; it should be an object, ideally with \\'key -> value\\' entries, [' + options.valuesToStrings + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.outputFormat) && !_AutoNumericHelper2.default.isInArray(options.outputFormat, [AutoNumeric.options.outputFormat.string, AutoNumeric.options.outputFormat.number, AutoNumeric.options.outputFormat.dot, AutoNumeric.options.outputFormat.negativeDot, AutoNumeric.options.outputFormat.comma, AutoNumeric.options.outputFormat.negativeComma, AutoNumeric.options.outputFormat.dotNegative, AutoNumeric.options.outputFormat.commaNegative])) {\n                _AutoNumericHelper2.default.throwError('The custom locale format option \\'outputFormat\\' is invalid ; it should either be null, \\'string\\', \\'number\\', \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.outputFormat + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.isCancellable) && !_AutoNumericHelper2.default.isBoolean(options.isCancellable)) {\n                _AutoNumericHelper2.default.throwError('The cancellable behavior option \\'isCancellable\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.isCancellable + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.modifyValueOnWheel) && !_AutoNumericHelper2.default.isBoolean(options.modifyValueOnWheel)) {\n                _AutoNumericHelper2.default.throwError('The increment/decrement on mouse wheel option \\'modifyValueOnWheel\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.modifyValueOnWheel + '] given.');\n            }\n\n            if (!(_AutoNumericHelper2.default.isString(options.wheelStep) || _AutoNumericHelper2.default.isNumber(options.wheelStep)) || options.wheelStep !== 'progressive' && !testPositiveFloatOrInteger.test(options.wheelStep) || Number(options.wheelStep) === 0) {\n                // A step equal to '0' is rejected\n                _AutoNumericHelper2.default.throwError('The wheel step value option \\'wheelStep\\' is invalid ; it should either be the string \\'progressive\\', or a number or a string that represents a positive number (excluding zero), [' + options.wheelStep + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isInArray(options.serializeSpaces, [AutoNumeric.options.serializeSpaces.plus, AutoNumeric.options.serializeSpaces.percent])) {\n                _AutoNumericHelper2.default.throwError('The space replacement character option \\'serializeSpaces\\' is invalid ; it should either be \\'+\\' or \\'%20\\', [' + options.serializeSpaces + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.noEventListeners) && !_AutoNumericHelper2.default.isBoolean(options.noEventListeners)) {\n                _AutoNumericHelper2.default.throwError('The option \\'noEventListeners\\' that prevent the creation of event listeners is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.noEventListeners + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.styleRules) && !(_AutoNumericHelper2.default.isObject(options.styleRules) && (options.styleRules.hasOwnProperty('positive') || options.styleRules.hasOwnProperty('negative') || options.styleRules.hasOwnProperty('ranges') || options.styleRules.hasOwnProperty('userDefined')))) {\n                _AutoNumericHelper2.default.throwError('The option \\'styleRules\\' is invalid ; it should be a correctly structured object, with one or more \\'positive\\', \\'negative\\', \\'ranges\\' or \\'userDefined\\' attributes, [' + options.styleRules + '] given.');\n            }\n\n            // Deeper tests of the `styleRules` object : Check that the callback, if defined, is a function\n            if (!_AutoNumericHelper2.default.isNull(options.styleRules) && options.styleRules.hasOwnProperty('userDefined') && !_AutoNumericHelper2.default.isNull(options.styleRules.userDefined)) {\n                options.styleRules.userDefined.forEach(function (rule) {\n                    if (rule.hasOwnProperty('callback') && !_AutoNumericHelper2.default.isFunction(rule.callback)) {\n                        _AutoNumericHelper2.default.throwError('The callback defined in the `userDefined` attribute is not a function, ' + _typeof(rule.callback) + ' given.');\n                    }\n                });\n            }\n\n            if (!_AutoNumericHelper2.default.isNull(options.rawValueDivisor) && !testPositiveFloatOrInteger.test(options.rawValueDivisor) || options.rawValueDivisor === 0 || options.rawValueDivisor === '0' || options.rawValueDivisor === 1 || options.rawValueDivisor === '1') {\n                _AutoNumericHelper2.default.throwError('The raw value divisor option \\'rawValueDivisor\\' is invalid ; it should be a positive number higher than one, preferably an integer, [' + options.rawValueDivisor + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.readOnly) && !_AutoNumericHelper2.default.isBoolean(options.readOnly)) {\n                _AutoNumericHelper2.default.throwError('The option \\'readOnly\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.readOnly + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.unformatOnHover) && !_AutoNumericHelper2.default.isBoolean(options.unformatOnHover)) {\n                _AutoNumericHelper2.default.throwError('The option \\'unformatOnHover\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unformatOnHover + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.failOnUnknownOption) && !_AutoNumericHelper2.default.isBoolean(options.failOnUnknownOption)) {\n                _AutoNumericHelper2.default.throwError('The debug option \\'failOnUnknownOption\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.failOnUnknownOption + '] given.');\n            }\n\n            if (!_AutoNumericHelper2.default.isTrueOrFalseString(options.createLocalList) && !_AutoNumericHelper2.default.isBoolean(options.createLocalList)) {\n                _AutoNumericHelper2.default.throwError('The debug option \\'createLocalList\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.createLocalList + '] given.');\n            }\n        }\n\n        /**\n         * Check the `decimalPlaces*` options and output the relevant warnings if some of those will get overwritten during the initialization or settings update.\n         *\n         * @param {object} options\n         * @private\n         */\n\n    }, {\n        key: '_validateDecimalPlacesRawValue',\n        value: function _validateDecimalPlacesRawValue(options) {\n            // Checks if the number of decimal places for the raw value is lower than the `decimalPlaces`, `decimalPlacesShownOnFocus` and/or `decimalPlacesShownOnBlur` options\n            if (!_AutoNumericHelper2.default.isNull(options.decimalPlacesRawValue)) {\n                if (options.decimalPlacesRawValue < options.decimalPlaces) {\n                    _AutoNumericHelper2.default.warning('The number of decimal places to store in the raw value [' + options.decimalPlacesRawValue + '] is lower than the ones to display [' + options.decimalPlaces + ']. This will likely confuse your users.\\nTo solve that, you\\'d need to either set `decimalPlacesRawValue` to `null`, or set a number of decimal places for the raw value equal of bigger than `decimalPlaces`.', options.showWarnings);\n                }\n\n                if (options.decimalPlacesRawValue < options.decimalPlacesShownOnFocus) {\n                    _AutoNumericHelper2.default.warning('The number of decimal places to store in the raw value [' + options.decimalPlacesRawValue + '] is lower than the ones shown on focus [' + options.decimalPlacesShownOnFocus + ']. This will likely confuse your users.\\nTo solve that, you\\'d need to either set `decimalPlacesRawValue` to `null`, or set a number of decimal places for the raw value equal of bigger than `decimalPlacesShownOnFocus`.', options.showWarnings);\n                }\n\n                if (options.decimalPlacesRawValue < options.decimalPlacesShownOnBlur) {\n                    _AutoNumericHelper2.default.warning('The number of decimal places to store in the raw value [' + options.decimalPlacesRawValue + '] is lower than the ones shown when unfocused [' + options.decimalPlacesShownOnBlur + ']. This will likely confuse your users.\\nTo solve that, you\\'d need to either set `decimalPlacesRawValue` to `null`, or set a number of decimal places for the raw value equal of bigger than `decimalPlacesShownOnBlur`.', options.showWarnings);\n                }\n            }\n        }\n\n        /**\n         * Return `true` if the settings/options are valid, `false` otherwise.\n         *\n         * @param {object} options\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'areSettingsValid',\n        value: function areSettingsValid(options) {\n            var isValid = true;\n            try {\n                this.validate(options, true);\n            } catch (error) {\n                isValid = false;\n            }\n\n            return isValid;\n        }\n\n        /**\n         * Return the default autoNumeric settings.\n         *\n         * @returns {object}\n         */\n\n    }, {\n        key: 'getDefaultConfig',\n        value: function getDefaultConfig() {\n            return AutoNumeric.defaultSettings;\n        }\n\n        /**\n         * Return all the predefined language options in one object.\n         * You can also access a specific language object directly by using `AutoNumeric.getPredefinedOptions().French` for instance.\n         *\n         * @returns {object}\n         */\n\n    }, {\n        key: 'getPredefinedOptions',\n        value: function getPredefinedOptions() {\n            return AutoNumeric.predefinedOptions;\n        }\n\n        /**\n         * Analyse the given array `options` and return a single 'merged' option objet.\n         * `options` can be `null`, or an array of an option objects, or an array containing another array of option objects / strings (pre-defined option names)\n         *\n         * @param {null|Array<object|string|Array<string|object>>} options\n         * @returns {null|object}\n         * @private\n         */\n\n    }, {\n        key: '_generateOptionsObjectFromOptionsArray',\n        value: function _generateOptionsObjectFromOptionsArray(options) {\n            var _this7 = this;\n\n            var optionsResult = void 0;\n            if (_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(options) || options.length === 0) {\n                optionsResult = null;\n            } else {\n                optionsResult = {};\n                if (options.length === 1 && Array.isArray(options[0])) {\n                    options[0].forEach(function (optionObject) {\n                        // Using `_getOptionObject()` allows using pre-defined names in the `options` array\n                        _extends(optionsResult, _this7._getOptionObject(optionObject));\n                    });\n                } else if (options.length >= 1) {\n                    options.forEach(function (optionObject) {\n                        _extends(optionsResult, _this7._getOptionObject(optionObject));\n                    });\n                }\n            }\n\n            return optionsResult;\n        }\n\n        /**\n         * Format the given number (or numeric string) with the given options. This returns the formatted value as a string.\n         * This can also format the given DOM element value with the given options and returns the formatted value as a string.\n         * Note : This function does *not* update that element value with the newly formatted value.\n         * This basically allows to get the formatted value without first having to initialize an AutoNumeric object.\n         *\n         * @param {number|string|HTMLElement|HTMLInputElement} numericStringOrDomElement A number, or a string that represent a javascript number, or a DOM element\n         * @param {object|null} options Multiple objects can be passed, the latter overwriting the settings from the former ones\n         * @returns {string|null}\n         */\n\n    }, {\n        key: 'format',\n        value: function format(numericStringOrDomElement) {\n            if (_AutoNumericHelper2.default.isUndefined(numericStringOrDomElement) || numericStringOrDomElement === null) {\n                return null;\n            }\n\n            // Retrieve the value to format\n            var value = void 0;\n            if (_AutoNumericHelper2.default.isElement(numericStringOrDomElement)) {\n                value = _AutoNumericHelper2.default.getElementValue(numericStringOrDomElement);\n            } else {\n                value = numericStringOrDomElement;\n            }\n\n            if (!_AutoNumericHelper2.default.isString(value) && !_AutoNumericHelper2.default.isNumber(value)) {\n                _AutoNumericHelper2.default.throwError('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.');\n            }\n\n            // Manage options\n\n            for (var _len5 = arguments.length, options = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n                options[_key5 - 1] = arguments[_key5];\n            }\n\n            var optionsToUse = this._generateOptionsObjectFromOptionsArray(options);\n\n            // Initiate a very basic settings object\n            var settings = _extends({}, this.getDefaultConfig(), optionsToUse);\n            if (value < 0) {\n                settings.negativeSignCharacter = '-';\n            } else {\n                settings.negativeSignCharacter = '';\n            }\n\n            var regex = {};\n            this._cachesUsualRegularExpressions(settings, regex); // This is needed by `_stripAllNonNumberCharacters` that uses those regex\n\n            // Check the validity of the `value` parameter\n            // Convert the value to a numeric string, stripping unnecessary characters in the process\n            var valueString = this._toNumericValue(value, settings);\n            if (isNaN(Number(valueString))) {\n                _AutoNumericHelper2.default.throwError('The value [' + valueString + '] that you are trying to format is not a recognized number.');\n            }\n\n            // Basic tests to check if the given valueString is valid\n\n            var _checkIfInRangeWithOv = this._checkIfInRangeWithOverrideOption(valueString, settings),\n                _checkIfInRangeWithOv2 = _slicedToArray(_checkIfInRangeWithOv, 2),\n                minTest = _checkIfInRangeWithOv2[0],\n                maxTest = _checkIfInRangeWithOv2[1];\n\n            if (!minTest || !maxTest) {\n                // Throw a custom event\n                _AutoNumericHelper2.default.triggerEvent(AutoNumeric.events.formatted, document, 'Range test failed');\n                _AutoNumericHelper2.default.throwError('The value [' + valueString + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n            }\n\n            // Generate the `negativePositiveSignPlacement` option as needed\n            this._correctNegativePositiveSignPlacementOption(settings);\n            // Calculate the needed decimal places\n            this._calculateDecimalPlacesOnInit(settings);\n\n            // Multiply the raw value with `rawValueDivisor` if defined\n            if (!_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(settings.rawValueDivisor) && settings.rawValueDivisor !== 0 && // Only divide if the `rawValueDivisor` option is set\n            valueString !== '' && valueString !== null) {\n                // Do not modify the `valueString` if it's an empty string or null\n                valueString *= settings.rawValueDivisor;\n            }\n\n            // Everything is ok, proceed to rounding, formatting and grouping\n            valueString = this._roundFormattedValueShownOnFocus(valueString, settings);\n            valueString = this._modifyNegativeSignAndDecimalCharacterForFormattedValue(valueString, settings);\n            valueString = this._addGroupSeparators(valueString, settings, false, valueString);\n\n            return valueString;\n        }\n\n        /**\n         * Format the given DOM element value, and set the resulting value back as the element value.\n         *\n         * @param {HTMLElement|HTMLInputElement} domElement\n         * @param {object} options\n         * @returns {string|null}\n         */\n\n    }, {\n        key: 'formatAndSet',\n        value: function formatAndSet(domElement) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            //FIXME test this\n            var formattedValue = this.format(domElement, options);\n            _AutoNumericHelper2.default.setElementValue(domElement, formattedValue);\n\n            return formattedValue;\n        }\n\n        /**\n         * Unformat the given formatted string with the given options. This returns a numeric string.\n         * It can also unformat the given DOM element value with the given options and returns the unformatted numeric string.\n         * Note: This does *not* update that element value.\n         * This basically allows to get the unformatted value without first having to initialize an AutoNumeric object.\n         *\n         * @param {string|number|HTMLElement|HTMLInputElement} numericStringOrDomElement A number, or a string that represent a javascript number, or a DOM element\n         * @param {object|null} options Multiple objects can be passed, the latter overwriting the settings from the former ones\n         * @returns {string|number|NaN}\n         */\n\n    }, {\n        key: 'unformat',\n        value: function unformat(numericStringOrDomElement) {\n            if (_AutoNumericHelper2.default.isNumberStrict(numericStringOrDomElement)) {\n                // Giving an unformatted value should return the same unformatted value, whatever the options passed as a parameter\n                return numericStringOrDomElement;\n            }\n\n            // Retrieve the value to unformat\n            var value = void 0;\n            if (_AutoNumericHelper2.default.isElement(numericStringOrDomElement)) {\n                value = _AutoNumericHelper2.default.getElementValue(numericStringOrDomElement);\n            } else {\n                value = numericStringOrDomElement;\n            }\n\n            if (_AutoNumericHelper2.default.isUndefined(value) || value === null) {\n                return null;\n            }\n\n            if (_AutoNumericHelper2.default.isArray(value) || _AutoNumericHelper2.default.isObject(value)) {\n                // Check the validity of the `value` parameter\n                _AutoNumericHelper2.default.throwError('A number or a string representing a number is needed to be able to unformat it, [' + value + '] given.');\n            }\n\n            // Manage options\n\n            for (var _len6 = arguments.length, options = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n                options[_key6 - 1] = arguments[_key6];\n            }\n\n            var optionsToUse = this._generateOptionsObjectFromOptionsArray(options);\n\n            // Generate the settings\n            var settings = _extends({}, this.getDefaultConfig(), optionsToUse);\n            value = value.toString();\n\n            // This checks if a negative sign is anywhere in the `value`, not just on the very first character (ie. '12345.67-')\n            if (_AutoNumericHelper2.default.isNegative(value)) {\n                settings.negativeSignCharacter = '-';\n            } else if (!_AutoNumericHelper2.default.isNull(settings.negativeBracketsTypeOnBlur)) {\n                var _settings$negativeBra3 = settings.negativeBracketsTypeOnBlur.split(',');\n\n                var _settings$negativeBra4 = _slicedToArray(_settings$negativeBra3, 2);\n\n                settings.firstBracket = _settings$negativeBra4[0];\n                settings.lastBracket = _settings$negativeBra4[1];\n\n                if (value.charAt(0) === settings.firstBracket && value.charAt(value.length - 1) === settings.lastBracket) {\n                    settings.negativeSignCharacter = '-';\n                    value = this._removeBrackets(value, settings, false);\n                }\n            }\n\n            value = this._convertToNumericString(value, settings);\n            var unwantedCharacters = new RegExp('[^+-0123456789.]', 'gi');\n            if (unwantedCharacters.test(value)) {\n                return NaN;\n            }\n\n            // Generate the `negativePositiveSignPlacement` option as needed\n            this._correctNegativePositiveSignPlacementOption(settings);\n            // Calculate the needed decimal places\n            if (settings.decimalPlacesRawValue) {\n                // `originalDecimalPlacesRawValue` needs to be defined\n                settings.originalDecimalPlacesRawValue = settings.decimalPlacesRawValue;\n            } else {\n                settings.originalDecimalPlacesRawValue = settings.decimalPlaces;\n            }\n\n            this._calculateDecimalPlacesOnInit(settings);\n\n            // Divide the raw value with `rawValueDivisor` if defined\n            if (!_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(settings.rawValueDivisor) && settings.rawValueDivisor !== 0 && // Only divide if the `rawValueDivisor` option is set\n            value !== '' && value !== null) {\n                // Do not modify the `value` if it's an empty string or null\n                value /= settings.rawValueDivisor;\n            }\n\n            value = this._roundRawValue(value, settings);\n            value = value.replace(settings.decimalCharacter, '.'); // Here we need to convert back the decimal character to a period since `_roundValue` adds it in some cases\n            value = this._toLocale(value, settings.outputFormat);\n\n            return value;\n        }\n\n        /**\n         * Unformat the given DOM element value, and set the resulting value back as the element value.\n         *\n         * @param {HTMLElement|HTMLInputElement} domElement\n         * @param {object} options\n         * @returns {*}\n         */\n\n    }, {\n        key: 'unformatAndSet',\n        value: function unformatAndSet(domElement) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            //FIXME test this\n            var unformattedValue = this.unformat(domElement, options);\n            _AutoNumericHelper2.default.setElementValue(domElement, unformattedValue);\n\n            return unformattedValue;\n        }\n\n        /**\n         * Unformat and localize the given formatted string with the given options. This returns a numeric string.\n         * It can also unformat and localize the given DOM element value with the given options and returns the unformatted numeric string.\n         * Note: This does *not* update that element value.\n         * This basically allows to get the localized value without first having to initialize an AutoNumeric object.\n         *\n         * @param {string|number|HTMLElement|HTMLInputElement} numericStringOrDomElement\n         * @param {object} options\n         * @returns {*}\n         */\n\n    }, {\n        key: 'localize',\n        value: function localize(numericStringOrDomElement) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            var value = void 0;\n            if (_AutoNumericHelper2.default.isElement(numericStringOrDomElement)) {\n                value = _AutoNumericHelper2.default.getElementValue(numericStringOrDomElement);\n            } else {\n                value = numericStringOrDomElement;\n            }\n\n            if (_AutoNumericHelper2.default.isNull(options)) {\n                options = AutoNumeric.defaultSettings;\n            }\n\n            value = this.unformat(value, options);\n\n            //XXX The following code is pretty close to the one you can find in `getLocalized()`, but different enough so we won't refactor it.\n            if (Number(value) === 0 && options.leadingZero !== AutoNumeric.options.leadingZero.keep) {\n                value = '0';\n            }\n\n            var outputFormatToUse = void 0;\n            if (_AutoNumericHelper2.default.isNull(options)) {\n                outputFormatToUse = options.outputFormat;\n            } else {\n                outputFormatToUse = AutoNumeric.defaultSettings.outputFormat;\n            }\n\n            return this._toLocale(value, outputFormatToUse);\n        }\n    }, {\n        key: 'localizeAndSet',\n        value: function localizeAndSet(domElement) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            //FIXME test this\n            var localizedValue = this.localize(domElement, options);\n            _AutoNumericHelper2.default.setElementValue(domElement, localizedValue);\n\n            return localizedValue;\n        }\n\n        /**\n         * Return `true` if the given DOM element has an AutoNumeric object that manages it.\n         *\n         * @param {HTMLElement} domElement\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isManagedByAutoNumeric',\n        value: function isManagedByAutoNumeric(domElement) {\n            //FIXME test this\n            return this._isInGlobalList(domElement);\n        }\n\n        /**\n         * Return the AutoNumeric object that manages the given DOM element.\n         *\n         * @param {HTMLElement} domElement\n         * @returns {null|AutoNumeric}\n         */\n\n    }, {\n        key: 'getAutoNumericElement',\n        value: function getAutoNumericElement(domElement) {\n            //FIXME test this\n            if (!this.isManagedByAutoNumeric(domElement)) {\n                return null;\n            }\n\n            return this._getFromGlobalList(domElement);\n        }\n    }, {\n        key: '_stripAllNonNumberCharacters',\n        value: function _stripAllNonNumberCharacters(s, settings, stripZeros, isFocused) {\n            //XXX Note; this function is static since we need to pass a `settings` object when calling the static `AutoNumeric.format()` method\n            //TODO This function is called 10 times (sic!) on each key input, couldn't we lower that number? cf. issue #325\n            //TODO Refactor this with `convertToNumericString()` if possible?\n            s = String(s); // Typecast to to a string, in case that the initialValue is a number\n\n            if (settings.currencySymbol !== '') {\n                // Remove currency sign\n                s = s.replace(settings.currencySymbol, '');\n            }\n\n            if (settings.suffixText) {\n                // Remove suffix\n                s = s.replace(settings.suffixText, '');\n            }\n\n            //TODO Remove the positive sign too?\n\n            // First replace anything before digits\n            s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n            // Then replace anything after digits\n            s = s.replace(settings.skipLastAutoStrip, '$1');\n\n            // Then remove any uninteresting characters\n            s = s.replace(settings.allowedAutoStrip, '');\n            if (settings.decimalCharacterAlternative) {\n                s = s.replace(settings.decimalCharacterAlternative, settings.decimalCharacter);\n            }\n\n            // Get only number string\n            var m = s.match(settings.numRegAutoStrip);\n            s = m ? [m[1], m[2], m[3]].join('') : '';\n\n            if (settings.leadingZero === AutoNumeric.options.leadingZero.allow || settings.leadingZero === AutoNumeric.options.leadingZero.keep) {\n                var negativeSign = '';\n\n                var _s$split = s.split(settings.decimalCharacter),\n                    _s$split2 = _slicedToArray(_s$split, 2),\n                    integerPart = _s$split2[0],\n                    decimalPart = _s$split2[1];\n\n                var modifiedIntegerPart = integerPart;\n                if (_AutoNumericHelper2.default.contains(modifiedIntegerPart, settings.negativeSignCharacter)) {\n                    negativeSign = settings.negativeSignCharacter;\n                    modifiedIntegerPart = modifiedIntegerPart.replace(settings.negativeSignCharacter, '');\n                }\n\n                // Strip leading zero on positive value if need\n                if (negativeSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                    modifiedIntegerPart = modifiedIntegerPart.slice(1);\n                }\n\n                // Strip leading zero on negative value if need\n                if (negativeSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                    modifiedIntegerPart = modifiedIntegerPart.slice(1);\n                }\n\n                s = '' + negativeSign + modifiedIntegerPart + (_AutoNumericHelper2.default.isUndefined(decimalPart) ? '' : settings.decimalCharacter + decimalPart);\n            }\n\n            if (stripZeros && settings.leadingZero === AutoNumeric.options.leadingZero.deny || !isFocused && settings.leadingZero === AutoNumeric.options.leadingZero.allow) {\n                s = s.replace(settings.stripReg, '$1$2');\n            }\n\n            return s;\n        }\n\n        /**\n         * Sets or removes brackets on negative values, depending on the focus state, which is passed as `isFocused`.\n         * The focus state is 'stored' in that object property.\n         *\n         * @param {string} value\n         * @param {object} settings\n         * @param {boolean} isFocused\n         * @returns {*}\n         */\n\n    }, {\n        key: '_toggleNegativeBracket',\n        value: function _toggleNegativeBracket(value, settings, isFocused) {\n            //XXX Note; this function is static since we need to pass a `settings` object when calling the static `AutoNumeric.format()` method\n            var result = void 0;\n            if (isFocused) {\n                result = this._removeBrackets(value, settings);\n            } else {\n                result = this._addBrackets(value, settings);\n            }\n\n            return result;\n        }\n\n        /**\n         * Add the bracket types specified in the `settings` object, to the given string `value`.\n         *\n         * @param {string} value\n         * @param {object} settings\n         * @returns {string}\n         * @private\n         */\n\n    }, {\n        key: '_addBrackets',\n        value: function _addBrackets(value, settings) {\n            var result = void 0;\n            if (!_AutoNumericHelper2.default.isNull(settings.negativeBracketsTypeOnBlur)) {\n                result = '' + settings.firstBracket + value.replace(settings.negativeSignCharacter, '') + settings.lastBracket;\n            } else {\n                result = value;\n            }\n\n            return result;\n        }\n\n        /**\n         * Remove the bracket types specified in the `settings` object, from the given string `value`.\n         *\n         * @param {string} value\n         * @param {object} settings\n         * @param {boolean} rearrangeSignsAndValueOrder If set to `true`, then only the brackets are remove and a negative sign is added, without reordering the negative sign, currency symbol and value according to the settings.\n         * @returns {string}\n         * @private\n         */\n\n    }, {\n        key: '_removeBrackets',\n        value: function _removeBrackets(value, settings) {\n            var rearrangeSignsAndValueOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n            var result = void 0;\n            if (!_AutoNumericHelper2.default.isNull(settings.negativeBracketsTypeOnBlur) && value.charAt(0) === settings.firstBracket) {\n                // Remove the brackets if they are present\n                result = value.replace(settings.firstBracket, '');\n                result = result.replace(settings.lastBracket, '');\n\n                // Add back the negative sign at the right place\n                if (rearrangeSignsAndValueOrder) {\n                    // First we need to remove the currency symbol from the value, since we want to be able to add back the negative sign at the right place (including between the value and the currency sign)\n                    result = result.replace(settings.currencySymbol, '');\n                    result = this._mergeCurrencySignNegativePositiveSignAndValue(result, settings, true, false); //TODO This assume the value is negative and non-empty. Is this always the case?\n                } else {\n                    // Here we only want to add the negative sign since we removed the brackets, without reordering\n                    result = '-' + result;\n                }\n            } else {\n                result = value;\n            }\n\n            return result;\n        }\n    }, {\n        key: '_convertToNumericString',\n        value: function _convertToNumericString(s, settings) {\n            // Remove the currency symbol\n            s = s.replace(settings.currencySymbol, '');\n\n            // Remove the grouping separators (thousands separators usually)\n            s = s.replace(new RegExp('[' + settings.digitGroupSeparator + ']', 'g'), '');\n\n            // Replace the decimal character by a dot\n            if (settings.decimalCharacter !== '.') {\n                s = s.replace(settings.decimalCharacter, '.');\n            }\n\n            // Remove the suffixText\n            if (settings.suffixText !== AutoNumeric.options.suffixText.none) {\n                s = s.replace(settings.suffixText, '');\n            }\n\n            // Move the trailing negative sign to the right position, if any\n            if (_AutoNumericHelper2.default.isNegative(s) && s.lastIndexOf('-') === s.length - 1) {\n                s = s.replace('-', '');\n                s = '-' + s;\n            }\n\n            // Convert arabic numbers to latin ones, if any\n            var convertToNumber = settings.leadingZero !== AutoNumeric.options.leadingZero.keep;\n            var temp = _AutoNumericHelper2.default.arabicToLatinNumbers(s, convertToNumber, false, false);\n            if (!isNaN(temp)) {\n                s = temp.toString();\n            }\n\n            return s;\n        }\n\n        /**\n         * Converts the ISO numeric string to the locale decimal and minus sign placement.\n         * See the \"outputFormat\" option definition for more details.\n         *\n         * @param {string|null} value\n         * @param {string|null} locale\n         * @returns {*}\n         */\n\n    }, {\n        key: '_toLocale',\n        value: function _toLocale(value, locale) {\n            if (_AutoNumericHelper2.default.isNull(locale) || locale === AutoNumeric.options.outputFormat.string) {\n                return value;\n            }\n\n            var result = void 0;\n            switch (locale) {\n                case AutoNumeric.options.outputFormat.number:\n                    result = Number(value);\n                    break;\n                case AutoNumeric.options.outputFormat.dotNegative:\n                    result = _AutoNumericHelper2.default.isNegative(value) ? value.replace('-', '') + '-' : value;\n                    break;\n                case AutoNumeric.options.outputFormat.comma:\n                case AutoNumeric.options.outputFormat.negativeComma:\n                    result = value.replace('.', ',');\n                    break;\n                case AutoNumeric.options.outputFormat.commaNegative:\n                    result = value.replace('.', ',');\n                    result = _AutoNumericHelper2.default.isNegative(result) ? result.replace('-', '') + '-' : result;\n                    break;\n                // The default case\n                case AutoNumeric.options.outputFormat.dot:\n                case AutoNumeric.options.outputFormat.negativeDot:\n                    result = value;\n                    break;\n                default:\n                    _AutoNumericHelper2.default.throwError('The given outputFormat [' + locale + '] option is not recognized.');\n            }\n\n            return result;\n        }\n    }, {\n        key: '_modifyNegativeSignAndDecimalCharacterForFormattedValue',\n        value: function _modifyNegativeSignAndDecimalCharacterForFormattedValue(s, settings) {\n            //XXX Note; this function is static since we need to pass a `settings` object when calling the static `AutoNumeric.format()` method\n            if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n                s = s.replace('-', settings.negativeSignCharacter);\n            }\n\n            if (settings.decimalCharacter !== '.') {\n                s = s.replace('.', settings.decimalCharacter);\n            }\n\n            return s;\n        }\n\n        /**\n         * Return `true` if the given value is empty or is equal to the negative sign character defined in the given settings.\n         *\n         * @param {string} value\n         * @param {object} settings\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_isElementValueEmptyOrOnlyTheNegativeSign',\n        value: function _isElementValueEmptyOrOnlyTheNegativeSign(value, settings) {\n            return value === '' || value === settings.negativeSignCharacter;\n        }\n\n        /**\n         * Return the value with the currency symbol and the suffix text ordered according to the given settings.\n         *\n         * @param {string} value\n         * @param {object} settings\n         * @param {boolean} signOnEmpty\n         * @returns {*}\n         * @private\n         */\n\n    }, {\n        key: '_orderValueCurrencySymbolAndSuffixText',\n        value: function _orderValueCurrencySymbolAndSuffixText(value, settings, signOnEmpty) {\n            var result = void 0;\n            if (settings.emptyInputBehavior === AutoNumeric.options.emptyInputBehavior.always || signOnEmpty) {\n                if (settings.negativePositiveSignPlacement === AutoNumeric.options.negativePositiveSignPlacement.left) {\n                    result = value + settings.currencySymbol + settings.suffixText;\n                } else {\n                    result = settings.currencySymbol + value + settings.suffixText;\n                }\n            } else {\n                result = value;\n            }\n\n            return result;\n        }\n\n        /**\n         * Modify the input value by adding the group separators, as defined in the settings.\n         *\n         * @param {string} inputValue The formatted value (ie. with the `decimalCharacter` defined in the settings, not the raw value)\n         * @param {object} settings\n         * @param {boolean} isFocused\n         * @param {number|string|null} currentRawValue The object current raw value (`this.rawValue`)\n         * @param {number|string|null} forcedRawValue If this is set, then this rawValue is used instead of the one passed through the `settings` object. This is useful is some very specific cases where we need to set the raw value *after* settings the formatted value, using the `_addGroupSeparators()` method.\n         * @returns {*}\n         */\n\n    }, {\n        key: '_addGroupSeparators',\n        value: function _addGroupSeparators(inputValue, settings, isFocused, currentRawValue) {\n            var forcedRawValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n            //TODO Test if `inputValue` === '', and return '' directly if that's the case,\n            //XXX Note; this function is static since we need to pass a `settings` object when calling the static `AutoNumeric.format()` method\n            var isValueNegative = _AutoNumericHelper2.default.isNegative(inputValue) || _AutoNumericHelper2.default.isNegativeWithBrackets(inputValue, settings.firstBracket, settings.lastBracket); // Test if the value is negative before removing the negative sign\n\n            inputValue = this._stripAllNonNumberCharacters(inputValue, settings, false, isFocused);\n\n            if (this._isElementValueEmptyOrOnlyTheNegativeSign(inputValue, settings)) {\n                return this._orderValueCurrencySymbolAndSuffixText(inputValue, settings, true);\n            }\n\n            var isZeroOrHasNoValue = _AutoNumericHelper2.default.isZeroOrHasNoValue(inputValue);\n\n            // Temporarily remove the negative sign if present\n            if (isValueNegative) {\n                inputValue = inputValue.replace('-', '');\n            }\n\n            settings.digitalGroupSpacing = settings.digitalGroupSpacing.toString();\n            var digitalGroup = void 0;\n            switch (settings.digitalGroupSpacing) {\n                case AutoNumeric.options.digitalGroupSpacing.two:\n                    digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n                    break;\n                case AutoNumeric.options.digitalGroupSpacing.twoScaled:\n                    digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n                    break;\n                case AutoNumeric.options.digitalGroupSpacing.four:\n                    digitalGroup = /(\\d)((\\d{4}?)+)$/;\n                    break;\n                case AutoNumeric.options.digitalGroupSpacing.three:\n                default:\n                    digitalGroup = /(\\d)((\\d{3}?)+)$/;\n            }\n\n            // Splits the string at the decimal string\n\n            var _inputValue$split = inputValue.split(settings.decimalCharacter),\n                _inputValue$split2 = _slicedToArray(_inputValue$split, 2),\n                integerPart = _inputValue$split2[0],\n                decimalPart = _inputValue$split2[1];\n\n            if (settings.decimalCharacterAlternative && _AutoNumericHelper2.default.isUndefined(decimalPart)) {\n                var _inputValue$split3 = inputValue.split(settings.decimalCharacterAlternative);\n\n                var _inputValue$split4 = _slicedToArray(_inputValue$split3, 2);\n\n                integerPart = _inputValue$split4[0];\n                decimalPart = _inputValue$split4[1];\n            }\n\n            if (settings.digitGroupSeparator !== '') {\n                // Re-inserts the thousand separator via a regular expression\n                while (digitalGroup.test(integerPart)) {\n                    integerPart = integerPart.replace(digitalGroup, '$1' + settings.digitGroupSeparator + '$2');\n                }\n            }\n\n            // Find out how many decimal places should be kept, depending on the object state (isFocused)\n            var decimalPlacesToRoundTo = void 0;\n            if (isFocused) {\n                decimalPlacesToRoundTo = settings.decimalPlacesShownOnFocus;\n            } else {\n                decimalPlacesToRoundTo = settings.decimalPlacesShownOnBlur;\n            }\n\n            if (decimalPlacesToRoundTo !== 0 && !_AutoNumericHelper2.default.isUndefined(decimalPart)) {\n                if (decimalPart.length > decimalPlacesToRoundTo) {\n                    // Trim the excessive number of decimal places\n                    decimalPart = decimalPart.substring(0, decimalPlacesToRoundTo);\n                }\n\n                // Joins the whole number with the decimal value\n                inputValue = '' + integerPart + settings.decimalCharacter + decimalPart;\n            } else {\n                // Otherwise if it's an integer\n                inputValue = integerPart;\n            }\n\n            // Add back the negative/positive sign and the currency symbol, at the right positions\n            inputValue = AutoNumeric._mergeCurrencySignNegativePositiveSignAndValue(inputValue, settings, isValueNegative, isZeroOrHasNoValue); //TODO this function is called again in `_toggleNegativeBracket` if the brackets are removed; let's DRY this\n\n            if (_AutoNumericHelper2.default.isNull(forcedRawValue)) {\n                // If the raw value is not forced, use the default one from the settings object\n                forcedRawValue = currentRawValue;\n            }\n\n            // Toggle the negative sign and brackets\n            if (settings.negativeBracketsTypeOnBlur !== null && (forcedRawValue < 0 || _AutoNumericHelper2.default.isNegativeStrict(inputValue))) {\n                inputValue = this._toggleNegativeBracket(inputValue, settings, isFocused);\n            }\n\n            var result = void 0;\n            if (settings.suffixText) {\n                result = '' + inputValue + settings.suffixText;\n            } else {\n                result = inputValue;\n            }\n\n            return result;\n        }\n\n        /**\n         * Return a semi-formatted string where the input value, the negative or positive sign, and the currency symbol are stitched together at the right positions, using the options set in the `settings` object.\n         * Note : the `inputValue` is usually not a numeric string since the grouping symbols are already added to it at this point.\n         *\n         * @param {string} inputValue\n         * @param {object} settings\n         * @param {boolean} isValueNegative\n         * @param {boolean} isZeroOrHasNoValue\n         * @returns {*}\n         * @throws\n         * @private\n         */\n\n    }, {\n        key: '_mergeCurrencySignNegativePositiveSignAndValue',\n        value: function _mergeCurrencySignNegativePositiveSignAndValue(inputValue, settings, isValueNegative, isZeroOrHasNoValue) {\n            var signToUse = '';\n            if (isValueNegative) {\n                signToUse = settings.negativeSignCharacter;\n            } else if (settings.showPositiveSign && !isZeroOrHasNoValue) {\n                signToUse = settings.positiveSignCharacter;\n            }\n\n            var result = void 0;\n            if (settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.prefix) {\n                if (settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && settings.showPositiveSign && !isZeroOrHasNoValue)) {\n                    switch (settings.negativePositiveSignPlacement) {\n                        case AutoNumeric.options.negativePositiveSignPlacement.prefix:\n                        case AutoNumeric.options.negativePositiveSignPlacement.left:\n                            result = '' + signToUse + settings.currencySymbol + inputValue;\n                            break;\n                        case AutoNumeric.options.negativePositiveSignPlacement.right:\n                            result = '' + settings.currencySymbol + signToUse + inputValue;\n                            break;\n                        case AutoNumeric.options.negativePositiveSignPlacement.suffix:\n                            result = '' + settings.currencySymbol + inputValue + signToUse;\n                            break;\n                    }\n                } else {\n                    result = settings.currencySymbol + inputValue;\n                }\n            } else if (settings.currencySymbolPlacement === AutoNumeric.options.currencySymbolPlacement.suffix) {\n                if (settings.negativePositiveSignPlacement !== AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && settings.showPositiveSign && !isZeroOrHasNoValue)) {\n                    switch (settings.negativePositiveSignPlacement) {\n                        case AutoNumeric.options.negativePositiveSignPlacement.suffix:\n                        case AutoNumeric.options.negativePositiveSignPlacement.right:\n                            result = '' + inputValue + settings.currencySymbol + signToUse;\n                            break;\n                        case AutoNumeric.options.negativePositiveSignPlacement.left:\n                            result = '' + inputValue + signToUse + settings.currencySymbol;\n                            break;\n                        case AutoNumeric.options.negativePositiveSignPlacement.prefix:\n                            result = '' + signToUse + inputValue + settings.currencySymbol;\n                            break;\n                    }\n                } else {\n                    result = inputValue + settings.currencySymbol;\n                }\n            }\n\n            return result;\n        }\n    }, {\n        key: '_truncateZeros',\n        value: function _truncateZeros(roundedInputValue, decimalPlacesNeeded) {\n            var regex = void 0;\n            switch (decimalPlacesNeeded) {\n                case 0:\n                    // Prevents padding - removes trailing zeros until the first significant digit is encountered\n                    regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                    break;\n                case 1:\n                    // Allows padding when decimalPlacesNeeded equals one - leaves one zero trailing the decimal character\n                    regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                    break;\n                default:\n                    // Removes superfluous zeros after the decimalPlacesNeeded length\n                    regex = new RegExp('(\\\\.\\\\d{' + decimalPlacesNeeded + '}(?:\\\\d*[1-9])?)0*');\n            }\n\n            // If there are no decimal places, we don't need a decimal point at the end\n            roundedInputValue = roundedInputValue.replace(regex, '$1');\n            if (decimalPlacesNeeded === 0) {\n                roundedInputValue = roundedInputValue.replace(/\\.$/, '');\n            }\n\n            return roundedInputValue;\n        }\n\n        /**\n         * Round the given `value` with the number of decimal places to keep for the raw value.\n         *\n         * @param {string|null} value An unformatted numeric value\n         * @param {object} settings\n         * @returns {*}\n         * @private\n         */\n\n    }, {\n        key: '_roundRawValue',\n        value: function _roundRawValue(value, settings) {\n            return this._roundValue(value, settings, settings.decimalPlacesRawValue);\n        }\n\n        /**\n         * Round the given `value` with the number of decimal places to show for the element is focused.\n         *\n         * @param {string|null} value An unformatted numeric value\n         * @param {object} settings\n         * @returns {*}\n         * @private\n         */\n\n    }, {\n        key: '_roundFormattedValueShownOnFocus',\n        value: function _roundFormattedValueShownOnFocus(value, settings) {\n            return this._roundValue(value, settings, Number(settings.decimalPlacesShownOnFocus));\n        }\n\n        /**\n         * Round the given `value` with the number of decimal places to show for the element is unfocused.\n         *\n         * @param {string|null} value An unformatted numeric value\n         * @param {object} settings\n         * @returns {*}\n         * @private\n         */\n\n    }, {\n        key: '_roundFormattedValueShownOnBlur',\n        value: function _roundFormattedValueShownOnBlur(value, settings) {\n            return this._roundValue(value, settings, Number(settings.decimalPlacesShownOnBlur));\n        }\n\n        /**\n         * Round the input value using the rounding method defined in the settings.\n         * This function accepts multiple rounding methods. See the documentation for more details about those.\n         *\n         * Note : This is handled as text since JavaScript math functions can return inaccurate values.\n         *\n         * @param {string|null} inputValue An unformatted numeric value\n         * @param {object} settings\n         * @param {int} decimalPlacesToRoundTo\n         * @returns {*}\n         */\n\n    }, {\n        key: '_roundValue',\n        value: function _roundValue(inputValue, settings, decimalPlacesToRoundTo) {\n            //XXX Note; this function is static since we need to pass a `settings` object when calling the static `AutoNumeric.format()` method\n            if (_AutoNumericHelper2.default.isNull(inputValue)) {\n                // Prevent rounding a `null` value\n                return inputValue;\n            }\n\n            //TODO Divide this function to make it easier to understand\n            inputValue = inputValue === '' ? '0' : inputValue.toString();\n            if (settings.roundingMethod === AutoNumeric.options.roundingMethod.toNearest05 || settings.roundingMethod === AutoNumeric.options.roundingMethod.toNearest05Alt || settings.roundingMethod === AutoNumeric.options.roundingMethod.upToNext05 || settings.roundingMethod === AutoNumeric.options.roundingMethod.downToNext05) {\n                return this._roundCloseTo05(inputValue, settings);\n            }\n\n            var _AutoNumeric$_prepare = AutoNumeric._prepareValueForRounding(inputValue, settings),\n                _AutoNumeric$_prepare2 = _slicedToArray(_AutoNumeric$_prepare, 2),\n                negativeSign = _AutoNumeric$_prepare2[0],\n                preparedValue = _AutoNumeric$_prepare2[1];\n\n            inputValue = preparedValue;\n\n            var decimalCharacterPosition = inputValue.lastIndexOf('.');\n            var inputValueHasNoDot = decimalCharacterPosition === -1; // No dot character is found in the `inputValue`\n\n            var _inputValue$split5 = inputValue.split('.'),\n                _inputValue$split6 = _slicedToArray(_inputValue$split5, 2),\n                decimalPart = _inputValue$split6[1]; // Here the decimal character is always a period '.'\n\n\n            var hasDecimals = decimalPart > 0;\n\n            // If no decimals are detected\n            if (!hasDecimals && (settings.allowDecimalPadding === AutoNumeric.options.allowDecimalPadding.never || settings.allowDecimalPadding === AutoNumeric.options.allowDecimalPadding.floats)) {\n                return Number(inputValue) === 0 ? inputValue : '' + negativeSign + inputValue;\n            }\n\n            // Else there are some decimal places that may need to be rounded\n            // Sets the truncate zero method\n            var temporaryDecimalPlacesOverride = void 0;\n            if (settings.allowDecimalPadding === AutoNumeric.options.allowDecimalPadding.always || settings.allowDecimalPadding === AutoNumeric.options.allowDecimalPadding.floats) {\n                temporaryDecimalPlacesOverride = decimalPlacesToRoundTo;\n            } else {\n                temporaryDecimalPlacesOverride = 0;\n            }\n\n            // Define the decimal position to use (use the very last position if there are no dot in the initial inputValue)\n            var decimalPositionToUse = inputValueHasNoDot ? inputValue.length - 1 : decimalCharacterPosition;\n            // Checks decimal places to determine if rounding is required\n            var checkDecimalPlaces = inputValue.length - 1 - decimalPositionToUse;\n            var inputValueRounded = '';\n\n            // Check if no rounding is required\n            if (checkDecimalPlaces <= decimalPlacesToRoundTo) {\n                // Check if we need to pad with zeros\n                inputValueRounded = inputValue;\n                if (checkDecimalPlaces < temporaryDecimalPlacesOverride) {\n                    if (inputValueHasNoDot) {\n                        inputValueRounded = '' + inputValueRounded + settings.decimalCharacter;\n                    }\n\n                    var zeros = '000000'; //TODO Change that string with a longer one to prevent having to loop numerous times in the next `while` statement?\n                    while (checkDecimalPlaces < temporaryDecimalPlacesOverride) {\n                        zeros = zeros.substring(0, temporaryDecimalPlacesOverride - checkDecimalPlaces);\n                        inputValueRounded += zeros;\n                        checkDecimalPlaces += zeros.length;\n                    }\n                } else if (checkDecimalPlaces > temporaryDecimalPlacesOverride) {\n                    inputValueRounded = this._truncateZeros(inputValueRounded, temporaryDecimalPlacesOverride);\n                } else if (checkDecimalPlaces === 0 && temporaryDecimalPlacesOverride === 0) {\n                    // Remove any trailing dot, if any\n                    inputValueRounded = inputValueRounded.replace(/\\.$/, '');\n                }\n\n                return Number(inputValueRounded) === 0 ? inputValueRounded : '' + negativeSign + inputValueRounded;\n            }\n\n            // Rounded length of the string after rounding\n            var roundedStrLength = void 0;\n            if (inputValueHasNoDot) {\n                roundedStrLength = decimalPlacesToRoundTo - 1;\n            } else {\n                roundedStrLength = Number(decimalPlacesToRoundTo) + Number(decimalCharacterPosition);\n            }\n\n            var lastDigit = Number(inputValue.charAt(roundedStrLength + 1));\n            var inputValueArray = inputValue.substring(0, roundedStrLength + 1).split('');\n            var odd = void 0;\n            if (inputValue.charAt(roundedStrLength) === '.') {\n                odd = inputValue.charAt(roundedStrLength - 1) % 2;\n            } else {\n                odd = inputValue.charAt(roundedStrLength) % 2;\n            }\n\n            if (this._shouldRoundUp(lastDigit, settings, negativeSign, odd)) {\n                // Round up the last digit if required, and continue until no more 9's are found\n                for (var i = inputValueArray.length - 1; i >= 0; i -= 1) {\n                    if (inputValueArray[i] !== '.') {\n                        inputValueArray[i] = +inputValueArray[i] + 1;\n                        if (inputValueArray[i] < 10) {\n                            break;\n                        }\n\n                        if (i > 0) {\n                            inputValueArray[i] = '0';\n                        }\n                    }\n                }\n            }\n\n            // Reconstruct the string, converting any 10's to 0's\n            inputValueArray = inputValueArray.slice(0, roundedStrLength + 1);\n\n            // Return the rounded value\n            inputValueRounded = this._truncateZeros(inputValueArray.join(''), temporaryDecimalPlacesOverride);\n\n            return Number(inputValueRounded) === 0 ? inputValueRounded : '' + negativeSign + inputValueRounded;\n        }\n\n        /**\n         * Round the `value` when the rounding method deals with '.05'\n         *\n         * @param {string} value\n         * @param {object} settings\n         * @returns {string}\n         * @private\n         */\n\n    }, {\n        key: '_roundCloseTo05',\n        value: function _roundCloseTo05(value, settings) {\n            switch (settings.roundingMethod) {\n                case AutoNumeric.options.roundingMethod.toNearest05:\n                case AutoNumeric.options.roundingMethod.toNearest05Alt:\n                    value = (Math.round(value * 20) / 20).toString();\n                    break;\n                case AutoNumeric.options.roundingMethod.upToNext05:\n                    value = (Math.ceil(value * 20) / 20).toString();\n                    break;\n                default:\n                    value = (Math.floor(value * 20) / 20).toString();\n            }\n\n            var result = void 0;\n            if (!_AutoNumericHelper2.default.contains(value, '.')) {\n                result = value + '.00';\n            } else if (value.length - value.indexOf('.') < 3) {\n                result = value + '0';\n            } else {\n                result = value;\n            }\n\n            return result;\n        }\n\n        /**\n         * Modify the given `value` in order to make it usable for the rest of the rounding function.\n         * This convert the `value` to a positive one, trim any leading zeros and make sure it does not starts with a leading dot.\n         *\n         * @param {string} value\n         * @param {object} settings\n         * @returns {[string, string]}\n         * @private\n         */\n\n    }, {\n        key: '_prepareValueForRounding',\n        value: function _prepareValueForRounding(value, settings) {\n            // Checks if `inputValue` is a negative value\n            var negativeSign = '';\n            if (_AutoNumericHelper2.default.isNegativeStrict(value)) {\n                negativeSign = '-';\n\n                // Removes the negative sign that will be added back later if required\n                value = value.replace('-', '');\n            }\n\n            // Append a zero if the first character is not a digit (then it is likely a dot)\n            if (!value.match(/^\\d/)) {\n                value = '0' + value;\n            }\n\n            // Determines if the value is equal to zero. If it is, remove the negative sign\n            if (Number(value) === 0) {\n                negativeSign = '';\n            }\n\n            // Trims leading zero's as needed\n            if (Number(value) > 0 && settings.leadingZero !== AutoNumeric.options.leadingZero.keep || value.length > 0 && settings.leadingZero === AutoNumeric.options.leadingZero.allow) {\n                value = value.replace(/^0*(\\d)/, '$1');\n            }\n\n            return [negativeSign, value];\n        }\n\n        /**\n         * Return `true` if a round up should be done given the last digit, the settings and other information about the value.\n         * \n         * @param {number} lastDigit\n         * @param {object} settings\n         * @param {string} negativeSign\n         * @param {number} odd\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: '_shouldRoundUp',\n        value: function _shouldRoundUp(lastDigit, settings, negativeSign, odd) {\n            return lastDigit > 4 && settings.roundingMethod === AutoNumeric.options.roundingMethod.halfUpSymmetric || // Round half up symmetric\n            lastDigit > 4 && settings.roundingMethod === AutoNumeric.options.roundingMethod.halfUpAsymmetric && negativeSign === '' || // Round half up asymmetric positive values\n            lastDigit > 5 && settings.roundingMethod === AutoNumeric.options.roundingMethod.halfUpAsymmetric && negativeSign === '-' || // Round half up asymmetric negative values\n            lastDigit > 5 && settings.roundingMethod === AutoNumeric.options.roundingMethod.halfDownSymmetric || // Round half down symmetric\n            lastDigit > 5 && settings.roundingMethod === AutoNumeric.options.roundingMethod.halfDownAsymmetric && negativeSign === '' || // Round half down asymmetric positive values\n            lastDigit > 4 && settings.roundingMethod === AutoNumeric.options.roundingMethod.halfDownAsymmetric && negativeSign === '-' || // Round half down asymmetric negative values\n            lastDigit > 5 && settings.roundingMethod === AutoNumeric.options.roundingMethod.halfEvenBankersRounding || lastDigit === 5 && settings.roundingMethod === AutoNumeric.options.roundingMethod.halfEvenBankersRounding && odd === 1 || lastDigit > 0 && settings.roundingMethod === AutoNumeric.options.roundingMethod.toCeilingTowardPositiveInfinity && negativeSign === '' || lastDigit > 0 && settings.roundingMethod === AutoNumeric.options.roundingMethod.toFloorTowardNegativeInfinity && negativeSign === '-' || lastDigit > 0 && settings.roundingMethod === AutoNumeric.options.roundingMethod.upRoundAwayFromZero; // Round up away from zero\n        }\n\n        /**\n         * Truncates the decimal part of a number to the given number of decimal places `decimalPlacesToRoundTo`.\n         *\n         * @param {string} value\n         * @param {object} settings\n         * @param {boolean} isPaste\n         * @param {int} decimalPlacesToRoundTo\n         * @returns {*}\n         */\n\n    }, {\n        key: '_truncateDecimalPlaces',\n        value: function _truncateDecimalPlaces(value, settings, isPaste, decimalPlacesToRoundTo) {\n            if (isPaste) {\n                value = this._roundFormattedValueShownOnFocus(value, settings);\n            }\n\n            var _value$split = value.split(settings.decimalCharacter),\n                _value$split2 = _slicedToArray(_value$split, 2),\n                integerPart = _value$split2[0],\n                decimalPart = _value$split2[1];\n\n            // Truncate the decimal part to the satisfying length since we would round it anyway\n\n\n            if (decimalPart && decimalPart.length > decimalPlacesToRoundTo) {\n                if (decimalPlacesToRoundTo > 0) {\n                    var modifiedDecimalPart = decimalPart.substring(0, decimalPlacesToRoundTo);\n                    value = '' + integerPart + settings.decimalCharacter + modifiedDecimalPart;\n                } else {\n                    value = integerPart;\n                }\n            }\n\n            return value;\n        }\n\n        /**\n         * Check that the number satisfy the format conditions\n         * and lays between settings.minimumValue and settings.maximumValue\n         * and the string length does not exceed the digits in settings.minimumValue and settings.maximumValue\n         *\n         * @param {string} value\n         * @param {object} settings\n         * @returns {*}\n         */\n\n    }, {\n        key: '_checkIfInRangeWithOverrideOption',\n        value: function _checkIfInRangeWithOverrideOption(value, settings) {\n            value = value.toString();\n            value = value.replace(',', '.');\n            var minParse = _AutoNumericHelper2.default.parseStr(settings.minimumValue);\n            var maxParse = _AutoNumericHelper2.default.parseStr(settings.maximumValue);\n            var valParse = _AutoNumericHelper2.default.parseStr(value);\n\n            var result = void 0;\n            switch (settings.overrideMinMaxLimits) {\n                case AutoNumeric.options.overrideMinMaxLimits.floor:\n                    result = [_AutoNumericHelper2.default.testMinMax(minParse, valParse) > -1, true];\n                    break;\n                case AutoNumeric.options.overrideMinMaxLimits.ceiling:\n                    result = [true, _AutoNumericHelper2.default.testMinMax(maxParse, valParse) < 1];\n                    break;\n                case AutoNumeric.options.overrideMinMaxLimits.ignore:\n                    result = [true, true];\n                    break;\n                default:\n                    result = [_AutoNumericHelper2.default.testMinMax(minParse, valParse) > -1, _AutoNumericHelper2.default.testMinMax(maxParse, valParse) < 1];\n            }\n\n            return result;\n        }\n    }, {\n        key: '_readCookie',\n        value: function _readCookie(name) {\n            var nameEQ = name + '=';\n            var ca = document.cookie.split(';');\n            var c = '';\n            for (var i = 0; i < ca.length; i += 1) {\n                c = ca[i];\n                while (c.charAt(0) === ' ') {\n                    c = c.substring(1, c.length);\n                }\n                if (c.indexOf(nameEQ) === 0) {\n                    return c.substring(nameEQ.length, c.length);\n                }\n            }\n\n            return null;\n        }\n\n        /**\n         * Test if sessionStorage is supported.\n         * This is taken from Modernizr.\n         *\n         * @returns {boolean}\n         */\n\n    }, {\n        key: '_storageTest',\n        value: function _storageTest() {\n            var mod = 'modernizr';\n            try {\n                sessionStorage.setItem(mod, mod);\n                sessionStorage.removeItem(mod);\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n    }, {\n        key: '_correctNegativePositiveSignPlacementOption',\n        value: function _correctNegativePositiveSignPlacementOption(settings) {\n            //XXX Note; this function is static since we need to pass a `settings` object when calling the static `AutoNumeric.format()` method\n            // If negativePositiveSignPlacement is already set, we do not overwrite it\n            if (!_AutoNumericHelper2.default.isNull(settings.negativePositiveSignPlacement)) {\n                return;\n            }\n\n            if (!_AutoNumericHelper2.default.isUndefined(settings) && _AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(settings.negativePositiveSignPlacement) && !_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(settings.currencySymbol)) {\n                switch (settings.currencySymbolPlacement) {\n                    case AutoNumeric.options.currencySymbolPlacement.suffix:\n                        settings.negativePositiveSignPlacement = AutoNumeric.options.negativePositiveSignPlacement.prefix; // Default -1,234.56 €\n                        break;\n                    case AutoNumeric.options.currencySymbolPlacement.prefix:\n                        settings.negativePositiveSignPlacement = AutoNumeric.options.negativePositiveSignPlacement.left; // Default -$1,234.56\n                        break;\n                    default:\n                    //\n                }\n            } else {\n                // Sets the default value if `negativePositiveSignPlacement` is `null`\n                settings.negativePositiveSignPlacement = AutoNumeric.options.negativePositiveSignPlacement.left;\n            }\n        }\n\n        /**\n         * Correct the `caretPositionOnFocus` and `selectOnFocus` options, since setting both leads to a conflict.\n         * This method directly modifies the `options` object passed as a parameter, then returns it.\n         * It returns `null` if the given option is `null`.\n         *\n         * @param {object} options The options passed as an argument by the user\n         * @returns {object|null}\n         * @private\n         */\n\n    }, {\n        key: '_correctCaretPositionOnFocusAndSelectOnFocusOptions',\n        value: function _correctCaretPositionOnFocusAndSelectOnFocusOptions(options) {\n            if (_AutoNumericHelper2.default.isNull(options)) {\n                return null;\n            }\n\n            // If the user has set the `caretPositionOnFocus` option, do not set `selectOnFocus` to `true` by default\n            if (!_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(options.caretPositionOnFocus) && _AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(options.selectOnFocus)) {\n                options.selectOnFocus = AutoNumeric.options.selectOnFocus.doNotSelect;\n            }\n\n            // If the user has set the `selectOnFocus` option to `true`, set `caretPositionOnFocus` to `doNoForceCaretPosition`\n            if (_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(options.caretPositionOnFocus) && !_AutoNumericHelper2.default.isUndefinedOrNullOrEmpty(options.selectOnFocus) && options.selectOnFocus === AutoNumeric.options.selectOnFocus.select) {\n                options.caretPositionOnFocus = AutoNumeric.options.caretPositionOnFocus.doNoForceCaretPosition;\n            }\n\n            return options;\n        }\n\n        /**\n         * Calculate the number de decimal places to be used by the AutoNumeric object, for each of its state, and for its formatted and raw value.\n         * By default, the `rawValue` precision is the same as the formatted value one.\n         *\n         * This method is called during the AutoNumeric object initialization. This assumes some internal variable state.\n         *\n         * This methods set the following options accordingly to their own value and the mandatory `decimalPlaces` option:\n         * - decimalPlacesRawValue     (nullable)\n         * - decimalPlacesShownOnBlur  (nullable)\n         * - decimalPlacesShownOnFocus (nullable)\n         *\n         * Note: the `decimalPlaces` option is only used here and only serve to define those three previous options value.\n         * AutoNumeric will then *only* use `decimalPlacesRawValue`, `decimalPlacesShownOnBlur` and `decimalPlacesShownOnFocus` from there.\n         *\n         * This methods directly modifies the `settings` object passed as a parameter.\n         *\n         * @param {object} settings This is an object with the new settings to use.\n         * @private\n         */\n\n    }, {\n        key: '_calculateDecimalPlacesOnInit',\n        value: function _calculateDecimalPlacesOnInit(settings) {\n            // Check the `decimalPlaces*` options and output any warnings as needed, before modifying those options\n            this._validateDecimalPlacesRawValue(settings);\n\n            // Initialization phase\n            //XXX This assumes at this stage, `settings.decimalPlaces` as been set from the default options\n\n            // Overwrite the `decimalPlaces*` values if the `decimalPlaces*` options are not set in the `settings`\n            // Sets `decimalPlacesShownOnBlur` (previously known as `scaleDecimalPlaces`)\n            if (settings.decimalPlacesShownOnFocus === AutoNumeric.options.decimalPlacesShownOnFocus.useDefault) {\n                settings.decimalPlacesShownOnFocus = settings.decimalPlaces;\n            }\n\n            if (settings.decimalPlacesShownOnBlur === AutoNumeric.options.decimalPlacesShownOnBlur.useDefault) {\n                settings.decimalPlacesShownOnBlur = settings.decimalPlaces;\n            }\n\n            if (settings.decimalPlacesRawValue === AutoNumeric.options.decimalPlacesRawValue.useDefault) {\n                settings.decimalPlacesRawValue = settings.decimalPlaces;\n            }\n\n            // Add the additional decimal places to the raw value\n            var additionalDecimalPlacesRawValue = 0;\n            if (settings.rawValueDivisor && settings.rawValueDivisor !== AutoNumeric.options.rawValueDivisor.none) {\n                additionalDecimalPlacesRawValue = String(settings.rawValueDivisor).length - 1; // ie. Dividing by '100' adds 2 decimal places to the needed precision\n                if (additionalDecimalPlacesRawValue < 0) {\n                    additionalDecimalPlacesRawValue = 0;\n                }\n            }\n\n            settings.decimalPlacesRawValue = Math.max(Math.max(settings.decimalPlacesShownOnBlur, settings.decimalPlacesShownOnFocus) + additionalDecimalPlacesRawValue, Number(settings.originalDecimalPlacesRawValue) + additionalDecimalPlacesRawValue);\n        }\n\n        /**\n         * Recalculate the number de decimal places to be used by the AutoNumeric object, for each of its state, and for its formatted and raw value.\n         * By default, the `rawValue` precision is the same as the formatted value one.\n         *\n         * This method is close to the one called during initialization, `_calculateDecimalPlacesOnInit()`, but with slight difference so that the `decimalPlaces*` options are correctly updated as needed.\n         *\n         * This methods set the following options accordingly to their own value and the mandatory `decimalPlaces` option:\n         * - decimalPlacesRawValue     (nullable)\n         * - decimalPlacesShownOnBlur  (nullable)\n         * - decimalPlacesShownOnFocus (nullable)\n         *\n         * Note: the `decimalPlaces` option is only used here and only serve to define those three previous options value.\n         * AutoNumeric will then *only* use `decimalPlacesRawValue`, `decimalPlacesShownOnBlur` and `decimalPlacesShownOnFocus` from there.\n         *\n         * This methods directly modifies the `settings` object passed as a parameter.\n         *\n         * @param {object} settings This is an object with the new settings to use.\n         * @param {object} currentSettings This is the current settings (`this.settings`) used by the element.\n         * @private\n         */\n\n    }, {\n        key: '_calculateDecimalPlacesOnUpdate',\n        value: function _calculateDecimalPlacesOnUpdate(settings) {\n            var currentSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            // Check the `decimalPlaces*` options and output any warnings as needed, before modifying those options\n            this._validateDecimalPlacesRawValue(settings);\n\n            // Update phase\n            if (_AutoNumericHelper2.default.isNull(currentSettings)) {\n                _AutoNumericHelper2.default.throwError('When updating the settings, the previous ones should be passed as an argument.');\n            }\n\n            var decimalPlacesInOptions = 'decimalPlaces' in settings;\n            if (!(decimalPlacesInOptions || 'decimalPlacesRawValue' in settings || 'decimalPlacesShownOnFocus' in settings || 'decimalPlacesShownOnBlur' in settings || 'rawValueDivisor' in settings)) {\n                // Do Nothing if no decimal places-related options are modified\n                return;\n            }\n\n            // Overwrite the `decimalPlaces*` values if the `decimalPlaces*` options are not set in the `settings`\n            if (decimalPlacesInOptions) {\n                if (!('decimalPlacesShownOnFocus' in settings) || settings.decimalPlacesShownOnFocus === AutoNumeric.options.decimalPlacesShownOnFocus.useDefault) {\n                    settings.decimalPlacesShownOnFocus = settings.decimalPlaces;\n                }\n\n                if (!('decimalPlacesShownOnBlur' in settings) || settings.decimalPlacesShownOnBlur === AutoNumeric.options.decimalPlacesShownOnBlur.useDefault) {\n                    settings.decimalPlacesShownOnBlur = settings.decimalPlaces;\n                }\n\n                if (!('decimalPlacesRawValue' in settings) || settings.decimalPlacesRawValue === AutoNumeric.options.decimalPlacesRawValue.useDefault) {\n                    settings.decimalPlacesRawValue = settings.decimalPlaces;\n                }\n            } else {\n                if (_AutoNumericHelper2.default.isUndefined(settings.decimalPlacesShownOnFocus)) {\n                    settings.decimalPlacesShownOnFocus = currentSettings.decimalPlacesShownOnFocus;\n                }\n\n                if (_AutoNumericHelper2.default.isUndefined(settings.decimalPlacesShownOnBlur)) {\n                    settings.decimalPlacesShownOnBlur = currentSettings.decimalPlacesShownOnBlur;\n                }\n            }\n\n            // Add the additional decimal places to the raw value\n            var additionalDecimalPlacesRawValue = 0;\n            if (settings.rawValueDivisor && settings.rawValueDivisor !== AutoNumeric.options.rawValueDivisor.none) {\n                additionalDecimalPlacesRawValue = String(settings.rawValueDivisor).length - 1; // ie. Dividing by '100' adds 2 decimal places to the needed precision\n                if (additionalDecimalPlacesRawValue < 0) {\n                    additionalDecimalPlacesRawValue = 0;\n                }\n            }\n\n            if (!settings.decimalPlaces && !settings.decimalPlacesRawValue) {\n                settings.decimalPlacesRawValue = Math.max(Math.max(settings.decimalPlacesShownOnBlur, settings.decimalPlacesShownOnFocus) + additionalDecimalPlacesRawValue, Number(currentSettings.originalDecimalPlacesRawValue) + additionalDecimalPlacesRawValue);\n            } else {\n                settings.decimalPlacesRawValue = Math.max(Math.max(settings.decimalPlacesShownOnBlur, settings.decimalPlacesShownOnFocus) + additionalDecimalPlacesRawValue, Number(settings.decimalPlacesRawValue) + additionalDecimalPlacesRawValue);\n            }\n        }\n    }, {\n        key: '_cachesUsualRegularExpressions',\n        value: function _cachesUsualRegularExpressions(settings, regex) {\n            var allNumbersReg = '[0-9]';\n            var noAllNumbersReg = '[^0-9]';\n\n            // Test if there is a negative character in the string\n            var aNegReg = settings.negativeSignCharacter ? '([-\\\\' + settings.negativeSignCharacter + ']?)' : '(-?)';\n            regex.aNegRegAutoStrip = aNegReg;\n\n            var negativeSignRegPart = void 0;\n            if (settings.negativeSignCharacter) {\n                negativeSignRegPart = '\\\\' + settings.negativeSignCharacter;\n            } else {\n                negativeSignRegPart = '';\n            }\n\n            settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + negativeSignRegPart + '\\\\' + settings.decimalCharacter + allNumbersReg + '].*?(' + allNumbersReg + '|\\\\' + settings.decimalCharacter + allNumbersReg + ')');\n            settings.skipLastAutoStrip = new RegExp('(' + allNumbersReg + '\\\\' + settings.decimalCharacter + '?)[^\\\\' + settings.decimalCharacter + allNumbersReg + ']' + noAllNumbersReg + '*$');\n\n            var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n            settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'g');\n            settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.decimalCharacter + '?(' + allNumbersReg + '+\\\\' + settings.decimalCharacter + allNumbersReg + '+)|(' + allNumbersReg + '*(?:\\\\' + settings.decimalCharacter + allNumbersReg + '*)?))');\n\n            // Using this regex version `^${regex.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n            settings.stripReg = new RegExp('^' + regex.aNegRegAutoStrip + '0*(' + allNumbersReg + ')');\n        }\n    }, {\n        key: '_convertOldOptionsToNewOnes',\n        value: function _convertOldOptionsToNewOnes(options) {\n            //TODO Delete this function once the old options are not used anymore\n            var oldOptionsConverter = {\n                // Old option names, with their corresponding new names\n                aSep: 'digitGroupSeparator',\n                nSep: 'showOnlyNumbersOnFocus',\n                dGroup: 'digitalGroupSpacing',\n                aDec: 'decimalCharacter',\n                altDec: 'decimalCharacterAlternative',\n                aSign: 'currencySymbol',\n                pSign: 'currencySymbolPlacement',\n                pNeg: 'negativePositiveSignPlacement',\n                aSuffix: 'suffixText',\n                oLimits: 'overrideMinMaxLimits',\n                vMax: 'maximumValue',\n                vMin: 'minimumValue',\n                mDec: 'decimalPlacesOverride',\n                eDec: 'decimalPlacesShownOnFocus',\n                scaleDecimal: 'decimalPlacesShownOnBlur',\n                aStor: 'saveValueToSessionStorage',\n                mRound: 'roundingMethod',\n                aPad: 'allowDecimalPadding',\n                nBracket: 'negativeBracketsTypeOnBlur',\n                wEmpty: 'emptyInputBehavior',\n                lZero: 'leadingZero',\n                aForm: 'formatOnPageLoad',\n                sNumber: 'selectNumberOnly',\n                anDefault: 'defaultValueOverride',\n                unSetOnSubmit: 'unformatOnSubmit',\n                outputType: 'outputFormat',\n                debug: 'showWarnings',\n\n                // Current options :\n                allowDecimalPadding: true,\n                caretPositionOnFocus: true,\n                createLocalList: true,\n                currencySymbol: true,\n                currencySymbolPlacement: true,\n                decimalCharacter: true,\n                decimalCharacterAlternative: true,\n                decimalPlaces: true,\n                decimalPlacesRawValue: true,\n                decimalPlacesShownOnBlur: true,\n                decimalPlacesShownOnFocus: true,\n                defaultValueOverride: true,\n                digitalGroupSpacing: true,\n                digitGroupSeparator: true,\n                divisorWhenUnfocused: true,\n                emptyInputBehavior: true,\n                failOnUnknownOption: true,\n                formatOnPageLoad: true,\n                historySize: true,\n                isCancellable: true,\n                leadingZero: true,\n                maximumValue: true,\n                minimumValue: true,\n                modifyValueOnWheel: true,\n                negativeBracketsTypeOnBlur: true,\n                negativePositiveSignPlacement: true,\n                noEventListeners: true,\n                onInvalidPaste: true,\n                outputFormat: true,\n                overrideMinMaxLimits: true,\n                rawValueDivisor: true,\n                readOnly: true,\n                roundingMethod: true,\n                saveValueToSessionStorage: true,\n                selectNumberOnly: true,\n                selectOnFocus: true,\n                serializeSpaces: true,\n                showOnlyNumbersOnFocus: true,\n                showPositiveSign: true,\n                showWarnings: true,\n                styleRules: true,\n                suffixText: true,\n                symbolWhenUnfocused: true,\n                unformatOnHover: true,\n                unformatOnSubmit: true,\n                valuesToStrings: true,\n                wheelStep: true,\n\n                // Additional information that are added to the `settings` object :\n                //FIXME Find a way to exclude those internal data from the settings object (ideally by using another object, or better yet, class attributes) -->\n                allowedAutoStrip: true,\n                mIntNeg: true,\n                mIntPos: true,\n                negativeSignCharacter: true,\n                numRegAutoStrip: true,\n                originalDecimalPlaces: true,\n                originalDecimalPlacesRawValue: true,\n                positiveSignCharacter: true,\n                skipFirstAutoStrip: true,\n                skipLastAutoStrip: true,\n                stripReg: true\n            };\n\n            for (var option in options) {\n                if (options.hasOwnProperty(option)) {\n                    if (oldOptionsConverter[option] === true) {\n                        // If the option is a 'new' option, we continue looping\n                        continue;\n                    }\n\n                    if (oldOptionsConverter.hasOwnProperty(option)) {\n                        // Else we have an 'old' option name\n                        _AutoNumericHelper2.default.warning('You are using the deprecated option name \\'' + option + '\\'. Please use \\'' + oldOptionsConverter[option] + '\\' instead from now on. The old option name will be dropped very soon\\u2122.', true);\n\n                        // Then we modify the initial option object to use the new options instead of the old ones\n                        options[oldOptionsConverter[option]] = options[option];\n                        delete options[option];\n                    } else if (options.failOnUnknownOption) {\n                        // ...or the option name is unknown. This means there is a problem with the options object, therefore we throw an error.\n                        _AutoNumericHelper2.default.throwError('Option name \\'' + option + '\\' is unknown. Please fix the options passed to autoNumeric');\n                    }\n                }\n            }\n\n            if ('mDec' in options) {\n                _AutoNumericHelper2.default.warning('The old `mDec` option has been deprecated in favor of more accurate options ; `decimalPlaces`, `decimalPlacesRawValue`, `decimalPlacesShownOnFocus` and `decimalPlacesShownOnBlur`.', true);\n            }\n        }\n    }, {\n        key: '_toNumericValue',\n        value: function _toNumericValue(value, settings) {\n            //XXX Note; this function is static since we need to pass a `settings` object when calling the static `AutoNumeric.format()` method\n            var result = void 0;\n            if (_AutoNumericHelper2.default.isNumber(Number(value))) {\n                // The value has either already been stripped, or a 'real' javascript number is passed as a parameter\n                result = value;\n            } else {\n                // Else if it's a string that `Number()` cannot typecast, then we try to convert the localized numeric string to a numeric one\n                // Convert the value to a numeric string, stripping unnecessary characters in the process\n                result = this._convertToNumericString(value.toString(), settings);\n\n                // If the result is still not a numeric string, then we throw a warning\n                if (!_AutoNumericHelper2.default.isNumber(Number(result))) {\n                    _AutoNumericHelper2.default.warning('The value \"' + value + '\" being \\'set\\' is not numeric and therefore cannot be used appropriately.', settings.showWarnings);\n                    result = NaN;\n                }\n            }\n\n            return result;\n        }\n    }, {\n        key: '_checkIfInRange',\n        value: function _checkIfInRange(value, parsedMinValue, parsedMaxValue) {\n            var parsedValue = _AutoNumericHelper2.default.parseStr(value);\n            return _AutoNumericHelper2.default.testMinMax(parsedMinValue, parsedValue) > -1 && _AutoNumericHelper2.default.testMinMax(parsedMaxValue, parsedValue) < 1;\n        }\n    }, {\n        key: '_shouldSkipEventKey',\n        value: function _shouldSkipEventKey(eventKeyName) {\n            var isFnKeys = _AutoNumericHelper2.default.isInArray(eventKeyName, _AutoNumericEnum2.default.keyName._allFnKeys);\n            var isOSKeys = eventKeyName === _AutoNumericEnum2.default.keyName.OSLeft || eventKeyName === _AutoNumericEnum2.default.keyName.OSRight;\n            var isContextMenu = eventKeyName === _AutoNumericEnum2.default.keyName.ContextMenu;\n            var isSomeNonPrintableKeys = _AutoNumericHelper2.default.isInArray(eventKeyName, _AutoNumericEnum2.default.keyName._someNonPrintableKeys);\n            var isOtherNonPrintableKeys = eventKeyName === _AutoNumericEnum2.default.keyName.NumLock || eventKeyName === _AutoNumericEnum2.default.keyName.ScrollLock || eventKeyName === _AutoNumericEnum2.default.keyName.Insert || eventKeyName === _AutoNumericEnum2.default.keyName.Command;\n            var isUnrecognizableKeys = eventKeyName === _AutoNumericEnum2.default.keyName.Unidentified;\n\n            return isFnKeys || isOSKeys || isContextMenu || isSomeNonPrintableKeys || isUnrecognizableKeys || isOtherNonPrintableKeys;\n        }\n    }, {\n        key: '_serialize',\n        value: function _serialize(form) {\n            var intoAnArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n            var formatType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'unformatted';\n\n            var _this8 = this;\n\n            var serializedSpaceCharacter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '+';\n            var forcedOutputFormat = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n            var result = [];\n\n            if ((typeof form === 'undefined' ? 'undefined' : _typeof(form)) === 'object' && form.nodeName.toLowerCase() === 'form') {\n                Array.prototype.slice.call(form.elements).forEach(function (element) {\n                    if (element.name && !element.disabled && ['file', 'reset', 'submit', 'button'].indexOf(element.type) === -1) {\n                        if (element.type === 'select-multiple') {\n                            Array.prototype.slice.call(element.options).forEach(function (option) {\n                                if (option.selected) {\n                                    //TODO Should we unformat/format/localize the selection option (which be default should be read-only)?\n                                    if (intoAnArray) {\n                                        result.push({ name: element.name, value: option.value });\n                                    } else {\n                                        // into a string\n                                        result.push(encodeURIComponent(element.name) + '=' + encodeURIComponent(option.value));\n                                    }\n                                }\n                            });\n                        } else if (['checkbox', 'radio'].indexOf(element.type) === -1 || element.checked) {\n                            var valueResult = void 0;\n                            if (_this8.isManagedByAutoNumeric(element)) {\n                                var anObject = void 0;\n                                switch (formatType) {\n                                    case 'unformatted':\n                                        anObject = _this8.getAutoNumericElement(element);\n                                        if (!_AutoNumericHelper2.default.isNull(anObject)) {\n                                            valueResult = _this8.unformat(element, anObject.getSettings());\n                                        }\n                                        break;\n                                    case 'localized':\n                                        anObject = _this8.getAutoNumericElement(element);\n                                        if (!_AutoNumericHelper2.default.isNull(anObject)) {\n                                            // Here I need to clone the setting object, otherwise I would modify it when changing the `outputFormat` option value\n                                            var currentSettings = _AutoNumericHelper2.default.cloneObject(anObject.getSettings());\n                                            if (!_AutoNumericHelper2.default.isNull(forcedOutputFormat)) {\n                                                currentSettings.outputFormat = forcedOutputFormat;\n                                            }\n\n                                            valueResult = _this8.localize(element, currentSettings);\n                                        }\n                                        break;\n                                    case 'formatted':\n                                    default:\n                                        valueResult = element.value;\n                                }\n                            } else {\n                                valueResult = element.value;\n                            }\n\n                            if (_AutoNumericHelper2.default.isUndefined(valueResult)) {\n                                _AutoNumericHelper2.default.throwError('This error should never be hit. If it has, something really wrong happened!');\n                            }\n\n                            if (intoAnArray) {\n                                result.push({ name: element.name, value: valueResult });\n                            } else {\n                                // into a string\n                                result.push(encodeURIComponent(element.name) + '=' + encodeURIComponent(valueResult));\n                            }\n                        }\n                    }\n                });\n            }\n\n            var finalResult = void 0;\n\n            if (intoAnArray) {\n                // Result as an Array\n                // Note: `serializedSpaceCharacter` does not affect the array result since we do not change the space character for this one\n                finalResult = result;\n            } else {\n                // Result as a string\n                finalResult = result.join('&');\n\n                if ('+' === serializedSpaceCharacter) {\n                    finalResult = finalResult.replace(/%20/g, '+');\n                }\n            }\n\n            return finalResult;\n        }\n\n        /**\n         * Serialize the form values to a string, outputting numeric strings for each AutoNumeric-managed element values.\n         *\n         * @param {HTMLFormElement} form\n         * @param {string} serializedSpaceCharacter\n         * @returns {string}\n         */\n\n    }, {\n        key: '_serializeNumericString',\n        value: function _serializeNumericString(form) {\n            var serializedSpaceCharacter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '+';\n\n            return this._serialize(form, false, 'unformatted', serializedSpaceCharacter);\n        }\n\n        /**\n         * Serialize the form values to a string, outputting the formatted value as strings for each AutoNumeric-managed elements.\n         *\n         * @param {HTMLFormElement} form\n         * @param {string} serializedSpaceCharacter\n         * @returns {string}\n         */\n\n    }, {\n        key: '_serializeFormatted',\n        value: function _serializeFormatted(form) {\n            var serializedSpaceCharacter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '+';\n\n            return this._serialize(form, false, 'formatted', serializedSpaceCharacter);\n        }\n\n        /**\n         * Serialize the form values to a string, outputting localized strings for each AutoNumeric-managed element values.\n         *\n         * @param {HTMLFormElement} form\n         * @param {string} serializedSpaceCharacter\n         * @param {string|null} forcedOutputFormat If set, then this is the format that is used for the localization, instead of the default `outputFormat` option.\n         * @returns {string}\n         */\n\n    }, {\n        key: '_serializeLocalized',\n        value: function _serializeLocalized(form) {\n            var serializedSpaceCharacter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '+';\n            var forcedOutputFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n            return this._serialize(form, false, 'localized', serializedSpaceCharacter, forcedOutputFormat);\n        }\n\n        /**\n         * Generate an Array with the form values, outputting numeric strings for each AutoNumeric-managed element values.\n         *\n         * @param {HTMLFormElement} form\n         * @param {string} serializedSpaceCharacter\n         * @returns {Array}\n         */\n\n    }, {\n        key: '_serializeNumericStringArray',\n        value: function _serializeNumericStringArray(form) {\n            var serializedSpaceCharacter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '+';\n\n            return this._serialize(form, true, 'unformatted', serializedSpaceCharacter);\n        }\n\n        /**\n         * Generate an Array with the form values, outputting the formatted value as strings for each AutoNumeric-managed elements.\n         *\n         * @param {HTMLFormElement} form\n         * @param {string} serializedSpaceCharacter\n         * @returns {Array}\n         */\n\n    }, {\n        key: '_serializeFormattedArray',\n        value: function _serializeFormattedArray(form) {\n            var serializedSpaceCharacter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '+';\n\n            return this._serialize(form, true, 'formatted', serializedSpaceCharacter);\n        }\n\n        /**\n         * Generate an Array with the form values, outputting localized strings for each AutoNumeric-managed element values.\n         *\n         * @param {HTMLFormElement} form\n         * @param {string} serializedSpaceCharacter\n         * @param {string|null} forcedOutputFormat If set, then this is the format that is used for the localization, instead of the default `outputFormat` option.\n         * @returns {Array}\n         */\n\n    }, {\n        key: '_serializeLocalizedArray',\n        value: function _serializeLocalizedArray(form) {\n            var serializedSpaceCharacter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '+';\n            var forcedOutputFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n            return this._serialize(form, true, 'localized', serializedSpaceCharacter, forcedOutputFormat);\n        }\n    }]);\n\n    return AutoNumeric;\n}();\n\n/**\n * Initialize multiple DOM elements in one call (and possibly pass multiple values that will be mapped to each DOM element).\n *\n * @example\n * // Init multiple DOM elements in one call (and possibly pass multiple values that will be mapped to each DOM element)\n * [anElement1, anElement2, anElement3] = AutoNumeric.multiple([domElement1, domElement2, domElement3], { options });\n * [anElement1, anElement2, anElement3] = AutoNumeric.multiple([domElement1, domElement2, domElement3], [{ options }, 'euroPos']);\n * [anElement1, anElement2, anElement3] = AutoNumeric.multiple([domElement1, domElement2, domElement3], 12345.789, { options });\n * [anElement1, anElement2, anElement3] = AutoNumeric.multiple([domElement1, domElement2, domElement3], 12345.789, [{ options }, 'euroPos']);\n * [anElement1, anElement2, anElement3] = AutoNumeric.multiple.french([domElement1, domElement2, domElement3], [12345.789, 234.78, null], { options });\n * [anElement1, anElement2, anElement3] = AutoNumeric.multiple.french([domElement1, domElement2, domElement3], [12345.789, 234.78, null], [{ options }, 'euroPos']);\n *\n * // Special case, if a <form> element is passed (or any other 'parent' (or 'root') DOM element), then autoNumeric will initialize each child `<input>` elements recursively, ignoring those referenced in the `exclude` attribute\n * [anElement1, anElement2] = AutoNumeric.multiple({ rootElement: formElement }, { options });\n * [anElement1, anElement2] = AutoNumeric.multiple({ rootElement: formElement, exclude : [hiddenElement, tokenElement] }, { options });\n * [anElement1, anElement2] = AutoNumeric.multiple({ rootElement: formElement, exclude : [hiddenElement, tokenElement] }, [12345.789, null], { options });\n *\n * // If you want to select multiple elements via a css selector, then you must use the `multiple` function. Under the hood `QuerySelectorAll` is used.\n * [anElement1, anElement2] = AutoNumeric.multiple('.myCssClass > input', { options }); // This always return an Array, even if there is only one element selected\n * [anElement1, anElement2] = AutoNumeric.multiple('.myCssClass > input', [null, 12345.789], { options }); // Idem above, but with passing the initial values too\n *\n * @param {string|Array|{ rootElement: HTMLElement }|{ rootElement: HTMLElement, exclude: Array<HTMLInputElement>}} arg1\n * @param {number|Array|object|null} initialValue\n * @param {object|Array|null} options\n * @returns {Array}\n */\n\n\nAutoNumeric.multiple = function (arg1) {\n    var initialValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    var result = [];\n\n    // Analyze the arguments and transform them to make them exploitable\n    if (_AutoNumericHelper2.default.isObject(initialValue)) {\n        // If the user gave an option object as the second argument, instead of the initial values\n        options = initialValue;\n        initialValue = null;\n    }\n\n    if (_AutoNumericHelper2.default.isString(arg1)) {\n        arg1 = [].concat(_toConsumableArray(document.querySelectorAll(arg1))); // Convert a NodeList to an Array (cf. http://stackoverflow.com/a/37297292/2834898)\n    } else if (_AutoNumericHelper2.default.isObject(arg1)) {\n        if (!arg1.hasOwnProperty('rootElement')) {\n            _AutoNumericHelper2.default.throwError('The object passed to the \\'multiple\\' function is invalid ; no \\'rootElement\\' attribute found.');\n        }\n\n        // Retrieve the DOM element list from the given <form> element\n        var elements = [].concat(_toConsumableArray(arg1.rootElement.querySelectorAll('input')));\n        if (arg1.hasOwnProperty('exclude')) {\n            if (!Array.isArray(arg1.exclude)) {\n                _AutoNumericHelper2.default.throwError('The \\'exclude\\' array passed to the \\'multiple\\' function is invalid.');\n            }\n\n            // Filter out the excluded elements\n            arg1 = _AutoNumericHelper2.default.filterOut(elements, arg1.exclude);\n        } else {\n            arg1 = elements;\n        }\n    } else if (!_AutoNumericHelper2.default.isArray(arg1)) {\n        _AutoNumericHelper2.default.throwError('The given parameters to the \\'multiple\\' function are invalid.');\n    }\n\n    if (arg1.length === 0) {\n        var showWarnings = true;\n        if (!_AutoNumericHelper2.default.isNull(options) && _AutoNumericHelper2.default.isBoolean(options.showWarnings)) {\n            showWarnings = options.showWarnings;\n        }\n\n        _AutoNumericHelper2.default.warning('No valid DOM elements were given hence no AutoNumeric object were instantiated.', showWarnings);\n\n        return [];\n    }\n\n    // At this point, we know `arg1` is an array of DOM elements\n\n    // This function can be initialized with two types of array, one for the initial values, and/or one for the options.\n    // So we need to find out if an array is detected if the user passed an array of initial values, or an array of options\n    // Therefore, we analyze the content of the arrays for the second and third arguments\n    // ...for the second parameter :\n    var isInitialValueArray = _AutoNumericHelper2.default.isArray(initialValue);\n    var isInitialValueArrayAndNotEmpty = isInitialValueArray && initialValue.length >= 1;\n    var secondArgumentIsInitialValueArray = false;\n    var secondArgumentIsOptionArray = false;\n    // Any of the arrays can be either an array of initial values, or an array of option object/pre-defined option names\n    if (isInitialValueArrayAndNotEmpty) {\n        var typeOfFirstArrayElement = _typeof(Number(initialValue[0]));\n        // First we test the second argument\n        secondArgumentIsInitialValueArray = typeOfFirstArrayElement === 'number' && !isNaN(Number(initialValue[0]));\n\n        if (!secondArgumentIsInitialValueArray) {\n            // If the second argument is an array, but not an array of values, check if it's instead an array of options/pre-defined option names\n            if (typeOfFirstArrayElement === 'string' || isNaN(typeOfFirstArrayElement) || typeOfFirstArrayElement === 'object') {\n                secondArgumentIsOptionArray = true;\n            }\n        }\n    }\n\n    // ...for the third parameter :\n    var isOptionsArrayAndNotEmpty = _AutoNumericHelper2.default.isArray(options) && options.length >= 1;\n    var thirdArgumentIsOptionArray = false;\n    if (isOptionsArrayAndNotEmpty) {\n        var _typeOfFirstArrayElement = _typeof(options[0]);\n        if (_typeOfFirstArrayElement === 'string' || _typeOfFirstArrayElement === 'object') {\n            // If the third argument is an array of options/pre-defined option names\n            thirdArgumentIsOptionArray = true;\n        }\n    }\n\n    // Depending of our findings, we generate the options variable to use `optionsToUse`, either directly, or merged\n    var optionsToUse = void 0;\n    if (secondArgumentIsOptionArray) {\n        optionsToUse = AutoNumeric.mergeOptions(initialValue);\n    } else if (thirdArgumentIsOptionArray) {\n        optionsToUse = AutoNumeric.mergeOptions(options);\n    } else {\n        optionsToUse = options;\n    }\n\n    // Initialize the initial values\n    var isInitialValueNumber = _AutoNumericHelper2.default.isNumber(initialValue);\n    var initialValueArraySize = void 0;\n    if (secondArgumentIsInitialValueArray) {\n        initialValueArraySize = initialValue.length;\n    }\n\n    // Instantiate each AutoNumeric objects\n    arg1.forEach(function (domElement, index) {\n        if (isInitialValueNumber) {\n            // We set the same value for each elements\n            result.push(new AutoNumeric(domElement, initialValue, optionsToUse));\n        } else if (secondArgumentIsInitialValueArray && index <= initialValueArraySize) {\n            result.push(new AutoNumeric(domElement, initialValue[index], optionsToUse));\n        } else {\n            result.push(new AutoNumeric(domElement, null, optionsToUse));\n        }\n    });\n\n    return result;\n};\n\n/**\n * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\n * //TODO Make sure we call that at least once when loading the AutoNumeric library\n */\n(function () {\n    if (typeof window.CustomEvent === 'function') {\n        return false;\n    }\n\n    function CustomEvent(event, params) {\n        params = params || { bubbles: false, cancelable: false, detail: void 0 };\n        var evt = document.createEvent('CustomEvent');\n        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n        return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n    window.CustomEvent = CustomEvent;\n})();\n\n/**\n * //XXX This is needed in order to get direct access to the `AutoNumeric` constructor without having to use `new AutoNumeric.default()` (cf. http://stackoverflow.com/a/36389244/2834898) : using `export var __useDefault = true;` does not work though.\n * //XXX The workaround (using `module.exports = AutoNumeric` instead of `export default class AutoNumeric {}`) comes from https://github.com/webpack/webpack/issues/706#issuecomment-167908576\n * //XXX And the explanation why Babel 6 changed the way Babel 5 worked : http://stackoverflow.com/a/33506169/2834898\n * //XXX Ideally, we should be able to just declare `export default class AutoNumeric {}` in the future, and remove the following `module.exports = AutoNumeric;` line\n *\n * @type {AutoNumeric}\n */\nmodule.exports = AutoNumeric;\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXV0b051bWVyaWMuanM/YjJlOSJdLCJuYW1lcyI6WyJBdXRvTnVtZXJpYyIsImFyZzEiLCJhcmcyIiwiYXJnMyIsIl9zZXRBcmd1bWVudHNWYWx1ZXMiLCJkb21FbGVtZW50IiwiaW5pdGlhbFZhbHVlIiwidXNlck9wdGlvbnMiLCJkZWZhdWx0UmF3VmFsdWUiLCJfc2V0U2V0dGluZ3MiLCJfY2hlY2tFbGVtZW50Iiwic2F2ZWRDYW5jZWxsYWJsZVZhbHVlIiwiaGlzdG9yeVRhYmxlIiwiaGlzdG9yeVRhYmxlSW5kZXgiLCJvbkdvaW5nUmVkbyIsInBhcmVudEZvcm0iLCJfZ2V0UGFyZW50Rm9ybSIsInJ1bk9uY2UiLCJzZXR0aW5ncyIsImZvcm1hdE9uUGFnZUxvYWQiLCJfZm9ybWF0RGVmYXVsdFZhbHVlT25QYWdlTG9hZCIsImlzSW5wdXRFbGVtZW50IiwiaXNDb250ZW50RWRpdGFibGUiLCJub0V2ZW50TGlzdGVuZXJzIiwiX2NyZWF0ZUV2ZW50TGlzdGVuZXJzIiwiX3NldFJlYWRPbmx5IiwiX3NhdmVJbml0aWFsVmFsdWVzIiwic2Vzc2lvblN0b3JhZ2VBdmFpbGFibGUiLCJjb25zdHJ1Y3RvciIsIl9zdG9yYWdlVGVzdCIsInN0b3JhZ2VOYW1lUHJlZml4IiwiX3NldFBlcnNpc3RlbnRTdG9yYWdlTmFtZSIsImlzRm9jdXNlZCIsImlzV2hlZWxFdmVudCIsImlzRHJvcEV2ZW50IiwiaXNFZGl0aW5nIiwiY3JlYXRlTG9jYWxMaXN0IiwiX2NyZWF0ZUxvY2FsTGlzdCIsIl9hZGRUb0dsb2JhbExpc3QiLCJnbG9iYWwiLCJzZXQiLCJuZXdWYWx1ZSIsIm9wdGlvbnMiLCJhdXRvTnVtZXJpY0xvY2FsTGlzdCIsImZvckVhY2giLCJhTk9iamVjdCIsInNldFVuZm9ybWF0dGVkIiwidmFsdWUiLCJnZXQiLCJjYWxsYmFjayIsInJlc3VsdCIsInB1c2giLCJfZXhlY3V0ZUNhbGxiYWNrIiwiZ2V0TnVtZXJpY1N0cmluZyIsImdldEZvcm1hdHRlZCIsImdldE51bWJlciIsImdldExvY2FsaXplZCIsInJlZm9ybWF0IiwidW5mb3JtYXQiLCJ1bmZvcm1hdExvY2FsaXplZCIsImZvcmNlZE91dHB1dEZvcm1hdCIsInVwZGF0ZSIsIm5ld09wdGlvbnMiLCJpc1ByaXN0aW5lIiwiY2hlY2tPbmx5UmF3VmFsdWUiLCJjbGVhciIsImZvcmNlQ2xlYXJBbGwiLCJyZW1vdmUiLCJ3aXBlIiwibnVrZSIsImhhcyIsImRvbUVsZW1lbnRPckF1dG9OdW1lcmljT2JqZWN0Iiwibm9kZSIsImFkZE9iamVjdCIsIm90aGVyQXV0b051bWVyaWNPYmplY3QiLCJnZXRBdXRvTnVtZXJpY0VsZW1lbnQiLCJfaGFzTG9jYWxMaXN0Iiwib3RoZXJBTkxvY2FsTGlzdCIsIl9nZXRMb2NhbExpc3QiLCJzaXplIiwibWVyZ2VkTG9jYWxMaXN0cyIsIk1hcCIsIm1lcmdlTWFwcyIsIl9hZGRUb0xvY2FsTGlzdCIsIl9zZXRMb2NhbExpc3QiLCJyZW1vdmVPYmplY3QiLCJrZWVwQ3VycmVudEFOT2JqZWN0IiwiaW5pdGlhbENvbXBsZXRlTG9jYWxMaXN0IiwiZGVsZXRlIiwiZW1wdHkiLCJrZWVwRWFjaEFOT2JqZWN0SW5JdHNPd25MaXN0IiwiZWxlbWVudHMiLCJnZXRMaXN0IiwicmVzZXQiLCJyYXdWYWx1ZSIsImRlZmF1bHRTZXR0aW5ncyIsImFsbG93RGVjaW1hbFBhZGRpbmciLCJjYXJldFBvc2l0aW9uT25Gb2N1cyIsIl9kZWxldGVMb2NhbExpc3QiLCJjdXJyZW5jeVN5bWJvbCIsImN1cnJlbmN5U3ltYm9sUGxhY2VtZW50IiwiZGVjaW1hbENoYXJhY3RlciIsImRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSIsImRlY2ltYWxQbGFjZXMiLCJ3YXJuaW5nIiwic2hvd1dhcm5pbmdzIiwiZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlIiwiZGVjaW1hbFBsYWNlc1Nob3duT25CbHVyIiwiZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyIsImRlZmF1bHRWYWx1ZU92ZXJyaWRlIiwiZGlnaXRhbEdyb3VwU3BhY2luZyIsImRpZ2l0R3JvdXBTZXBhcmF0b3IiLCJkaXZpc29yV2hlblVuZm9jdXNlZCIsImVtcHR5SW5wdXRCZWhhdmlvciIsIm51bGwiLCJmYWlsT25Vbmtub3duT3B0aW9uIiwiaGlzdG9yeVNpemUiLCJpc0NhbmNlbGxhYmxlIiwibGVhZGluZ1plcm8iLCJtYXhpbXVtVmFsdWUiLCJtaW5pbXVtVmFsdWUiLCJtb2RpZnlWYWx1ZU9uV2hlZWwiLCJuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciIsIm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50Iiwibm9FdmVudHMiLCJhZGRFdmVudHMiLCJfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMiLCJvbkludmFsaWRQYXN0ZSIsIm91dHB1dEZvcm1hdCIsIm92ZXJyaWRlTWluTWF4TGltaXRzIiwicmF3VmFsdWVEaXZpc29yIiwicmVhZE9ubHkiLCJyb3VuZGluZ01ldGhvZCIsInNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UiLCJzeW1ib2xXaGVuVW5mb2N1c2VkIiwic2VsZWN0TnVtYmVyT25seSIsInNlbGVjdE9uRm9jdXMiLCJzZXJpYWxpemVTcGFjZXMiLCJzaG93T25seU51bWJlcnNPbkZvY3VzIiwic2hvd1Bvc2l0aXZlU2lnbiIsInN0eWxlUnVsZXMiLCJzdWZmaXhUZXh0IiwidW5mb3JtYXRPbkhvdmVyIiwidW5mb3JtYXRPblN1Ym1pdCIsInZhbHVlc1RvU3RyaW5ncyIsIndoZWVsU3RlcCIsImluaXRpYWxWYWx1ZUh0bWxBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJpc051bGwiLCJfb25Gb2N1c0luRnVuYyIsIl9vbkZvY3VzSW4iLCJlIiwiX29uRm9jdXNJbkFuZE1vdXNlRW50ZXJGdW5jIiwiX29uRm9jdXNJbkFuZE1vdXNlRW50ZXIiLCJfb25Gb2N1c0Z1bmMiLCJfb25Gb2N1cyIsIl9vbktleWRvd25GdW5jIiwiX29uS2V5ZG93biIsIl9vbktleXByZXNzRnVuYyIsIl9vbktleXByZXNzIiwiX29uSW5wdXRGdW5jIiwiX29uSW5wdXQiLCJfb25LZXl1cEZ1bmMiLCJfb25LZXl1cCIsIl9vbkZvY3VzT3V0QW5kTW91c2VMZWF2ZUZ1bmMiLCJfb25Gb2N1c091dEFuZE1vdXNlTGVhdmUiLCJfb25QYXN0ZUZ1bmMiLCJfb25QYXN0ZSIsIl9vbldoZWVsRnVuYyIsIl9vbldoZWVsIiwiX29uRm9ybVN1Ym1pdEZ1bmMiLCJfb25Gb3JtU3VibWl0IiwiX29uS2V5ZG93bkdsb2JhbEZ1bmMiLCJfb25LZXlkb3duR2xvYmFsIiwiX29uS2V5dXBHbG9iYWxGdW5jIiwiX29uS2V5dXBHbG9iYWwiLCJfb25Ecm9wRnVuYyIsIl9vbkRyb3AiLCJhZGRFdmVudExpc3RlbmVyIiwiX2RvZXNHbG9iYWxMaXN0RXhpc3RzIiwiZG9jdW1lbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaXNFbXB0eUhpc3RvcnlUYWJsZSIsImxlbmd0aCIsIl9oaXN0b3J5VGFibGVDdXJyZW50VmFsdWVVc2VkIiwiYWRkTmV3SGlzdG9yeVN0YXRlIiwibmV4dEhpc3RvcnlTdGF0ZUluZGV4IiwiYXJyYXlUcmltIiwic2VsZWN0aW9uIiwiZ2V0RWxlbWVudFNlbGVjdGlvbiIsInNlbGVjdGlvblN0YXJ0Iiwic3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJlbmQiLCJfaGlzdG9yeVRhYmxlRm9yZ2V0IiwidW5kbyIsImNoZWNrIiwidW5kb0luZm8iLCJzZXRFbGVtZW50U2VsZWN0aW9uIiwiX2hpc3RvcnlUYWJsZVVuZG9PclJlZG8iLCJudW1iZXJPZkVudHJpZXNUb0ZvcmdldCIsInNoaWZ0ZWRBd2F5IiwiaSIsInNoaWZ0IiwiaW5kZXhUb1VzZSIsImlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSIsInBvc2l0aXZlIiwiX2FkZENTU0NsYXNzIiwiX3JlbW92ZUNTU0NsYXNzIiwibmVnYXRpdmUiLCJyYW5nZXMiLCJyYW5nZSIsIm1pbiIsIm1heCIsImNsYXNzIiwidXNlckRlZmluZWQiLCJpc0Z1bmN0aW9uIiwidXNlck9iamVjdCIsImlzU3RyaW5nIiwiY2xhc3NlcyIsImlzQXJyYXkiLCJjYWxsYmFja1Jlc3VsdCIsInVzZXJDbGFzcyIsImluZGV4IiwiaXNJbkFycmF5IiwiaXNJbnQiLCJ0aHJvd0Vycm9yIiwiY3NzQ2xhc3NOYW1lIiwiY2xhc3NMaXN0IiwiYWRkIiwib3JpZ2luYWxTZXR0aW5ncyIsImNsb25lT2JqZWN0IiwibnVtZXJpY1N0cmluZyIsIm9wdGlvbnNUb1VzZSIsIm9wdGlvbk9iamVjdCIsImVycm9yIiwic2F2ZUNoYW5nZVRvSGlzdG9yeSIsImlzVW5kZWZpbmVkIiwiX3NldEVsZW1lbnRBbmRSYXdWYWx1ZSIsIl9zYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlIiwiX3RvTnVtZXJpY1ZhbHVlIiwiaXNOYU4iLCJOdW1iZXIiLCJzZXRWYWx1ZSIsInplcm8iLCJfY2hlY2tJZkluUmFuZ2VXaXRoT3ZlcnJpZGVPcHRpb24iLCJtaW5UZXN0IiwibWF4VGVzdCIsIl9jaGVja1ZhbHVlc1RvU3RyaW5ncyIsImlzWmVybyIsImlzWmVyb09ySGFzTm9WYWx1ZSIsImZvcmNlZFJhd1ZhbHVlIiwiX3JvdW5kUmF3VmFsdWUiLCJfdHJpbUxlYWRpbmdBbmRUcmFpbGluZ1plcm9zIiwicmVwbGFjZSIsIl9nZXRSYXdWYWx1ZVRvRm9ybWF0IiwiX3JvdW5kRm9ybWF0dGVkVmFsdWVTaG93bk9uRm9jdXMiLCJ0b1N0cmluZyIsIl9yb3VuZEZvcm1hdHRlZFZhbHVlU2hvd25PbkJsdXIiLCJfbW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvckZvcm1hdHRlZFZhbHVlIiwiX2FkZEdyb3VwU2VwYXJhdG9ycyIsInRyaWdnZXJFdmVudCIsImV2ZW50cyIsIm1pblJhbmdlRXhjZWVkZWQiLCJtYXhSYW5nZUV4Y2VlZGVkIiwiX3JlbW92ZVZhbHVlRnJvbVBlcnNpc3RlbnRTdG9yYWdlIiwiYWx3YXlzIiwic3RyaXBwZWRWYWx1ZSIsIl9yZW1vdmVCcmFja2V0cyIsIm5vcm1hbGl6ZWRWYWx1ZSIsIl9zdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMiLCJpc051bWJlciIsIl9pc1VzZXJNYW51YWxseUVkaXRpbmdUaGVWYWx1ZSIsIl9wYXJzZVN0eWxlUnVsZXMiLCJfaGlzdG9yeVRhYmxlQWRkIiwibmV3RWxlbWVudFZhbHVlIiwib2xkRWxlbWVudFZhbHVlIiwiZ2V0RWxlbWVudFZhbHVlIiwic2V0RWxlbWVudFZhbHVlIiwiZm9ybWF0dGVkIiwib2xkVmFsdWUiLCJpc0Jvb2xlYW4iLCJfc2V0RWxlbWVudFZhbHVlIiwiX3NldFJhd1ZhbHVlIiwicmF3VmFsdWVGb3JUaGVFbGVtZW50VmFsdWUiLCJTdHJpbmciLCJ2YWx1ZXNUb1N0cmluZ3NLZXlzIiwidHJpbVBhZGRlZFplcm9zRnJvbURlY2ltYWxQbGFjZXMiLCJfdG9Mb2NhbGUiLCJpc0VtcHR5U3RyaW5nIiwia2VlcCIsIm91dHB1dEZvcm1hdFRvVXNlIiwic2VsZWN0TnVtYmVyIiwiX2RlZmF1bHRTZWxlY3RBbGwiLCJ1bmZvcm1hdHRlZFZhbHVlIiwidmFsdWVMZW4iLCJjdXJyZW5jeVN5bWJvbFNpemUiLCJuZWdMZW4iLCJpc05lZ2F0aXZlIiwic3VmZml4VGV4dExlbiIsInN1ZmZpeCIsImxlZnQiLCJwcmVmaXgiLCJyaWdodCIsImlzUG9zaXRpdmUiLCJub25lIiwiZWxlbWVudFZhbHVlIiwiaW5kZXhPZiIsImRlY2ltYWxDb3VudCIsInBhcmVudE5vZGUiLCJvdGhlckFuRWxlbWVudCIsImRvbUVsZW1lbnRUb0RldGFjaCIsIl9yZW1vdmVGcm9tTG9jYWxMaXN0IiwicmVGb3JtYXQiLCJ2YWx1ZU9yRWxlbWVudCIsIm9wdGlvbk92ZXJyaWRlIiwiX2Zvcm1hdE9yVW5mb3JtYXRPdGhlciIsInN0cmluZ09yRWxlbWVudCIsImlzRm9ybWF0dGluZyIsInZhbHVlT3JTdHJpbmdPckVsZW1lbnQiLCJzZXR0aW5nc1RvVXNlIiwiX2Nsb25lQW5kTWVyZ2VTZXR0aW5ncyIsImlzRWxlbWVudCIsImZvcm1hdCIsImRvbUVsZW1lbnRPckFycmF5T3JTdHJpbmciLCJhdHRhY2hlZCIsInJldHVybkFTaW5nbGVBdXRvTnVtZXJpY09iamVjdCIsImRvbUVsZW1lbnRzQXJyYXkiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY3VycmVudExvY2FsTGlzdCIsImF1dG9OdW1lcmljT2JqZWN0c0FycmF5Iiwib3JpZ2luYWxDcmVhdGVMb2NhbExpc3RTZXR0aW5nIiwibmV3QXV0b051bWVyaWNFbGVtZW50IiwidGVtcG9yYXJ5Rm9yY2VkT3B0aW9ucyIsImZvY3VzIiwiX3JlbW92ZUZyb21HbG9iYWxMaXN0IiwicmVtb3ZlQ2hpbGQiLCJmb3JjZVNlYXJjaCIsInRhZ05hbWUiLCJ0b0xvd2VyQ2FzZSIsIl9zZXJpYWxpemVOdW1lcmljU3RyaW5nIiwiZm9ybSIsIl9zZXJpYWxpemVGb3JtYXR0ZWQiLCJfc2VyaWFsaXplTG9jYWxpemVkIiwiX3NlcmlhbGl6ZU51bWVyaWNTdHJpbmdBcnJheSIsIl9zZXJpYWxpemVGb3JtYXR0ZWRBcnJheSIsIl9zZXJpYWxpemVMb2NhbGl6ZWRBcnJheSIsIkpTT04iLCJzdHJpbmdpZnkiLCJmb3JtQXJyYXlOdW1lcmljU3RyaW5nIiwiZm9ybUFycmF5Rm9ybWF0dGVkIiwiZm9ybUFycmF5TG9jYWxpemVkIiwiaW5wdXRzIiwiX2dldENoaWxkQU5JbnB1dEVsZW1lbnQiLCJpbnB1dCIsImZvcm1VbmZvcm1hdCIsInN1Ym1pdCIsImZvcm1SZWZvcm1hdCIsImZvcm1OdW1lcmljU3RyaW5nIiwiZm9ybUZvcm1hdHRlZCIsImZvcm1VbmZvcm1hdExvY2FsaXplZCIsImZvcm1Mb2NhbGl6ZWQiLCJmb3JtSnNvbk51bWVyaWNTdHJpbmciLCJmb3JtSnNvbkZvcm1hdHRlZCIsImZvcm1Kc29uTG9jYWxpemVkIiwibG9jYWxMaXN0IiwiYXV0b051bWVyaWNPYmplY3QiLCJuZXdTZXR0aW5ncyIsInByZWRlZmluZWRPcHRpb24iLCJfbWVyZ2VTZXR0aW5ncyIsIl91cGRhdGVQcmVkZWZpbmVkT3B0aW9ucyIsImdldFByZWRlZmluZWRPcHRpb25zIiwiRnJlbmNoIiwiTm9ydGhBbWVyaWNhbiIsIkJyaXRpc2giLCJTd2lzcyIsIkphcGFuZXNlIiwiU3BhbmlzaCIsIkNoaW5lc2UiLCJCcmF6aWxpYW4iLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImh0bWxBdHRyaWJ1dGUiLCJjYW1lbGl6ZSIsImlzVHJhaWxpbmdOZWdhdGl2ZSIsInNwbGl0IiwiZmlyc3RCcmFja2V0IiwibGFzdEJyYWNrZXQiLCJzIiwibmVnYXRpdmVTaWduQ2hhcmFjdGVyIiwibWF0Y2giLCJpc1ZhbHVlTmVnYXRpdmUiLCJ0b3RhbExlbmd0aCIsInZhbHVlU2l6ZSIsImludGVnZXJTaXplIiwiaGFzRGVjaW1hbENoYXIiLCJvZmZzZXREZWNpbWFsQ2hhciIsImNvbnRhaW5zIiwiZGVjaW1hbExlZnQiLCJkZWNpbWFsUmlnaHQiLCJzaWduVG9Vc2UiLCJwb3NpdGl2ZVNpZ25DaGFyYWN0ZXIiLCJwb3NpdGl2ZU5lZ2F0aXZlU2lnblNpemUiLCJjYXJldFBvc2l0aW9uIiwib3JpZ2luYWxEaWdpdEdyb3VwU2VwYXJhdG9yIiwib3JpZ2luYWxDdXJyZW5jeVN5bWJvbCIsIm9yaWdpbmFsU3VmZml4VGV4dCIsIm5hbWUiLCJyYXdWYWx1ZVN0b3JhZ2VOYW1lIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiaWQiLCJzZXNzaW9uU3RvcmFnZSIsInNldEl0ZW0iLCJjb29raWUiLCJnZXRJdGVtIiwiX3JlYWRDb29raWUiLCJyZW1vdmVJdGVtIiwiZGF0ZSIsIkRhdGUiLCJzZXRUaW1lIiwiZ2V0VGltZSIsImV4cGlyZXMiLCJ0b1VUQ1N0cmluZyIsImluaXRpYWxFbGVtZW50VmFsdWUiLCJ0eXBlIiwiYWx0S2V5IiwiX3VuZm9ybWF0QWx0SG92ZXJlZCIsImhvdmVyZWRXaXRoQWx0IiwiX3JlZm9ybWF0QWx0SG92ZXJlZCIsInJhd1ZhbHVlVG9Gb3JtYXQiLCJyb3VuZGVkVmFsdWUiLCJvbmx5TnVtYmVycyIsImZvcm1hdHRlZFZhbHVlIiwidmFsdWVPbkZvY3VzIiwidGFyZ2V0IiwibGFzdFZhbCIsImlzRW1wdHlWYWx1ZSIsIl9pc0VsZW1lbnRWYWx1ZUVtcHR5T3JPbmx5VGhlTmVnYXRpdmVTaWduIiwib3JkZXJlZFZhbHVlIiwiX29yZGVyVmFsdWVDdXJyZW5jeVN5bWJvbEFuZFN1ZmZpeFRleHQiLCJfc2F2ZUNhbmNlbGxhYmxlVmFsdWUiLCJzZWxlY3QiLCJfaW5pdGlhbENhcmV0UG9zaXRpb24iLCJnZXRIb3ZlcmVkRWxlbWVudCIsIl91cGRhdGVFdmVudEtleUluZm8iLCJpbml0aWFsVmFsdWVPbktleWRvd24iLCJwcm9jZXNzZWQiLCJldmVudEtleSIsImtleU5hbWUiLCJFc2MiLCJwcmV2ZW50RGVmYXVsdCIsIm5hdGl2ZSIsInRhcmdldFZhbHVlIiwiRW50ZXIiLCJjaGFuZ2UiLCJfdXBkYXRlSW50ZXJuYWxQcm9wZXJ0aWVzIiwiX3Byb2Nlc3NOb25QcmludGFibGVLZXlzQW5kU2hvcnRjdXRzIiwiQmFja3NwYWNlIiwiRGVsZXRlIiwiX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbiIsIl9mb3JtYXRWYWx1ZSIsInRocm93SW5wdXQiLCJJbnNlcnQiLCJpc0NoYXJhY3Rlckluc2VydGlvbkFsbG93ZWQiLCJfcHJvY2Vzc0NoYXJhY3Rlckluc2VydGlvbiIsInBvc2l0aW9uIiwiYW5kcm9pZFNlbGVjdGlvblN0YXJ0IiwiQW5kcm9pZERlZmF1bHQiLCJjaGFyQ29kZUF0IiwiY2hhckF0IiwiZGVjaW1hbENoYXJhY3RlclBvc2l0aW9uIiwiaGFzRGVjaW1hbENoYXJhY3RlciIsIl9zZXRDYXJldFBvc2l0aW9uIiwiWiIsInoiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJfaGlzdG9yeVRhYmxlUmVkbyIsIl9oaXN0b3J5VGFibGVVbmRvIiwiQWx0Iiwic2tpcCIsInZhbHVlUGFydHNCZWZvcmVQYXN0ZSIsImlzT25BbmRyb2lkIiwiVGFiIiwiaXNSYXdWYWx1ZU51bGwiLCJlbGVtZW50VmFsdWVJc0FscmVhZHlTZXQiLCJfbW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvclJhd1ZhbHVlIiwiX3JvdW5kVmFsdWUiLCJncm91cGVkVmFsdWUiLCJuZXZlciIsImZsb2F0cyIsIl9vbkJsdXIiLCJyYXdQYXN0ZWRUZXh0Iiwid2luZG93IiwiY2xpcGJvYXJkRGF0YSIsImdldERhdGEiLCJpbml0aWFsRm9ybWF0dGVkVmFsdWUiLCJzZWxlY3Rpb25TaXplIiwiaXNBbGxJbnB1dFRleHRTZWxlY3RlZCIsImlzUGFzdGVOZWdhdGl2ZSIsImlzTmVnYXRpdmVTdHJpY3QiLCJzbGljZSIsInVudHJhbnNsYXRlZFBhc3RlZFRleHQiLCJfcHJlcGFyZVBhc3RlZFRleHQiLCJwYXN0ZWRUZXh0IiwiYXJhYmljVG9MYXRpbk51bWJlcnMiLCJjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyIsImluaXRpYWxVbmZvcm1hdHRlZE51bWJlciIsImlzSW5pdGlhbFZhbHVlTmVnYXRpdmUiLCJpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlIiwibGVmdFBhcnRDb250YWluZWRBRG90IiwibGVmdFBhcnQiLCJyaWdodFBhcnQiLCJ0cnVuY2F0ZSIsImxlZnRGb3JtYXR0ZWRQYXJ0IiwicmlnaHRGb3JtYXR0ZWRQYXJ0Iiwic2V0UmF3TmVnYXRpdmVTaWduIiwiY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uIiwiY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlIiwibWluUGFyc2UiLCJwYXJzZVN0ciIsIm1heFBhcnNlIiwibGFzdEdvb2RLbm93blJlc3VsdCIsInBhc3RlZFRleHRJbmRleCIsIm1vZGlmaWVkTGVmdFBhcnQiLCJfY2hlY2tJZkluUmFuZ2UiLCJsYXN0R29vZEtub3duUmVzdWx0SW5kZXgiLCJsYXN0R29vZEtub3duUmVzdWx0U2l6ZSIsInJlcGxhY2VDaGFyQXQiLCJpZ25vcmUiLCJjbGFtcCIsImxlZnRGb3JtYXR0ZWRQYXJ0MiIsInJpZ2h0Rm9ybWF0dGVkUGFydDIiLCJpbmRleFdoZXJlUGFzdGVkVGV4dEhhc0JlZW5JbnNlcnRlZCIsImluZGV4U2VsZWN0aW9uRW5kSW5SYXdWYWx1ZSIsInNlbGVjdGVkVGV4dCIsImNvdW50Q2hhckluVGV4dCIsInZhbHVlSGFzQmVlblNldCIsInZhbHVlSGFzQmVlbkNsYW1wZWQiLCJjbGFtcGVkVmFsdWUiLCJjbGFtcFRvUmFuZ2VMaW1pdHMiLCJjYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIiLCJmaW5kQ2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyIiwiY3VycmVudFVuZm9ybWF0dGVkVmFsdWUiLCJpc1doZWVsVXBFdmVudCIsImlzV2hlZWxEb3duRXZlbnQiLCJzdGVwIiwiYWRkQW5kUm91bmRUb05lYXJlc3RBdXRvIiwic3VidHJhY3RBbmRSb3VuZFRvTmVhcmVzdEF1dG8iLCJfc2V0U2VsZWN0aW9uIiwiZHJvcHBlZFRleHQiLCJkYXRhVHJhbnNmZXIiLCJjbGVhbmVkVmFsdWUiLCJ1bmZvcm1hdE90aGVyIiwiY2hhcmFjdGVyIiwiaG92ZXJlZEVsZW1lbnQiLCJpc01hbmFnZWRCeUF1dG9OdW1lcmljIiwiYW5FbGVtZW50IiwiYWxsb3dlZFRhZ0xpc3QiLCJjdXJyZW50RWxlbWVudFRhZyIsIl9pc0VsZW1lbnRUYWdTdXBwb3J0ZWQiLCJfaXNJbnB1dEVsZW1lbnQiLCJfaXNJbnB1dFR5cGVTdXBwb3J0ZWQiLCJoYXNBdHRyaWJ1dGUiLCJmb3JjZWRJbml0aWFsVmFsdWUiLCJjdXJyZW50VmFsdWUiLCJ1bkxvY2FsaXplZEN1cnJlbnRWYWx1ZSIsIkluZmluaXR5IiwiX2dldFZhbHVlRnJvbVBlcnNpc3RlbnRTdG9yYWdlIiwidG9TdHJpcCIsIm1heGltdW1WYWx1ZUludGVnZXJQYXJ0IiwibWluaW11bVZhbHVlSW50ZWdlclBhcnQiLCJtSW50UG9zIiwiTWF0aCIsIm1JbnROZWciLCJPYmplY3QiLCJrZXlzIiwiX2NvbnZlcnRPbGRPcHRpb25zVG9OZXdPbmVzIiwiZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlSW5PcHRpb25zIiwib3JpZ2luYWxEZWNpbWFsUGxhY2VzUmF3VmFsdWUiLCJkZWNpbWFsUGxhY2VzSW5PcHRpb25zIiwib3JpZ2luYWxEZWNpbWFsUGxhY2VzIiwiX2NhbGN1bGF0ZURlY2ltYWxQbGFjZXNPblVwZGF0ZSIsImdldERlZmF1bHRDb25maWciLCJkYXRhc2V0IiwiY2FyZXRGaXgiLCJfdHJhbnNmb3JtT3B0aW9uc1ZhbHVlc1RvRGVmYXVsdFR5cGVzIiwiX3J1bkNhbGxiYWNrc0ZvdW5kSW5UaGVTZXR0aW5nc09iamVjdCIsIl9jb3JyZWN0TmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRPcHRpb24iLCJfY29ycmVjdENhcmV0UG9zaXRpb25PbkZvY3VzQW5kU2VsZWN0T25Gb2N1c09wdGlvbnMiLCJfY2FsY3VsYXRlRGVjaW1hbFBsYWNlc09uSW5pdCIsIl9jYWxjdWxhdGVWTWluQW5kVk1heEludGVnZXJTaXplcyIsIl9zZXRBbHRlcm5hdGl2ZURlY2ltYWxTZXBhcmF0b3JDaGFyYWN0ZXIiLCJfc2V0VHJhaWxpbmdOZWdhdGl2ZVNpZ25JbmZvIiwicmVnZXgiLCJfY2FjaGVzVXN1YWxSZWd1bGFyRXhwcmVzc2lvbnMiLCJfc2V0QnJhY2tldHMiLCJfY2FsY3VsYXRlVmFsdWVzVG9TdHJpbmdzS2V5cyIsImlzRW1wdHlPYmoiLCJ2YWxpZGF0ZSIsIl9rZWVwQW5PcmlnaW5hbFNldHRpbmdzQ29weSIsInRleHQiLCJzdWJzdHJpbmciLCJfZ2V0TGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbiIsInN0cmlwWmVyb3MiLCJIeXBoZW4iLCJkZW55IiwibnVtMCIsIm51bXBhZDAiLCJtIiwiUmVnRXhwIiwiYU5lZ1JlZ0F1dG9TdHJpcCIsImlzUGFzdGUiLCJfbm9ybWFsaXplUGFydHMiLCJub3JtYWxpemVkTGVmdCIsIm5vcm1hbGl6ZWRSaWdodCIsIm5vcm1hbGl6ZWROZXdWYWx1ZSIsInJvdW5kZWRSYXdWYWx1ZSIsIl90cnVuY2F0ZURlY2ltYWxQbGFjZXMiLCJ0ZXN0VmFsdWUiLCJ2YWx1ZVRvU2V0T25FbXB0eSIsInJvdW5kZWRWYWx1ZVRvU2hvdyIsImN1cnJlbmN5U3ltYm9sTGVuIiwiaGFzTmVnIiwiX2dldFNpZ25Qb3NpdGlvbiIsInNpZ25Qb3NpdGlvbiIsImN1cnJlbmN5U3ltYm9sUG9zaXRpb24iLCJvbGRQYXJ0cyIsInN1YnN0ciIsIl9zZXRWYWx1ZVBhcnRzIiwiam9pbiIsIm1ldGFLZXkiLCJfY2hlY2tQYXN0ZSIsIl9zaG91bGRTa2lwRXZlbnRLZXkiLCJhIiwiYyIsInYiLCJ4IiwiX2V4cGFuZFNlbGVjdGlvbk9uU2lnbiIsIkxlZnRBcnJvdyIsIlJpZ2h0QXJyb3ciLCJfZGlyZWN0aW9uS2V5cyIsIl9nZXRVbmZvcm1hdHRlZExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24iLCJfcHJvY2Vzc0NoYXJhY3RlckRlbGV0aW9uSWZUcmFpbGluZ05lZ2F0aXZlU2lnbiIsIk51bXBhZERvdCIsIl9pc0RlY2ltYWxDaGFyYWN0ZXJJbnNlcnRpb25BbGxvd2VkIiwiZXZlbnROdW1iZXIiLCJzdWJQYXJ0cyIsIm5lZ2F0aXZlU2lnbiIsImxlZnRBciIsInNpZ25QYXJ0cyIsImVzY2FwZUNociIsImVzY2FwZWRQYXJ0cyIsIm1pbmlQYXJ0cyIsImxlZnRSZWciLCJuZXdMZWZ0IiwiaXNBcmcxRWxlbWVudCIsImlzQXJnMVN0cmluZyIsImlzQXJnMk9iamVjdCIsImlzT2JqZWN0IiwiaXNBcmcyQXJyYXkiLCJBcnJheSIsImlzQXJnMk51bWJlciIsImlzTnVtYmVyT3JBcmFiaWMiLCJpc0FyZzJQcmVEZWZpbmVkT3B0aW9uTmFtZSIsIl9pc1ByZURlZmluZWRPcHRpb25WYWxpZCIsImlzQXJnMk51bGwiLCJpc0FyZzJFbXB0eVN0cmluZyIsImlzQXJnM09iamVjdCIsImlzQXJnM0FycmF5IiwiaXNBcmczTnVsbCIsImlzQXJnM1ByZURlZmluZWRPcHRpb25OYW1lIiwiX2dldE9wdGlvbk9iamVjdCIsIm1lcmdlT3B0aW9ucyIsInF1ZXJ5U2VsZWN0b3IiLCJvcHRpb25zQXJyYXkiLCJtZXJnZWRPcHRpb25zIiwib3B0aW9uT2JqZWN0T3JQcmVkZWZpbmVkT3B0aW9uU3RyaW5nIiwicHJlRGVmaW5lZE9wdGlvbk5hbWUiLCJwcmVkZWZpbmVkT3B0aW9ucyIsIm9wdGlvbk9iamVjdE9yUHJlZGVmaW5lZE5hbWUiLCJmb3JtTm9kZSIsImlucHV0TGlzdCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiYXV0b051bWVyaWNJbnB1dHMiLCJpbnB1dEVsZW1lbnRzIiwicHJvdG90eXBlIiwiY2FsbCIsInRlc3QiLCJfaXNJbkdsb2JhbExpc3QiLCJ3ZWFrTWFwTmFtZSIsIldlYWtNYXAiLCJhdXRvTnVtZXJpY0dsb2JhbExpc3ROYW1lIiwiX2NyZWF0ZVdlYWtNYXAiLCJfY3JlYXRlR2xvYmFsTGlzdCIsIl9nZXRGcm9tR2xvYmFsTGlzdCIsImdldFNldHRpbmdzIiwic2hvdWxkRXh0ZW5kRGVmYXVsdE9wdGlvbnMiLCJvcmlnaW5hbE9wdGlvbnMiLCJpc09yaWdpbmFsT3B0aW9uQW5PYmplY3QiLCJpc1RydWVPckZhbHNlU3RyaW5nIiwidGVzdFBvc2l0aXZlSW50ZWdlciIsInRlc3ROdW1lcmljYWxDaGFyYWN0ZXJzIiwidGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24iLCJ0ZXN0UG9zaXRpdmVGbG9hdE9ySW50ZWdlciIsImRvTm9Gb3JjZUNhcmV0UG9zaXRpb24iLCJjb21tYSIsImRvdCIsIm5vcm1hbFNwYWNlIiwidGhpblNwYWNlIiwibmFycm93Tm9CcmVha1NwYWNlIiwibm9CcmVha1NwYWNlIiwibm9TZXBhcmF0b3IiLCJhcG9zdHJvcGhlIiwiYXJhYmljVGhvdXNhbmRzU2VwYXJhdG9yIiwiZG90QWJvdmUiLCJtaWRkbGVEb3QiLCJhcmFiaWNEZWNpbWFsU2VwYXJhdG9yIiwiZGVjaW1hbFNlcGFyYXRvcktleVN5bWJvbCIsImNlaWxpbmciLCJmbG9vciIsInBhcnNlRmxvYXQiLCJfdmFsaWRhdGVEZWNpbWFsUGxhY2VzUmF3VmFsdWUiLCJoYWxmVXBTeW1tZXRyaWMiLCJoYWxmVXBBc3ltbWV0cmljIiwiaGFsZkRvd25TeW1tZXRyaWMiLCJoYWxmRG93bkFzeW1tZXRyaWMiLCJoYWxmRXZlbkJhbmtlcnNSb3VuZGluZyIsInVwUm91bmRBd2F5RnJvbVplcm8iLCJkb3duUm91bmRUb3dhcmRaZXJvIiwidG9DZWlsaW5nVG93YXJkUG9zaXRpdmVJbmZpbml0eSIsInRvRmxvb3JUb3dhcmROZWdhdGl2ZUluZmluaXR5IiwidG9OZWFyZXN0MDUiLCJ0b05lYXJlc3QwNUFsdCIsInVwVG9OZXh0MDUiLCJkb3duVG9OZXh0MDUiLCJwYXJlbnRoZXNlcyIsImJyYWNrZXRzIiwiY2hldnJvbnMiLCJjdXJseUJyYWNlcyIsImFuZ2xlQnJhY2tldHMiLCJqYXBhbmVzZVF1b3RhdGlvbk1hcmtzIiwiaGFsZkJyYWNrZXRzIiwid2hpdGVTcXVhcmVCcmFja2V0cyIsInF1b3RhdGlvbk1hcmtzIiwiZ3VpbGxlbWV0cyIsInByZXNzIiwiYWxsb3ciLCJzdHJpbmciLCJudW1iZXIiLCJuZWdhdGl2ZURvdCIsIm5lZ2F0aXZlQ29tbWEiLCJkb3ROZWdhdGl2ZSIsImNvbW1hTmVnYXRpdmUiLCJwbHVzIiwicGVyY2VudCIsInJ1bGUiLCJpc1ZhbGlkIiwib3B0aW9uc1Jlc3VsdCIsIm51bWVyaWNTdHJpbmdPckRvbUVsZW1lbnQiLCJfZ2VuZXJhdGVPcHRpb25zT2JqZWN0RnJvbU9wdGlvbnNBcnJheSIsInZhbHVlU3RyaW5nIiwiaXNOdW1iZXJTdHJpY3QiLCJfY29udmVydFRvTnVtZXJpY1N0cmluZyIsInVud2FudGVkQ2hhcmFjdGVycyIsIk5hTiIsImxvY2FsaXplZFZhbHVlIiwibG9jYWxpemUiLCJza2lwRmlyc3RBdXRvU3RyaXAiLCJza2lwTGFzdEF1dG9TdHJpcCIsImFsbG93ZWRBdXRvU3RyaXAiLCJudW1SZWdBdXRvU3RyaXAiLCJpbnRlZ2VyUGFydCIsImRlY2ltYWxQYXJ0IiwibW9kaWZpZWRJbnRlZ2VyUGFydCIsInN0cmlwUmVnIiwiX2FkZEJyYWNrZXRzIiwicmVhcnJhbmdlU2lnbnNBbmRWYWx1ZU9yZGVyIiwiX21lcmdlQ3VycmVuY3lTaWduTmVnYXRpdmVQb3NpdGl2ZVNpZ25BbmRWYWx1ZSIsImxhc3RJbmRleE9mIiwiY29udmVydFRvTnVtYmVyIiwidGVtcCIsImxvY2FsZSIsInNpZ25PbkVtcHR5IiwiaW5wdXRWYWx1ZSIsImN1cnJlbnRSYXdWYWx1ZSIsImlzTmVnYXRpdmVXaXRoQnJhY2tldHMiLCJkaWdpdGFsR3JvdXAiLCJ0d28iLCJ0d29TY2FsZWQiLCJmb3VyIiwidGhyZWUiLCJkZWNpbWFsUGxhY2VzVG9Sb3VuZFRvIiwiX3RvZ2dsZU5lZ2F0aXZlQnJhY2tldCIsInJvdW5kZWRJbnB1dFZhbHVlIiwiZGVjaW1hbFBsYWNlc05lZWRlZCIsIl9yb3VuZENsb3NlVG8wNSIsIl9wcmVwYXJlVmFsdWVGb3JSb3VuZGluZyIsInByZXBhcmVkVmFsdWUiLCJpbnB1dFZhbHVlSGFzTm9Eb3QiLCJoYXNEZWNpbWFscyIsInRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSIsImRlY2ltYWxQb3NpdGlvblRvVXNlIiwiY2hlY2tEZWNpbWFsUGxhY2VzIiwiaW5wdXRWYWx1ZVJvdW5kZWQiLCJ6ZXJvcyIsIl90cnVuY2F0ZVplcm9zIiwicm91bmRlZFN0ckxlbmd0aCIsImxhc3REaWdpdCIsImlucHV0VmFsdWVBcnJheSIsIm9kZCIsIl9zaG91bGRSb3VuZFVwIiwicm91bmQiLCJjZWlsIiwibW9kaWZpZWREZWNpbWFsUGFydCIsInZhbFBhcnNlIiwidGVzdE1pbk1heCIsIm5hbWVFUSIsImNhIiwibW9kIiwiZG9Ob3RTZWxlY3QiLCJ1c2VEZWZhdWx0IiwiYWRkaXRpb25hbERlY2ltYWxQbGFjZXNSYXdWYWx1ZSIsImN1cnJlbnRTZXR0aW5ncyIsImFsbE51bWJlcnNSZWciLCJub0FsbE51bWJlcnNSZWciLCJhTmVnUmVnIiwibmVnYXRpdmVTaWduUmVnUGFydCIsImFsbG93ZWQiLCJvbGRPcHRpb25zQ29udmVydGVyIiwiYVNlcCIsIm5TZXAiLCJkR3JvdXAiLCJhRGVjIiwiYWx0RGVjIiwiYVNpZ24iLCJwU2lnbiIsInBOZWciLCJhU3VmZml4Iiwib0xpbWl0cyIsInZNYXgiLCJ2TWluIiwibURlYyIsImVEZWMiLCJzY2FsZURlY2ltYWwiLCJhU3RvciIsIm1Sb3VuZCIsImFQYWQiLCJuQnJhY2tldCIsIndFbXB0eSIsImxaZXJvIiwiYUZvcm0iLCJzTnVtYmVyIiwiYW5EZWZhdWx0IiwidW5TZXRPblN1Ym1pdCIsIm91dHB1dFR5cGUiLCJkZWJ1ZyIsIm9wdGlvbiIsInBhcnNlZE1pblZhbHVlIiwicGFyc2VkTWF4VmFsdWUiLCJwYXJzZWRWYWx1ZSIsImV2ZW50S2V5TmFtZSIsImlzRm5LZXlzIiwiX2FsbEZuS2V5cyIsImlzT1NLZXlzIiwiT1NMZWZ0IiwiT1NSaWdodCIsImlzQ29udGV4dE1lbnUiLCJDb250ZXh0TWVudSIsImlzU29tZU5vblByaW50YWJsZUtleXMiLCJfc29tZU5vblByaW50YWJsZUtleXMiLCJpc090aGVyTm9uUHJpbnRhYmxlS2V5cyIsIk51bUxvY2siLCJTY3JvbGxMb2NrIiwiQ29tbWFuZCIsImlzVW5yZWNvZ25pemFibGVLZXlzIiwiVW5pZGVudGlmaWVkIiwiaW50b0FuQXJyYXkiLCJmb3JtYXRUeXBlIiwic2VyaWFsaXplZFNwYWNlQ2hhcmFjdGVyIiwibm9kZU5hbWUiLCJlbGVtZW50IiwiZGlzYWJsZWQiLCJzZWxlY3RlZCIsImVuY29kZVVSSUNvbXBvbmVudCIsImNoZWNrZWQiLCJ2YWx1ZVJlc3VsdCIsImFuT2JqZWN0IiwiZmluYWxSZXN1bHQiLCJfc2VyaWFsaXplIiwibXVsdGlwbGUiLCJyb290RWxlbWVudCIsImV4Y2x1ZGUiLCJmaWx0ZXJPdXQiLCJpc0luaXRpYWxWYWx1ZUFycmF5IiwiaXNJbml0aWFsVmFsdWVBcnJheUFuZE5vdEVtcHR5Iiwic2Vjb25kQXJndW1lbnRJc0luaXRpYWxWYWx1ZUFycmF5Iiwic2Vjb25kQXJndW1lbnRJc09wdGlvbkFycmF5IiwidHlwZU9mRmlyc3RBcnJheUVsZW1lbnQiLCJpc09wdGlvbnNBcnJheUFuZE5vdEVtcHR5IiwidGhpcmRBcmd1bWVudElzT3B0aW9uQXJyYXkiLCJpc0luaXRpYWxWYWx1ZU51bWJlciIsImluaXRpYWxWYWx1ZUFycmF5U2l6ZSIsIkN1c3RvbUV2ZW50IiwiZXZlbnQiLCJwYXJhbXMiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImRldGFpbCIsImV2dCIsImNyZWF0ZUV2ZW50IiwiaW5pdEN1c3RvbUV2ZW50IiwiRXZlbnQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztxakJBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZDQTs7QUFFQTs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OztBQUVBOzs7OztJQUtNQSxXO0FBQ0Y7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUNBLDJCQUFtRDtBQUFBLFlBQXZDQyxJQUF1Qyx1RUFBaEMsSUFBZ0M7O0FBQUE7O0FBQUEsWUFBMUJDLElBQTBCLHVFQUFuQixJQUFtQjtBQUFBLFlBQWJDLElBQWEsdUVBQU4sSUFBTTs7QUFBQTs7QUFDL0M7QUFDQTtBQUNBO0FBSCtDLG9DQUlHSCxZQUFZSSxtQkFBWixDQUFnQ0gsSUFBaEMsRUFBc0NDLElBQXRDLEVBQTRDQyxJQUE1QyxDQUpIO0FBQUEsWUFJdkNFLFVBSnVDLHlCQUl2Q0EsVUFKdUM7QUFBQSxZQUkzQkMsWUFKMkIseUJBSTNCQSxZQUoyQjtBQUFBLFlBSWJDLFdBSmEseUJBSWJBLFdBSmE7O0FBTS9DOzs7QUFDQSxhQUFLRixVQUFMLEdBQWtCQSxVQUFsQjs7QUFFQTtBQUNBLGFBQUtHLGVBQUwsR0FBdUIsRUFBdkIsQ0FWK0MsQ0FVcEI7QUFDM0IsYUFBS0MsWUFBTCxDQUFrQkYsV0FBbEIsRUFBK0IsS0FBL0I7QUFDQTtBQUNBO0FBQ0EsYUFBS0csYUFBTDs7QUFFQTtBQUNBO0FBQ0EsYUFBS0MscUJBQUwsR0FB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QUFsRCxFQUF5RTtBQUM1RXAxQixtQkFBT0MsSUFBUCxDQUFZLElBQUluRCxXQUFKLENBQWdCSyxVQUFoQixFQUE0QkMsYUFBYXlOLEtBQWIsQ0FBNUIsRUFBaURVLFlBQWpELENBQVo7QUFDSCxTQUZNLE1BRUE7QUFDSHZMLG1CQUFPQyxJQUFQLENBQVksSUFBSW5ELFdBQUosQ0FBZ0JLLFVBQWhCLEVBQTRCLElBQTVCLEVBQWtDb08sWUFBbEMsQ0FBWjtBQUNIO0FBQ0osS0FURDs7QUFXQSxXQUFPdkwsTUFBUDtBQUNILENBOUdEOztBQWdIQTs7OztBQUlBLENBQUMsWUFBVztBQUNaLFFBQUksT0FBTzJiLE9BQU8wWixXQUFkLEtBQThCLFVBQWxDLEVBQThDO0FBQzFDLGVBQU8sS0FBUDtBQUNIOztBQUVELGFBQVNBLFdBQVQsQ0FBcUJDLEtBQXJCLEVBQTRCQyxNQUE1QixFQUFvQztBQUNoQ0EsaUJBQVNBLFVBQVUsRUFBRUMsU0FBUyxLQUFYLEVBQWtCQyxZQUFZLEtBQTlCLEVBQXFDQyxRQUFRLEtBQUssQ0FBbEQsRUFBbkI7QUFDQSxZQUFNQyxNQUFNenRCLFNBQVMwdEIsV0FBVCxDQUFxQixhQUFyQixDQUFaO0FBQ0FELFlBQUlFLGVBQUosQ0FBb0JQLEtBQXBCLEVBQTJCQyxPQUFPQyxPQUFsQyxFQUEyQ0QsT0FBT0UsVUFBbEQsRUFBOERGLE9BQU9HLE1BQXJFO0FBQ0EsZUFBT0MsR0FBUDtBQUNIOztBQUVETixnQkFBWXpOLFNBQVosR0FBd0JqTSxPQUFPbWEsS0FBUCxDQUFhbE8sU0FBckM7QUFDQWpNLFdBQU8wWixXQUFQLEdBQXFCQSxXQUFyQjtBQUNDLENBZEQ7O0FBaUJBOzs7Ozs7OztBQVFBVSxPQUFPQyxPQUFQLEdBQWlCbDVCLFdBQWpCLEMiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogICAgICAgICAgICAgICBBdXRvTnVtZXJpYy5qc1xuICpcbiAqIEB2ZXJzaW9uICAgICAgNC4xLjAtYmV0YS4xXG4gKiBAZGF0ZSAgICAgICAgIDIwMTctMDgtMTEgVVRDIDIxOjQ1XG4gKlxuICogQGF1dGhvcnMgICAgICBCb2IgS25vdGhlLCBBbGV4YW5kcmUgQm9ubmVhdVxuICogQGNvbnRyaWJ1dG9ycyBTb2tvbG92IFl1cmEgYW5kIG90aGVycywgY2YuIEFVVEhPUlNcbiAqIEBjb3B5cmlnaHQgICAgMjAwOSBSb2JlcnQgSi4gS25vdGhlIGh0dHA6Ly93d3cuZGVjb3JwbGFuaXQuY29tL3BsdWdpbi9cbiAqIEBzaW5jZSAgICAgICAgMjAwOS0wOC0wOVxuICpcbiAqIEBzdW1tYXJ5ICAgICAgYXV0b051bWVyaWMgaXMgYSBzdGFuZGFsb25lIEphdmFzY3JpcHQgbGlicmFyeVxuICogICAgICAgICAgICAgICB0aGF0IHByb3ZpZGVzIGxpdmUgKmFzLXlvdS10eXBlKiBmb3JtYXR0aW5nIGZvclxuICogICAgICAgICAgICAgICBpbnRlcm5hdGlvbmFsIG51bWJlcnMgYW5kIGN1cnJlbmNpZXMuXG4gKlxuICogICAgICAgICAgICAgICBOb3RlIDogU29tZSBmdW5jdGlvbnMgYXJlIGJvcnJvd2VkIGZyb20gYmlnLmpzXG4gKiBAbGluayAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZy5qcy9cbiAqXG4gKiBQbGVhc2UgcmVwb3J0IGFueSBidWdzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9hdXRvTnVtZXJpYy9hdXRvTnVtZXJpY1xuICpcbiAqIEBsaWNlbnNlICAgICAgUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBAbGluayAgICAgICAgIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3ViIGxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gKiBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAqIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZ2xvYmFsIG1vZHVsZSAqL1xuXG4vL1RPRE8gUHJldmVudCBoYXZpbmcgdG8gZW50ZXIgcmVsYXRpdmUgcGF0aCBpbiB0aGUganMgZmlsZXMgKGllLiB1c2luZyBgLi9BdXRvTnVtZXJpY0hlbHBlcmAgaW5zdGVhZCBvZiBqdXN0IGBBdXRvTnVtZXJpY0hlbHBlcmApIChjZi4gaHR0cDovL21vZHVzY3JlYXRlLmNvbS9lczYtZXMyMDE1LWltcG9ydC1uby1yZWxhdGl2ZS1wYXRoLXdlYnBhY2svKVxuaW1wb3J0IEF1dG9OdW1lcmljSGVscGVyIGZyb20gJy4vQXV0b051bWVyaWNIZWxwZXInO1xuaW1wb3J0IEF1dG9OdW1lcmljRW51bSBmcm9tICcuL0F1dG9OdW1lcmljRW51bSc7XG5cbi8qKlxuICogQ2xhc3MgZGVjbGFyYXRpb24gZm9yIHRoZSBBdXRvTnVtZXJpYyBvYmplY3QuXG4gKlxuICogQW4gQXV0b051bWVyaWMgZWxlbWVudCBpcyBhbiBvYmplY3Qgd3JhcHBlciB0aGF0IGtlZXBzIGEgcmVmZXJlbmNlIHRvIHRoZSBET00gZWxlbWVudCBpdCBtYW5hZ2VzICh1c3VhbGx5IGFuIDxpbnB1dD4gb25lKSwgYW5kIHByb3ZpZGVzIGF1dG9OdW1lcmljLXNwZWNpZmljIHZhcmlhYmxlcyBhbmQgZnVuY3Rpb25zLlxuICovXG5jbGFzcyBBdXRvTnVtZXJpYyB7XG4gICAgLy9UT0RPIFVzZSB0aGUgYmV0dGVyIG5vdGF0aW9uIGBleHBvcnQgZGVmYXVsdCBjbGFzc2Agd2hlbiB3ZWJwYWNrIGFuZCBiYWJlbCB3aWxsIGFsbG93IGl0IChjZi4gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9pc3N1ZXMvNzA2KVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIEF1dG9OdW1lcmljIG9iamVjdCBvbnRvIHRoZSBnaXZlbiBET00gZWxlbWVudCwgYW5kIGF0dGFjaCB0aGUgc2V0dGluZ3MgYW5kIHJlbGF0ZWQgZXZlbnQgbGlzdGVuZXJzIHRvIGl0LlxuICAgICAqIFRoZSBvcHRpb25zIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgc2V0dGluZ3MgKGllLiB7ZGlnaXRHcm91cFNlcGFyYXRvcjogXCIuXCIsIGRlY2ltYWxDaGFyYWN0ZXI6IFwiLFwiLCBjdXJyZW5jeVN5bWJvbDogJ+KCrCAnfSlcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYW5FbGVtZW50ID0gbmV3IEF1dG9OdW1lcmljKGRvbUVsZW1lbnQpOyAvLyBXaXRoIHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAgICAgKiBhbkVsZW1lbnQgPSBuZXcgQXV0b051bWVyaWMoZG9tRWxlbWVudCwgeyBvcHRpb25zIH0pOyAvLyBXaXRoIG9uZSBvcHRpb24gb2JqZWN0XG4gICAgICogYW5FbGVtZW50ID0gbmV3IEF1dG9OdW1lcmljKGRvbUVsZW1lbnQsICdldXJvUG9zJyk7IC8vIFdpdGggYSBuYW1lZCBwcmUtZGVmaW5lZCBzdHJpbmdcbiAgICAgKiBhbkVsZW1lbnQgPSBuZXcgQXV0b051bWVyaWMoZG9tRWxlbWVudCwgW3sgb3B0aW9uczEgfSwgJ2V1cm9Qb3MnLCB7IG9wdGlvbnMyIH1dKTsgLy8gV2l0aCBtdWx0aXBsZSBvcHRpb24gb2JqZWN0cyAodGhlIGxhdGVzdCBvcHRpb24gb3ZlcndyaXRpbmcgdGhlIHByZXZpb3VzIG9uZXMpXG4gICAgICogYW5FbGVtZW50ID0gbmV3IEF1dG9OdW1lcmljKGRvbUVsZW1lbnQsIG51bGwsIHsgb3B0aW9ucyB9KTsgLy8gV2l0aCBvbmUgb3B0aW9uIG9iamVjdCwgYW5kIGEgZmFpbGVkIGluaXRpYWwgdmFsdWVcbiAgICAgKiBhbkVsZW1lbnQgPSBuZXcgQXV0b051bWVyaWMoZG9tRWxlbWVudCkuZnJlbmNoKCk7IC8vIFdpdGggb25lIHByZS1kZWZpbmVkIGxhbmd1YWdlIG9iamVjdFxuICAgICAqIGFuRWxlbWVudCA9IG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50KS5mcmVuY2goeyBvcHRpb25zIH0pOy8vIFdpdGggb25lIHByZS1kZWZpbmVkIGxhbmd1YWdlIG9iamVjdCBhbmQgYWRkaXRpb25hbCBvcHRpb25zIHRoYXQgd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdHNcbiAgICAgKlxuICAgICAqIC8vIC4uLm9yIGluaXQgYW5kIHNldCB0aGUgdmFsdWUgaW4gb25lIGNhbGwgOlxuICAgICAqIGFuRWxlbWVudCA9IG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50LCAxMjM0NS43ODkpOyAvLyBXaXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMsIGFuZCBhbiBpbml0aWFsIHZhbHVlXG4gICAgICogYW5FbGVtZW50ID0gbmV3IEF1dG9OdW1lcmljKGRvbUVsZW1lbnQsIDEyMzQ1Ljc4OSwgeyBvcHRpb25zIH0pO1xuICAgICAqIGFuRWxlbWVudCA9IG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50LCAnMTIzNDUuNzg5JywgeyBvcHRpb25zIH0pO1xuICAgICAqIGFuRWxlbWVudCA9IG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50LCAxMjM0NS43ODksICdldXJvUG9zJyk7XG4gICAgICogYW5FbGVtZW50ID0gbmV3IEF1dG9OdW1lcmljKGRvbUVsZW1lbnQsIDEyMzQ1Ljc4OSwgW3sgb3B0aW9uczEgfSwgJ2V1cm9Qb3MnLCB7IG9wdGlvbnMyIH1dKTtcbiAgICAgKiBhbkVsZW1lbnQgPSBuZXcgQXV0b051bWVyaWMoZG9tRWxlbWVudCwgMTIzNDUuNzg5KS5mcmVuY2goeyBvcHRpb25zIH0pO1xuICAgICAqIGFuRWxlbWVudCA9IG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50LCAxMjM0NS43ODksIHsgb3B0aW9ucyB9KS5mcmVuY2goeyBvcHRpb25zIH0pOyAvLyBOb3QgcmVhbGx5IGhlbHBmdWwsIGJ1dCBwb3NzaWJsZVxuICAgICAqXG4gICAgICogLy8gVGhlIEF1dG9OdW1lcmljIGNvbnN0cnVjdG9yIGNsYXNzIGNhbiBhbHNvIGFjY2VwdCBhIHN0cmluZyBhcyBhIGNzcyBzZWxlY3Rvci4gVW5kZXIgdGhlIGhvb2QgdGhpcyB1c2UgYFF1ZXJ5U2VsZWN0b3JgIGFuZCBsaW1pdCBpdHNlbGYgdG8gb25seSB0aGUgZmlyc3QgZWxlbWVudCBpdCBmaW5kcy5cbiAgICAgKiBhbkVsZW1lbnQgPSBuZXcgQXV0b051bWVyaWMoJy5teUNzc0NsYXNzID4gaW5wdXQnKTtcbiAgICAgKiBhbkVsZW1lbnQgPSBuZXcgQXV0b051bWVyaWMoJy5teUNzc0NsYXNzID4gaW5wdXQnLCB7IG9wdGlvbnMgfSk7XG4gICAgICogYW5FbGVtZW50ID0gbmV3IEF1dG9OdW1lcmljKCcubXlDc3NDbGFzcyA+IGlucHV0JywgJ2V1cm9Qb3MnKTtcbiAgICAgKiBhbkVsZW1lbnQgPSBuZXcgQXV0b051bWVyaWMoJy5teUNzc0NsYXNzID4gaW5wdXQnLCBbeyBvcHRpb25zMSB9LCAnZXVyb1BvcycsIHsgb3B0aW9uczIgfV0pO1xuICAgICAqIGFuRWxlbWVudCA9IG5ldyBBdXRvTnVtZXJpYygnLm15Q3NzQ2xhc3MgPiBpbnB1dCcsIDEyMzQ1Ljc4OSk7XG4gICAgICogYW5FbGVtZW50ID0gbmV3IEF1dG9OdW1lcmljKCcubXlDc3NDbGFzcyA+IGlucHV0JywgMTIzNDUuNzg5LCB7IG9wdGlvbnMgfSk7XG4gICAgICogYW5FbGVtZW50ID0gbmV3IEF1dG9OdW1lcmljKCcubXlDc3NDbGFzcyA+IGlucHV0JywgMTIzNDUuNzg5LCAnZXVyb1BvcycpO1xuICAgICAqIGFuRWxlbWVudCA9IG5ldyBBdXRvTnVtZXJpYygnLm15Q3NzQ2xhc3MgPiBpbnB1dCcsIDEyMzQ1Ljc4OSwgW3sgb3B0aW9uczEgfSwgJ2V1cm9Qb3MnLCB7IG9wdGlvbnMyIH1dKTtcbiAgICAgKiBhbkVsZW1lbnQgPSBuZXcgQXV0b051bWVyaWMoJy5teUNzc0NsYXNzID4gaW5wdXQnLCBudWxsLCB7IG9wdGlvbnMgfSk7IC8vIFdpdGggYSBmYWlsZWQgaW5pdGlhbCB2YWx1ZVxuICAgICAqIGFuRWxlbWVudCA9IG5ldyBBdXRvTnVtZXJpYygnLm15Q3NzQ2xhc3MgPiBpbnB1dCcsIDEyMzQ1Ljc4OSkuZnJlbmNoKHsgb3B0aW9ucyB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fEFycmF5fG51bWJlcnxzdHJpbmd9IGFyZzFcbiAgICAgKiBAcGFyYW0ge29iamVjdHxBcnJheXxudW1iZXJ8c3RyaW5nfG51bGx9IGFyZzJcbiAgICAgKiBAcGFyYW0ge29iamVjdHxBcnJheXxudW1iZXJ8c3RyaW5nfG51bGx9IGFyZzNcbiAgICAgKiBAdGhyb3dzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXJnMSA9IG51bGwsIGFyZzIgPSBudWxsLCBhcmczID0gbnVsbCkge1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLSBJbml0aWFsaXphdGlvblxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBhcmd1bWVudHNcbiAgICAgICAgY29uc3QgeyBkb21FbGVtZW50LCBpbml0aWFsVmFsdWUsIHVzZXJPcHRpb25zIH0gPSBBdXRvTnVtZXJpYy5fc2V0QXJndW1lbnRzVmFsdWVzKGFyZzEsIGFyZzIsIGFyZzMpO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGVsZW1lbnRcbiAgICAgICAgdGhpcy5kb21FbGVtZW50ID0gZG9tRWxlbWVudDtcblxuICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgc2V0dGluZ3NcbiAgICAgICAgdGhpcy5kZWZhdWx0UmF3VmFsdWUgPSAnJzsgLy8gVGhlIGRlZmF1bHQgcmF3IHZhbHVlIHRvIHNldCB3aGVuIGluaXRpYWxpemluZyBhbiBBdXRvTnVtZXJpYyBvYmplY3RcbiAgICAgICAgdGhpcy5fc2V0U2V0dGluZ3ModXNlck9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgLy9UT0RPIElmIGBzdHlsZVJ1bGVzYCBpcyBub3QgbnVsbCwgYWRkIGJ5IGRlZmF1bHQgYSBjbGFzcyAnYXV0b051bWVyaWMnIHRoYXQgYWRkcyB0cmFuc2l0aW9uIHRvIGNvbG9yLCBiYWNrZ3JvdW5kLWNvbG9yLCBib3JkZXItY29sb3IgcHJvcGVydGllc1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgRE9NIGVsZW1lbnQgaXMgc3VwcG9ydGVkXG4gICAgICAgIHRoaXMuX2NoZWNrRWxlbWVudCgpO1xuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBhZGRpdGlvbmFsIGF0dHJpYnV0ZXMgaW5zaWRlIHRoZSBBdXRvTnVtZXJpYyBvYmplY3RcbiAgICAgICAgLy8gTm90ZTogVGhpcyB2YXJpYWJsZSBpcyBuZWVkZWQgYW5kIG5vdCBhIGR1cGxpY2F0ZSBvZiBgaW5pdGlhbFZhbHVlT25LZXlkb3duYCBub3IgYHZhbHVlT25Gb2N1c2Agc2luY2UgaXQgc2VydmVzIGEgZGlmZmVyZW50IHB1cnBvc2UgYW5kIGhhcyBhIGRpZmZlcmVudCBsaWZlY3ljbGVcbiAgICAgICAgdGhpcy5zYXZlZENhbmNlbGxhYmxlVmFsdWUgPSBudWxsO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHVuZG8vcmVkbyB2YXJpYWJsZXNcbiAgICAgICAgdGhpcy5oaXN0b3J5VGFibGUgPSBbXTsgLy8gS2VlcCB0cmFjayBvZiAqYWxsKiB2YWxpZCBzdGF0ZXMgb2YgdGhlIGVsZW1lbnQgdmFsdWVcbiAgICAgICAgdGhpcy5oaXN0b3J5VGFibGVJbmRleCA9IC0xOyAvLyBQb2ludGVyIHRvIHRoZSBjdXJyZW50IHVuZG8vcmVkbyBzdGF0ZS4gVGhpcyB3aWxsIGJlIHNldCB0byAnMCcgZHVyaW5nIGluaXRpYWxpemF0aW9uIHNpbmNlIGl0IGZpcnN0IGFkZHMgaXRzZWxmLlxuICAgICAgICB0aGlzLm9uR29pbmdSZWRvID0gZmFsc2U7IC8vIFZhcmlhYmxlIHRoYXQga2VlcHMgdHJhY2sgaWYgYSAncmVkbycgaXMgb25nb2luZyAoaW4gb3JkZXIgdG8gcHJldmVudCBhbiAndW5kbycgdG8gYmUgbGF1bmNoIHdoZW4gcmVsZWFzaW5nIHRoZSBzaGlmdCBrZXkgYmVmb3JlIHRoZSBjdHJsIGtleSBhZnRlciBhICdyZWRvJyBzaG9ydGN1dClcblxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBwYXJlbnQgZm9ybSBlbGVtZW50LCBpZiBhbnlcbiAgICAgICAgdGhpcy5wYXJlbnRGb3JtID0gdGhpcy5fZ2V0UGFyZW50Rm9ybSgpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgaW5pdGlhbCB2YWx1ZSBpZiBpdCBleGlzdHMgYW5kIGlmIHRoZSBgZm9ybWF0T25QYWdlTG9hZGAgb3B0aW9uIHdpbGwgYWxsb3cgaXRcbiAgICAgICAgaWYgKCF0aGlzLnJ1bk9uY2UgJiYgdGhpcy5zZXR0aW5ncy5mb3JtYXRPblBhZ2VMb2FkKSB7XG4gICAgICAgICAgICAvLyBGb3JtYXQgdGhlIGVsZW1lbnQgdmFsdWUgaWYgbmVlZGVkXG4gICAgICAgICAgICB0aGlzLl9mb3JtYXREZWZhdWx0VmFsdWVPblBhZ2VMb2FkKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJ1bk9uY2UgPSB0cnVlO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgZXZlbnRzIGxpc3RlbmVycyBvbmx5IG9uIGlucHV0IGVsZW1lbnRzXG4gICAgICAgIGlmICh0aGlzLmlzSW5wdXRFbGVtZW50IHx8IHRoaXMuaXNDb250ZW50RWRpdGFibGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5ub0V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgLy9YWFggSGVyZSB3ZSBtYWtlIHN1cmUgdGhlIGdsb2JhbCBsaXN0IGlzIGNyZWF0ZWQgYWZ0ZXIgY3JlYXRpbmcgdGhlIGV2ZW50IGxpc3RlbmVycywgdG8gb25seSBjcmVhdGUgdGhlIGV2ZW50IGxpc3RlbmVycyBvbiBgZG9jdW1lbnRgIG9uY2VcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVFdmVudExpc3RlbmVycygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9zZXRSZWFkT25seSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2F2ZSB0aGUgaW5pdGlhbCB2YWx1ZXMgKGh0bWwgYXR0cmlidXRlICsgZWxlbWVudC52YWx1ZSkgZm9yIHRoZSBwcmlzdGluZSB0ZXN0XG4gICAgICAgIHRoaXMuX3NhdmVJbml0aWFsVmFsdWVzKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXR1cCB0aGUgZGF0YSBmb3IgdGhlIHBlcnNpc3RlbnQgc3RvcmFnZSBzb2x1dGlvbiAoaWUuIHNlc3Npb25TdG9yYWdlIG9yIGNvb2tpZXMpXG4gICAgICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2VBdmFpbGFibGUgPSB0aGlzLmNvbnN0cnVjdG9yLl9zdG9yYWdlVGVzdCgpO1xuICAgICAgICB0aGlzLnN0b3JhZ2VOYW1lUHJlZml4ID0gJ0FVVE9fJzsgLy8gVGhlIHByZWZpeCBmb3IgdGhlIHJhdyB2YWx1ZSBzdG9yYWdlIG5hbWUgdmFyaWFibGUgY2FuIGJlIG1vZGlmaWVkIGhlcmVcbiAgICAgICAgdGhpcy5fc2V0UGVyc2lzdGVudFN0b3JhZ2VOYW1lKCk7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0gVHJhY2tpbmdcbiAgICAgICAgLy8gS2VlcCB0cmFjayBpZiB0aGUgZWxlbWVudCBpcyBjdXJyZW50bHkgZm9jdXNlZFxuICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAvLyBLZWVwIHRyYWNrIGlmIGEgbW91c2Ugd2hlZWwgZXZlbnQgaXMgY3VycmVudGx5IG9uZ29pbmdcbiAgICAgICAgdGhpcy5pc1doZWVsRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgLy8gS2VlcCB0cmFjayBpZiBhIGRyb3AgZXZlbnQgaXMgY3VycmVudGx5IG9uZ29pbmdcbiAgICAgICAgdGhpcy5pc0Ryb3BFdmVudCA9IGZhbHNlO1xuICAgICAgICAvLyBLZWVwIHRyYWNrIGlmIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBlZGl0aW5nIHRoZSBlbGVtZW50XG4gICAgICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY3JlYXRlTG9jYWxMaXN0KSB7XG4gICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIGV2ZXJ5IEF1dG9OdW1lcmljIGVsZW1lbnRzIHRoYXQgdGhpcyBvYmplY3QgaW5pdGlhbGl6ZWRcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUxvY2FsTGlzdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBhbGwgQXV0b051bWVyaWMgZWxlbWVudHMgaW4gdGhlIGN1cnJlbnQgd2ViIHBhZ2VcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fYWRkVG9HbG9iYWxMaXN0KHRoaXMpO1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tIE1ldGhvZHNcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBnbG9iYWwgZnVuY3Rpb25zXG4gICAgICAgIHRoaXMuZ2xvYmFsID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgdGhlIHNhbWUgZ2l2ZW4gZWxlbWVudCB2YWx1ZSBmb3IgZWFjaCBlbGVtZW50cyBpbiB0aGUgbG9jYWwgQXV0b051bWVyaWMgZWxlbWVudCBsaXN0LCBhbmQgZm9ybWF0IHRob3NlIGVsZW1lbnRzIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBuZXdWYWx1ZSBUaGUgdmFsdWUgbXVzdCBiZSBhIG51bWJlciBvciBhIG51bWVyaWMgc3RyaW5nXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBIHNldHRpbmdzIG9iamVjdCB0aGF0IHdpbGwgb3ZlcnJpZGUgdGhlIGN1cnJlbnQgc2V0dGluZ3MuIE5vdGU6IHRoZSB1cGRhdGUgaXMgZG9uZSBvbmx5IGlmIHRoZSBgbmV3VmFsdWVgIGlzIGRlZmluZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldDogKG5ld1ZhbHVlLCBvcHRpb25zID0gbnVsbCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3QuZm9yRWFjaChhTk9iamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFOT2JqZWN0LnNldChuZXdWYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCB0aGUgdmFsdWUgZ2l2ZW4gdmFsdWUgZGlyZWN0bHkgYXMgdGhlIERPTSBlbGVtZW50IHZhbHVlLCB3aXRob3V0IGZvcm1hdHRpbmcgaXQgYmVmb3JlaGFuZC5cbiAgICAgICAgICAgICAqIFRoaXMgc2V0cyB0aGUgc2FtZSB1bmZvcm1hdHRlZCB2YWx1ZSBmb3IgZWFjaCBlbGVtZW50cyBpbiB0aGUgbG9jYWwgQXV0b051bWVyaWMgZWxlbWVudCBsaXN0LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldFVuZm9ybWF0dGVkOiAodmFsdWUsIG9wdGlvbnMgPSBudWxsKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdC5mb3JFYWNoKGFOT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYU5PYmplY3Quc2V0VW5mb3JtYXR0ZWQodmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIGlzIGFuIGFsaWFzIG9mIHRoZSBgZ2V0TnVtZXJpY1N0cmluZygpYCBmdW5jdGlvbiwgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBhbnltb3JlLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258bnVsbH0gY2FsbGJhY2sgSWYgYSBjYWxsYmFjayBpcyBwYXNzZWQsIHRoZW4gdGhlIHJlc3VsdCBpcyBwYXNzZWQgdG8gaXQgYXMgaXRzIGZpcnN0IGFyZ3VtZW50LCBhbmQgdGhlIEF1dG9OdW1lcmljIG9iamVjdCBoYXMgaXRzIHNlY29uZFxuICAgICAgICAgICAgICogQHJldHVybnMge0FycmF5PHN0cmluZz59XG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IChjYWxsYmFjayA9IG51bGwpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0LmZvckVhY2goYU5PYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhTk9iamVjdC5nZXQoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXhlY3V0ZUNhbGxiYWNrKHJlc3VsdCwgY2FsbGJhY2spO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJuIGFuIGFycmF5IG9mIHRoZSB1bmZvcm1hdHRlZCB2YWx1ZXMgKGFzIGEgc3RyaW5nKSBvZiBlYWNoIEF1dG9OdW1lcmljIGVsZW1lbnQgb2YgdGhlIGxvY2FsIEF1dG9OdW1lcmljIGVsZW1lbnQgbGlzdFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258bnVsbH0gY2FsbGJhY2sgSWYgYSBjYWxsYmFjayBpcyBwYXNzZWQsIHRoZW4gdGhlIHJlc3VsdCBpcyBwYXNzZWQgdG8gaXQgYXMgaXRzIGZpcnN0IGFyZ3VtZW50LCBhbmQgdGhlIEF1dG9OdW1lcmljIG9iamVjdCBoYXMgaXRzIHNlY29uZFxuICAgICAgICAgICAgICogQHJldHVybnMge0FycmF5PHN0cmluZz59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldE51bWVyaWNTdHJpbmc6IChjYWxsYmFjayA9IG51bGwpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0LmZvckVhY2goYU5PYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhTk9iamVjdC5nZXROdW1lcmljU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGVDYWxsYmFjayhyZXN1bHQsIGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybiBhbiBhcnJheSBvZiB0aGUgY3VycmVudCBmb3JtYXR0ZWQgdmFsdWVzIChhcyBhIHN0cmluZykgb2YgZWFjaCBBdXRvTnVtZXJpYyBlbGVtZW50IG9mIHRoZSBsb2NhbCBBdXRvTnVtZXJpYyBlbGVtZW50IGxpc3RcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG51bGx9IGNhbGxiYWNrIElmIGEgY2FsbGJhY2sgaXMgcGFzc2VkLCB0aGVuIHRoZSByZXN1bHQgaXMgcGFzc2VkIHRvIGl0IGFzIGl0cyBmaXJzdCBhcmd1bWVudCwgYW5kIHRoZSBBdXRvTnVtZXJpYyBvYmplY3QgaGFzIGl0cyBzZWNvbmRcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRGb3JtYXR0ZWQ6IChjYWxsYmFjayA9IG51bGwpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0LmZvckVhY2goYU5PYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhTk9iamVjdC5nZXRGb3JtYXR0ZWQoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXhlY3V0ZUNhbGxiYWNrKHJlc3VsdCwgY2FsbGJhY2spO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJuIGFuIGFycmF5IG9mIHRoZSBlbGVtZW50IHVuZm9ybWF0dGVkIHZhbHVlcyAoYXMgYSByZWFsIEphdmFzY3JpcHQgbnVtYmVyKSwgZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgbG9jYWwgQXV0b051bWVyaWMgZWxlbWVudCBsaXN0XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbnxudWxsfSBjYWxsYmFjayBJZiBhIGNhbGxiYWNrIGlzIHBhc3NlZCwgdGhlbiB0aGUgcmVzdWx0IGlzIHBhc3NlZCB0byBpdCBhcyBpdHMgZmlyc3QgYXJndW1lbnQsIGFuZCB0aGUgQXV0b051bWVyaWMgb2JqZWN0IGhhcyBpdHMgc2Vjb25kXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0TnVtYmVyOiAoY2FsbGJhY2sgPSBudWxsKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdC5mb3JFYWNoKGFOT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYU5PYmplY3QuZ2V0TnVtYmVyKCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGVDYWxsYmFjayhyZXN1bHQsIGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIHVuZm9ybWF0dGVkIHZhbHVlcyAoZm9sbG93aW5nIHRoZSBgb3V0cHV0Rm9ybWF0YCBzZXR0aW5nKSBvZiBlYWNoIGVsZW1lbnQgb2YgdGhlIGxvY2FsIEF1dG9OdW1lcmljIGVsZW1lbnQgbGlzdCBpbnRvIGFuIGFycmF5XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbnxudWxsfSBjYWxsYmFjayBJZiBhIGNhbGxiYWNrIGlzIHBhc3NlZCwgdGhlbiB0aGUgcmVzdWx0IGlzIHBhc3NlZCB0byBpdCBhcyBpdHMgZmlyc3QgYXJndW1lbnQsIGFuZCB0aGUgQXV0b051bWVyaWMgb2JqZWN0IGhhcyBpdHMgc2Vjb25kXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0TG9jYWxpemVkOiAoY2FsbGJhY2sgPSBudWxsKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdC5mb3JFYWNoKGFOT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYU5PYmplY3QuZ2V0TG9jYWxpemVkKCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGVDYWxsYmFjayhyZXN1bHQsIGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZvcmNlIGVhY2ggZWxlbWVudCBvZiB0aGUgbG9jYWwgQXV0b051bWVyaWMgZWxlbWVudCBsaXN0IHRvIHJlZm9ybWF0IGl0cyB2YWx1ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZWZvcm1hdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3QuZm9yRWFjaChhTk9iamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFOT2JqZWN0LnJlZm9ybWF0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlbW92ZSB0aGUgZm9ybWF0dGluZyBhbmQga2VlcCBvbmx5IHRoZSByYXcgdW5mb3JtYXR0ZWQgdmFsdWUgKGFzIGEgbnVtZXJpY1N0cmluZykgaW4gZWFjaCBlbGVtZW50cyBvZiB0aGUgbG9jYWwgQXV0b051bWVyaWMgZWxlbWVudCBsaXN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHVuZm9ybWF0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdC5mb3JFYWNoKGFOT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYU5PYmplY3QudW5mb3JtYXQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlIHRoZSBmb3JtYXR0aW5nIGFuZCBrZWVwIG9ubHkgdGhlIGxvY2FsaXplZCB1bmZvcm1hdHRlZCB2YWx1ZSBpbiB0aGUgZWxlbWVudCwgd2l0aCB0aGUgb3B0aW9uIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG91dHB1dEZvcm1hdCBpZiBuZWVkZWRcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bGx8c3RyaW5nfSBmb3JjZWRPdXRwdXRGb3JtYXQgSWYgc2V0IHRvIHNvbWV0aGluZyBkaWZmZXJlbnQgdGhhbiBgbnVsbGAsIHRoZW4gdGhpcyBpcyB1c2VkIGFzIGFuIG92ZXJyaWRpbmcgb3V0cHV0Rm9ybWF0IG9wdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB1bmZvcm1hdExvY2FsaXplZDogKGZvcmNlZE91dHB1dEZvcm1hdCA9IG51bGwpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0LmZvckVhY2goYU5PYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhTk9iamVjdC51bmZvcm1hdExvY2FsaXplZChmb3JjZWRPdXRwdXRGb3JtYXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGVzIHRoZSBBdXRvTnVtZXJpYyBzZXR0aW5ncywgYW5kIGltbWVkaWF0ZWx5IGZvcm1hdCB0aGUgZWxlbWVudHMgYWNjb3JkaW5nbHksIGZvciBlYWNoIGVsZW1lbnRzIG9mIHRoZSBsb2NhbCBBdXRvTnVtZXJpYyBlbGVtZW50IGxpc3RcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3T3B0aW9ucyBUaGlzIGNhbiBiZSBlaXRoZXIgb25lIG9yIG1vcmUgb3B0aW9uIG9iamVjdHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdXBkYXRlOiAoLi4ubmV3T3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3QuZm9yRWFjaChhTk9iamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFOT2JqZWN0LnVwZGF0ZSguLi5uZXdPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJuIGB0cnVlYCBpZiAqYWxsKiB0aGUgYXV0b051bWVyaWMtbWFuYWdlZCBlbGVtZW50cyBhcmUgcHJpc3RpbmUsIGlmIHRoZWlyIHJhdyB2YWx1ZSBoYXNuJ3QgY2hhbmdlZC5cbiAgICAgICAgICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJhdyB1bmZvcm1hdHRlZCB2YWx1ZSBpcyBzdGlsbCB0aGUgc2FtZSBldmVuIGlmIHRoZSBmb3JtYXR0ZWQgb25lIGhhcyBjaGFuZ2VkIChkdWUgdG8gYSBjb25maWd1cmF0aW9uIHVwZGF0ZSBmb3IgaW5zdGFuY2UpLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tPbmx5UmF3VmFsdWUgSWYgc2V0IHRvIGB0cnVlYCwgdGhlIHByaXN0aW5lIHZhbHVlIGlzIGRvbmUgb24gdGhlIHJhdyB1bmZvcm1hdHRlZCB2YWx1ZSwgbm90IHRoZSBmb3JtYXR0ZWQgb25lLiBJZiBzZXQgdG8gYGZhbHNlYCwgdGhpcyBhbHNvIGNoZWNrcyB0aGF0IHRoZSBmb3JtYXR0ZWQgdmFsdWUgaGFzbid0IGNoYW5nZWQuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaXNQcmlzdGluZTogKGNoZWNrT25seVJhd1ZhbHVlID0gdHJ1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpc1ByaXN0aW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0LmZvckVhY2goYU5PYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcmlzdGluZSAmJiAhYU5PYmplY3QuaXNQcmlzdGluZShjaGVja09ubHlSYXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJpc3RpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJpc3RpbmU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEV4ZWN1dGUgdGhlIGBjbGVhcigpYCBtZXRob2Qgb24gZWFjaCBBdXRvTnVtZXJpYyBvYmplY3QgaW4gdGhlIGxvY2FsIEF1dG9OdW1lcmljIGVsZW1lbnQgbGlzdFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VDbGVhckFsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjbGVhcjogKGZvcmNlQ2xlYXJBbGwgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3QuZm9yRWFjaChhTk9iamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFOT2JqZWN0LmNsZWFyKGZvcmNlQ2xlYXJBbGwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFeGVjdXRlIHRoZSBgcmVtb3ZlKClgIG1ldGhvZCBvbiBlYWNoIEF1dG9OdW1lcmljIG9iamVjdCBpbiB0aGUgbG9jYWwgQXV0b051bWVyaWMgZWxlbWVudCBsaXN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJlbW92ZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3QuZm9yRWFjaChhTk9iamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFOT2JqZWN0LnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFeGVjdXRlIHRoZSBgd2lwZSgpYCBtZXRob2Qgb24gZWFjaCBBdXRvTnVtZXJpYyBvYmplY3QgaW4gdGhlIGxvY2FsIEF1dG9OdW1lcmljIGVsZW1lbnQgbGlzdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB3aXBlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdC5mb3JFYWNoKGFOT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYU5PYmplY3Qud2lwZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFeGVjdXRlIHRoZSBgbnVrZSgpYCBtZXRob2Qgb24gZWFjaCBBdXRvTnVtZXJpYyBvYmplY3QgaW4gdGhlIGxvY2FsIEF1dG9OdW1lcmljIGVsZW1lbnQgbGlzdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBudWtlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdC5mb3JFYWNoKGFOT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYU5PYmplY3QubnVrZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBnaXZlbiBBdXRvTnVtZXJpYyBvYmplY3QgKG9yIERPTSBlbGVtZW50KSBpcyBpbiB0aGUgbG9jYWwgQXV0b051bWVyaWMgZWxlbWVudCBsaXN0XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MSW5wdXRFbGVtZW50fEF1dG9OdW1lcmljfSBkb21FbGVtZW50T3JBdXRvTnVtZXJpY09iamVjdFxuICAgICAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGhhczogZG9tRWxlbWVudE9yQXV0b051bWVyaWNPYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGRvbUVsZW1lbnRPckF1dG9OdW1lcmljT2JqZWN0IGluc3RhbmNlb2YgQXV0b051bWVyaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdC5oYXMoZG9tRWxlbWVudE9yQXV0b051bWVyaWNPYmplY3Qubm9kZSgpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0Lmhhcyhkb21FbGVtZW50T3JBdXRvTnVtZXJpY09iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWRkIGFuIGV4aXN0aW5nIEF1dG9OdW1lcmljIG9iamVjdCAob3IgRE9NIGVsZW1lbnQpIHRvIHRoZSBsb2NhbCBBdXRvTnVtZXJpYyBlbGVtZW50IGxpc3QsIHVzaW5nIHRoZSBET00gZWxlbWVudCBhcyB0aGUga2V5LlxuICAgICAgICAgICAgICogVGhpcyBtYW5hZ2VzIHRoZSBjYXNlIHdoZXJlIGBhZGRPYmplY3RgIGlzIHVzZWQgb24gYW4gQXV0b051bWVyaWMgb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgbXVsdGlwbGUgZWxlbWVudHMgaW4gaXRzIGxvY2FsIGxpc3QuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MSW5wdXRFbGVtZW50fEF1dG9OdW1lcmljfSBkb21FbGVtZW50T3JBdXRvTnVtZXJpY09iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhZGRPYmplY3Q6IGRvbUVsZW1lbnRPckF1dG9OdW1lcmljT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCB3aXRoIHRoZSBzYW1lIGRhdGEsIHdoYXRldmVyIHRoZSB1c2VyIHBhc3NlZCBhcyBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICBsZXQgZG9tRWxlbWVudDtcbiAgICAgICAgICAgICAgICBsZXQgb3RoZXJBdXRvTnVtZXJpY09iamVjdDtcbiAgICAgICAgICAgICAgICBpZiAoZG9tRWxlbWVudE9yQXV0b051bWVyaWNPYmplY3QgaW5zdGFuY2VvZiBBdXRvTnVtZXJpYykge1xuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50ID0gZG9tRWxlbWVudE9yQXV0b051bWVyaWNPYmplY3Qubm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICBvdGhlckF1dG9OdW1lcmljT2JqZWN0ID0gZG9tRWxlbWVudE9yQXV0b051bWVyaWNPYmplY3Q7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudCA9IGRvbUVsZW1lbnRPckF1dG9OdW1lcmljT2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICBvdGhlckF1dG9OdW1lcmljT2JqZWN0ID0gQXV0b051bWVyaWMuZ2V0QXV0b051bWVyaWNFbGVtZW50KGRvbUVsZW1lbnRPckF1dG9OdW1lcmljT2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCBhdXRvTnVtZXJpYyBvYmplY3QgaGFzIGEgbG9jYWwgbGlzdFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faGFzTG9jYWxMaXN0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlTG9jYWxMaXN0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIG90aGVyIGF1dG9OdW1lcmljIG9iamVjdCBoYXMgYSBsb2NhbCBsaXN0Li4uXG4gICAgICAgICAgICAgICAgbGV0IG90aGVyQU5Mb2NhbExpc3QgPSBvdGhlckF1dG9OdW1lcmljT2JqZWN0Ll9nZXRMb2NhbExpc3QoKTtcbiAgICAgICAgICAgICAgICBpZiAob3RoZXJBTkxvY2FsTGlzdC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBpZiB0aGUgb3RoZXIgQXV0b051bWVyaWMgb2JqZWN0IGhhcyBhbiBlbXB0eSBsb2NhbCBsaXN0LCB0aGVuIHBvcHVsYXRlIGl0c2VsZiB0byBpdFxuICAgICAgICAgICAgICAgICAgICBvdGhlckF1dG9OdW1lcmljT2JqZWN0Ll9jcmVhdGVMb2NhbExpc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJBTkxvY2FsTGlzdCA9IG90aGVyQXV0b051bWVyaWNPYmplY3QuX2dldExvY2FsTGlzdCgpOyAvLyBVcGRhdGUgdGhlIG90aGVyIGxvY2FsIGxpc3RcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgbWVyZ2VkTG9jYWxMaXN0cztcbiAgICAgICAgICAgICAgICBpZiAob3RoZXJBTkxvY2FsTGlzdCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgICAgICAvLyAuLi5JZiBpdCBkb2VzLCBtZXJnZSB0aGUgbG9jYWwgbGlzdHMgdG9nZXRoZXJcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkTG9jYWxMaXN0cyA9IEF1dG9OdW1lcmljSGVscGVyLm1lcmdlTWFwcyh0aGlzLl9nZXRMb2NhbExpc3QoKSwgb3RoZXJBTkxvY2FsTGlzdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uSWYgbm90LCBqdXN0IHNldCB0aGUgY3VycmVudCBsb2NhbCBsaXN0IG9udG8gdGhlIG90aGVyIEF1dG9OdW1lcmljIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHNwZWNpZnkgdGhlIEF1dG9OdW1lcmljIG9iamVjdCwgb3RoZXJ3aXNlIHRoZSBgX2FkZFRvTG9jYWxMaXN0YCBmdW5jdGlvbiB3b3VsZCBub3QgY29ycmVjdGx5IGFkZCB0aGUgQXV0b051bWVyaWMgb2JqZWN0IHNpbmNlIHdlIHdvdWxkIG5vdCBoYXZlIGEgcmVmZXJlbmNlIHRvIGl0LCBidXQgYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgQXV0b051bWVyaWMgb2JqZWN0IG9uIHdoaWNoIGlzIGNhbGxlZCB0aGlzIG1ldGhvZC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVG9Mb2NhbExpc3QoZG9tRWxlbWVudCwgb3RoZXJBdXRvTnVtZXJpY09iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZExvY2FsTGlzdHMgPSB0aGlzLl9nZXRMb2NhbExpc3QoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlc3VsdGluZyBsaXN0LCBvbiBhbGwgdGhlIG9iamVjdHMgb2YgdGhhdCBsb2NhbCBsaXN0IChzbyB0aGF0IHdlIGNhbiBpbmRpZmZlcmVudGx5IHVzZSBgaW5pdCgpYCBvbiBhbnkgb2JqZWN0IGJlbG9uZ2luZyB0byB0aGF0IGxpc3QpXG4gICAgICAgICAgICAgICAgbWVyZ2VkTG9jYWxMaXN0cy5mb3JFYWNoKGFOT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYU5PYmplY3QuX3NldExvY2FsTGlzdChtZXJnZWRMb2NhbExpc3RzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBBdXRvTnVtZXJpYyBvYmplY3QgKG9yIERPTSBlbGVtZW50KSBmcm9tIHRoZSBsb2NhbCBBdXRvTnVtZXJpYyBlbGVtZW50IGxpc3QsIHVzaW5nIHRoZSBET00gZWxlbWVudCBhcyB0aGUga2V5LlxuICAgICAgICAgICAgICogSWYgdGhpcyBmdW5jdGlvbiBhdHRlbXB0cyB0byByZW1vdmUgdGhlIGN1cnJlbnQgQXV0b051bWVyaWMgb2JqZWN0IGZyb20gdGhlIGxvY2FsIGxpc3QsIGEgd2FybmluZyBpcyBzaG93biwgYnV0IHRoZSBkZWxldGlvbiBpcyBzdGlsbCBkb25lLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFNwZWNpYWwgY2FzZXMgOlxuICAgICAgICAgICAgICogLSBJZiB0aGUgY3VycmVudCBvYmplY3QgcmVtb3ZlcyBpdHNlbGYsIHRoZW4gaXQncyByZW1vdmVkIGZyb20gdGhlIHNoYXJlZCBsb2NhbCBsaXN0LCB0aGVuIGEgbmV3IGVtcHR5IGxvY2FsIGxpc3QgaXMgdXNlZC9jcmVhdGVkXG4gICAgICAgICAgICAgKiAtIElmIGFub3RoZXIgb2JqZWN0IHJlbW92ZSB0aGlzIG9iamVjdCwgdGhlbiBhIGxvY2FsIGxpc3Qgd2l0aCBvbmx5IHRoaXMgb2JqZWN0IGlzIHVzZWQvY3JlYXRlZFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTElucHV0RWxlbWVudHxBdXRvTnVtZXJpY30gZG9tRWxlbWVudE9yQXV0b051bWVyaWNPYmplY3RcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcEN1cnJlbnRBTk9iamVjdCBJZiBzZXQgdG8gYGZhbHNlYCwgdGhlbiB0aGUgZnVuY3Rpb24gd2lsbCBhbHNvIHJlbW92ZSB0aGUgY3VycmVudCBBdXRvTnVtZXJpYyBvYmplY3QgaWYgYXNrZWQsIG90aGVyd2lzZSBpdCB3aWxsIGlnbm9yZSBpdCBhbmQgcHJpbnQgYSB3YXJuaW5nIG1lc3NhZ2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVtb3ZlT2JqZWN0OiAoZG9tRWxlbWVudE9yQXV0b051bWVyaWNPYmplY3QsIGtlZXBDdXJyZW50QU5PYmplY3QgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggdGhlIHNhbWUgZGF0YSwgd2hhdGV2ZXIgdGhlIHVzZXIgcGFzc2VkIGFzIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIGxldCBkb21FbGVtZW50O1xuICAgICAgICAgICAgICAgIGxldCBvdGhlckF1dG9OdW1lcmljT2JqZWN0O1xuICAgICAgICAgICAgICAgIGlmIChkb21FbGVtZW50T3JBdXRvTnVtZXJpY09iamVjdCBpbnN0YW5jZW9mIEF1dG9OdW1lcmljKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQgPSBkb21FbGVtZW50T3JBdXRvTnVtZXJpY09iamVjdC5ub2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyQXV0b051bWVyaWNPYmplY3QgPSBkb21FbGVtZW50T3JBdXRvTnVtZXJpY09iamVjdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50ID0gZG9tRWxlbWVudE9yQXV0b051bWVyaWNPYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyQXV0b051bWVyaWNPYmplY3QgPSBBdXRvTnVtZXJpYy5nZXRBdXRvTnVtZXJpY0VsZW1lbnQoZG9tRWxlbWVudE9yQXV0b051bWVyaWNPYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb3RoZXIgb2JqZWN0IGZyb20gdGhlIGxvY2FsIGxpc3RcbiAgICAgICAgICAgICAgICBjb25zdCBpbml0aWFsQ29tcGxldGVMb2NhbExpc3QgPSB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0O1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3QuZGVsZXRlKGRvbUVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsb2NhbCBsaXN0IGZvciBhbGwgb2JqZWN0cyBpbiBpdFxuICAgICAgICAgICAgICAgIGluaXRpYWxDb21wbGV0ZUxvY2FsTGlzdC5mb3JFYWNoKGFOT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYU5PYmplY3QuX3NldExvY2FsTGlzdCh0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICgha2VlcEN1cnJlbnRBTk9iamVjdCAmJiBkb21FbGVtZW50ID09PSB0aGlzLm5vZGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG9iamVjdCBpcyByZW1vdmVkIGJ5IGl0c2VsZlxuICAgICAgICAgICAgICAgICAgICAvLyBFbXB0eSB0aGUgb2JqZWN0IGxvY2FsIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJBdXRvTnVtZXJpY09iamVjdC5fc2V0TG9jYWxMaXN0KG5ldyBNYXApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgb2JqZWN0IGlzIHJlbW92ZWQgYnkgYW5vdGhlciBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBsb2NhbCBsaXN0IGZvciB0aGUgcmVtb3ZlZCBvYmplY3QsIHdpdGggb25seSB0aGlzIG9iamVjdCBpbiBpdFxuICAgICAgICAgICAgICAgICAgICBvdGhlckF1dG9OdW1lcmljT2JqZWN0Ll9jcmVhdGVMb2NhbExpc3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlbW92ZSBhbGwgZWxlbWVudHMgZnJvbSB0aGUgc2hhcmVkIGxpc3QsIGVmZmVjdGl2ZWx5IGVtcHR5aW5nIGl0LlxuICAgICAgICAgICAgICogVGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiBjYWxsaW5nIGBkZXRhY2goKWAgb24gZWFjaCBvZiBpdHMgZWxlbWVudHMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBrZWVwRWFjaEFOT2JqZWN0SW5JdHNPd25MaXN0IElmIHNldCB0byBgdHJ1ZWAsIHRoZW4gaW5zdGVhZCBvZiBjb21wbGV0ZWx5IGVtcHR5aW5nIHRoZSBsb2NhbCBsaXN0IG9mIGVhY2ggQXV0b051bWVyaWMgb2JqZWN0cywgZWFjaCBvbmUgb2YgdGhvc2Uga2VlcHMgaXRzZWxmIGluIGl0cyBvd24gbG9jYWwgbGlzdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlbXB0eTogKGtlZXBFYWNoQU5PYmplY3RJbkl0c093bkxpc3QgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxDb21wbGV0ZUxvY2FsTGlzdCA9IHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3Q7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxvY2FsIGxpc3QgZm9yIGFsbCBvYmplY3RzIGluIGl0XG4gICAgICAgICAgICAgICAgaW5pdGlhbENvbXBsZXRlTG9jYWxMaXN0LmZvckVhY2goYU5PYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2VlcEVhY2hBTk9iamVjdEluSXRzT3duTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYU5PYmplY3QuX2NyZWF0ZUxvY2FsTGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYU5PYmplY3QuX3NldExvY2FsTGlzdChuZXcgTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBhbGwgdGhlIEF1dG9OdW1lcmljIERPTSBlbGVtZW50cyB0aGF0IGhhdmUgYmVlbiBpbml0aWFsaXplZCBieSBlYWNoIG90aGVyXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHJldHVybnMge0FycmF5PEhUTUxFbGVtZW50Pn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZWxlbWVudHM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0LmZvckVhY2goYU5PYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhTk9iamVjdC5ub2RlKCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJuIHRoZSBgTWFwYCBvYmplY3QgZGlyZWN0bHlcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtNYXB9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldExpc3Q6ICgpID0+IHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3QsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudCBpbiB0aGUgbG9jYWwgQXV0b051bWVyaWMgZWxlbWVudCBsaXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzaXplOiAoKSA9PiB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0LnNpemUsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBmdW5jdGlvbnMgdGhhdCB3aWxsIGFsbG93IHRvIGNoYW5nZSBlYWNoIHNldHRpbmcgb25lIGJ5IG9uZVxuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIGVhY2ggb3B0aW9ucywgd2UgZGVmaW5lIGlmIHdlIG5lZWQgdG8gcmVmb3JtYXQgdGhlIGVsZW1lbnQgY29udGVudCAoZG9lcyBjaGFuZ2luZyB0aGUgb3B0aW9ucyBzaG91bGQgY2hhbmdlIHRoZSB3YXkgaXRzIHZhbHVlIGlzIGRpc3BsYXllZD8pLlxuICAgICAgICAgKiBJZiB5ZXMsIHRoZW4gd2UgdXNlIHRoZSBgdXBkYXRlKClgIGZvciBmb3JjZSBhIHJlZm9ybWF0LCBvdGhlcndpc2UsIHdlIGp1c3QgdXBkYXRlIHRoZSBgc2V0dGluZ3NgIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVzZXQgYW55IG9wdGlvbnMgc2V0IHByZXZpb3VzbHksIGJ5IG92ZXJ3cml0aW5nIHRoZW0gd2l0aCB0aGUgZGVmYXVsdCBzZXR0aW5nc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVzZXQgICAgICAgICAgICAgICAgICAgICAgICA6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvL1RPRE8gQWRkIGEgYHNldHRpbmdzYCBwYXJhbWV0ZXIgc28gdGhhdCB0aGUgdXNlciBjYW4gcmVzZXQgdG8gYSBzcGVjaWZpYyBzZXQgb2Ygc2V0dGluZ3MuIFRoaXMgaXMgZGlmZmVyZW50IHRoYW4gdXBkYXRlIHNpbmNlIGl0IGRyb3BzIGFueSBub24tZGVmYXVsdCBzZXR0aW5ncyBiZWZvcmUgdXNpbmcgdGhvc2UgbmV3IHNldHRpbmdzLlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MgPSB7IHJhd1ZhbHVlIDogdGhpcy5kZWZhdWx0UmF3VmFsdWUgfTsgLy8gSGVyZSB3ZSBwYXNzIHRoZSBkZWZhdWx0IHJhd1ZhbHVlIGluIG9yZGVyIHRvIHByZXZlbnQgc2hvd2luZyBhIHdhcm5pbmcgdGhhdCB3ZSB0cnkgdG8gc2V0IGFuIGB1bmRlZmluZWRgIHZhbHVlXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoQXV0b051bWVyaWMuZGVmYXVsdFNldHRpbmdzKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFsbG93RGVjaW1hbFBhZGRpbmcgICAgICAgICAgOiBhbGxvd0RlY2ltYWxQYWRkaW5nID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IGFsbG93RGVjaW1hbFBhZGRpbmcgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Gb2N1cyAgICAgICAgIDogY2FyZXRQb3NpdGlvbk9uRm9jdXMgPT4geyAvL0ZJWE1FIHRlc3QgdGhpc1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuY2FyZXRQb3NpdGlvbk9uRm9jdXMgPSBjYXJldFBvc2l0aW9uT25Gb2N1cztcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNyZWF0ZUxvY2FsTGlzdCAgICAgICAgICAgICAgOiBjcmVhdGVMb2NhbExpc3QgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuY3JlYXRlTG9jYWxMaXN0ID0gY3JlYXRlTG9jYWxMaXN0O1xuXG4gICAgICAgICAgICAgICAgLy8gRGVsZXRlIHRoZSBsb2NhbCBsaXN0IHdoZW4gdGhpcyBpcyBzZXQgdG8gYGZhbHNlYCwgY3JlYXRlIGl0IGlmIHRoaXMgaXMgc2V0IHRvIGB0cnVlYCBhbmQgdGhlcmUgaXMgbm90IHByZS1leGlzdGluZyBsaXN0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY3JlYXRlTG9jYWxMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faGFzTG9jYWxMaXN0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUxvY2FsTGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVsZXRlTG9jYWxMaXN0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3VycmVuY3lTeW1ib2wgICAgICAgICAgICAgICA6IGN1cnJlbmN5U3ltYm9sID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IGN1cnJlbmN5U3ltYm9sIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgICAgICA6IGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50IH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjaW1hbENoYXJhY3RlciAgICAgICAgICAgICA6IGRlY2ltYWxDaGFyYWN0ZXIgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgZGVjaW1hbENoYXJhY3RlciB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSAgOiBkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlID0gZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGUgdGhlIGRlY2ltYWwgcGxhY2VzIGdsb2JhbGx5LCB3aGljaCBtZWFucyB0aGlzIG92ZXJyaWRlIGFueSBwcmV2aW91c2x5IHNldCBudW1iZXIgb2YgZGVjaW1hbCBzaG93biBvbiBmb2N1cywgb24gYmx1ciwgb3IgaW4gdGhlIHJhdyB2YWx1ZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2ludH0gZGVjaW1hbFBsYWNlc1xuICAgICAgICAgICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkZWNpbWFsUGxhY2VzICAgICAgICAgICAgICAgIDogZGVjaW1hbFBsYWNlcyA9PiB7XG4gICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIud2FybmluZygnVXNpbmcgYG9wdGlvbnMuZGVjaW1hbFBsYWNlcygpYCBpbnN0ZWFkIG9mIGNhbGxpbmcgdGhlIHNwZWNpZmljIGBvcHRpb25zLmRlY2ltYWxQbGFjZXNSYXdWYWx1ZSgpYCwgYG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cygpYCBhbmQgYG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25CbHVyKClgIG1ldGhvZHMgd2lsbCByZXNldCB0aG9zZSBvcHRpb25zLlxcblBsZWFzZSBjYWxsIHRoZSBzcGVjaWZpYyBtZXRob2RzIGlmIHlvdSBkbyBub3Qgd2FudCB0byByZXNldCB0aG9zZS4nLCB0aGlzLnNldHRpbmdzLnNob3dXYXJuaW5ncyk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBkZWNpbWFsUGxhY2VzIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlICAgICAgICA6IGRlY2ltYWxQbGFjZXNSYXdWYWx1ZSA9PiB7IC8vRklYTUUgdGVzdCB0aGlzXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBkZWNpbWFsUGxhY2VzUmF3VmFsdWUgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNpbWFsUGxhY2VzU2hvd25PbkJsdXIgICAgIDogZGVjaW1hbFBsYWNlc1Nob3duT25CbHVyID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IGRlY2ltYWxQbGFjZXNTaG93bk9uQmx1ciB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgICAgOiBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVPdmVycmlkZSAgICAgICAgIDogZGVmYXVsdFZhbHVlT3ZlcnJpZGUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgZGVmYXVsdFZhbHVlT3ZlcnJpZGUgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaWdpdGFsR3JvdXBTcGFjaW5nICAgICAgICAgIDogZGlnaXRhbEdyb3VwU3BhY2luZyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBkaWdpdGFsR3JvdXBTcGFjaW5nIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICAgICAgICA6IGRpZ2l0R3JvdXBTZXBhcmF0b3IgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgZGlnaXRHcm91cFNlcGFyYXRvciB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpdmlzb3JXaGVuVW5mb2N1c2VkICAgICAgICAgOiBkaXZpc29yV2hlblVuZm9jdXNlZCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBkaXZpc29yV2hlblVuZm9jdXNlZCB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVtcHR5SW5wdXRCZWhhdmlvciAgICAgICAgICAgOiBlbXB0eUlucHV0QmVoYXZpb3IgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJhd1ZhbHVlID09PSBudWxsICYmIGVtcHR5SW5wdXRCZWhhdmlvciAhPT0gQXV0b051bWVyaWMub3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3IubnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgOiBpZiB0aGUgY3VycmVudCBgcmF3VmFsdWVgIGlzIGBudWxsYCBhbmQgdGhlIGBlbXB0eUlucHV0QmVoYXZpb3JgIGlzIGNoYW5nZWQgdG8gc29tZXRoaW5nIGVsc2UgdGhhbiBgJ251bGwnYCwgdGhlbiBpdCBtYWtlcyB0aGF0IGByYXdWYWx1ZWAgaW52YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gSGVyZSB3ZSBjYW4gZWl0aGVyIHByZXZlbnQgdGhlIG9wdGlvbiB1cGRhdGUgYW5kIHRocm93IGFuIGVycm9yLCBvciBzdGlsbCBhY2NlcHQgdGhlIG9wdGlvbiB1cGRhdGUgYW5kIHVwZGF0ZSB0aGUgdmFsdWUgZnJvbSBgbnVsbGAgdG8gYCcnYC5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2Fubm90IGtlZXAgYHJhd1ZhbHVlYCB0byBgbnVsbGAgc2luY2UgaWYgYGVtcHR5SW5wdXRCZWhhdmlvcmAgaXMgbm90IHNldCB0byBgbnVsbGAsIGxvdHMgb2YgZnVuY3Rpb24gYXNzdW1lIGByYXdWYWx1ZWAgaXMgYSBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLndhcm5pbmcoYFlvdSBhcmUgdHJ5aW5nIHRvIG1vZGlmeSB0aGUgXFxgZW1wdHlJbnB1dEJlaGF2aW9yXFxgIG9wdGlvbiB0byBzb21ldGhpbmcgZGlmZmVyZW50IHRoYW4gXFxgJ251bGwnXFxgICgke2VtcHR5SW5wdXRCZWhhdmlvcn0pLCBidXQgdGhlIGVsZW1lbnQgcmF3IHZhbHVlIGlzIGN1cnJlbnRseSBzZXQgdG8gXFxgbnVsbFxcYC4gVGhpcyB3b3VsZCByZXN1bHQgaW4gYW4gaW52YWxpZCBcXGByYXdWYWx1ZVxcYC4gSW4gb3JkZXIgdG8gZml4IHRoYXQsIHRoZSBlbGVtZW50IHZhbHVlIGhhcyBiZWVuIGNoYW5nZWQgdG8gdGhlIGVtcHR5IHN0cmluZyBcXGAnJ1xcYC5gLCB0aGlzLnNldHRpbmdzLnNob3dXYXJuaW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IGVtcHR5SW5wdXRCZWhhdmlvciB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZhaWxPblVua25vd25PcHRpb24gICAgICAgICAgOiBmYWlsT25Vbmtub3duT3B0aW9uID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmZhaWxPblVua25vd25PcHRpb24gPSBmYWlsT25Vbmtub3duT3B0aW9uOyAvL0ZJWE1FIHRlc3QgdGhpc1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9ybWF0T25QYWdlTG9hZCAgICAgICAgICAgICA6IGZvcm1hdE9uUGFnZUxvYWQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuZm9ybWF0T25QYWdlTG9hZCA9IGZvcm1hdE9uUGFnZUxvYWQ7IC8vRklYTUUgdGVzdCB0aGlzXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoaXN0b3J5U2l6ZSAgICAgICAgICAgICAgICAgIDogaGlzdG9yeVNpemUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuaGlzdG9yeVNpemUgPSBoaXN0b3J5U2l6ZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzQ2FuY2VsbGFibGUgICAgICAgICAgICAgICAgOiBpc0NhbmNlbGxhYmxlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmlzQ2FuY2VsbGFibGUgPSBpc0NhbmNlbGxhYmxlOyAvL0ZJWE1FIHRlc3QgdGhpc1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVhZGluZ1plcm8gICAgICAgICAgICAgICAgICA6IGxlYWRpbmdaZXJvID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IGxlYWRpbmdaZXJvIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF4aW11bVZhbHVlICAgICAgICAgICAgICAgICA6IG1heGltdW1WYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBtYXhpbXVtVmFsdWUgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtaW5pbXVtVmFsdWUgICAgICAgICAgICAgICAgIDogbWluaW11bVZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IG1pbmltdW1WYWx1ZSB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vZGlmeVZhbHVlT25XaGVlbCAgICAgICAgICAgOiBtb2RpZnlWYWx1ZU9uV2hlZWwgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MubW9kaWZ5VmFsdWVPbldoZWVsID0gbW9kaWZ5VmFsdWVPbldoZWVsOyAvL0ZJWE1FIHRlc3QgdGhpc1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgICA6IG5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IG5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50IH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm9FdmVudExpc3RlbmVycyAgICAgICAgICAgICA6IG5vRXZlbnRMaXN0ZW5lcnMgPT4geyAvL0ZJWE1FIHRlc3QgdGhpc1xuICAgICAgICAgICAgICAgIGlmIChub0V2ZW50TGlzdGVuZXJzID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5vRXZlbnRMaXN0ZW5lcnMubm9FdmVudHMgJiYgdGhpcy5zZXR0aW5ncy5ub0V2ZW50TGlzdGVuZXJzID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5vRXZlbnRMaXN0ZW5lcnMuYWRkRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZXZlbnRzIG9uY2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IG5vRXZlbnRMaXN0ZW5lcnMgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkludmFsaWRQYXN0ZSAgICAgICAgICAgICAgIDogb25JbnZhbGlkUGFzdGUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Mub25JbnZhbGlkUGFzdGUgPSBvbkludmFsaWRQYXN0ZTsgLy9GSVhNRSB0ZXN0IHRoaXNcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdCAgICAgICAgICAgICAgICAgOiBvdXRwdXRGb3JtYXQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Mub3V0cHV0Rm9ybWF0ID0gb3V0cHV0Rm9ybWF0O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3ZlcnJpZGVNaW5NYXhMaW1pdHMgICAgICAgICA6IG92ZXJyaWRlTWluTWF4TGltaXRzID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IG92ZXJyaWRlTWluTWF4TGltaXRzIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmF3VmFsdWVEaXZpc29yICAgICAgICAgICAgICA6IHJhd1ZhbHVlRGl2aXNvciA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyByYXdWYWx1ZURpdmlzb3IgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWFkT25seSAgICAgICAgICAgICAgICAgICAgIDogcmVhZE9ubHkgPT4geyAvL0ZJWE1FIHRlc3QgdGhpc1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MucmVhZE9ubHkgPSByZWFkT25seTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRSZWFkT25seSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcm91bmRpbmdNZXRob2QgICAgICAgICAgICAgICA6IHJvdW5kaW5nTWV0aG9kID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHJvdW5kaW5nTWV0aG9kIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSAgICA6IHNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN5bWJvbFdoZW5VbmZvY3VzZWQgICAgICAgICAgOiBzeW1ib2xXaGVuVW5mb2N1c2VkID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHN5bWJvbFdoZW5VbmZvY3VzZWQgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxlY3ROdW1iZXJPbmx5ICAgICAgICAgICAgIDogc2VsZWN0TnVtYmVyT25seSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5zZWxlY3ROdW1iZXJPbmx5ID0gc2VsZWN0TnVtYmVyT25seTsgLy9GSVhNRSB0ZXN0IHRoaXNcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbGVjdE9uRm9jdXMgICAgICAgICAgICAgICAgOiBzZWxlY3RPbkZvY3VzID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnNlbGVjdE9uRm9jdXMgPSBzZWxlY3RPbkZvY3VzOyAvL0ZJWE1FIHRlc3QgdGhpc1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VyaWFsaXplU3BhY2VzICAgICAgICAgICAgICA6IHNlcmlhbGl6ZVNwYWNlcyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5zZXJpYWxpemVTcGFjZXMgPSBzZXJpYWxpemVTcGFjZXM7IC8vRklYTUUgdGVzdCB0aGlzXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaG93T25seU51bWJlcnNPbkZvY3VzICAgICAgIDogc2hvd09ubHlOdW1iZXJzT25Gb2N1cyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBzaG93T25seU51bWJlcnNPbkZvY3VzIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd1Bvc2l0aXZlU2lnbiAgICAgICAgICAgICA6IHNob3dQb3NpdGl2ZVNpZ24gPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgc2hvd1Bvc2l0aXZlU2lnbiB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNob3dXYXJuaW5ncyAgICAgICAgICAgICAgICAgOiBzaG93V2FybmluZ3MgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Muc2hvd1dhcm5pbmdzID0gc2hvd1dhcm5pbmdzOyAvL0ZJWE1FIHRlc3QgdGhpc1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3R5bGVSdWxlcyAgICAgICAgICAgICAgICAgICA6IHN0eWxlUnVsZXMgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgc3R5bGVSdWxlcyB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1ZmZpeFRleHQgICAgICAgICAgICAgICAgICAgOiBzdWZmaXhUZXh0ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHN1ZmZpeFRleHQgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bmZvcm1hdE9uSG92ZXIgICAgICAgICAgICAgIDogdW5mb3JtYXRPbkhvdmVyID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnVuZm9ybWF0T25Ib3ZlciA9IHVuZm9ybWF0T25Ib3ZlcjsgLy9GSVhNRSB0ZXN0IHRoaXNcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuZm9ybWF0T25TdWJtaXQgICAgICAgICAgICAgOiB1bmZvcm1hdE9uU3VibWl0ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnVuZm9ybWF0T25TdWJtaXQgPSB1bmZvcm1hdE9uU3VibWl0OyAvL0ZJWE1FIHRlc3QgdGhpc1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsdWVzVG9TdHJpbmdzICAgICAgICAgICAgICAgOiB2YWx1ZXNUb1N0cmluZ3MgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgdmFsdWVzVG9TdHJpbmdzIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2hlZWxTdGVwICAgICAgICAgICAgICAgICAgICA6IHdoZWVsU3RlcCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy53aGVlbFN0ZXAgPSB3aGVlbFN0ZXA7IC8vRklYTUUgdGVzdCB0aGlzXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBhdXRvTnVtZXJpYyB2ZXJzaW9uIG51bWJlciAoZm9yIGRlYnVnZ2luZyBwdXJwb3NlKVxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgdmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuICc0LjEuMC1iZXRhLjEnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRha2UgdGhlIHBhcmFtZXRlcnMgZ2l2ZW4gdG8gdGhlIEF1dG9OdW1lcmljIG9iamVjdCwgYW5kIG91dHB1dCB0aGUgdGhyZWUgdmFyaWFibGVzIHRoYXQgYXJlIG5lZWRlZCB0byBmaW5pc2ggaW5pdGlhbGl6aW5nIGl0IDpcbiAgICAgKiAtIGRvbUVsZW1lbnQgOiBUaGUgdGFyZ2V0IERPTSBlbGVtZW50XG4gICAgICogLSBpbml0aWFsVmFsdWUgOiBUaGUgaW5pdGlhbCB2YWx1ZSwgb3IgYG51bGxgIGlmIG5vbmUgaXMgZ2l2ZW5cbiAgICAgKiAtIHVzZXJPcHRpb25zIDogVGhlIG9wdGlvbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fEFycmF5fG51bWJlcnxzdHJpbmd9IGFyZzFcbiAgICAgKiBAcGFyYW0ge29iamVjdHxBcnJheXxudW1iZXJ8c3RyaW5nfG51bGx9IGFyZzJcbiAgICAgKiBAcGFyYW0ge29iamVjdHxBcnJheXxudW1iZXJ8c3RyaW5nfG51bGx9IGFyZzNcbiAgICAgKiBAcmV0dXJucyB7e2RvbUVsZW1lbnQ6ICosIGluaXRpYWxWYWx1ZTogKiwgdXNlck9wdGlvbnM6ICp9fVxuICAgICAqIEB0aHJvd3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBfc2V0QXJndW1lbnRzVmFsdWVzKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgLy8gQmFzaWMgY2hlY2sgb24gdGhlIGFyZ3VtZW50IGNvdW50XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bGwoYXJnMSkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoJ0F0IGxlYXN0IG9uZSB2YWxpZCBwYXJhbWV0ZXIgaXMgbmVlZGVkIGluIG9yZGVyIHRvIGluaXRpYWxpemUgYW4gQXV0b051bWVyaWMgb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmVwYXJlIHRoZSBhcmd1bWVudHMgaW4gb3JkZXIgdG8gY3JlYXRlIHRoZSBBdXRvTnVtZXJpYyBvYmplY3Qgd2l0aCB0aGUgcmlnaHQgdmFsdWVzXG4gICAgICAgIC8vIFRlc3QgdGhlIGFyZ3VtZW50IHR5cGVzXG4gICAgICAgIGNvbnN0IGlzQXJnMUVsZW1lbnQgPSBBdXRvTnVtZXJpY0hlbHBlci5pc0VsZW1lbnQoYXJnMSk7XG4gICAgICAgIGNvbnN0IGlzQXJnMVN0cmluZyA9IEF1dG9OdW1lcmljSGVscGVyLmlzU3RyaW5nKGFyZzEpO1xuXG4gICAgICAgIGNvbnN0IGlzQXJnMk9iamVjdCA9IEF1dG9OdW1lcmljSGVscGVyLmlzT2JqZWN0KGFyZzIpO1xuICAgICAgICBjb25zdCBpc0FyZzJBcnJheSA9IEFycmF5LmlzQXJyYXkoYXJnMikgJiYgYXJnMi5sZW5ndGggPiAwO1xuICAgICAgICBjb25zdCBpc0FyZzJOdW1iZXIgPSBBdXRvTnVtZXJpY0hlbHBlci5pc051bWJlck9yQXJhYmljKGFyZzIpIHx8IGFyZzIgPT09ICcnO1xuICAgICAgICBjb25zdCBpc0FyZzJQcmVEZWZpbmVkT3B0aW9uTmFtZSA9IHRoaXMuX2lzUHJlRGVmaW5lZE9wdGlvblZhbGlkKGFyZzIpO1xuICAgICAgICBjb25zdCBpc0FyZzJOdWxsID0gQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKGFyZzIpO1xuICAgICAgICBjb25zdCBpc0FyZzJFbXB0eVN0cmluZyA9IEF1dG9OdW1lcmljSGVscGVyLmlzRW1wdHlTdHJpbmcoYXJnMik7XG5cbiAgICAgICAgY29uc3QgaXNBcmczT2JqZWN0ID0gQXV0b051bWVyaWNIZWxwZXIuaXNPYmplY3QoYXJnMyk7XG4gICAgICAgIGNvbnN0IGlzQXJnM0FycmF5ID0gQXJyYXkuaXNBcnJheShhcmczKSAmJiBhcmczLmxlbmd0aCA+IDA7XG4gICAgICAgIGNvbnN0IGlzQXJnM051bGwgPSBBdXRvTnVtZXJpY0hlbHBlci5pc051bGwoYXJnMyk7XG4gICAgICAgIGNvbnN0IGlzQXJnM1ByZURlZmluZWRPcHRpb25OYW1lID0gdGhpcy5faXNQcmVEZWZpbmVkT3B0aW9uVmFsaWQoYXJnMyk7XG5cbiAgICAgICAgLy8gR2l2ZW4gdGhlIHBhcmFtZXRlcnMgcGFzc2VkLCBzb3J0IHRoZSBkYXRhIGFuZCByZXR1cm4gYSBzdGFibGUgc3RhdGUgYmVmb3JlIHRoZSBpbml0aWFsaXphdGlvblxuICAgICAgICBsZXQgZG9tRWxlbWVudDtcbiAgICAgICAgbGV0IHVzZXJPcHRpb25zO1xuICAgICAgICBsZXQgaW5pdGlhbFZhbHVlO1xuXG4gICAgICAgIC8vVE9ETyBTaW1wbGlmeSB0aG9zZSB0ZXN0cyAtLT5cbiAgICAgICAgaWYgKGlzQXJnMUVsZW1lbnQgJiYgaXNBcmcyTnVsbCAmJiBpc0FyZzNOdWxsKSB7XG4gICAgICAgICAgICAvLyBuZXcgQXV0b051bWVyaWMoZG9tRWxlbWVudCk7IC8vIFdpdGggdGhlIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICAgICAgZG9tRWxlbWVudCA9IGFyZzE7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdXNlck9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJnMUVsZW1lbnQgJiYgaXNBcmcyTnVtYmVyICYmIGlzQXJnM051bGwpIHtcbiAgICAgICAgICAgIC8vIG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50LCAxMjM0NS43ODkpOyAvLyBXaXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMsIGFuZCBhbiBpbml0aWFsIHZhbHVlXG4gICAgICAgICAgICAvLyBuZXcgQXV0b051bWVyaWMoZG9tRWxlbWVudCwgJzEyMzQ1Ljc4OScpO1xuICAgICAgICAgICAgZG9tRWxlbWVudCA9IGFyZzE7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSBhcmcyO1xuICAgICAgICAgICAgdXNlck9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJnMUVsZW1lbnQgJiYgaXNBcmcyT2JqZWN0ICYmIGlzQXJnM051bGwpIHtcbiAgICAgICAgICAgIC8vIG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50LCB7IG9wdGlvbnMgfSk7IC8vIFdpdGggb25lIG9wdGlvbiBvYmplY3RcbiAgICAgICAgICAgIGRvbUVsZW1lbnQgPSBhcmcxO1xuICAgICAgICAgICAgaW5pdGlhbFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHVzZXJPcHRpb25zID0gYXJnMjtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FyZzFFbGVtZW50ICYmIGlzQXJnMlByZURlZmluZWRPcHRpb25OYW1lICYmIGlzQXJnM051bGwpIHtcbiAgICAgICAgICAgIC8vIG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50LCAnZXVyb1BvcycpOyAvLyBXaXRoIG9uZSBwcmUtZGVmaW5lZCBvcHRpb24gbmFtZVxuICAgICAgICAgICAgZG9tRWxlbWVudCA9IGFyZzE7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdXNlck9wdGlvbnMgPSB0aGlzLl9nZXRPcHRpb25PYmplY3QoYXJnMik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcmcxRWxlbWVudCAmJiBpc0FyZzJBcnJheSAmJiBpc0FyZzNOdWxsKSB7XG4gICAgICAgICAgICAvLyBuZXcgQXV0b051bWVyaWMoZG9tRWxlbWVudCwgW3sgb3B0aW9uczEgfSwgeyBvcHRpb25zMiB9XSk7IC8vIFdpdGggbXVsdGlwbGUgb3B0aW9uIG9iamVjdHMgKHRoZSBsYXRlc3Qgb3B0aW9uIG92ZXJ3cml0aW5nIHRoZSBwcmV2aW91cyBvbmVzKVxuICAgICAgICAgICAgZG9tRWxlbWVudCA9IGFyZzE7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdXNlck9wdGlvbnMgPSB0aGlzLm1lcmdlT3B0aW9ucyhhcmcyKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FyZzFFbGVtZW50ICYmIChpc0FyZzJOdWxsIHx8IGlzQXJnMkVtcHR5U3RyaW5nKSAmJiBpc0FyZzNPYmplY3QpIHtcbiAgICAgICAgICAgIC8vIG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50LCBudWxsLCB7IG9wdGlvbnMgfSk7IC8vIFdpdGggb25lIG9wdGlvbiBvYmplY3RcbiAgICAgICAgICAgIGRvbUVsZW1lbnQgPSBhcmcxO1xuICAgICAgICAgICAgaW5pdGlhbFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHVzZXJPcHRpb25zID0gYXJnMztcbiAgICAgICAgfSBlbHNlIGlmIChpc0FyZzFFbGVtZW50ICYmIChpc0FyZzJOdWxsIHx8IGlzQXJnMkVtcHR5U3RyaW5nKSAmJiBpc0FyZzNBcnJheSkge1xuICAgICAgICAgICAgLy8gbmV3IEF1dG9OdW1lcmljKGRvbUVsZW1lbnQsIG51bGwsIFt7IG9wdGlvbnMxIH0sIHsgb3B0aW9uczIgfV0pOyAvLyBXaXRoIG11bHRpcGxlIG9wdGlvbiBvYmplY3RzXG4gICAgICAgICAgICBkb21FbGVtZW50ID0gYXJnMTtcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB1c2VyT3B0aW9ucyA9IHRoaXMubWVyZ2VPcHRpb25zKGFyZzMpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJnMVN0cmluZyAmJiBpc0FyZzJOdWxsICYmIGlzQXJnM051bGwpIHtcbiAgICAgICAgICAgIC8vIG5ldyBBdXRvTnVtZXJpYygnLm15Q3NzQ2xhc3MgPiBpbnB1dCcpO1xuICAgICAgICAgICAgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXJnMSk7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdXNlck9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJnMVN0cmluZyAmJiBpc0FyZzJPYmplY3QgJiYgaXNBcmczTnVsbCkge1xuICAgICAgICAgICAgLy8gbmV3IEF1dG9OdW1lcmljKCcubXlDc3NDbGFzcyA+IGlucHV0JywgeyBvcHRpb25zIH0pO1xuICAgICAgICAgICAgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXJnMSk7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdXNlck9wdGlvbnMgPSBhcmcyO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJnMVN0cmluZyAmJiBpc0FyZzJQcmVEZWZpbmVkT3B0aW9uTmFtZSAmJiBpc0FyZzNOdWxsKSB7XG4gICAgICAgICAgICAvLyBuZXcgQXV0b051bWVyaWMoJy5teUNzc0NsYXNzID4gaW5wdXQnLCAnZXVyb1BvcycpO1xuICAgICAgICAgICAgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXJnMSk7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdXNlck9wdGlvbnMgPSB0aGlzLl9nZXRPcHRpb25PYmplY3QoYXJnMik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcmcxU3RyaW5nICYmIGlzQXJnMkFycmF5ICYmIGlzQXJnM051bGwpIHtcbiAgICAgICAgICAgIC8vIG5ldyBBdXRvTnVtZXJpYygnLm15Q3NzQ2xhc3MgPiBpbnB1dCcsIFt7IG9wdGlvbnMxIH0sIHsgb3B0aW9uczIgfV0pOyAvLyBXaXRoIG11bHRpcGxlIG9wdGlvbiBvYmplY3RzXG4gICAgICAgICAgICBkb21FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhcmcxKTtcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB1c2VyT3B0aW9ucyA9IHRoaXMubWVyZ2VPcHRpb25zKGFyZzIpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJnMVN0cmluZyAmJiAoaXNBcmcyTnVsbCB8fCBpc0FyZzJFbXB0eVN0cmluZykgJiYgaXNBcmczT2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBuZXcgQXV0b051bWVyaWMoJy5teUNzc0NsYXNzID4gaW5wdXQnLCBudWxsLCB7IG9wdGlvbnMgfSk7XG4gICAgICAgICAgICBkb21FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhcmcxKTtcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB1c2VyT3B0aW9ucyA9IGFyZzM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcmcxU3RyaW5nICYmIChpc0FyZzJOdWxsIHx8IGlzQXJnMkVtcHR5U3RyaW5nKSAmJiBpc0FyZzNBcnJheSkge1xuICAgICAgICAgICAgLy8gbmV3IEF1dG9OdW1lcmljKCcubXlDc3NDbGFzcyA+IGlucHV0JywgbnVsbCwgW3sgb3B0aW9uczEgfSwgeyBvcHRpb25zMiB9XSk7IC8vIFdpdGggbXVsdGlwbGUgb3B0aW9uIG9iamVjdHNcbiAgICAgICAgICAgIGRvbUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGFyZzEpO1xuICAgICAgICAgICAgaW5pdGlhbFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHVzZXJPcHRpb25zID0gdGhpcy5tZXJnZU9wdGlvbnMoYXJnMyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcmcxU3RyaW5nICYmIGlzQXJnMk51bWJlciAmJiBpc0FyZzNOdWxsKSB7XG4gICAgICAgICAgICAvLyBuZXcgQXV0b051bWVyaWMoJy5teUNzc0NsYXNzID4gaW5wdXQnLCAxMjM0NS43ODkpO1xuICAgICAgICAgICAgLy8gbmV3IEF1dG9OdW1lcmljKCcubXlDc3NDbGFzcyA+IGlucHV0JywgJzEyMzQ1Ljc4OScpO1xuICAgICAgICAgICAgLy8gbmV3IEF1dG9OdW1lcmljKCcubXlDc3NDbGFzcyA+IGlucHV0JywgJycpO1xuICAgICAgICAgICAgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXJnMSk7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSBhcmcyO1xuICAgICAgICAgICAgdXNlck9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJnMVN0cmluZyAmJiBpc0FyZzJOdW1iZXIgJiYgaXNBcmczT2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBuZXcgQXV0b051bWVyaWMoJy5teUNzc0NsYXNzID4gaW5wdXQnLCAxMjM0NS43ODksIHsgb3B0aW9ucyB9KTtcbiAgICAgICAgICAgIC8vIG5ldyBBdXRvTnVtZXJpYygnLm15Q3NzQ2xhc3MgPiBpbnB1dCcsICcxMjM0NS43ODknLCB7IG9wdGlvbnMgfSk7XG4gICAgICAgICAgICAvLyBuZXcgQXV0b051bWVyaWMoJy5teUNzc0NsYXNzID4gaW5wdXQnLCAnJywgeyBvcHRpb25zIH0pO1xuICAgICAgICAgICAgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXJnMSk7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSBhcmcyO1xuICAgICAgICAgICAgdXNlck9wdGlvbnMgPSBhcmczO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJnMVN0cmluZyAmJiBpc0FyZzJOdW1iZXIgJiYgaXNBcmczUHJlRGVmaW5lZE9wdGlvbk5hbWUpIHtcbiAgICAgICAgICAgIC8vIG5ldyBBdXRvTnVtZXJpYygnLm15Q3NzQ2xhc3MgPiBpbnB1dCcsIDEyMzQ1Ljc4OSwgJ2V1cm9Qb3MnKTtcbiAgICAgICAgICAgIC8vIG5ldyBBdXRvTnVtZXJpYygnLm15Q3NzQ2xhc3MgPiBpbnB1dCcsICcxMjM0NS43ODknLCAnZXVyb1BvcycpO1xuICAgICAgICAgICAgLy8gbmV3IEF1dG9OdW1lcmljKCcubXlDc3NDbGFzcyA+IGlucHV0JywgJycsICdldXJvUG9zJyk7XG4gICAgICAgICAgICBkb21FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhcmcxKTtcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IGFyZzI7XG4gICAgICAgICAgICB1c2VyT3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbk9iamVjdChhcmczKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FyZzFFbGVtZW50ICYmIGlzQXJnMk51bWJlciAmJiBpc0FyZzNPYmplY3QpIHtcbiAgICAgICAgICAgIC8vIG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50LCAxMjM0NS43ODksIHsgb3B0aW9ucyB9KTtcbiAgICAgICAgICAgIC8vIG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50LCAnMTIzNDUuNzg5JywgeyBvcHRpb25zIH0pO1xuICAgICAgICAgICAgLy8gbmV3IEF1dG9OdW1lcmljKGRvbUVsZW1lbnQsICcnLCB7IG9wdGlvbnMgfSk7XG4gICAgICAgICAgICBkb21FbGVtZW50ID0gYXJnMTtcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IGFyZzI7XG4gICAgICAgICAgICB1c2VyT3B0aW9ucyA9IGFyZzM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcmcxRWxlbWVudCAmJiBpc0FyZzJOdW1iZXIgJiYgaXNBcmczUHJlRGVmaW5lZE9wdGlvbk5hbWUpIHtcbiAgICAgICAgICAgIC8vIG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50LCAxMjM0NS43ODksICdldXJvUG9zJyk7XG4gICAgICAgICAgICAvLyBuZXcgQXV0b051bWVyaWMoZG9tRWxlbWVudCwgJzEyMzQ1Ljc4OScsICdldXJvUG9zJyk7XG4gICAgICAgICAgICAvLyBuZXcgQXV0b051bWVyaWMoZG9tRWxlbWVudCwgJycsICdldXJvUG9zJyk7XG4gICAgICAgICAgICBkb21FbGVtZW50ID0gYXJnMTtcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZSA9IGFyZzI7XG4gICAgICAgICAgICB1c2VyT3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbk9iamVjdChhcmczKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FyZzFFbGVtZW50ICYmIGlzQXJnMk51bWJlciAmJiBpc0FyZzNBcnJheSkge1xuICAgICAgICAgICAgLy8gbmV3IEF1dG9OdW1lcmljKGRvbUVsZW1lbnQsIDEyMzQ1Ljc4OSwgW3sgb3B0aW9uczEgfSwgeyBvcHRpb25zMiB9XSk7XG4gICAgICAgICAgICAvLyBuZXcgQXV0b051bWVyaWMoZG9tRWxlbWVudCwgJzEyMzQ1Ljc4OScsIFt7IG9wdGlvbnMxIH0sIHsgb3B0aW9uczIgfV0pO1xuICAgICAgICAgICAgLy8gbmV3IEF1dG9OdW1lcmljKGRvbUVsZW1lbnQsICcnLCBbeyBvcHRpb25zMSB9LCB7IG9wdGlvbnMyIH1dKTtcbiAgICAgICAgICAgIGRvbUVsZW1lbnQgPSBhcmcxO1xuICAgICAgICAgICAgaW5pdGlhbFZhbHVlID0gYXJnMjtcbiAgICAgICAgICAgIHVzZXJPcHRpb25zID0gdGhpcy5tZXJnZU9wdGlvbnMoYXJnMyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgcGFyYW1ldGVycyBnaXZlbiB0byB0aGUgQXV0b051bWVyaWMgb2JqZWN0IGFyZSBub3QgdmFsaWQsICcke2FyZzF9JywgJyR7YXJnMn0nIGFuZCAnJHthcmczfScgZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgc2VsZWN0b3IgJyR7YXJnMX0nIGRpZCBub3Qgc2VsZWN0IGFueSB2YWxpZCBET00gZWxlbWVudC4gUGxlYXNlIGNoZWNrIG9uIHdoaWNoIGVsZW1lbnQgeW91IGNhbGxlZCBBdXRvTnVtZXJpYy5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGRvbUVsZW1lbnQsIGluaXRpYWxWYWx1ZSwgdXNlck9wdGlvbnMgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZSB0aGUgb3B0aW9uIG9iamVjdHMgZm91bmQgaW4gdGhlIGdpdmVuIGFycmF5IGBvcHRpb25zQXJyYXlgLlxuICAgICAqIElmIGEgYHN0cmluZ2AgaXMgZm91bmQsIHRoZW4gd2UgdHJ5IHRvIGdldCB0aGUgcmVsYXRlZCBwcmUtZGVmaW5lZCBvcHRpb24gdXNpbmcgdGhhdCBzdHJpbmcgYXMgaXRzIG5hbWUuXG4gICAgICogV2hlbiBtZXJnaW5nIHRoZSBvcHRpb25zLCB0aGUgbGF0ZXN0IG9wdGlvbiBvdmVyd3JpdGUgYW55IHByZXZpb3VzbHkgc2V0LiBUaGlzIGFsbG93cyB0byBmaW5lIHR1bmUgYSBwcmUtZGVmaW5lZCBvcHRpb24gZm9yIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheTxvYmplY3R8c3RyaW5nPn0gb3B0aW9uc0FycmF5XG4gICAgICogQHJldHVybnMge3t9fVxuICAgICAqL1xuICAgIHN0YXRpYyBtZXJnZU9wdGlvbnMob3B0aW9uc0FycmF5KSB7XG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIHVzZSBtdWx0aXBsZSBvcHRpb25zIChzdHJpbmdzIG9yIG9iamVjdHMpIGluIGFuIGFycmF5LCBhbmQgb3ZlcndyaXRlIHRoZSBwcmV2aW91cyBvbmUgd2l0aCB0aGUgbmV4dCBvcHRpb24gZWxlbWVudCA7IHRoaXMgaXMgdXNlZnVsIHRvIHR1bmUgdGhlIHdhbnRlZCBmb3JtYXRcbiAgICAgICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHt9O1xuICAgICAgICBvcHRpb25zQXJyYXkuZm9yRWFjaChvcHRpb25PYmplY3RPclByZWRlZmluZWRPcHRpb25TdHJpbmcgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtZXJnZWRPcHRpb25zLCB0aGlzLl9nZXRPcHRpb25PYmplY3Qob3B0aW9uT2JqZWN0T3JQcmVkZWZpbmVkT3B0aW9uU3RyaW5nKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtZXJnZWRPcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHByZS1kZWZpbmVkIG9wdGlvbiBuYW1lIGlzIGFuIGF0dHJpYnV0ZSBvZiB0aGUgYEF1dG9OdW1lcmljLnByZWRlZmluZWRPcHRpb25zYCBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVEZWZpbmVkT3B0aW9uTmFtZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9pc1ByZURlZmluZWRPcHRpb25WYWxpZChwcmVEZWZpbmVkT3B0aW9uTmFtZSkge1xuICAgICAgICByZXR1cm4gQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnMuaGFzT3duUHJvcGVydHkocHJlRGVmaW5lZE9wdGlvbk5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBvcHRpb24gb2JqZWN0IGJhc2VkIG9uIHRoZSBnaXZlbiBwYXJhbWV0ZXIuXG4gICAgICogSWYgYG9wdGlvbk9iamVjdE9yUHJlZGVmaW5lZE5hbWVgIGlzIGFzIHN0cmluZywgdGhlbiB3ZSByZXRyaWV2ZSB0aGUgcHJlLWRlZmluZWQgb3B0aW9uIG9iamVjdCwgaWYgaXQncyBhbiBvYmplY3QsIHdlIHVzZSBpdCBhcyBpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gb3B0aW9uT2JqZWN0T3JQcmVkZWZpbmVkTmFtZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgc3RhdGljIF9nZXRPcHRpb25PYmplY3Qob3B0aW9uT2JqZWN0T3JQcmVkZWZpbmVkTmFtZSkge1xuICAgICAgICBsZXQgb3B0aW9ucztcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzU3RyaW5nKG9wdGlvbk9iamVjdE9yUHJlZGVmaW5lZE5hbWUpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gQXV0b051bWVyaWMuZ2V0UHJlZGVmaW5lZE9wdGlvbnMoKVtvcHRpb25PYmplY3RPclByZWRlZmluZWROYW1lXTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkKDApIHx8IG9wdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZ2l2ZW4gcHJlLWRlZmluZWQgbmFtZSBkb2VzIG5vdCBleGlzdCwgd2FybiB0aGF0IHNvbWV0aGluZyBpcyB3cm9uZywgYW5kIGNvbnRpbnVlIHRoZSBleGVjdXRpb24gb2YgdGhlIGluaXRpYWxpemF0aW9uXG4gICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIud2FybmluZyhgVGhlIGdpdmVuIHByZS1kZWZpbmVkIG9wdGlvbiBbJHtvcHRpb25PYmplY3RPclByZWRlZmluZWROYW1lfV0gaXMgbm90IHJlY29nbml6ZWQgYnkgYXV0b051bWVyaWMuIFBsZWFzZSBjaGVjayB0aGF0IHByZS1kZWZpbmVkIG9wdGlvbiBuYW1lLmAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBBIGBzZXR0aW5nc2Agb2JqZWN0XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uT2JqZWN0T3JQcmVkZWZpbmVkTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhdmUgdGhlIGluaXRpYWwgZWxlbWVudCB2YWx1ZXMgZm9yIGxhdGVyIHVzZSBpbiB0aGUgcHJpc3RpbmUgdGVzdC5cbiAgICAgKiBUaG9zZSB2YWx1ZXMgYXJlIDpcbiAgICAgKiAtIHRoZSBodG1sIGF0dHJpYnV0ZSAoaWUuIDxpbnB1dCB2YWx1ZT0nNDInPiksIGFuZFxuICAgICAqIC0gdGhlIHNjcmlwdCBgdmFsdWVgIChpZS4gYGxldCBkb21FbGVtZW50LnZhbHVlYClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVsbHxudW1iZXJ8c3RyaW5nfSBpbml0aWFsVmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zYXZlSW5pdGlhbFZhbHVlcyhpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgLy8gS2VlcCB0aGUgdmVyeSBmaXJzdCBpbml0aWFsIHZhbHVlcyAoaW4gdGhlIGh0bWwgYXR0cmlidXRlIGFuZCBzZXQgYnkgdGhlIHNjcmlwdCkuIFRoaXMgaXMgbmVlZGVkIHRvIGNoZWNrIGlmIHRoZSBlbGVtZW50IGlzIHByaXN0aW5lLlxuICAgICAgICAvLyBTYXZlIHRoZSBodG1sIGF0dHJpYnV0ZSAndmFsdWUnXG4gICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlSHRtbEF0dHJpYnV0ZSA9IHRoaXMuZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bGwodGhpcy5pbml0aWFsVmFsdWVIdG1sQXR0cmlidXRlKSkge1xuICAgICAgICAgICAgLy8gU2V0IHRoZSBkZWZhdWx0IGVtcHR5IHZhbHVlIGF0dHJpYnV0ZSBpbnN0ZWFkIG9mIGBudWxsYCwgc2luY2UgaWYgdGhlIGluaXRpYWwgdmFsdWUgaXMgbnVsbCwgdGhlIGVtcHR5IHN0cmluZyBpcyB1c2VkXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZUh0bWxBdHRyaWJ1dGUgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNhdmUgdGhlICdzY3JpcHQnIHZhbHVlXG4gICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKHRoaXMuaW5pdGlhbFZhbHVlKSkge1xuICAgICAgICAgICAgLy8gU2FtZSBhcyBhYm92ZVxuICAgICAgICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHJlZmVyZW5jZXMgdG8gdGhlIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25zLCBzbyB3ZSBjYW4gdGhlbiBjbGVhbmx5IHJlbW92ZXMgdGhvc2UgbGlzdGVuZXJzIGlmIG5lZWRlZFxuICAgICAgICAvLyBUaGF0IHdvdWxkIG5vdCBiZSBwb3NzaWJsZSBpZiB3ZSB1c2VkIGNsb3N1cmVzIGRpcmVjdGx5IGluIHRoZSBldmVudCBoYW5kbGVyIGRlY2xhcmF0aW9uc1xuICAgICAgICB0aGlzLl9vbkZvY3VzSW5GdW5jID0gZSA9PiB7IHRoaXMuX29uRm9jdXNJbihlKTsgfTtcbiAgICAgICAgdGhpcy5fb25Gb2N1c0luQW5kTW91c2VFbnRlckZ1bmMgPSBlID0+IHsgdGhpcy5fb25Gb2N1c0luQW5kTW91c2VFbnRlcihlKTsgfTtcbiAgICAgICAgdGhpcy5fb25Gb2N1c0Z1bmMgPSAoKSA9PiB7IHRoaXMuX29uRm9jdXMoKTsgfTtcbiAgICAgICAgdGhpcy5fb25LZXlkb3duRnVuYyA9IGUgPT4geyB0aGlzLl9vbktleWRvd24oZSk7IH07XG4gICAgICAgIHRoaXMuX29uS2V5cHJlc3NGdW5jID0gZSA9PiB7IHRoaXMuX29uS2V5cHJlc3MoZSk7IH07XG4gICAgICAgIHRoaXMuX29uSW5wdXRGdW5jID0gZSA9PiB7IHRoaXMuX29uSW5wdXQoZSk7IH07XG4gICAgICAgIHRoaXMuX29uS2V5dXBGdW5jID0gZSA9PiB7IHRoaXMuX29uS2V5dXAoZSk7IH07XG4gICAgICAgIHRoaXMuX29uRm9jdXNPdXRBbmRNb3VzZUxlYXZlRnVuYyA9IGUgPT4geyB0aGlzLl9vbkZvY3VzT3V0QW5kTW91c2VMZWF2ZShlKTsgfTtcbiAgICAgICAgdGhpcy5fb25QYXN0ZUZ1bmMgPSBlID0+IHsgdGhpcy5fb25QYXN0ZShlKTsgfTtcbiAgICAgICAgdGhpcy5fb25XaGVlbEZ1bmMgPSBlID0+IHsgdGhpcy5fb25XaGVlbChlKTsgfTtcbiAgICAgICAgdGhpcy5fb25Gb3JtU3VibWl0RnVuYyA9ICgpID0+IHsgdGhpcy5fb25Gb3JtU3VibWl0KCk7IH07XG4gICAgICAgIHRoaXMuX29uS2V5ZG93bkdsb2JhbEZ1bmMgPSBlID0+IHsgdGhpcy5fb25LZXlkb3duR2xvYmFsKGUpOyB9O1xuICAgICAgICB0aGlzLl9vbktleXVwR2xvYmFsRnVuYyA9IGUgPT4geyB0aGlzLl9vbktleXVwR2xvYmFsKGUpOyB9O1xuICAgICAgICB0aGlzLl9vbkRyb3BGdW5jID0gZSA9PiB7IHRoaXMuX29uRHJvcChlKTsgfTtcblxuICAgICAgICAvLyBBZGQgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMuX29uRm9jdXNJbkZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fb25Gb2N1c0luQW5kTW91c2VFbnRlckZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fb25Gb2N1c0Z1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLl9vbkZvY3VzSW5BbmRNb3VzZUVudGVyRnVuYywgZmFsc2UpO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5ZG93bkZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgdGhpcy5fb25LZXlwcmVzc0Z1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5fb25JbnB1dEZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5fb25LZXl1cEZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9vbkZvY3VzT3V0QW5kTW91c2VMZWF2ZUZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLl9vbkZvY3VzT3V0QW5kTW91c2VMZWF2ZUZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgdGhpcy5fb25QYXN0ZUZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5fb25XaGVlbEZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzLl9vbkRyb3BGdW5jLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwodGhpcy5wYXJlbnRGb3JtKSkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRGb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIHRoaXMuX29uRm9ybVN1Ym1pdEZ1bmMsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBvbmUgZ2xvYmFsIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUga2V5dXAgZXZlbnQgb24gdGhlIGRvY3VtZW50IG9iamVjdCwgd2hpY2ggd2lsbCBiZSBzaGFyZWQgYnkgYWxsIHRoZSBhdXRvTnVtZXJpYyBlbGVtZW50c1xuICAgICAgICBpZiAoIUF1dG9OdW1lcmljLl9kb2VzR2xvYmFsTGlzdEV4aXN0cygpKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlkb3duR2xvYmFsRnVuYywgZmFsc2UpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLl9vbktleXVwR2xvYmFsRnVuYywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCB0aGUgYXV0b051bWVyaWMtcmVsYXRlZCBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSBnaXZlbiBET00gZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCkgeyAvL0ZJWE1FIHRlc3QgdGhpc1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMuX29uRm9jdXNJbkZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fb25Gb2N1c0luQW5kTW91c2VFbnRlckZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fb25Gb2N1c0Z1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLl9vbkZvY3VzSW5BbmRNb3VzZUVudGVyRnVuYywgZmFsc2UpO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX29uRm9jdXNPdXRBbmRNb3VzZUxlYXZlRnVuYywgZmFsc2UpO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX29uRm9jdXNPdXRBbmRNb3VzZUxlYXZlRnVuYywgZmFsc2UpO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5ZG93bkZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgdGhpcy5fb25LZXlwcmVzc0Z1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5fb25JbnB1dEZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5fb25LZXl1cEZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgdGhpcy5fb25QYXN0ZUZ1bmMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5fb25XaGVlbEZ1bmMsIGZhbHNlKTtcblxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlkb3duR2xvYmFsRnVuYywgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuX29uS2V5dXBHbG9iYWxGdW5jLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwodGhpcy5wYXJlbnRGb3JtKSkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRGb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIHRoaXMuX29uRm9ybVN1Ym1pdEZ1bmMsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZWxlbWVudCBhdHRyaWJ1dGUgJ3JlYWRvbmx5JyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRSZWFkT25seSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNJbnB1dEVsZW1lbnQgJiYgdGhpcy5zZXR0aW5ncy5yZWFkT25seSkge1xuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50LnJlYWRPbmx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhdmUgdGhlIGN1cnJlbnQgcmF3IHZhbHVlIGludG8gdGhlIGhpc3RvcnkgdGFibGUsIGFsb25nIHdpdGggdGhlIHNlbGVjdGlvbiBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIElmIHRoZSB1c2VyIGhhcyBkb25lIHNvbWUgdW5kb3MgYW5kIHRyaWVzIHRvIGVudGVyOlxuICAgICAqIC0gYSBuZXcgYW5kIGRpZmZlcmVudCBudW1iZXIgdGhhbiB0aGUgJ25leHQnIHN0YXRlLCB0aGlzIGRyb3BzIHRoZSByZXN0IG9mIHRoZSBoaXN0b3J5IHRhYmxlXG4gICAgICogLSB0aGUgdmVyeSBzYW1lIG51bWJlciB0aGF0IHJlc3VsdCBpbiB0aGUgc2FtZSByYXdWYWx1ZSB0aGFuIHRoZSAnbmV4dCcgc3RhdGUsIHdlIG9ubHkgbW92ZSB0aGUgaGlzdG9yeSB0YWJsZSBwb2ludGVyIHRvIHRoZSBuZXh0IHN0YXRlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oaXN0b3J5VGFibGVBZGQoKSB7XG4gICAgICAgIC8vVE9ETyBBZGQgYSBgdGhpcy5zZXR0aW5ncy5zYXZlU2VsZWN0aW9uc0ludG9IaXN0b3J5YCBvcHRpb24gdG8gcHJldmVudCBzYXZpbmcgdGhlIHNlbGVjdGlvbnMgKGluIG9yZGVyIHRvIGdhaW4gcGVyZm9ybWFuY2UpXG4gICAgICAgIGNvbnN0IGlzRW1wdHlIaXN0b3J5VGFibGUgPSB0aGlzLmhpc3RvcnlUYWJsZS5sZW5ndGggPT09IDA7XG4gICAgICAgIC8vIE9ubHkgYWRkIGEgbmV3IHZhbHVlIGlmIGl0J3MgZGlmZmVyZW50IHRoYW4gdGhlIHByZXZpb3VzIG9uZSAodG8gcHJldmVudCBpbmZpbml0ZWx5IGFkZGluZyB2YWx1ZXMgb24gbW91c2VvdmVyIGZvciBpbnN0YW5jZSlcbiAgICAgICAgaWYgKGlzRW1wdHlIaXN0b3J5VGFibGUgfHwgdGhpcy5yYXdWYWx1ZSAhPT0gdGhpcy5faGlzdG9yeVRhYmxlQ3VycmVudFZhbHVlVXNlZCgpKSB7XG4gICAgICAgICAgICAvLyBUcmltIHRoZSBoaXN0b3J5IHRhYmxlIGlmIHRoZSB1c2VyIGNoYW5nZWQgdGhlIHZhbHVlIG9mIGFuIGludGVybWVkaWFyeSBzdGF0ZVxuICAgICAgICAgICAgbGV0IGFkZE5ld0hpc3RvcnlTdGF0ZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIWlzRW1wdHlIaXN0b3J5VGFibGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBzb21lIHVuZG8gaGFzIGJlZW4gZG9uZSBhbmQgdGhlIHVzZXIgdHlwZSB0aGUgZXhhY3Qgc2FtZSBkYXRhIHRoYW4gdGhlIG5leHQgZW50cnkgYWZ0ZXIgdGhlIGN1cnJlbnQgaGlzdG9yeSBwb2ludGVyLCBkbyBubyBkcm9wIHRoZSByZXN0IG9mIHRoZSAncmVkbycgbGlzdCwgYW5kIGp1c3QgYWR2YW5jZSB0aGUgaGlzdG9yeVRhYmxlSW5kZXhcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0SGlzdG9yeVN0YXRlSW5kZXggPSB0aGlzLmhpc3RvcnlUYWJsZUluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dEhpc3RvcnlTdGF0ZUluZGV4IDwgdGhpcy5oaXN0b3J5VGFibGUubGVuZ3RoICYmIHRoaXMucmF3VmFsdWUgPT09IHRoaXMuaGlzdG9yeVRhYmxlW25leHRIaXN0b3J5U3RhdGVJbmRleF0udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpbnB1dCByZXN1bHQgaW4gdGhlIHNhbWUgc3RhdGUgdGhhbiB0aGUgbmV4dCBvbmUsIGRvIG5vdCByZW1vdmUgdGhlIG5leHQgaGlzdG9yeSBzdGF0ZXMgbm9yIGFkZCBhIG5ldyBvbmVcbiAgICAgICAgICAgICAgICAgICAgYWRkTmV3SGlzdG9yeVN0YXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QgcmVtb3ZlIGFueXRoaW5nIHRoYXQgaXMgYWZ0ZXIgdGhlIGN1cnJlbnQgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuYXJyYXlUcmltKHRoaXMuaGlzdG9yeVRhYmxlLCB0aGlzLmhpc3RvcnlUYWJsZUluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGhpc3RvcnkgcG9pbnRlclxuICAgICAgICAgICAgdGhpcy5oaXN0b3J5VGFibGVJbmRleCsrO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG5ldyBoaXN0b3J5IHN0YXRlLCBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmIChhZGROZXdIaXN0b3J5U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBzZWxlY3Rpb24gaW5mb1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRTZWxlY3Rpb24odGhpcy5kb21FbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uLnN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gc2VsZWN0aW9uLmVuZDtcblxuICAgICAgICAgICAgICAgIC8vIFRoZW4gYWRkIHRoZSBuZXcgcmF3IHZhbHVlXG4gICAgICAgICAgICAgICAgdGhpcy5oaXN0b3J5VGFibGUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIHJhd1ZhbHVlIGFuZCBzZWxlY3Rpb24gc3RhcnQvZW5kXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnJhd1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc2VsZWN0aW9uIGZvciB0aGlzIGVsZW1lbnQgaXMgdGVtcG9yYXJ5LCBhbmQgd2lsbCBiZSB1cGRhdGVkIHdoZW4gdGhlIG5leHQgaGlzdG9yeSBzdGF0ZSB3aWxsIGJlIHJlY29yZGVkLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGF0IHdheSwgd2UgYXJlIGFsd2F5cyBzdXJlIHdlIHNhdmUgdGhlIGxhc3QgY2FyZXQgb3Igc2VsZWN0aW9uIHBvc2l0aW9ucyBqdXN0IGJlZm9yZSB0aGUgdmFsdWUgaXMgY2hhbmdlZC4gT3RoZXJ3aXNlIHdlIHdvdWxkIG9ubHkgc2F2ZSB0aG9zZSBwb3NpdGlvbnMgd2hlbiB0aGUgdmFsdWUgaXMgZmlyc3QgY2hhbmdlZCwgYW5kIHdvdWxkIG5vdCB0YWtlIGludG8gYWNjb3VudCB0aGF0IHRoZSB1c2VyIGNvdWxkIG1vdmUgdGhlIGNhcmV0IGFyb3VuZCBhZnRlcndhcmQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBpbnN0YW5jZSwgdGhpcyBpcyBuZWVkZWQgaWYgdGhlIHVzZXIgY2hhbmdlIHRoZSBlbGVtZW50IHZhbHVlLCBhbmQgaW1tZWRpYXRlbHkgdW5kbyBpdCA7IGlmIGhlIHRoZW4gZG9lcyBhIHJlZG8sIGhlJ2xsIHNlZSB0aGUgdmFsdWUgYW5kIHRoZSByaWdodCBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gVG8gc3VtIHVwOyBUaGUgc2VsZWN0aW9uIHBvc2l0aW9uIGFyZSBub3QgYWx3YXlzICsxIGNoYXJhY3Rlciwgc2luY2UgaXQgY291bGQgYWxzbyBiZSAnMicgaWYgYSBncm91cCBzZXBhcmF0b3IgaXMgYWRkZWQgd2hlbiBlbnRlcmluZyBvbmUgY2hhcmFjdGVyLiBUaGF0J3Mgd2h5IHRoZSBjdXJyZW50IGhpc3Rvcnkgc3RhdGUgY2FyZXQvc2VsZWN0aW9uIHBvc2l0aW9uIGlzIHVwZGF0ZWQgb24gZWFjaCBga2V5dXBgIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5zZWxlY3Rpb25TdGFydCArIDEsIC8vIEhlcmUgd2UgYWRkIG9uZSBzaW5jZSB0aGUgdXNlciBhZGRlZCBvbmUgY2hhcmFjdGVyIHRvb1xuICAgICAgICAgICAgICAgICAgICBlbmQgIDogdGhpcy5zZWxlY3Rpb25FbmQgKyAxLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWxlY3Rpb24gaW4gdGhlIHByZXZpb3VzIGVudHJ5LCBpbiBvcmRlciB0byBrZWVwIHRyYWNrIG9mIHRoZSB1cGRhdGVkIGNhcmV0L3NlbGVjdGlvbiBwb3NpdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oaXN0b3J5VGFibGUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpc3RvcnlUYWJsZVt0aGlzLmhpc3RvcnlUYWJsZUluZGV4IC0gMV0uc3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpc3RvcnlUYWJsZVt0aGlzLmhpc3RvcnlUYWJsZUluZGV4IC0gMV0uZW5kID0gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBMaW1pdCB0aGUgaGlzdG9yeSB0YWJsZSBzaXplIGFjY29yZGluZyB0byB0aGUgYGhpc3RvcnlTaXplYCBvcHRpb25cbiAgICAgICAgICAgIGlmICh0aGlzLmhpc3RvcnlUYWJsZS5sZW5ndGggPiB0aGlzLnNldHRpbmdzLmhpc3RvcnlTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGlzdG9yeVRhYmxlRm9yZ2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWJ1ZyBmdW5jdGlvbiBmb3IgdGhlIGhpc3RvcnkgdGFibGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIC8qXG4gICAgX2RlYnVnSGlzdG9yeVRhYmxlKCkge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBtYXJrO1xuICAgICAgICB0aGlzLmhpc3RvcnlUYWJsZS5mb3JFYWNoKGhpc3RvcnkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGlzdG9yeVRhYmxlSW5kZXggPT09IGkpIHtcbiAgICAgICAgICAgICAgICBtYXJrID0gJz4gJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFyayA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coYCR7bWFya30ke2krK306ICR7aGlzdG9yeS52YWx1ZX0gJHtoaXN0b3J5LnN0YXJ0fXwke2hpc3RvcnkuZW5kfSBbb25Hb2luZ1JlZG86ICR7dGhpcy5vbkdvaW5nUmVkb31dYCk7IC8vREVCVUdcbiAgICAgICAgfSk7XG4gICAgfVxuICAgICovXG5cbiAgICAvKipcbiAgICAgKiAnVW5kbycgb3IgJ1JlZG8nIHRoZSBsYXN0L25leHQgdXNlciBlbnRyeSBpbiB0aGUgaGlzdG9yeSB0YWJsZS5cbiAgICAgKiBUaGlzIGRvZXMgbm90IG1vZGlmeSB0aGUgaGlzdG9yeSB0YWJsZSwgb25seSB0aGUgcG9pbnRlciB0byB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdW5kbyBJZiBzZXQgdG8gYHRydWVgLCB0aGVuIHRoaXMgZnVuY3Rpb24gZG9lcyBhbiAnVW5kbycsIG90aGVyd2lzZSBpdCBkb2VzIGEgJ1JlZG8nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGlzdG9yeVRhYmxlVW5kb09yUmVkbyh1bmRvID0gdHJ1ZSkge1xuICAgICAgICBsZXQgY2hlY2s7XG4gICAgICAgIGlmICh1bmRvKSB7XG4gICAgICAgICAgICAvLyBPbmx5ICd1bmRvJyBpZiB0aGVyZSBhcmUgc29tZSBpbmZvIHRvIHVuZG9cbiAgICAgICAgICAgIGNoZWNrID0gdGhpcy5oaXN0b3J5VGFibGVJbmRleCA+IDA7XG4gICAgICAgICAgICBpZiAoY2hlY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpc3RvcnlUYWJsZUluZGV4LS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPbmx5ICdyZWRvJyBpZiB0aGVyZSBhcmUgc29tZSBpbmZvIHRvIHJlZG8gYXQgdGhlIGVuZCBvZiB0aGUgaGlzdG9yeSB0YWJsZVxuICAgICAgICAgICAgY2hlY2sgPSB0aGlzLmhpc3RvcnlUYWJsZUluZGV4ICsgMSA8IHRoaXMuaGlzdG9yeVRhYmxlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChjaGVjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlzdG9yeVRhYmxlSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGVjaykge1xuICAgICAgICAgICAgLy8gU2V0IHRoZSB2YWx1ZSBiYWNrXG4gICAgICAgICAgICBjb25zdCB1bmRvSW5mbyA9IHRoaXMuaGlzdG9yeVRhYmxlW3RoaXMuaGlzdG9yeVRhYmxlSW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5zZXQodW5kb0luZm8udmFsdWUsIG51bGwsIGZhbHNlKTsgLy8gbmV4dCBvciBwcmV2aW91cyByYXcgdmFsdWVcblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBzZWxlY3Rpb24gYmFja1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLmRvbUVsZW1lbnQsIHVuZG9JbmZvLnN0YXJ0LCB1bmRvSW5mby5lbmQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogJ1VuZG8nIHRoZSBsYXN0IHVzZXIgZW50cnkgYnkgZ29pbmcgYmFjayBvbmUgZW50cnkgaW4gdGhlIGhpc3RvcnkgdGFibGUuXG4gICAgICogVGhpcyBrZWVwcyB0aGUgZm9sbG93aW5nIGVudHJpZXMgaW4gb3JkZXIgdG8gYWxsb3cgZm9yIGEgJ3JlZG8nLlxuICAgICAqIFRoaXMgZG9lcyBub3QgbW9kaWZ5IHRoZSBoaXN0b3J5IHRhYmxlLCBvbmx5IHRoZSBwb2ludGVyIHRvIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hpc3RvcnlUYWJsZVVuZG8oKSB7XG4gICAgICAgIHRoaXMuX2hpc3RvcnlUYWJsZVVuZG9PclJlZG8odHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogJ1JlZG8nIHRoZSBuZXh0IHVzZXIgZW50cnkgaW4gdGhlIGhpc3RvcnkgdGFibGUuXG4gICAgICogVGhpcyBkb2VzIG5vdCBtb2RpZnkgdGhlIGhpc3RvcnkgdGFibGUsIG9ubHkgdGhlIHBvaW50ZXIgdG8gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGlzdG9yeVRhYmxlUmVkbygpIHtcbiAgICAgICAgdGhpcy5faGlzdG9yeVRhYmxlVW5kb09yUmVkbyhmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGhpc3RvcnkgdGFibGUgdG8gaXRzIGluaXRpYWwgc3RhdGUsIGFuZCBzZWxlY3QgdGhlIHZhbHVlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgLypcbiAgICByZXNldEhpc3RvcnlUYWJsZSgpIHsgLy9GSVhNRSBUZXN0IHRoaXNcbiAgICAgICAgdGhpcy5zZXQodGhpcy5yYXdWYWx1ZSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICB0aGlzLnNlbGVjdCgpO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgICAgIHRoaXMuaGlzdG9yeVRhYmxlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLmhpc3RvcnlUYWJsZSA9IFt7XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSByYXdWYWx1ZSBhbmQgc2VsZWN0aW9uIHN0YXJ0L2VuZFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMucmF3VmFsdWUsXG4gICAgICAgICAgICBzdGFydDogc2VsZWN0aW9uLnN0YXJ0LFxuICAgICAgICAgICAgZW5kICA6IHNlbGVjdGlvbi5lbmQsXG4gICAgICAgIH1dO1xuICAgIH1cbiAgICAqL1xuXG4gICAgLyoqXG4gICAgICogTWFrZSB0aGUgaGlzdG9yeSB0YWJsZSBmb3JnZXQgaXRzIGZpcnN0IE4gZWxlbWVudHMsIHNoaWZ0aW5nIGl0cyBpbmRleGVzIGluIHRoZSBwcm9jZXNzLlxuICAgICAqIGBOYCBiZWluZyBnaXZlbiBhcyB0aGUgYG51bWJlck9mRW50cmllc1RvRm9yZ2V0YCBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyT2ZFbnRyaWVzVG9Gb3JnZXRcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fEFycmF5PG9iamVjdD59IFRoZSBkaXNjYXJkZWQgb2JqZWN0cywgaW4gYW4gQXJyYXkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGlzdG9yeVRhYmxlRm9yZ2V0KG51bWJlck9mRW50cmllc1RvRm9yZ2V0ID0gMSkge1xuICAgICAgICBjb25zdCBzaGlmdGVkQXdheSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mRW50cmllc1RvRm9yZ2V0OyBpKyspIHtcbiAgICAgICAgICAgIHNoaWZ0ZWRBd2F5LnB1c2godGhpcy5oaXN0b3J5VGFibGUuc2hpZnQoKSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGhpc3RvcnkgdGFibGUgaW5kZXggYWNjb3JkaW5nbHlcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeVRhYmxlSW5kZXgtLTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhpc3RvcnlUYWJsZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgbW9yZSB0aW1lcyB0aGFuIHRoZXJlIGlzIHN0YXRlcyBpbiB0aGUgaGlzdG9yeSB0YWJsZVxuICAgICAgICAgICAgICAgIHRoaXMuaGlzdG9yeVRhYmxlSW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoaWZ0ZWRBd2F5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHNoaWZ0ZWRBd2F5WzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNoaWZ0ZWRBd2F5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY3VycmVudGx5IHVzZWQgdmFsdWUgZnJvbSB0aGUgaGlzdG9yeSB0YWJsZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hpc3RvcnlUYWJsZUN1cnJlbnRWYWx1ZVVzZWQoKSB7XG4gICAgICAgIGxldCBpbmRleFRvVXNlID0gdGhpcy5oaXN0b3J5VGFibGVJbmRleDtcbiAgICAgICAgaWYgKGluZGV4VG9Vc2UgPCAwKSB7XG4gICAgICAgICAgICBpbmRleFRvVXNlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkodGhpcy5oaXN0b3J5VGFibGVbaW5kZXhUb1VzZV0pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuaGlzdG9yeVRhYmxlW2luZGV4VG9Vc2VdLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgYHN0eWxlUnVsZXNgIG9wdGlvbiBhbmQgcnVuIHRoZSB0ZXN0IGZvciBlYWNoIGdpdmVuIHJ1bGVzLCBlaXRoZXIgcHJlLWRlZmluZWQgb25lcyBsaWtlIGBwb3NpdGl2ZWAsIGBuZWdhdGl2ZWAgYW5kIGByYW5nZXNgLCBvciB1c2VyIGRlZmluZWQgY2FsbGJhY2tzIHdpdGhpbiB0aGUgYHVzZXJEZWZpbmVkYCBhdHRyaWJ1dGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcGFyc2VTdHlsZVJ1bGVzKCkge1xuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHRoaXMuc2V0dGluZ3Muc3R5bGVSdWxlcykgfHwgdGhpcy5yYXdWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICdwb3NpdGl2ZScgYXR0cmlidXRlXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHRoaXMuc2V0dGluZ3Muc3R5bGVSdWxlcy5wb3NpdGl2ZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhd1ZhbHVlID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRDU1NDbGFzcyh0aGlzLnNldHRpbmdzLnN0eWxlUnVsZXMucG9zaXRpdmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVDU1NDbGFzcyh0aGlzLnNldHRpbmdzLnN0eWxlUnVsZXMucG9zaXRpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ25lZ2F0aXZlJyBhdHRyaWJ1dGVcbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkodGhpcy5zZXR0aW5ncy5zdHlsZVJ1bGVzLm5lZ2F0aXZlKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmF3VmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkQ1NTQ2xhc3ModGhpcy5zZXR0aW5ncy5zdHlsZVJ1bGVzLm5lZ2F0aXZlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ1NTQ2xhc3ModGhpcy5zZXR0aW5ncy5zdHlsZVJ1bGVzLm5lZ2F0aXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vICdyYW5nZXMnIGF0dHJpYnV0ZVxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSh0aGlzLnNldHRpbmdzLnN0eWxlUnVsZXMucmFuZ2VzKSAmJiB0aGlzLnNldHRpbmdzLnN0eWxlUnVsZXMucmFuZ2VzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5zdHlsZVJ1bGVzLnJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yYXdWYWx1ZSA+PSByYW5nZS5taW4gJiYgdGhpcy5yYXdWYWx1ZSA8IHJhbmdlLm1heCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRDU1NDbGFzcyhyYW5nZS5jbGFzcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ1NTQ2xhc3MocmFuZ2UuY2xhc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gJ3VzZXJEZWZpbmVkJyBhdHRyaWJ1dGVcbiAgICAgICAgLy9UT0RPIEFsc28gcGFzcyB0aGUgb2xkIHJhdyB2YWx1ZSBhcyBhIHBhcmFtZXRlciwgYW5kIG5vdCBvbmx5IHRoZSBuZXcgcmF3IHZhbHVlXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHRoaXMuc2V0dGluZ3Muc3R5bGVSdWxlcy51c2VyRGVmaW5lZCkgJiYgdGhpcy5zZXR0aW5ncy5zdHlsZVJ1bGVzLnVzZXJEZWZpbmVkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5zdHlsZVJ1bGVzLnVzZXJEZWZpbmVkLmZvckVhY2godXNlck9iamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzRnVuY3Rpb24odXNlck9iamVjdC5jYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGVzdCBmb3IgdGhlIHR5cGUgb2YgdGhlIGBjbGFzc2VzYCBhdHRyaWJ1dGUsIHdoaWNoIGNoYW5nZXMgdGhlIGZ1bmN0aW9uIGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc1N0cmluZyh1c2VyT2JqZWN0LmNsYXNzZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiAnY2xhc3NlcycgaXMgYSBzdHJpbmcsIHNldCBpdCBpZiBgdHJ1ZWAsIHJlbW92ZSBpdCBpZiBgZmFsc2VgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlck9iamVjdC5jYWxsYmFjayh0aGlzLnJhd1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZENTU0NsYXNzKHVzZXJPYmplY3QuY2xhc3Nlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNTU0NsYXNzKHVzZXJPYmplY3QuY2xhc3Nlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNBcnJheSh1c2VyT2JqZWN0LmNsYXNzZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlck9iamVjdC5jbGFzc2VzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmICdjbGFzc2VzJyBpcyBhbiBhcnJheSB3aXRoIG9ubHkgMiBlbGVtZW50cywgc2V0IHRoZSBmaXJzdCBjbGFzcyBpZiBgdHJ1ZWAsIHRoZSBzZWNvbmQgaWYgYGZhbHNlYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VyT2JqZWN0LmNhbGxiYWNrKHRoaXMucmF3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZENTU0NsYXNzKHVzZXJPYmplY3QuY2xhc3Nlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNTU0NsYXNzKHVzZXJPYmplY3QuY2xhc3Nlc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ1NTQ2xhc3ModXNlck9iamVjdC5jbGFzc2VzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkQ1NTQ2xhc3ModXNlck9iamVjdC5jbGFzc2VzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHVzZXJPYmplY3QuY2xhc3Nlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNhbGxiYWNrIHJldHVybnMgYW4gYXJyYXkgb2YgaW5kZXhlcyB0byB1c2Ugb24gdGhlIGBjbGFzc2VzYCBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrUmVzdWx0ID0gdXNlck9iamVjdC5jYWxsYmFjayh0aGlzLnJhd1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNBcnJheShjYWxsYmFja1Jlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbXVsdGlwbGUgaW5kZXhlcyBhcmUgcmV0dXJuZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlck9iamVjdC5jbGFzc2VzLmZvckVhY2goKHVzZXJDbGFzcywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc0luQXJyYXkoaW5kZXgsIGNhbGxiYWNrUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZENTU0NsYXNzKHVzZXJDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNTU0NsYXNzKHVzZXJDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNJbnQoY2FsbGJhY2tSZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG9ubHkgb25lIGluZGV4IGlzIHJldHVybmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJPYmplY3QuY2xhc3Nlcy5mb3JFYWNoKCh1c2VyQ2xhc3MsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IGNhbGxiYWNrUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkQ1NTQ2xhc3ModXNlckNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ1NTQ2xhc3ModXNlckNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bGwoY2FsbGJhY2tSZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgdGhlIGNsYXNzZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlck9iamVjdC5jbGFzc2VzLmZvckVhY2godXNlckNsYXNzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNTU0NsYXNzKHVzZXJDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBjYWxsYmFjayByZXN1bHQgaXMgbm90IGFuIGFycmF5IG5vciBhIHZhbGlkIGFycmF5IGluZGV4LCAke3R5cGVvZiBjYWxsYmFja1Jlc3VsdH0gZ2l2ZW4uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKCdUaGUgY2xhc3NlcyBhdHRyaWJ1dGUgaXMgbm90IHZhbGlkIGZvciB0aGUgYHN0eWxlUnVsZXNgIG9wdGlvbi4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkodXNlck9iamVjdC5jbGFzc2VzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgJ2NsYXNzZXMnIGlzIGB1bmRlZmluZWRgIG9yIGBudWxsYCwgdGhlbiB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggdGhlIEF1dG9OdW1lcmljIG9iamVjdCBwYXNzZWQgYXMgYSBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJPYmplY3QuY2FsbGJhY2sodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKCdUaGUgY2FsbGJhY2svY2xhc3NlcyBzdHJ1Y3R1cmUgaXMgbm90IHZhbGlkIGZvciB0aGUgYHN0eWxlUnVsZXNgIG9wdGlvbi4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLndhcm5pbmcoYFRoZSBnaXZlbiBcXGBzdHlsZVJ1bGVzXFxgIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLCAke3R5cGVvZiBjYWxsYmFja30gZ2l2ZW4uYCwgdGhpcy5zZXR0aW5ncy5zaG93V2FybmluZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBnaXZlbiBDU1MgY2xhc3MgdG8gdGhlIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNzc0NsYXNzTmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZENTU0NsYXNzKGNzc0NsYXNzTmFtZSkge1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LmFkZChjc3NDbGFzc05hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgZ2l2ZW4gQ1NTIGNsYXNzIGZyb20gdGhlIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNzc0NsYXNzTmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZUNTU0NsYXNzKGNzc0NsYXNzTmFtZSkge1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjc3NDbGFzc05hbWUpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgYXJlIHRoZSBwdWJsaWMgZnVuY3Rpb24gYXZhaWxhYmxlIG9uIGVhY2ggYXV0b051bWVyaWMtbWFuYWdlZCBlbGVtZW50XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCB1cGRhdGVzIHRoZSBBdXRvTnVtZXJpYyBzZXR0aW5ncywgYW5kIGltbWVkaWF0ZWx5IGZvcm1hdCB0aGUgZWxlbWVudCBhY2NvcmRpbmdseS5cbiAgICAgKiBUaGUgb3B0aW9ucyBwYXNzZWQgYXMgcGFyYW1ldGVyKHMpIGlzIGVpdGhlciBvbmUgb3IgbWFueSBvYmplY3RzIHRoYXQgZWFjaCBjb250YWlucyBzb21lIHNldHRpbmdzLCBpZS4gOlxuICAgICAqIHtcbiAgICAgKiAgICAgZGlnaXRHcm91cFNlcGFyYXRvcjogXCIuXCIsXG4gICAgICogICAgIGRlY2ltYWxDaGFyYWN0ZXI6IFwiLFwiLFxuICAgICAqICAgICBjdXJyZW5jeVN5bWJvbDogJ+KCrCAnLFxuICAgICAqIH1cbiAgICAgKiBJZiBtdWx0aXBsZSBvcHRpb25zIGFyZSBwYXNzZWQsIHRoZSBsYXR0ZXIgb3ZlcndyaXRlIHRoZSBwcmV2aW91cyBvbmVzLlxuICAgICAqXG4gICAgICogTm90ZTogSWYgdGhlIG5ldyBzZXR0aW5ncyBhcmUgbm90IHZhbGlkYXRlZCwgb3IgdGhlIGNhbGwgdG8gYHNldCgpYCBmYWlscywgdGhlbiB0aGUgcHJldmlvdXMgdmFsaWQgc2V0dGluZ3MgYXJlIHJldmVydGVkIGJhY2sgdG8uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBhbkVsZW1lbnQudXBkYXRlKHsgb3B0aW9ucyB9KSAvLyBVcGRhdGVzIHRoZSBzZXR0aW5nc1xuICAgICAqIEBleGFtcGxlIGFuRWxlbWVudC51cGRhdGUoeyBvcHRpb25zMSB9LCB7IG9wdGlvbnMyIH0pIC8vIFVwZGF0ZXMgdGhlIHNldHRpbmdzIHdpdGggbXVsdGlwbGUgb3B0aW9uIG9iamVjdHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdPcHRpb25zXG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqL1xuICAgIHVwZGF0ZSguLi5uZXdPcHRpb25zKSB7XG4gICAgICAgIC8vIEtlZXAgYSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBzZXR0aW5ncyBiZWZvcmUgY2hhbmdpbmcgdGhlbSwgaW4gY2FzZSB0aGV5IGRvIG5vdCB2YWxpZGF0ZSBjb3JyZWN0bHksIHNvIHdlIGNhbiBzd2l0Y2ggYmFjayB0byB0aGVtXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU2V0dGluZ3MgPSBBdXRvTnVtZXJpY0hlbHBlci5jbG9uZU9iamVjdCh0aGlzLnNldHRpbmdzKTsgLy9UT0RPIENoZWNrIHRoYXQgdGhlIGBzdHlsZVJ1bGVzYCBvcHRpb24gaXMgY29ycmVjdGx5IGNsb25lZCAoZHVlIHRvIGRlcHRoIGNsb25pbmcgbGltaXRhdGlvbilcblxuICAgICAgICAvLyBTdG9yZSB0aGUgY3VycmVudCB1bmZvcm1hdHRlZCBpbnB1dCB2YWx1ZVxuICAgICAgICBjb25zdCBudW1lcmljU3RyaW5nID0gdGhpcy5yYXdWYWx1ZTtcblxuICAgICAgICAvLyBHZW5lcmF0ZSBhIHNpbmdsZSBvcHRpb24gb2JqZWN0IHdpdGggdGhlIHNldHRpbmdzIGZyb20gdGhlIGxhdHRlciBvdmVyd3JpdGluZyB0aG9zZSBmcm9tIHRoZSBmb3JtZXJcbiAgICAgICAgbGV0IG9wdGlvbnNUb1VzZSA9IHt9O1xuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWRPck51bGxPckVtcHR5KG5ld09wdGlvbnMpIHx8IG5ld09wdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBvcHRpb25zVG9Vc2UgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKG5ld09wdGlvbnMubGVuZ3RoID49IDEpIHtcbiAgICAgICAgICAgIG5ld09wdGlvbnMuZm9yRWFjaChvcHRpb25PYmplY3QgPT4ge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9uc1RvVXNlLCBvcHRpb25PYmplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHNldHRpbmdzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRTZXR0aW5ncyhvcHRpb25zVG9Vc2UsIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBSZWZvcm1hdCB0aGUgaW5wdXQgdmFsdWUgd2l0aCB0aGUgbmV3IHNldHRpbmdzXG4gICAgICAgICAgICAvLyBOb3RlOiB3ZSBhbHdheXMgYHNldGAsIGV2ZW4gd2hlbiBgbnVtZXJpY1N0cmluZ2AgaXMgdGhlIGVtcHR5IHN0cmluZyAnJywgc2luY2UgYGVtcHR5SW5wdXRCZWhhdmlvcmAgKHNldCB0byBgYWx3YXlzYCBvciBgemVyb2ApIGNhbiBjaGFuZ2UgaG93IHRoZSBlbXB0eSBpbnB1dCBpcyBmb3JtYXR0ZWRcbiAgICAgICAgICAgIHRoaXMuc2V0KG51bWVyaWNTdHJpbmcpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHNldHRpbmdzIHZhbGlkYXRpb24gZmFpbHMsIHRoZW4gd2Ugc3dpdGNoIGJhY2sgdG8gdGhlIHByZXZpb3VzIHZhbGlkIHNldHRpbmdzXG4gICAgICAgICAgICB0aGlzLl9zZXRTZXR0aW5ncyhvcmlnaW5hbFNldHRpbmdzLCB0cnVlKTsgLy8gYF9zZXRTZXR0aW5ncygpYCBpcyB1c2VkIGhlcmUgaW5zdGVhZCBvZiBkaXJlY3RseSBkb2luZyBgdGhpcy5zZXR0aW5ncyA9IG9yaWdpbmFsU2V0dGluZ3M7YCBzaW5jZSBsb3RzIG9mIHNpZGUgdmFyaWFibGVzIGFyZSBjYWxjdWxhdGVkIGZyb20gdGhlIHNldHRpbmdzLCBhbmQgd2UgbmVlZCB0byBnZXQgdGhvc2UgYmFjayB0byB0aGVpciBwcmV2aW91cyBzdGF0ZS4gTm90ZTogYF9zZXRTZXR0aW5ncygpYCBpcyBjYWxsZWQgaW4gdGhlICd1cGRhdGUnIG1vZGUgaW4gb3JkZXIgdG8gY29ycmVjdGx5IHNldCBiYWNrIHRoZSBgb3JpZ2luYWxEZWNpbWFsUGxhY2VzUmF3VmFsdWVgIHZhbHVlLlxuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVW5hYmxlIHRvIHVwZGF0ZSB0aGUgc2V0dGluZ3MsIHRob3NlIGFyZSBpbnZhbGlkOiBbJHtlcnJvcn1dYCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgY3VycmVudCBhdXRvTnVtZXJpYyBzZXR0aW5ncyBpbiBlZmZlY3QuXG4gICAgICogWW91IGNhbiB0aGVuIGRpcmVjdGx5IGFjY2VzcyBlYWNoIG9wdGlvbiBieSB1c2luZyBpdHMgbmFtZSA6IGBhbkVsZW1lbnQuZ2V0U2V0dGluZ3MoKS5vcHRpb25OYW1lQXV0b0NvbXBsZXRlZGAuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGFuRWxlbWVudC5nZXRTZXR0aW5ncygpXG4gICAgICogYW5FbGVtZW50LmdldFNldHRpbmdzKCkuZGVjaW1hbENoYXJhY3RlciAvLyBSZXR1cm4gdGhlIGRlY2ltYWxDaGFyYWN0ZXIgc2V0dGluZyBhcyBhIHN0cmluZyAtIGFueSB2YWxpZCBvcHRpb24gbmFtZSBjYW4gYmUgdXNlZFxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXRTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBnaXZlbiBlbGVtZW50IHZhbHVlLCBhbmQgZm9ybWF0IGl0IGltbWVkaWF0ZWx5LlxuICAgICAqIEFkZGl0aW9uYWxseSwgdGhpcyBgc2V0KClgIG1ldGhvZCBjYW4gYWNjZXB0IG9wdGlvbnMgdGhhdCB3aWxsIGJlIG1lcmdlZCBpbnRvIHRoZSBjdXJyZW50IEF1dG9OdW1lcmljIGVsZW1lbnQsIHRha2luZyBwcmVjZWRlbmNlIG92ZXIgYW55IHByZXZpb3VzIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgYW5FbGVtZW50LnNldCgnMTIzNDUuNjcnKSAvLyBGb3JtYXRzIHRoZSB2YWx1ZVxuICAgICAqIEBleGFtcGxlIGFuRWxlbWVudC5zZXQoMTIzNDUuNjcpIC8vIEZvcm1hdHMgdGhlIHZhbHVlXG4gICAgICogQGV4YW1wbGUgYW5FbGVtZW50LnNldCgxMjM0NS42NywgeyBkZWNpbWFsQ2hhcmFjdGVyIDogJywnIH0pIC8vIFVwZGF0ZSB0aGUgc2V0dGluZ3MgYW5kIGZvcm1hdHMgdGhlIHZhbHVlIGluIG9uZSBnb1xuICAgICAqIEBleGFtcGxlIGFuRWxlbWVudC5ub3J0aEFtZXJpY2FuKCkuc2V0KCckMTIsMzQ1LjY3JykgLy8gU2V0IGFuIGFscmVhZHkgZm9ybWF0dGVkIHZhbHVlICh0aGlzIGRvZXMgbm90IF9leGFjdGx5XyByZXNwZWN0IHRoZSBjdXJyZW5jeSBzeW1ib2wvbmVnYXRpdmUgcGxhY2VtZW50cywgYnV0IG9ubHkgcmVtb3ZlIGFsbCBub24tbnVtYmVycyBjaGFyYWN0ZXJzLCBhY2NvcmRpbmcgdG8gdGhlIG9uZXMgZ2l2ZW4gaW4gdGhlIHNldHRpbmdzKVxuICAgICAqIEBleGFtcGxlIGFuRWxlbWVudC5zZXQobnVsbCkgLy8gU2V0IHRoZSByYXdWYWx1ZSBhbmQgZWxlbWVudCB2YWx1ZSB0byBgbnVsbGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xudWxsfSBuZXdWYWx1ZSBUaGUgdmFsdWUgbXVzdCBiZSBhIE51bWJlciwgYSBudW1lcmljIHN0cmluZyBvciBgbnVsbGAgKGlmIGBlbXB0eUlucHV0QmVoYXZpb3JgIGlzIHNldCB0byBgJ251bGwnYClcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBIHNldHRpbmdzIG9iamVjdCB0aGF0IHdpbGwgb3ZlcnJpZGUgdGhlIGN1cnJlbnQgc2V0dGluZ3MuIE5vdGU6IHRoZSB1cGRhdGUgaXMgZG9uZSBvbmx5IGlmIHRoZSBgbmV3VmFsdWVgIGlzIGRlZmluZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzYXZlQ2hhbmdlVG9IaXN0b3J5IElmIHNldCB0byBgdHJ1ZWAsIHRoZW4gdGhlIGNoYW5nZSBpcyByZWNvcmRlZCBpbiB0aGUgaGlzdG9yeSB0YWJsZVxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKiBAdGhyb3dzXG4gICAgICovXG4gICAgc2V0KG5ld1ZhbHVlLCBvcHRpb25zID0gbnVsbCwgc2F2ZUNoYW5nZVRvSGlzdG9yeSA9IHRydWUpIHtcbiAgICAgICAgLy9UT0RPIEFkZCB0aGUgYHNhdmVTZXR0aW5nc2Agb3B0aW9ucy4gSWYgYHRydWVgLCB0aGVuIHdoZW4gYG9wdGlvbnNgIGlzIHBhc3NlZCwgdGhlbiBpdCBvdmVyd3JpdGUgdGhlIGN1cnJlbnQgYHRoaXMuc2V0dGluZ3NgLiBJZiBgZmFsc2VgIHRoZSBgb3B0aW9uc2AgYXJlIG9ubHkgdXNlZCBvbmNlIGFuZCBgdGhpcy5zZXR0aW5nc2AgaXMgbm90IG1vZGlmaWVkXG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZChuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLndhcm5pbmcoYFlvdSBhcmUgdHJ5aW5nIHRvIHNldCBhbiAndW5kZWZpbmVkJyB2YWx1ZSA7IGFuIGVycm9yIGNvdWxkIGhhdmUgb2NjdXJyZWQuYCwgdGhpcy5zZXR0aW5ncy5zaG93V2FybmluZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgb3B0aW9ucyB1cGRhdGUgaXMgZG9uZSBvbmx5IGlmIHRoZSBgbmV3VmFsdWVgIGlzIG5vdCBgdW5kZWZpbmVkYFxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0U2V0dGluZ3Mob3B0aW9ucywgdHJ1ZSk7IC8vIFdlIGRvIG5vdCBjYWxsIGB1cGRhdGVgIGhlcmUgc2luY2UgdGhpcyB3b3VsZCBjYWxsIGBzZXRgIHRvb1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBudWxsICYmIHRoaXMuc2V0dGluZ3MuZW1wdHlJbnB1dEJlaGF2aW9yICE9PSBBdXRvTnVtZXJpYy5vcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvci5udWxsKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci53YXJuaW5nKGBZb3UgYXJlIHRyeWluZyB0byBzZXQgdGhlIFxcYG51bGxcXGAgdmFsdWUgd2hpbGUgdGhlIFxcYGVtcHR5SW5wdXRCZWhhdmlvclxcYCBvcHRpb24gaXMgc2V0IHRvICR7dGhpcy5zZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3J9LiBJZiB5b3Ugd2FudCB0byBiZSBhYmxlIHRvIHNldCB0aGUgXFxgbnVsbFxcYCB2YWx1ZSwgeW91IG5lZWQgdG8gY2hhbmdlIHRoZSAnZW1wdHlJbnB1dEJlaGF2aW9yJyBvcHRpb24gdG8gXFxgJ251bGwnXFxgLmAsIHRoaXMuc2V0dGluZ3Muc2hvd1dhcm5pbmdzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBpZiAobmV3VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vVE9ETyBNZXJnZSB0aGlzIGludG8gYSBnbG9iYWwgYGlmIChuZXdWYWx1ZSA9PT0gbnVsbCkge2AgdGVzdCwgd2l0aCB0aGUgdGVzdCBhYm92ZVxuICAgICAgICAgICAgLy8gSGVyZSB0aGlzLnNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3IubnVsbFxuICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudEFuZFJhd1ZhbHVlKG51bGwsIG51bGwsIHNhdmVDaGFuZ2VUb0hpc3RvcnkpO1xuICAgICAgICAgICAgdGhpcy5fc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rvci5fdG9OdW1lcmljVmFsdWUobmV3VmFsdWUsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICBpZiAoaXNOYU4oTnVtYmVyKHZhbHVlKSkpIHtcbiAgICAgICAgICAgIC8vVE9ETyBEbyBub3QgbW9kaWZ5IHRoZSBlbGVtZW50IHZhbHVlIGlmIHRoZSBuZXdWYWx1ZSByZXN1bHRzIGluIGBOYU5gLiBNYWtlIHN1cmUgdGhlIHNldHRpbmdzLCBpZiBtb2RpZmllZCwgYXJlIHJldmVydCBiYWNrIHRvby5cbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLndhcm5pbmcoYFRoZSB2YWx1ZSB5b3UgYXJlIHRyeWluZyB0byBzZXQgcmVzdWx0cyBpbiBcXGBOYU5cXGAuIFRoZSBlbGVtZW50IHZhbHVlIGlzIHNldCB0byB0aGUgZW1wdHkgc3RyaW5nIGluc3RlYWQuYCwgdGhpcy5zZXR0aW5ncy5zaG93V2FybmluZ3MpO1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSgnJywgc2F2ZUNoYW5nZVRvSGlzdG9yeSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAodmFsdWUgPT09ICcnICYmIHRoaXMuc2V0dGluZ3MuZW1wdHlJbnB1dEJlaGF2aW9yID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvci56ZXJvKSB7XG4gICAgICAgICAgICAvLyBLZWVwIHRoZSB2YWx1ZSB6ZXJvIGluc2lkZSB0aGUgZWxlbWVudFxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gdGhpcy5jb25zdHJ1Y3Rvci5fY2hlY2tJZkluUmFuZ2VXaXRoT3ZlcnJpZGVPcHRpb24odmFsdWUsIHRoaXMuc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAvLyBNb2RpZnkgdGhlIGZvcm1hdHRlZCB2YWx1ZSBpZiB0aGUgcmF3VmFsdWUgaXMgZm91bmQgaW4gdGhlIGB2YWx1ZXNUb1N0cmluZ3NgIG9wdGlvblxuICAgICAgICAgICAgaWYgKG1pblRlc3QgJiYgbWF4VGVzdCAmJiB0aGlzLnNldHRpbmdzLnZhbHVlc1RvU3RyaW5ncyAmJiB0aGlzLl9jaGVja1ZhbHVlc1RvU3RyaW5ncyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIHJhdyB2YWx1ZSBub3JtYWxseSwgYW5kIHRoZSBmb3JtYXR0ZWQgdmFsdWUgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBzdHJpbmdcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRFbGVtZW50QW5kUmF3VmFsdWUodGhpcy5zZXR0aW5ncy52YWx1ZXNUb1N0cmluZ3NbdmFsdWVdLCB2YWx1ZSwgc2F2ZUNoYW5nZVRvSGlzdG9yeSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoaXMgdGVzdCBpcyBuZWVkZWQgYnkgdGhlIGBzaG93UG9zaXRpdmVTaWduYCBvcHRpb25cbiAgICAgICAgICAgIGNvbnN0IGlzWmVybyA9IEF1dG9OdW1lcmljSGVscGVyLmlzWmVyb09ySGFzTm9WYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoaXNaZXJvKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAnMCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtaW5UZXN0ICYmIG1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICBsZXQgZm9yY2VkUmF3VmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLl9yb3VuZFJhd1ZhbHVlKHZhbHVlLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICBmb3JjZWRSYXdWYWx1ZSA9IHRoaXMuX3RyaW1MZWFkaW5nQW5kVHJhaWxpbmdaZXJvcyhmb3JjZWRSYXdWYWx1ZS5yZXBsYWNlKHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgJy4nKSk7IC8vIE1vdmUgdGhlIGBzZXRSYXdWYWx1ZWAgY2FsbCBhZnRlciB0aGUgYHNldEVsZW1lbnRWYWx1ZWAgb25lXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9nZXRSYXdWYWx1ZVRvRm9ybWF0KHZhbHVlKTsgLy8gTXVsdGlwbHkgdGhlIHJhdyB2YWx1ZSB0byBvYnRhaW4gdGhlIGZvcm1hdHRlZCB2YWx1ZVxuXG4gICAgICAgICAgICAgICAgLy8gUm91bmQgdGhlIGdpdmVuIHZhbHVlIGFjY29yZGluZyB0byB0aGUgb2JqZWN0IHN0YXRlIChmb2N1c2VkL3VuZm9jdXNlZClcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLl9yb3VuZEZvcm1hdHRlZFZhbHVlU2hvd25PbkZvY3VzKHZhbHVlLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5kaXZpc29yV2hlblVuZm9jdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIHRoaXMuc2V0dGluZ3MuZGl2aXNvcldoZW5VbmZvY3VzZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuY29uc3RydWN0b3IuX3JvdW5kRm9ybWF0dGVkVmFsdWVTaG93bk9uQmx1cih2YWx1ZSwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLl9tb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yRm9ybWF0dGVkVmFsdWUodmFsdWUsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rvci5fYWRkR3JvdXBTZXBhcmF0b3JzKHZhbHVlLCB0aGlzLnNldHRpbmdzLCB0aGlzLmlzRm9jdXNlZCwgdGhpcy5yYXdWYWx1ZSwgZm9yY2VkUmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0ZvY3VzZWQgJiYgdGhpcy5zZXR0aW5ncy5zeW1ib2xXaGVuVW5mb2N1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYCR7dmFsdWV9JHt0aGlzLnNldHRpbmdzLnN5bWJvbFdoZW5VbmZvY3VzZWR9YDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIHx8IHRoaXMuc2V0dGluZ3MuZGl2aXNvcldoZW5VbmZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRBbmRSYXdWYWx1ZSh2YWx1ZSwgZm9yY2VkUmF3VmFsdWUsIHNhdmVDaGFuZ2VUb0hpc3RvcnkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghbWluVGVzdCkge1xuICAgICAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50cmlnZ2VyRXZlbnQoQXV0b051bWVyaWMuZXZlbnRzLm1pblJhbmdlRXhjZWVkZWQsIHRoaXMuZG9tRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRyaWdnZXJFdmVudChBdXRvTnVtZXJpYy5ldmVudHMubWF4UmFuZ2VFeGNlZWRlZCwgdGhpcy5kb21FbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7dmFsdWV9XSBiZWluZyBzZXQgZmFsbHMgb3V0c2lkZSBvZiB0aGUgbWluaW11bVZhbHVlIFske3RoaXMuc2V0dGluZ3MubWluaW11bVZhbHVlfV0gYW5kIG1heGltdW1WYWx1ZSBbJHt0aGlzLnNldHRpbmdzLm1heGltdW1WYWx1ZX1dIHJhbmdlIHNldCBmb3IgdGhpcyBlbGVtZW50YCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVWYWx1ZUZyb21QZXJzaXN0ZW50U3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUoJycsIHNhdmVDaGFuZ2VUb0hpc3RvcnkpOyAvL1RPRE8gU2hvdWxkbid0IHdlIGp1c3QgZHJvcCB0aGF0IGZhdWx0eSBuZXdWYWx1ZSBhbmQga2VlcCB0aGUgcHJldmlvdXMgb25lPyBUaGlzIGlzIGJlaGluZCBhIGB0aHJvd0Vycm9yKClgIGNhbGwgYW55d2F5Li5cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSGVyZSwgYHZhbHVlYCBlcXVhbCB0aGUgZW1wdHkgc3RyaW5nIGAnJ2BcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuZW1wdHlJbnB1dEJlaGF2aW9yLmFsd2F5cykge1xuICAgICAgICAgICAgICAgIC8vIEtlZXAgdGhlIGN1cnJlbmN5IHN5bWJvbCBhcyBwZXIgZW1wdHlJbnB1dEJlaGF2aW9yXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRBbmRSYXdWYWx1ZShyZXN1bHQsICcnLCBzYXZlQ2hhbmdlVG9IaXN0b3J5KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGdpdmVuIHZhbHVlIGRpcmVjdGx5IGFzIHRoZSBET00gZWxlbWVudCB2YWx1ZSwgd2l0aG91dCBmb3JtYXR0aW5nIGl0IGJlZm9yZWhhbmQuXG4gICAgICogWW91IGNhbiBhbHNvIHNldCB0aGUgdmFsdWUgYW5kIHVwZGF0ZSB0aGUgc2V0dGluZyBpbiBvbmUgZ28gKHRoZSB2YWx1ZSB3aWxsIGFnYWluIG5vdCBiZSBmb3JtYXR0ZWQgaW1tZWRpYXRlbHkpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqIEB0aHJvd3NcbiAgICAgKi9cbiAgICBzZXRVbmZvcm1hdHRlZCh2YWx1ZSwgb3B0aW9ucyA9IG51bGwpIHtcbiAgICAgICAgLy9UT0RPIFNob3VsZCB3ZSB1c2UgYEF1dG9OdW1lcmljLnVuZm9ybWF0KClgIGhlcmUgYW5kIHNldCB0aGUgdW5mb3JtYXR0ZWQgcmVzdWx0IGluIGNhc2UgYHZhbHVlYCBpcyBmb3JtYXR0ZWQ/XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCBBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIG9wdGlvbnMgdXBkYXRlIGlzIGRvbmUgb25seSBpZiB0aGUgYHZhbHVlYCBpcyBub3QgbnVsbFxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0U2V0dGluZ3Mob3B0aW9ucywgdHJ1ZSk7IC8vIFdlIGRvIG5vdCBjYWxsIGB1cGRhdGVgIGhlcmUgc2luY2UgdGhpcyB3b3VsZCBjYWxsIGBzZXRgIHRvb1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RyaXBwZWRWYWx1ZSA9IHRoaXMuY29uc3RydWN0b3IuX3JlbW92ZUJyYWNrZXRzKHZhbHVlLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgbGV0IG5vcm1hbGl6ZWRWYWx1ZSA9IHRoaXMuY29uc3RydWN0b3IuX3N0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhzdHJpcHBlZFZhbHVlLCB0aGlzLnNldHRpbmdzLCB0cnVlLCB0aGlzLmlzRm9jdXNlZCk7XG4gICAgICAgIG5vcm1hbGl6ZWRWYWx1ZSA9IG5vcm1hbGl6ZWRWYWx1ZS5yZXBsYWNlKHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgJy4nKTtcbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bWJlcihub3JtYWxpemVkVmFsdWUpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgdmFsdWUgaXMgbm90IGEgdmFsaWQgb25lLCBpdCdzIG5vdCBhIG51bWVyaWMgc3RyaW5nIG5vciBhIHJlY29nbml6ZWQgY3VycmVuY3kuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSB0aGlzLmNvbnN0cnVjdG9yLl9jaGVja0lmSW5SYW5nZVdpdGhPdmVycmlkZU9wdGlvbihub3JtYWxpemVkVmFsdWUsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICBpZiAobWluVGVzdCAmJiBtYXhUZXN0KSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgYG5vcm1hbGl6ZWRWYWx1ZWAgaXMgaW4gdGhlIHJhbmdlXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSB2YWx1ZSBpcyBvdXQgb2YgdGhlIHJhbmdlIGxpbWl0cyBbJHt0aGlzLnNldHRpbmdzLm1pbmltdW1WYWx1ZX0sICR7dGhpcy5zZXR0aW5ncy5tYXhpbXVtVmFsdWV9XS5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZ2l2ZW4gdmFsdWUgZGlyZWN0bHkgYXMgdGhlIERPTSBlbGVtZW50IHZhbHVlLCB3aXRob3V0IGZvcm1hdHRpbmcgaXQgYmVmb3JlaGFuZCwgYW5kIHdpdGhvdXQgY2hlY2tpbmcgaXRzIHZhbGlkaXR5LlxuICAgICAqIFRoaXMgYWxzbyB1cGRhdGVzIHRoZSBgcmF3VmFsdWVgIHdpdGggdGhlIGdpdmVuIGBuZXdWYWx1ZWAsIHdpdGhvdXQgY2hlY2tpbmcgaXQgdG9vIDsgaWYgaXQncyBub3QgZm9ybWF0dGVkIGxpa2UgYSBudW1iZXIgcmVjb2duaXplZCBieSBKYXZhc2NyaXB0LCB0aGlzICp3aWxsKiBsaWtlbHkgbWFrZSBvdGhlciBBdXRvTnVtZXJpYyBtZXRob2RzIGZhaWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8bnVsbH0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSB0byBzZXQgb24gdGhlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNhdmVDaGFuZ2VUb0hpc3RvcnkgSWYgc2V0IHRvIGB0cnVlYCwgdGhlbiB0aGUgY2hhbmdlIGlzIHJlY29yZGVkIGluIHRoZSBoaXN0b3J5IGFycmF5LCBvdGhlcndpc2UgaXQgaXMgbm90XG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqL1xuICAgIHNldFZhbHVlKG5ld1ZhbHVlLCBzYXZlQ2hhbmdlVG9IaXN0b3J5ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50QW5kUmF3VmFsdWUobmV3VmFsdWUsIHNhdmVDaGFuZ2VUb0hpc3RvcnkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhdmUgdGhlIHJhdyB2YWx1ZSBpbnNpZGUgdGhlIEF1dG9OdW1lcmljIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xudWxsfSByYXdWYWx1ZSBUaGUgbnVtZXJpYyB2YWx1ZSBhcyB1bmRlcnN0b29kIGJ5IEphdmFzY3JpcHQgbGlrZSBhIGBOdW1iZXJgXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzYXZlQ2hhbmdlVG9IaXN0b3J5IElmIHNldCB0byBgdHJ1ZWAsIHRoZW4gdGhlIGNoYW5nZSBpcyByZWNvcmRlZCBpbiB0aGUgaGlzdG9yeSBhcnJheSwgb3RoZXJ3aXNlIGl0IGlzIG5vdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFJhd1ZhbHVlKHJhd1ZhbHVlLCBzYXZlQ2hhbmdlVG9IaXN0b3J5ID0gdHJ1ZSkge1xuICAgICAgICAvLyBPbmx5IHNldCB0aGUgcmF3IHZhbHVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgY3VycmVudCBvbmVcbiAgICAgICAgaWYgKHRoaXMucmF3VmFsdWUgIT09IHJhd1ZhbHVlKSB7IC8vVE9ETyBNYW5hZ2UgdGhlIGNhc2Ugd2hlcmUgb25lIHZhbHVlIGlzIGEgc3RyaW5nIHdoaWxlIHRoZSBvdGhlciBpcyBhIG51bWJlcj9cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmF3IHZhbHVlXG4gICAgICAgICAgICB0aGlzLnJhd1ZhbHVlID0gcmF3VmFsdWU7IC8vIEJ5IGRlZmF1bHQsIGlmIHRoZSBgcmF3VmFsdWVgIGlzIGNoYW5nZWQgcHJvZ3JhbW1hdGljYWxseVxuXG4gICAgICAgICAgICBpZiAoKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwodGhpcy5zZXR0aW5ncy5yYXdWYWx1ZURpdmlzb3IpICYmIHRoaXMuc2V0dGluZ3MucmF3VmFsdWVEaXZpc29yICE9PSAwKSAmJiAvLyBPbmx5IGRpdmlkZSBpZiB0aGUgYHJhd1ZhbHVlRGl2aXNvcmAgb3B0aW9uIGlzIHNldFxuICAgICAgICAgICAgICAgIHJhd1ZhbHVlICE9PSAnJyAmJiByYXdWYWx1ZSAhPT0gbnVsbCAmJiAvLyBEbyBub3QgbW9kaWZ5IHRoZSBgcmF3VmFsdWVgIGlmIGl0J3MgYW4gZW1wdHkgc3RyaW5nIG9yIG51bGxcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1VzZXJNYW51YWxseUVkaXRpbmdUaGVWYWx1ZSgpKSB7IC8vIElmIHRoZSB1c2VyIGlzIG1hbnVhbGx5IGNoYW5naW5nIHRoZSBlbGVtZW50IHZhbHVlXG4gICAgICAgICAgICAgICAgdGhpcy5yYXdWYWx1ZSAvPSB0aGlzLnNldHRpbmdzLnJhd1ZhbHVlRGl2aXNvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hhbmdlIHRoZSBlbGVtZW50IHN0eWxlIG9yIHVzZSB0aGUgcmVsZXZhbnQgY2FsbGJhY2tzXG4gICAgICAgICAgICB0aGlzLl9wYXJzZVN0eWxlUnVsZXMoKTtcblxuICAgICAgICAgICAgaWYgKHNhdmVDaGFuZ2VUb0hpc3RvcnkpIHtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIGluIHRoZSBoaXN0b3J5IHRoZSBsYXN0IGtub3duIHJhdyB2YWx1ZSBhbmQgZm9ybWF0dGVkIHJlc3VsdCBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICB0aGlzLl9oaXN0b3J5VGFibGVBZGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZ2l2ZW4gdmFsdWUgb24gdGhlIERPTSBlbGVtZW50LCB3aXRob3V0IGFmZmVjdGluZyB0aGUgYHJhd1ZhbHVlYC5cbiAgICAgKiBUaGlzIHNlbmQgYW4gJ2F1dG9OdW1lcmljOmZvcm1hdHRlZCcgZXZlbnQgaWYgdGhlIG5ldyB2YWx1ZSBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgb2xkIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbmV3RWxlbWVudFZhbHVlXG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldEVsZW1lbnRWYWx1ZShuZXdFbGVtZW50VmFsdWUpIHtcbiAgICAgICAgLy9UT0RPIFVzZSBhbiBpbnRlcm5hbCBhdHRyaWJ1dGUgdG8gdHJhY2sgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGVsZW1lbnQgYGZvcm1hdHRlZFZhbHVlYCAobGlrZSBpdHMgY291bnRlcnBhcnQgYHJhd1ZhbHVlYCkuIFRoaXMgd291bGQgYWxsb3cgdXMgdG8gYXZvaWQgY2FsbGluZyBgZ2V0RWxlbWVudFZhbHVlYCBtYW55IHRpbWVzXG4gICAgICAgIC8vIGBvbGRFbGVtZW50VmFsdWVgIGlzIHRoZSBwcmV2aW91cyB2YWx1ZSB0aGF0IHdpbGwgYmUgb3ZlcndyaXR0ZW4uIFRoaXMgaXMgdXNlZCB0byBkZWNpZGUgaWYgYW4gZXZlbnQgc2hvdWxkIGJlIHNlbnQgb3Igbm90LlxuICAgICAgICBjb25zdCBvbGRFbGVtZW50VmFsdWUgPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KTtcblxuICAgICAgICBpZiAobmV3RWxlbWVudFZhbHVlICE9PSBvbGRFbGVtZW50VmFsdWUpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIHRoZSB2YWx1ZSBpZiBpdCdzIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IG9uZVxuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuc2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCwgbmV3RWxlbWVudFZhbHVlKTtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRyaWdnZXJFdmVudChBdXRvTnVtZXJpYy5ldmVudHMuZm9ybWF0dGVkLCB0aGlzLmRvbUVsZW1lbnQsIHsgb2xkVmFsdWU6IG9sZEVsZW1lbnRWYWx1ZSwgbmV3VmFsdWU6IG5ld0VsZW1lbnRWYWx1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZ2l2ZW4gdmFsdWUgb24gdGhlIERPTSBlbGVtZW50LCBhbmQgdGhlIHJhdyB2YWx1ZSBvbiBgdGhpcy5yYXdWYWx1ZWAsIGlmIGJvdGggYXJlIGdpdmVuLlxuICAgICAqIElmIG9ubHkgb25lIHZhbHVlIGlzIGdpdmVuLCB0aGVuIGJvdGggdGhlIERPTSBlbGVtZW50IHZhbHVlIGFuZCB0aGUgcmF3IHZhbHVlIGFyZSBzZXQgd2l0aCB0aGF0IHZhbHVlLlxuICAgICAqIFRoZSB0aGlyZCBhcmd1bWVudCBgc2F2ZUNoYW5nZVRvSGlzdG9yeWAgZGVmaW5lcyBpZiB0aGUgY2hhbmdlIHNob3VsZCBiZSByZWNvcmRlZCBpbiB0aGUgaGlzdG9yeSBhcnJheS5cbiAgICAgKiBOb3RlOiBpZiB0aGUgc2Vjb25kIGFyZ3VtZW50IGByYXdWYWx1ZWAgaXMgYSBib29sZWFuLCB3ZSBjb25zaWRlciB0aGF0IGlzIHJlYWxseSBpcyB0aGUgYHNhdmVDaGFuZ2VUb0hpc3RvcnlgIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfG51bGx9IG5ld0VsZW1lbnRWYWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xudWxsfGJvb2xlYW59IHJhd1ZhbHVlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzYXZlQ2hhbmdlVG9IaXN0b3J5XG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldEVsZW1lbnRBbmRSYXdWYWx1ZShuZXdFbGVtZW50VmFsdWUsIHJhd1ZhbHVlID0gbnVsbCwgc2F2ZUNoYW5nZVRvSGlzdG9yeSA9IHRydWUpIHtcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChyYXdWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJhd1ZhbHVlID0gbmV3RWxlbWVudFZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzQm9vbGVhbihyYXdWYWx1ZSkpIHtcbiAgICAgICAgICAgIHNhdmVDaGFuZ2VUb0hpc3RvcnkgPSByYXdWYWx1ZTtcbiAgICAgICAgICAgIHJhd1ZhbHVlID0gbmV3RWxlbWVudFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9YWFggVGhlIG9yZGVyIGhlcmUgaXMgaW1wb3J0YW50IDsgdGhlIHZhbHVlIHNob3VsZCBmaXJzdCBiZSBzZXQgb24gdGhlIGVsZW1lbnQsIHRoZW4gYW5kIG9ubHkgdGhlbiB3ZSBzaG91bGQgdXBkYXRlIHRoZSByYXcgdmFsdWVcbiAgICAgICAgLy8gSW4gdGhlIGBzZXQoKWAgZnVuY3Rpb24sIHdlIG1ha2Ugc3VyZSB0byBjYWxsIGBfc2V0UmF3VmFsdWVgICphZnRlciogYHNldEVsZW1lbnRWYWx1ZWAgc28gdGhhdCBpZiBgX3NldFJhd1ZhbHVlYCBjYWxscyBhIGNhbGxiYWNrIHRoYXQgbW9kaWZ5IHRoZSBgcmF3VmFsdWVgLCB0aGVuIHRoZSBuZXcgdmFsdWUgaXMgc2V0IGNvcnJlY3RseSAoYWZ0ZXIgYHNldEVsZW1lbnRWYWx1ZWAgYnJpZWZseSBzZXQgaXRzIHZhbHVlIGZpcnN0KVxuICAgICAgICB0aGlzLl9zZXRFbGVtZW50VmFsdWUobmV3RWxlbWVudFZhbHVlKTtcbiAgICAgICAgdGhpcy5fc2V0UmF3VmFsdWUocmF3VmFsdWUsIHNhdmVDaGFuZ2VUb0hpc3RvcnkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbXVsdGlwbGllZCByYXcgdmFsdWUgd2l0aCB0aGUgYHJhd1ZhbHVlRGl2aXNvcmAuXG4gICAgICogVGhpcyBpcyB1c2VkIHRvIGRpc3BsYXkgZGlmZmVyZW50IHZhbHVlcyBiZXR3ZWVuIHRoZSByYXcgYW5kIGZvcm1hdHRlZCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8bnVsbH0gcmF3VmFsdWUgVGhlIG51bWVyaWMgdmFsdWUgYXMgdW5kZXJzdG9vZCBieSBKYXZhc2NyaXB0IGxpa2UgYSBgTnVtYmVyYFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8c3RyaW5nfG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0UmF3VmFsdWVUb0Zvcm1hdChyYXdWYWx1ZSkge1xuICAgICAgICBsZXQgcmF3VmFsdWVGb3JUaGVFbGVtZW50VmFsdWU7XG4gICAgICAgIGlmICgoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbCh0aGlzLnNldHRpbmdzLnJhd1ZhbHVlRGl2aXNvcikgJiYgdGhpcy5zZXR0aW5ncy5yYXdWYWx1ZURpdmlzb3IgIT09IDApICYmIC8vIE9ubHkgbXVsdGlwbHkgaWYgdGhlIGByYXdWYWx1ZURpdmlzb3JgIG9wdGlvbiBpcyBzZXRcbiAgICAgICAgICAgIHJhd1ZhbHVlICE9PSAnJyAmJiByYXdWYWx1ZSAhPT0gbnVsbCkgeyAvLyBEbyBub3QgbW9kaWZ5IHRoZSBgcmF3VmFsdWVgIGlmIGl0J3MgYW4gZW1wdHkgc3RyaW5nIG9yIG51bGxcbiAgICAgICAgICAgIC8vICF0aGlzLl9pc1VzZXJNYW51YWxseUVkaXRpbmdUaGVWYWx1ZSgpKSB7IC8vIElmIHRoZSB1c2VyIGlzIE5PVCBtYW51YWxseSBjaGFuZ2luZyB0aGUgZWxlbWVudCB2YWx1ZSwgYnV0IHRoYXQgaXMgZG9uZSBwcm9ncmFtbWF0aWNhbGx5XG4gICAgICAgICAgICByYXdWYWx1ZUZvclRoZUVsZW1lbnRWYWx1ZSA9IHJhd1ZhbHVlICogdGhpcy5zZXR0aW5ncy5yYXdWYWx1ZURpdmlzb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYXdWYWx1ZUZvclRoZUVsZW1lbnRWYWx1ZSA9IHJhd1ZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJhd1ZhbHVlRm9yVGhlRWxlbWVudFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBoYXMgYSBjb3JyZXNwb25kaW5nIGtleSBpbiB0aGUgYHZhbHVlc1RvU3RyaW5nc2Agb3B0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgc3VjaCBhIGtleSBpcyBmb3VuZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGVja1ZhbHVlc1RvU3RyaW5ncyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQXV0b051bWVyaWNIZWxwZXIuaXNJbkFycmF5KFN0cmluZyh2YWx1ZSksIHRoaXMudmFsdWVzVG9TdHJpbmdzS2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgdXNlciBpcyBjdXJyZW50bHkgbW9kaWZ5aW5nIHRoZSBlbGVtZW50IHZhbHVlIG1hbnVhbGx5LlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNVc2VyTWFudWFsbHlFZGl0aW5nVGhlVmFsdWUoKSB7XG4gICAgICAgIC8vIHJldHVybiAodGhpcy5pc0ZvY3VzZWQgJiYgdGhpcy5pc0VkaXRpbmcpIHx8IHRoaXMuaXNXaGVlbEV2ZW50IHx8IHRoaXMuaXNEcm9wRXZlbnQ7XG4gICAgICAgIHJldHVybiAodGhpcy5pc0ZvY3VzZWQgJiYgdGhpcy5pc0VkaXRpbmcpIHx8IHRoaXMuaXNEcm9wRXZlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZnVuY3Rpb24gdXNpbmcgdGhlIGdpdmVuIHJlc3VsdCBhcyBpdHMgZmlyc3QgcGFyYW1ldGVyLCBhbmQgdGhlIEF1dG9OdW1lcmljIG9iamVjdCBhcyBpdHMgc2Vjb25kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfEFycmF5fG51bGx9IHJlc3VsdFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258bnVsbH0gY2FsbGJhY2sgSWYgYSBjYWxsYmFjayBpcyBwYXNzZWQsIHRoZW4gdGhlIHJlc3VsdCBpcyBwYXNzZWQgdG8gaXQgYXMgaXRzIGZpcnN0IGFyZ3VtZW50LCBhbmQgdGhlIEF1dG9OdW1lcmljIG9iamVjdCBoYXMgaXRzIHNlY29uZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2V4ZWN1dGVDYWxsYmFjayhyZXN1bHQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKGNhbGxiYWNrKSAmJiBBdXRvTnVtZXJpY0hlbHBlci5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsaWFzIG9mIHRoZSBgZ2V0TnVtZXJpY1N0cmluZygpYCBmdW5jdGlvbi5cbiAgICAgKiBEZXZlbG9wZXJzIHNob3VsZCB1c2Ugb25lIG9mIHRoZSBtb3JlIGV4cGxpY2l0IGZ1bmN0aW9uIG5hbWVzIHRvIGdldCB3aGF0IHRoZXkgd2FudCA6XG4gICAgICogLSBhIG51bWVyaWMgc3RyaW5nIDogYGdldE51bWVyaWNTdHJpbmcoKWBcbiAgICAgKiAtIGEgZm9ybWF0dGVkIHN0cmluZyA6IGBnZXRGb3JtYXR0ZWQoKWBcbiAgICAgKiAtIGEgbnVtYmVyIDogYGdldE51bWJlcigpYCwgb3JcbiAgICAgKiAtIGEgbG9jYWxpemVkIG51bWVyaWMgc3RyaW5nIDogYGdldExvY2FsaXplZCgpYFxuICAgICAqXG4gICAgICogQHVzYWdlIGFuRWxlbWVudC5nZXQoKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258bnVsbH0gY2FsbGJhY2sgSWYgYSBjYWxsYmFjayBpcyBwYXNzZWQsIHRoZW4gdGhlIHJlc3VsdCBpcyBwYXNzZWQgdG8gaXQgYXMgaXRzIGZpcnN0IGFyZ3VtZW50LCBhbmQgdGhlIEF1dG9OdW1lcmljIG9iamVjdCBoYXMgaXRzIHNlY29uZFxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgZ2V0KGNhbGxiYWNrID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1lcmljU3RyaW5nKGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHVuZm9ybWF0dGVkIHZhbHVlIGFzIGEgc3RyaW5nLlxuICAgICAqIFRoaXMgY2FuIGFsc28gcmV0dXJuIGBudWxsYCBpZiBgcmF3VmFsdWVgIGlzIG51bGwuXG4gICAgICpcbiAgICAgKiBAdXNhZ2UgYW5FbGVtZW50LmdldE51bWVyaWNTdHJpbmcoKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258bnVsbH0gY2FsbGJhY2sgSWYgYSBjYWxsYmFjayBpcyBwYXNzZWQsIHRoZW4gdGhlIHJlc3VsdCBpcyBwYXNzZWQgdG8gaXQgYXMgaXRzIGZpcnN0IGFyZ3VtZW50LCBhbmQgdGhlIEF1dG9OdW1lcmljIG9iamVjdCBoYXMgaXRzIHNlY29uZFxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIGdldE51bWVyaWNTdHJpbmcoY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bGwodGhpcy5yYXdWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBbHdheXMgcmV0dXJuIGEgbnVtZXJpYyBzdHJpbmdcbiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgc3RhdGVtZW50IGdldHMgcmlkIG9mIHRoZSB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgZGVjaW1hbCBwbGFjZXMgc2luY2UgdGhlIGN1cnJlbnQgbWV0aG9kIGRvZXMgbm90IHBhZCBkZWNpbWFsc1xuICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNIZWxwZXIudHJpbVBhZGRlZFplcm9zRnJvbURlY2ltYWxQbGFjZXModGhpcy5yYXdWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9leGVjdXRlQ2FsbGJhY2socmVzdWx0LCBjYWxsYmFjayk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgZm9ybWF0dGVkIHZhbHVlIG9mIHRoZSBBdXRvTnVtZXJpYyBlbGVtZW50IGFzIGEgc3RyaW5nXG4gICAgICpcbiAgICAgKiBAdXNhZ2UgYW5FbGVtZW50LmdldEZvcm1hdHRlZCgpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG51bGx9IGNhbGxiYWNrIElmIGEgY2FsbGJhY2sgaXMgcGFzc2VkLCB0aGVuIHRoZSByZXN1bHQgaXMgcGFzc2VkIHRvIGl0IGFzIGl0cyBmaXJzdCBhcmd1bWVudCwgYW5kIHRoZSBBdXRvTnVtZXJpYyBvYmplY3QgaGFzIGl0cyBzZWNvbmRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Rm9ybWF0dGVkKGNhbGxiYWNrID0gbnVsbCkge1xuICAgICAgICBpZiAoISgndmFsdWUnIGluIHRoaXMuZG9tRWxlbWVudCB8fCAndGV4dENvbnRlbnQnIGluIHRoaXMuZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBgLnZhbHVlYCBvciBgLnRleHRDb250ZW50JyBleGlzdHMgYmVmb3JlIHRyeWluZyB0byBhY2Nlc3MgdGhvc2UgcHJvcGVydGllc1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcignVW5hYmxlIHRvIGdldCB0aGUgZm9ybWF0dGVkIHN0cmluZyBmcm9tIHRoZSBlbGVtZW50LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX2V4ZWN1dGVDYWxsYmFjayhyZXN1bHQsIGNhbGxiYWNrKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZWxlbWVudCB1bmZvcm1hdHRlZCB2YWx1ZSBhcyBhIHJlYWwgSmF2YXNjcmlwdCBudW1iZXIuXG4gICAgICogV2FybmluZzogVGhpcyBjYW4gbGVhZCB0byBwcmVjaXNpb24gcHJvYmxlbXMgd2l0aCBiaWcgbnVtYmVycyB0aGF0IHNob3VsZCBiZSBzdG9yZWQgYXMgc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEB1c2FnZSBhbkVsZW1lbnQuZ2V0TnVtYmVyKClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258bnVsbH0gY2FsbGJhY2sgSWYgYSBjYWxsYmFjayBpcyBwYXNzZWQsIHRoZW4gdGhlIHJlc3VsdCBpcyBwYXNzZWQgdG8gaXQgYXMgaXRzIGZpcnN0IGFyZ3VtZW50LCBhbmQgdGhlIEF1dG9OdW1lcmljIG9iamVjdCBoYXMgaXRzIHNlY29uZFxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcnxudWxsfVxuICAgICAqL1xuICAgIGdldE51bWJlcihjYWxsYmFjayA9IG51bGwpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKHRoaXMucmF3VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNvbnN0cnVjdG9yLl90b0xvY2FsZSh0aGlzLmdldE51bWVyaWNTdHJpbmcoKSwgJ251bWJlcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZXhlY3V0ZUNhbGxiYWNrKHJlc3VsdCwgY2FsbGJhY2spO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdW5mb3JtYXR0ZWQgdmFsdWUsIGJ1dCBmb2xsb3dpbmcgdGhlIGBvdXRwdXRGb3JtYXRgIHNldHRpbmcsIHdoaWNoIG1lYW5zIHRoZSBvdXRwdXQgY2FuIGVpdGhlciBiZSA6XG4gICAgICogLSBhIHN0cmluZyAodGhhdCBjb3VsZCBvciBjb3VsZCBub3QgcmVwcmVzZW50IGEgbnVtYmVyIChpZS4gXCIxMjM0NSw2Ny1cIikpLCBvclxuICAgICAqIC0gYSBwbGFpbiBudW1iZXIgKGlmIHRoZSBzZXR0aW5nICdudW1iZXInIGlzIHVzZWQpLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCB0aGUgcmV0dXJuZWQgdmFsdWVzIGFyZSBhbiBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZC5cbiAgICAgKiBDaGVjayB0aGUgXCJvdXRwdXRGb3JtYXRcIiBvcHRpb24gZGVmaW5pdGlvbiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHVzYWdlIGFuRWxlbWVudC5nZXRMb2NhbGl6ZWQoKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVsbHxzdHJpbmd8ZnVuY3Rpb259IGZvcmNlZE91dHB1dEZvcm1hdCBJZiBzZXQgdG8gc29tZXRoaW5nIGRpZmZlcmVudCB0aGFuIGBudWxsYCwgdGhlbiB0aGlzIGlzIHVzZWQgYXMgYW4gb3ZlcnJpZGluZyBvdXRwdXRGb3JtYXQgb3B0aW9uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbnxudWxsfSBjYWxsYmFjayBJZiBhIGNhbGxiYWNrIGlzIHBhc3NlZCwgdGhlbiB0aGUgcmVzdWx0IGlzIHBhc3NlZCB0byBpdCBhcyBpdHMgZmlyc3QgYXJndW1lbnQsIGFuZCB0aGUgQXV0b051bWVyaWMgb2JqZWN0IGhhcyBpdHMgc2Vjb25kXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRMb2NhbGl6ZWQoZm9yY2VkT3V0cHV0Rm9ybWF0ID0gbnVsbCwgY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgICAgIC8vIEZpcnN0LCBjaGVjayBpZiBvbmx5IGEgY2FsbGJhY2sgaGFzIGJlZW4gcGFzc2VkLCBhbmQgaWYgc28sIHNhbml0aXplIHRoZSBwYXJhbWV0ZXJzXG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc0Z1bmN0aW9uKGZvcmNlZE91dHB1dEZvcm1hdCkgJiYgQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBmb3JjZWRPdXRwdXRGb3JtYXQ7XG4gICAgICAgICAgICBmb3JjZWRPdXRwdXRGb3JtYXQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlbiBnZXQgdGhlIGxvY2FsaXplZCB2YWx1ZVxuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc0VtcHR5U3RyaW5nKHRoaXMucmF3VmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSGVyZSBJIHVzZSBgdGhpcy5yYXdWYWx1ZWAgaW5zdGVhZCBvZiBgdGhpcy5nZXROdW1lcmljU3RyaW5nKClgIHNpbmNlIHRoZSBjdXJyZW50IGlucHV0IHZhbHVlIGNvdWxkIGJlIHVuZm9ybWF0dGVkIHdpdGggYSBsb2NhbGl6YXRpb24gKGllLiAnMTIzNDU2Nyw4OS0nKS5cbiAgICAgICAgICAgIC8vIEkgYWxzbyBjb252ZXJ0IHRoZSByYXdWYWx1ZSB0byBhIG51bWJlciwgdGhlbiBiYWNrIHRvIGEgc3RyaW5nIGluIG9yZGVyIHRvIGRyb3AgdGhlIGRlY2ltYWwgcGFydCBpZiB0aGUgcmF3VmFsdWUgaXMgYW4gaW50ZWdlci5cbiAgICAgICAgICAgIHZhbHVlID0gJycrTnVtYmVyKHRoaXMucmF3VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSAnJyAmJiBOdW1iZXIodmFsdWUpID09PSAwICYmIHRoaXMuc2V0dGluZ3MubGVhZGluZ1plcm8gIT09IEF1dG9OdW1lcmljLm9wdGlvbnMubGVhZGluZ1plcm8ua2VlcCkge1xuICAgICAgICAgICAgdmFsdWUgPSAnMCc7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3V0cHV0Rm9ybWF0VG9Vc2U7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bGwoZm9yY2VkT3V0cHV0Rm9ybWF0KSkge1xuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0VG9Vc2UgPSB0aGlzLnNldHRpbmdzLm91dHB1dEZvcm1hdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdFRvVXNlID0gZm9yY2VkT3V0cHV0Rm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jb25zdHJ1Y3Rvci5fdG9Mb2NhbGUodmFsdWUsIG91dHB1dEZvcm1hdFRvVXNlKTtcbiAgICAgICAgdGhpcy5fZXhlY3V0ZUNhbGxiYWNrKHJlc3VsdCwgY2FsbGJhY2spO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yY2UgdGhlIGVsZW1lbnQgdG8gcmVmb3JtYXQgaXRzIHZhbHVlIGFnYWluIChqdXN0IGluIGNhc2UgdGhlIGZvcm1hdHRpbmcgaGFzIGJlZW4gbG9zdCkuXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCByaWdodCBhZnRlciBhIGZvcm0gc3VibWlzc2lvbiBmb3IgaW5zdGFuY2UgKGFmdGVyIGEgcHJldmlvdXMgY2FsbCB0byBgdW5mb3JtYXRgKS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIGFuRWxlbWVudC5yZWZvcm1hdCgpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgcmVmb3JtYXQoKSB7XG4gICAgICAgIC8vIGB0aGlzLnJhd1ZhbHVlYCBpcyB1c2VkIGluc3RlYWQgb2YgYHRoaXMuZG9tRWxlbWVudC52YWx1ZWAgYmVjYXVzZSB3aGVuIHRoZSBjb250ZW50IGlzIGB1bmZvcm1hdExvY2FsaXplZGAsIGl0IGNhbiBiZWNvbWUgYSBzdHJpbmcgdGhhdCBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgbnVtYmVyIGVhc2lseVxuICAgICAgICB0aGlzLnNldCh0aGlzLnJhd1ZhbHVlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGZvcm1hdHRpbmcgYW5kIGtlZXAgb25seSB0aGUgcmF3IHVuZm9ybWF0dGVkIHZhbHVlIGluIHRoZSBlbGVtZW50IChhcyBhIG51bWVyaWNTdHJpbmcpXG4gICAgICogTm90ZTogdGhpcyBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZSBwcmV2aW91cyAndW5TZXQoKScgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHZhbHVlcyBhcmUgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5ncyAoaWUuIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiksIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZC5cbiAgICAgKiBAZXhhbXBsZSBhbkVsZW1lbnQudW5mb3JtYXQoKVxuICAgICAqXG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqL1xuICAgIHVuZm9ybWF0KCkge1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50VmFsdWUodGhpcy5nZXROdW1lcmljU3RyaW5nKCkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgZm9ybWF0dGluZyBhbmQga2VlcCBvbmx5IHRoZSBsb2NhbGl6ZWQgdW5mb3JtYXR0ZWQgdmFsdWUgaW4gdGhlIGVsZW1lbnQsIHdpdGggdGhlIG9wdGlvbiB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBvdXRwdXRGb3JtYXQgaWYgbmVlZGVkXG4gICAgICpcbiAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiwgb3IgZXZlbiBwbGFpbiBudW1iZXJzLlxuICAgICAqIFRha2UgYSBsb29rIGF0IHRoZSBgb3V0cHV0Rm9ybWF0YCBvcHRpb24gZGVmaW5pdGlvbiBpbiB0aGUgZGVmYXVsdCBzZXR0aW5ncyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudWxsfHN0cmluZ30gZm9yY2VkT3V0cHV0Rm9ybWF0IElmIHNldCB0byBzb21ldGhpbmcgZGlmZmVyZW50IHRoYW4gYG51bGxgLCB0aGVuIHRoaXMgaXMgdXNlZCBhcyBhbiBvdmVycmlkaW5nIG91dHB1dEZvcm1hdCBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgdW5mb3JtYXRMb2NhbGl6ZWQoZm9yY2VkT3V0cHV0Rm9ybWF0ID0gbnVsbCkge1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50VmFsdWUodGhpcy5nZXRMb2NhbGl6ZWQoZm9yY2VkT3V0cHV0Rm9ybWF0KSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgY3VycmVudCB2YWx1ZSBpcyB0aGUgc2FtZSBhcyB3aGVuIHRoZSBlbGVtZW50IGdvdCBpbml0aWFsaXplZC5cbiAgICAgKiBOb3RlOiBCeSBkZWZhdWx0LCB0aGlzIHJldHVybnMgYHRydWVgIGlmIHRoZSByYXcgdW5mb3JtYXR0ZWQgdmFsdWUgaXMgc3RpbGwgdGhlIHNhbWUgZXZlbiBpZiB0aGUgZm9ybWF0dGVkIG9uZSBoYXMgY2hhbmdlZCAoZHVlIHRvIGEgY29uZmlndXJhdGlvbiB1cGRhdGUgZm9yIGluc3RhbmNlKS5cbiAgICAgKiBJbiBvcmRlciB0byB0ZXN0IGlmIHRoZSBmb3JtYXR0ZWQgdmFsdWUgaXMgdGhlIHNhbWUgKHdoaWNoIG1lYW5zIG5laXRoZXIgdGhlIHJhdyB2YWx1ZSBub3IgdGhlIHNldHRpbmdzIGhhdmUgYmVlbiBjaGFuZ2VkKSwgdGhlbiB5b3UgbXVzdCBwYXNzIGBmYWxzZWAgYXMgaXRzIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjaGVja09ubHlSYXdWYWx1ZSBJZiBzZXQgdG8gYHRydWVgLCB0aGUgcHJpc3RpbmUgdmFsdWUgaXMgZG9uZSBvbiB0aGUgcmF3IHVuZm9ybWF0dGVkIHZhbHVlLCBub3QgdGhlIGZvcm1hdHRlZCBvbmUuICBJZiBzZXQgdG8gYGZhbHNlYCwgdGhpcyBhbHNvIGNoZWNrcyB0aGF0IHRoZSBmb3JtYXR0ZWQgdmFsdWUgaGFzbid0IGNoYW5nZWQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNQcmlzdGluZShjaGVja09ubHlSYXdWYWx1ZSA9IHRydWUpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKGNoZWNrT25seVJhd1ZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmluaXRpYWxWYWx1ZSA9PT0gdGhpcy5nZXROdW1lcmljU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmluaXRpYWxWYWx1ZUh0bWxBdHRyaWJ1dGUgPT09IHRoaXMuZ2V0Rm9ybWF0dGVkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCB0aGUgZm9ybWF0dGVkIGVsZW1lbnQgY29udGVudCwgYmFzZWQgb24gdGhlIGBzZWxlY3ROdW1iZXJPbmx5YCBvcHRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBzZWxlY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNlbGVjdE51bWJlck9ubHkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0TnVtYmVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0U2VsZWN0QWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgdGhlIHdob2xlIGVsZW1lbnQgY29udGVudCAoaW5jbHVkaW5nIHRoZSBjdXJyZW5jeSBzeW1ib2wpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RlZmF1bHRTZWxlY3RBbGwoKSB7XG4gICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRTZWxlY3Rpb24odGhpcy5kb21FbGVtZW50LCAwLCBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KS5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBvbmx5IHRoZSBudW1iZXJzIGluIHRoZSBmb3JtYXR0ZWQgZWxlbWVudCBjb250ZW50LCBsZWF2aW5nIG91dCB0aGUgY3VycmVuY3kgc3ltYm9sLCB3aGF0ZXZlciB0aGUgdmFsdWUgb2YgdGhlIGBzZWxlY3ROdW1iZXJPbmx5YCBvcHRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBzZWxlY3ROdW1iZXIoKSB7XG4gICAgICAgIC8vVE9ETyBNYWtlIHN1cmUgdGhlIHNlbGVjdGlvbiBpcyBvayB3aGVuIHNob3dQb3NpdGl2ZVNpZ24gaXMgc2V0IHRvIGB0cnVlYCAoc2VsZWN0IHRoZSBuZWdhdGl2ZSBzaWduLCBidXQgbm90IHRoZSBwb3NpdGl2ZSBvbmUpXG4gICAgICAgIGNvbnN0IHVuZm9ybWF0dGVkVmFsdWUgPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KTtcbiAgICAgICAgY29uc3QgdmFsdWVMZW4gPSB1bmZvcm1hdHRlZFZhbHVlLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY3VycmVuY3lTeW1ib2xTaXplID0gdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID0gdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudDtcbiAgICAgICAgY29uc3QgbmVnTGVuID0gKCFBdXRvTnVtZXJpY0hlbHBlci5pc05lZ2F0aXZlKHVuZm9ybWF0dGVkVmFsdWUpKT8wOjE7XG4gICAgICAgIGNvbnN0IHN1ZmZpeFRleHRMZW4gPSB0aGlzLnNldHRpbmdzLnN1ZmZpeFRleHQubGVuZ3RoO1xuXG4gICAgICAgIGxldCBzdGFydDtcbiAgICAgICAgaWYgKGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnN1ZmZpeCkge1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQubGVmdCAmJlxuICAgICAgICAgICAgbmVnTGVuID09PSAxICYmIGN1cnJlbmN5U3ltYm9sU2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gY3VycmVuY3lTeW1ib2xTaXplICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gY3VycmVuY3lTeW1ib2xTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGVuZDtcbiAgICAgICAgaWYgKGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnByZWZpeCkge1xuICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSBzdWZmaXhUZXh0TGVuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LmxlZnQ6XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IHZhbHVlTGVuIC0gKHN1ZmZpeFRleHRMZW4gKyBjdXJyZW5jeVN5bWJvbFNpemUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW5jeVN5bWJvbFNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIChjdXJyZW5jeVN5bWJvbFNpemUgKyBuZWdMZW4gKyBzdWZmaXhUZXh0TGVuKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHZhbHVlTGVuIC0gKGN1cnJlbmN5U3ltYm9sU2l6ZSArIHN1ZmZpeFRleHRMZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIChjdXJyZW5jeVN5bWJvbFNpemUgKyBzdWZmaXhUZXh0TGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRTZWxlY3Rpb24odGhpcy5kb21FbGVtZW50LCBzdGFydCwgZW5kKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3Qgb25seSB0aGUgaW50ZWdlciBwYXJ0IGluIHRoZSBmb3JtYXR0ZWQgZWxlbWVudCBjb250ZW50LCB3aGF0ZXZlciB0aGUgdmFsdWUgb2YgYHNlbGVjdE51bWJlck9ubHlgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgc2VsZWN0SW50ZWdlcigpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgY29uc3QgaXNQb3NpdGl2ZSA9IHRoaXMucmF3VmFsdWUgPj0gMDtcblxuICAgICAgICAvLyBOZWdhdGl2ZSBvciBwb3NpdGl2ZSBzaWduLCBpZiBhbnlcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQucHJlZml4IHx8XG4gICAgICAgICAgICAodGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5zdWZmaXggJiZcbiAgICAgICAgICAgICh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnByZWZpeCB8fFxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5ub25lKSkpIHtcbiAgICAgICAgICAgIGlmICgodGhpcy5zZXR0aW5ncy5zaG93UG9zaXRpdmVTaWduICYmIGlzUG9zaXRpdmUpIHx8ICAvLyBUaGlzIG9ubHkgZXhjbHVkZSB0aGUgcG9zaXRpdmUgc2lnbiBmcm9tIGJlaW5nIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgKCFpc1Bvc2l0aXZlICYmIHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQucHJlZml4ICYmIHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQubGVmdCkpIHsgLy8gQW5kIHRoaXMgZXhjbHVkZSB0aGUgbmVnYXRpdmUgc2lnbiBmcm9tIGJlaW5nIHNlbGVjdGVkIGluIHRoaXMgc3BlY2lhbCBjYXNlIDogJy3igqwgMS4yMzQsNTdzdWZmaXhUZXh0J1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3VycmVuY3kgc3ltYm9sXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnByZWZpeCkge1xuICAgICAgICAgICAgc3RhcnQgPSBzdGFydCArIHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzZWxlY3Rpb24gZW5kIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IGVsZW1lbnRWYWx1ZSA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZSh0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICBsZXQgZW5kID0gZWxlbWVudFZhbHVlLmluZGV4T2YodGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIE5vIGRlY2ltYWwgY2hhcmFjdGVyIGZvdW5kXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5zdWZmaXgpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBlbGVtZW50VmFsdWUubGVuZ3RoIC0gdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbC5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IGVsZW1lbnRWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRyYWlsaW5nIG5lZ2F0aXZlIHNpZ25cbiAgICAgICAgICAgIGlmICghaXNQb3NpdGl2ZSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnN1ZmZpeCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQuc3VmZml4KSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IGVuZCAtIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEF2b2lkIHNlbGVjdGluZyB0aGUgc3VmZml4IHRlc3RcbiAgICAgICAgICAgIGVuZCA9IGVuZCAtIHRoaXMuc2V0dGluZ3Muc3VmZml4VGV4dC5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5zZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMuZG9tRWxlbWVudCwgc3RhcnQsIGVuZCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IG9ubHkgdGhlIGRlY2ltYWwgcGFydCBpbiB0aGUgZm9ybWF0dGVkIGVsZW1lbnQgY29udGVudCwgd2hhdGV2ZXIgdGhlIHZhbHVlIG9mIGBzZWxlY3ROdW1iZXJPbmx5YFxuICAgICAqIE11bHRpcGxlIGNhc2VzIGFyZSBwb3NzaWJsZSA6XG4gICAgICogKzEuMjM0LDU3c3VmZml4VGV4dFxuICAgICAqXG4gICAgICog4oKsICsxLjIzNCw1N3N1ZmZpeFRleHRcbiAgICAgKiAr4oKsIDEuMjM0LDU3c3VmZml4VGV4dFxuICAgICAqIOKCrCAxLjIzNCw1NytzdWZmaXhUZXh0XG4gICAgICpcbiAgICAgKiAxLjIzNCw1Nysg4oKsc3VmZml4VGV4dFxuICAgICAqIDEuMjM0LDU3IOKCrCtzdWZmaXhUZXh0XG4gICAgICogKzEuMjM0LDU3IOKCrHN1ZmZpeFRleHRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBzZWxlY3REZWNpbWFsKCkge1xuICAgICAgICBsZXQgc3RhcnQgPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KS5pbmRleE9mKHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgIGxldCBlbmQ7XG5cbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgICAgLy8gVGhlIGRlY2ltYWwgY2hhcmFjdGVyIGhhcyBub3QgYmVlbiBmb3VuZCwgd2UgZGVzZWxlY3QgYWxsXG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICBlbmQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQSBkZWNpbWFsIGNoYXJhY3RlciBoYXMgYmVlbiBmb3VuZFxuICAgICAgICAgICAgc3RhcnQgPSBzdGFydCArIDE7IC8vIFdlIGFkZCAxIHRvIGV4Y2x1ZGUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGZyb20gdGhlIHNlbGVjdGlvblxuXG4gICAgICAgICAgICBsZXQgZGVjaW1hbENvdW50O1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbENvdW50ID0gdGhpcy5zZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWNpbWFsQ291bnQgPSB0aGlzLnNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uQmx1cjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZW5kID0gc3RhcnQgKyBOdW1iZXIoZGVjaW1hbENvdW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRTZWxlY3Rpb24odGhpcy5kb21FbGVtZW50LCBzdGFydCwgZW5kKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIERPTSBlbGVtZW50IHJlZmVyZW5jZSBvZiB0aGUgYXV0b051bWVyaWMtbWFuYWdlZCBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8SFRNTElucHV0RWxlbWVudH1cbiAgICAgKi9cbiAgICBub2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb21FbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgRE9NIGVsZW1lbnQgcmVmZXJlbmNlIG9mIHRoZSBwYXJlbnQgbm9kZSBvZiB0aGUgYXV0b051bWVyaWMtbWFuYWdlZCBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8SFRNTElucHV0RWxlbWVudHxOb2RlfVxuICAgICAqL1xuICAgIHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tRWxlbWVudC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGFjaCB0aGUgY3VycmVudCBBdXRvTnVtZXJpYyBlbGVtZW50IGZyb20gdGhlIHNoYXJlZCBsb2NhbCAnaW5pdCcgbGlzdC5cbiAgICAgKiBUaGlzIG1lYW5zIGFueSBjaGFuZ2VzIG1hZGUgb24gdGhhdCBsb2NhbCBzaGFyZWQgbGlzdCB3aWxsIG5vdCBiZSB0cmFuc21pdHRlZCB0byB0aGF0IGVsZW1lbnQgYW55bW9yZS5cbiAgICAgKiBOb3RlIDogVGhlIHVzZXIgY2FuIHByb3ZpZGUgYW5vdGhlciBBdXRvTnVtZXJpYyBlbGVtZW50LCBhbmQgZGV0YWNoIHRoaXMgb25lIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY30gb3RoZXJBbkVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgZGV0YWNoKG90aGVyQW5FbGVtZW50ID0gbnVsbCkgeyAvL0ZJWE1FIHRlc3QgdGhpc1xuICAgICAgICBsZXQgZG9tRWxlbWVudFRvRGV0YWNoO1xuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvdGhlckFuRWxlbWVudCkpIHtcbiAgICAgICAgICAgIGRvbUVsZW1lbnRUb0RldGFjaCA9IG90aGVyQW5FbGVtZW50Lm5vZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbUVsZW1lbnRUb0RldGFjaCA9IHRoaXMuZG9tRWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbW92ZUZyb21Mb2NhbExpc3QoZG9tRWxlbWVudFRvRGV0YWNoKTsgLy9GSVhNRSBXaGF0IGhhcHBlbnMgaWYgdGhlIHNlbGVjdGVkIGRvbSBlbGVtZW50IGRvZXMgbm90IGV4aXN0IGluIHRoZSBsaXN0P1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCB0aGUgZ2l2ZW4gQXV0b051bWVyaWMgZWxlbWVudCB0byB0aGUgc2hhcmVkIGxvY2FsICdpbml0JyBsaXN0LlxuICAgICAqIFdoZW4gZG9pbmcgdGhhdCwgYnkgZGVmYXVsdCB0aGUgRE9NIGNvbnRlbnQgaXMgbGVmdCB1bnRvdWNoZWQuXG4gICAgICogVGhlIHVzZXIgY2FuIGZvcmNlIGEgcmVmb3JtYXQgd2l0aCB0aGUgbmV3IHNoYXJlZCBsaXN0IG9wdGlvbnMgYnkgcGFzc2luZyBhIHNlY29uZCBhcmd1bWVudCB0byBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljfSBvdGhlckFuRWxlbWVudFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVGb3JtYXRcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgYXR0YWNoKG90aGVyQW5FbGVtZW50LCByZUZvcm1hdCA9IHRydWUpIHsgLy9GSVhNRSB0ZXN0IHRoaXNcbiAgICAgICAgdGhpcy5fYWRkVG9Mb2NhbExpc3Qob3RoZXJBbkVsZW1lbnQubm9kZSgpKTsgLy9GSVhNRSBTaG91bGQgd2UgbWFrZSBzdXJlIHRoZSBlbGVtZW50IGlzIG5vdCBhbHJlYWR5IGluIHRoZSBsaXN0P1xuICAgICAgICBpZiAocmVGb3JtYXQpIHtcbiAgICAgICAgICAgIG90aGVyQW5FbGVtZW50LnVwZGF0ZSh0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCBhbmQgcmV0dXJuIHRoZSBnaXZlbiB2YWx1ZSwgb3Igc2V0IHRoZSBmb3JtYXR0ZWQgdmFsdWUgaW50byB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQgaWYgb25lIGlzIHBhc3NlZCBhcyBhbiBhcmd1bWVudC5cbiAgICAgKiBCeSBkZWZhdWx0LCB0aGlzIHVzZSB0aGUgY3VycmVudCBlbGVtZW50IHNldHRpbmdzLlxuICAgICAqIFRoZSB1c2VyIGNhbiBvdmVycmlkZSBhbnkgb3B0aW9uIG9mIGl0cyBjaG9vc2luZyBieSBwYXNzaW5nIGFuIG9wdGlvbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxIVE1MRWxlbWVudHxIVE1MSW5wdXRFbGVtZW50fSB2YWx1ZU9yRWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVsbHxvYmplY3R9IG9wdGlvbk92ZXJyaWRlXG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIGZvcm1hdE90aGVyKHZhbHVlT3JFbGVtZW50LCBvcHRpb25PdmVycmlkZSA9IG51bGwpIHsgLy9GSVhNRSB0ZXN0IHRoaXNcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdE9yVW5mb3JtYXRPdGhlcih0cnVlLCB2YWx1ZU9yRWxlbWVudCwgb3B0aW9uT3ZlcnJpZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVuZm9ybWF0IGFuZCByZXR1cm4gdGhlIHJhdyBudW1lcmljIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiB2YWx1ZSwgb3IgZGlyZWN0bHkgc2V0IHRoZSB1bmZvcm1hdHRlZCB2YWx1ZSBpbnRvIHRoZSBnaXZlbiBET00gZWxlbWVudCBpZiBvbmUgaXMgcGFzc2VkIGFzIGFuIGFyZ3VtZW50LlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgdXNlIHRoZSBjdXJyZW50IGVsZW1lbnQgc2V0dGluZ3MuXG4gICAgICogVGhlIHVzZXIgY2FuIG92ZXJyaWRlIGFueSBvcHRpb24gb2YgaXRzIGNob29zaW5nIGJ5IHBhc3NpbmcgYW4gb3B0aW9uIG9iamVjdC5cblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxFbGVtZW50fEhUTUxJbnB1dEVsZW1lbnR9IHN0cmluZ09yRWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVsbHxvYmplY3R9IG9wdGlvbk92ZXJyaWRlXG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHVuZm9ybWF0T3RoZXIoc3RyaW5nT3JFbGVtZW50LCBvcHRpb25PdmVycmlkZSA9IG51bGwpIHsgLy9GSVhNRSB0ZXN0IHRoaXNcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdE9yVW5mb3JtYXRPdGhlcihmYWxzZSwgc3RyaW5nT3JFbGVtZW50LCBvcHRpb25PdmVycmlkZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZWl0aGVyIGZvcm1hdCBvciB1bmZvcm1hdCB0aGUgdmFsdWUgb2YgYW5vdGhlciBlbGVtZW50LlxuICAgICAqXG4gICAgICogLSBGb3JtYXQgYW5kIHJldHVybiB0aGUgZ2l2ZW4gdmFsdWUsIG9yIHNldCB0aGUgZm9ybWF0dGVkIHZhbHVlIGludG8gdGhlIGdpdmVuIERPTSBlbGVtZW50IGlmIG9uZSBpcyBwYXNzZWQgYXMgYW4gYXJndW1lbnQuXG4gICAgICogLSBVbmZvcm1hdCBhbmQgcmV0dXJuIHRoZSByYXcgbnVtZXJpYyBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gdmFsdWUsIG9yIGRpcmVjdGx5IHNldCB0aGUgdW5mb3JtYXR0ZWQgdmFsdWUgaW50byB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQgaWYgb25lIGlzIHBhc3NlZCBhcyBhbiBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgdXNlIHRoZSBjdXJyZW50IGVsZW1lbnQgc2V0dGluZ3MuXG4gICAgICogVGhlIHVzZXIgY2FuIG92ZXJyaWRlIGFueSBvcHRpb24gb2YgaXRzIGNob29zaW5nIGJ5IHBhc3NpbmcgYW4gb3B0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNGb3JtYXR0aW5nIElmIHNldCB0byBgdHJ1ZWAsIHRoZW4gdGhlIG1ldGhvZCBmb3JtYXRzLCBvdGhlcndpc2UgaWYgc2V0IHRvIGBmYWxzZWAsIGl0IHVuZm9ybWF0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xIVE1MRWxlbWVudHxIVE1MSW5wdXRFbGVtZW50fSB2YWx1ZU9yU3RyaW5nT3JFbGVtZW50XG4gICAgICogQHBhcmFtIHtudWxsfG9iamVjdH0gb3B0aW9uT3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZm9ybWF0T3JVbmZvcm1hdE90aGVyKGlzRm9ybWF0dGluZywgdmFsdWVPclN0cmluZ09yRWxlbWVudCwgb3B0aW9uT3ZlcnJpZGUgPSBudWxsKSB7IC8vRklYTUUgdGVzdCB0aGlzXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHdhbnRzIHRvIG92ZXJyaWRlIHRoZSBjdXJyZW50IGVsZW1lbnQgc2V0dGluZ3MgdGVtcG9yYXJpbHlcbiAgICAgICAgbGV0IHNldHRpbmdzVG9Vc2U7XG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKG9wdGlvbk92ZXJyaWRlKSkge1xuICAgICAgICAgICAgc2V0dGluZ3NUb1VzZSA9IHRoaXMuX2Nsb25lQW5kTWVyZ2VTZXR0aW5ncyhvcHRpb25PdmVycmlkZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXR0aW5nc1RvVXNlID0gdGhpcy5zZXR0aW5ncztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZW4gdGhlIHVuZm9ybWF0dGluZyBpcyBkb25lLi4uXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc0VsZW1lbnQodmFsdWVPclN0cmluZ09yRWxlbWVudCkpIHtcbiAgICAgICAgICAgIC8vIC4uLmVpdGhlciBkaXJlY3RseSBvbiB0aGUgRE9NIGVsZW1lbnQgdmFsdWVcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRWYWx1ZSA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZSh2YWx1ZU9yU3RyaW5nT3JFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChpc0Zvcm1hdHRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBBdXRvTnVtZXJpYy5mb3JtYXQoZWxlbWVudFZhbHVlLCBzZXR0aW5nc1RvVXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljLnVuZm9ybWF0KGVsZW1lbnRWYWx1ZSwgc2V0dGluZ3NUb1VzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRWYWx1ZSh2YWx1ZU9yU3RyaW5nT3JFbGVtZW50LCByZXN1bHQpOyAvL1RPRE8gVXNlIGB1bmZvcm1hdEFuZFNldGAgYW5kIGBmb3JtYXRBbmRTZXRgaW5zdGVhZFxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC4uLm9yIG9uIHRoZSBnaXZlbiB2YWx1ZVxuICAgICAgICBpZiAoaXNGb3JtYXR0aW5nKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBBdXRvTnVtZXJpYy5mb3JtYXQodmFsdWVPclN0cmluZ09yRWxlbWVudCwgc2V0dGluZ3NUb1VzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBBdXRvTnVtZXJpYy51bmZvcm1hdCh2YWx1ZU9yU3RyaW5nT3JFbGVtZW50LCBzZXR0aW5nc1RvVXNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoZSBjdXJyZW50IEF1dG9OdW1lcmljIGVsZW1lbnQgc2V0dGluZ3MgdG8gaW5pdGlhbGl6ZSB0aGUgRE9NIGVsZW1lbnQocykgZ2l2ZW4gYXMgYSBwYXJhbWV0ZXIuXG4gICAgICogRG9pbmcgc28gd2lsbCAqbGluayogdGhlIEF1dG9OdW1lcmljIGVsZW1lbnRzIHRvZ2V0aGVyIHNpbmNlIHRoZXkgd2lsbCBzaGFyZSB0aGUgc2FtZSBsb2NhbCBBdXRvTnVtZXJpYyBlbGVtZW50IGxpc3QuXG4gICAgICogKGNmLiBwcm90b3R5cGUgcGF0dGVybiA6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Byb3RvdHlwZV9wYXR0ZXJuKVxuICAgICAqXG4gICAgICogWW91IGNhbiBgaW5pdGAgZWl0aGVyIGEgc2luZ2xlIERPTSBlbGVtZW50IChpbiB0aGF0IGNhc2UgYW4gQXV0b051bWVyaWMgb2JqZWN0IHdpbGwgYmUgcmV0dXJuZWQpLCBvciBhbiBhcnJheSBvZiBET00gZWxlbWVudHMgb3IgYSBzdHJpbmcgdGhhdCB3aWxsIGJlIHVzZWQgYXMgYSBDU1Mgc2VsZWN0b3IuIEluIHRoZSBsYXR0ZXIgY2FzZXMsIGFuIGFycmF5IG9mIEF1dG9OdW1lcmljIG9iamVjdHMgd2lsbCB0aGVuIGJlIHJldHVybmVkIChvciBhbiBlbXB0eSBhcnJheSBpZiBub3RoaW5nIGdldHMgc2VsZWN0ZWQgYnkgdGhlIENTUyBzZWxlY3RvcikuXG4gICAgICpcbiAgICAgKiBVc2UgY2FzZSA6IE9uY2UgeW91IGhhdmUgYW4gQXV0b051bWVyaWMgZWxlbWVudCBhbHJlYWR5IHNldHVwIGNvcnJlY3RseSB3aXRoIHRoZSByaWdodCBvcHRpb25zLCB5b3UgY2FuIHVzZSBpdCBhcyBtYW55IHRpbWVzIHlvdSB3YW50IHRvIGluaXRpYWxpemUgYXMgbWFueSBvdGhlciBET00gZWxlbWVudHMgYXMgbmVlZGVkLlxuICAgICAqIE5vdGUgOiB0aGlzIHdvcmtzIG9ubHkgb24gZWxlbWVudHMgdGhhdCBjYW4gYmUgbWFuYWdlZCBieSBhdXRvTnVtZXJpYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTElucHV0RWxlbWVudHxBcnJheTxIVE1MRWxlbWVudHxIVE1MSW5wdXRFbGVtZW50PnxzdHJpbmd9IGRvbUVsZW1lbnRPckFycmF5T3JTdHJpbmdcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGF0dGFjaGVkIElmIHNldCB0byBgZmFsc2VgLCB0aGVuIHRoZSBuZXdseSBnZW5lcmF0ZWQgQXV0b051bWVyaWMgZWxlbWVudCB3aWxsIG5vdCBzaGFyZSB0aGUgc2FtZSBsb2NhbCBlbGVtZW50IGxpc3RcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN8W0F1dG9OdW1lcmljXX1cbiAgICAgKi9cbiAgICBpbml0KGRvbUVsZW1lbnRPckFycmF5T3JTdHJpbmcsIGF0dGFjaGVkID0gdHJ1ZSkge1xuICAgICAgICBsZXQgcmV0dXJuQVNpbmdsZUF1dG9OdW1lcmljT2JqZWN0ID0gZmFsc2U7IC8vIEJ5IGRlZmF1bHQsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBhcnJheSBvZiBBdXRvTnVtZXJpYyBvYmplY3RzXG4gICAgICAgIGxldCBkb21FbGVtZW50c0FycmF5ID0gW107XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc1N0cmluZyhkb21FbGVtZW50T3JBcnJheU9yU3RyaW5nKSkge1xuICAgICAgICAgICAgZG9tRWxlbWVudHNBcnJheSA9IFsuLi4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChkb21FbGVtZW50T3JBcnJheU9yU3RyaW5nKV07IC8vIENvbnZlcnQgYSBOb2RlTGlzdCB0byBhbiBBcnJheVxuICAgICAgICB9IGVsc2UgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzRWxlbWVudChkb21FbGVtZW50T3JBcnJheU9yU3RyaW5nKSkge1xuICAgICAgICAgICAgZG9tRWxlbWVudHNBcnJheS5wdXNoKGRvbUVsZW1lbnRPckFycmF5T3JTdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuQVNpbmdsZUF1dG9OdW1lcmljT2JqZWN0ID0gdHJ1ZTsgLy8gU3BlY2lhbCBjYXNlIHdoZW4gb25seSBvbmUgRE9NIGVsZW1lbnQgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyXG4gICAgICAgIH0gZWxzZSBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNBcnJheShkb21FbGVtZW50T3JBcnJheU9yU3RyaW5nKSkge1xuICAgICAgICAgICAgZG9tRWxlbWVudHNBcnJheSA9IGRvbUVsZW1lbnRPckFycmF5T3JTdHJpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgZ2l2ZW4gcGFyYW1ldGVycyB0byB0aGUgJ2luaXQnIGZ1bmN0aW9uIGFyZSBpbnZhbGlkLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvbUVsZW1lbnRzQXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci53YXJuaW5nKGBObyB2YWxpZCBET00gZWxlbWVudHMgd2VyZSBnaXZlbiBoZW5jZSBubyBBdXRvTnVtZXJpYyBvYmplY3Qgd2VyZSBpbnN0YW50aWF0ZWQuYCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRMb2NhbExpc3QgPSB0aGlzLl9nZXRMb2NhbExpc3QoKTtcbiAgICAgICAgY29uc3QgYXV0b051bWVyaWNPYmplY3RzQXJyYXkgPSBbXTtcblxuICAgICAgICAvLyBJbnN0YW50aWF0ZSAoYW5kIGxpbmsgZGVwZW5kaW5nIG9uIGBhdHRhY2hlZGApIGVhY2ggQXV0b051bWVyaWMgb2JqZWN0c1xuICAgICAgICBkb21FbGVtZW50c0FycmF5LmZvckVhY2goZG9tRWxlbWVudCA9PiB7XG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBuZXcgQXV0b051bWVyaWMgZWxlbWVudFxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxDcmVhdGVMb2NhbExpc3RTZXR0aW5nID0gdGhpcy5zZXR0aW5ncy5jcmVhdGVMb2NhbExpc3Q7XG4gICAgICAgICAgICBpZiAoYXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUZW1wb3JhcnkgdmFyaWFibGUgdG8ga25vdyBpZiB3ZSBzaG91bGQgY3JlYXRlIHRoZSBsb2NhbCBsaXN0IGR1cmluZyB0aGUgaW5pdGlhbGl6YXRpb24gKHNpbmNlIHdlJ2xsIHJlbW92ZSBpdCBhZnRlcndhcmRzKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuY3JlYXRlTG9jYWxMaXN0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG5ld0F1dG9OdW1lcmljRWxlbWVudCA9ICBuZXcgQXV0b051bWVyaWMoZG9tRWxlbWVudCwgQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKGRvbUVsZW1lbnQpLCB0aGlzLnNldHRpbmdzKTtcblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBjb21tb24gc2hhcmVkIGxvY2FsIGxpc3QgaWYgbmVlZGVkXG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciB3YW50cyB0byBjcmVhdGUgYSBkZXRhY2hlZCBuZXcgQXV0b051bWVyaWMgZWxlbWVudCwgdGhlbiBza2lwIHRoZSBmb2xsb3dpbmcgc3RlcCB0aGF0IGJpbmQgdGhlIHR3byBlbGVtZW50cyB0b2dldGhlciBieSBkZWZhdWx0XG4gICAgICAgICAgICBpZiAoYXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICAvLyAxKSBTZXQgdGhlIGxvY2FsIGxpc3QgcmVmZXJlbmNlIHRvIHBvaW50IHRvIHRoZSBpbml0aWFsaXplcidzIG9uZVxuICAgICAgICAgICAgICAgIG5ld0F1dG9OdW1lcmljRWxlbWVudC5fc2V0TG9jYWxMaXN0KGN1cnJlbnRMb2NhbExpc3QpO1xuXG4gICAgICAgICAgICAgICAgLy8gMikgQWRkIHRoZSBuZXcgZWxlbWVudCB0byB0aGF0IGV4aXN0aW5nIGxpc3RcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUb0xvY2FsTGlzdChkb21FbGVtZW50LCBuZXdBdXRvTnVtZXJpY0VsZW1lbnQpOyAvLyBIZXJlIHdlIHVzZSB0aGUgKm5ldyogQXV0b051bWVyaWMgb2JqZWN0IHJlZmVyZW5jZSB0byBhZGQgdG8gdGhlIGxvY2FsIGxpc3QsIHNpbmNlIHdlJ2xsIG5lZWQgdGhlIHJlZmVyZW5jZSB0byBgdGhpc2AgaW4gdGhlIG1ldGhvZHMgdG8gcG9pbnRzIHRvIHRoYXQgbmV3IEF1dG9OdW1lcmljIG9iamVjdC5cbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmNyZWF0ZUxvY2FsTGlzdCA9IG9yaWdpbmFsQ3JlYXRlTG9jYWxMaXN0U2V0dGluZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXV0b051bWVyaWNPYmplY3RzQXJyYXkucHVzaChuZXdBdXRvTnVtZXJpY0VsZW1lbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmV0dXJuQVNpbmdsZUF1dG9OdW1lcmljT2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBJZiBhIHNpbmdsZSBET00gZWxlbWVudCB3YXMgdXNlZCBhcyB0aGUgcGFyYW1ldGVyLCB0aGVuIHdlIHJldHVybiBhbiBBdXRvTnVtZXJpYyBvYmplY3QgZGlyZWN0bHlcbiAgICAgICAgICAgIHJldHVybiBhdXRvTnVtZXJpY09iamVjdHNBcnJheVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC4uLm90aGVyd2lzZSB3ZSByZXR1cm4gYW4gQXJyYXkgb2YgQXV0b051bWVyaWMgb2JqZWN0c1xuICAgICAgICByZXR1cm4gYXV0b051bWVyaWNPYmplY3RzQXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGVsZW1lbnQgdmFsdWUgZWl0aGVyIHRvIHRoZSBlbXB0eSBzdHJpbmcgJycsIG9yIHRoZSBjdXJyZW5jeSBzaWduLCBkZXBlbmRpbmcgb24gdGhlIGBlbXB0eUlucHV0QmVoYXZpb3JgIG9wdGlvbiB2YWx1ZS5cbiAgICAgKiBJZiB5b3Ugc2V0IHRoZSBgZm9yY2VDbGVhckFsbGAgYXJndW1lbnQgdG8gYHRydWVgLCB0aGVuIHRoZSBgZW1wdHlJbnB1dEJlaGF2aW9yYCBvcHRpb24gaXMgb3ZlcnJpZGRlbiBhbmQgdGhlIHdob2xlIGlucHV0IGlzIGNsZWFyLCBpbmNsdWRpbmcgYW55IGN1cnJlbmN5IHNpZ24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlQ2xlYXJBbGxcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgY2xlYXIoZm9yY2VDbGVhckFsbCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChmb3JjZUNsZWFyQWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wb3JhcnlGb3JjZWRPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGVtcHR5SW5wdXRCZWhhdmlvcjogQXV0b051bWVyaWMub3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3IuZm9jdXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zZXQoJycsIHRlbXBvcmFyeUZvcmNlZE9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXQoJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBhdXRvTnVtZXJpYyBkYXRhIGFuZCBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgZWxlbWVudCwgYnV0IGtlZXAgdGhlIGVsZW1lbnQgY29udGVudCBpbnRhY3QuXG4gICAgICogVGhpcyBhbHNvIGNsZWFycyB0aGUgdmFsdWUgZnJvbSBzZXNzaW9uU3RvcmFnZSAob3IgY29va2llLCBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0cykuXG4gICAgICogTm90ZTogdGhpcyBkb2VzIG5vdCByZW1vdmUgdGhlIGZvcm1hdHRpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBhbkVsZW1lbnQucmVtb3ZlKClcbiAgICAgKi9cbiAgICByZW1vdmUoKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVZhbHVlRnJvbVBlcnNpc3RlbnRTdG9yYWdlKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICAgICAgLy8gQWxzbyByZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgbG9jYWwgQXV0b051bWVyaWMgbGlzdFxuICAgICAgICB0aGlzLl9yZW1vdmVGcm9tTG9jYWxMaXN0KHRoaXMuZG9tRWxlbWVudCk7XG4gICAgICAgIC8vIEFsc28gcmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gdGhlIGdsb2JhbCBBdXRvTnVtZXJpYyBsaXN0XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuX3JlbW92ZUZyb21HbG9iYWxMaXN0KHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgYXV0b051bWVyaWMgZGF0YSBhbmQgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGVsZW1lbnQsIGFuZCByZXNldCBpdHMgdmFsdWUgdG8gdGhlIGVtcHR5IHN0cmluZyAnJy5cbiAgICAgKiBUaGlzIGFsc28gY2xlYXJzIHRoZSB2YWx1ZSBmcm9tIHNlc3Npb25TdG9yYWdlIChvciBjb29raWUsIGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnRzKS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIGFuRWxlbWVudC53aXBlKClcbiAgICAgKi9cbiAgICB3aXBlKCkge1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50VmFsdWUoJycpO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgYXV0b051bWVyaWMgZGF0YSBhbmQgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGVsZW1lbnQsIGFuZCBkZWxldGUgdGhlIERPTSBlbGVtZW50IGFsdG9nZXRoZXJcbiAgICAgKi9cbiAgICBudWtlKCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICAvLyBSZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgRE9NXG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgfVxuXG5cbiAgICAvLyBTcGVjaWFsIGZ1bmN0aW9ucyB0aGF0IHJlYWxseSB3b3JrIG9uIHRoZSBwYXJlbnQgPGZvcm0+IGVsZW1lbnQsIGluc3RlYWQgb2YgdGhlIDxpbnB1dD4gZWxlbWVudCBpdHNlbGZcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IDxmb3JtPiBlbGVtZW50IGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIHJldHVybiBgbnVsbGAuXG4gICAgICogSWYgdGhlIHBhcmVudCBmb3JtIGVsZW1lbnQgYXMgYWxyZWFkeSBiZWVuIGZvdW5kLCB0aGlzIGRpcmVjdGx5IHJldHVybiBhIHJlZmVyZW5jZSB0byBpdC5cbiAgICAgKiBIb3dldmVyLCB5b3UgY2FuIGZvcmNlIEF1dG9OdW1lcmljIHRvIHNlYXJjaCBhZ2FpbiBmb3IgaXRzIHJlZmVyZW5jZSBieSBwYXNzaW5nIGB0cnVlYCBhcyBhIHBhcmFtZXRlciB0byB0aGlzIG1ldGhvZC5cbiAgICAgKiBUaGlzIG1ldGhvZCB1cGRhdGVzIHRoZSBgdGhpcy5wYXJlbnRGb3JtYCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlU2VhcmNoIElmIHNldCB0byBgdHJ1ZWAsIHRoZSBwYXJlbnQgZm9ybSBpcyBzZWFyY2hlZCBhZ2FpbiwgZXZlbiBpZiBgdGhpcy5wYXJlbnRGb3JtYCBpcyBhbHJlYWR5IHNldC5cbiAgICAgKiBAcmV0dXJucyB7SFRNTEZvcm1FbGVtZW50fG51bGx9XG4gICAgICovXG4gICAgZm9ybShmb3JjZVNlYXJjaCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChmb3JjZVNlYXJjaCB8fCBBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkodGhpcy5wYXJlbnRGb3JtKSkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRGb3JtID0gdGhpcy5fZ2V0UGFyZW50Rm9ybSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Rm9ybTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCA8Zm9ybT4gZWxlbWVudCBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSByZXR1cm4gYG51bGxgLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0hUTUxGb3JtRWxlbWVudHxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFBhcmVudEZvcm0oKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbUVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYm9keScpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmRvbUVsZW1lbnQ7XG4gICAgICAgIGxldCB0YWdOYW1lO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChub2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSB3aGVuIHVzaW5nIHRlbXBsYXRlcyB3aXRoIGZyYW1ld29ya3MgbGlrZSBWdWUuanMsIHdoZXJlIHRoZSBpbnB1dCBlbGVtZW50IGNhbiBiZSAnZGV0YWNoZWQnIHdoZW4gaW5pdGlhbGl6aW5nIHRoZSBET00gc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLnRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICB0YWdOYW1lID0gbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhZ05hbWUgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEdldCBvdXQgb2YgdGhlIGxvb3AgaWYgd2UgZ2V0IHVwIHRvIHRoZSBgPGJvZHk+YCBlbGVtZW50XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHRhZ05hbWUgIT09ICdmb3JtJyk7XG5cbiAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdmb3JtJykge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHN0cmluZyBpbiBzdGFuZGFyZCBVUkwtZW5jb2RlZCBub3RhdGlvbiB3aXRoIHRoZSBmb3JtIGlucHV0IHZhbHVlcyBiZWluZyB1bmZvcm1hdHRlZC5cbiAgICAgKiBUaGlzIHN0cmluZyBjYW4gYmUgdXNlZCBhcyBhIHF1ZXJ5IGZvciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZm9ybU51bWVyaWNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLl9zZXJpYWxpemVOdW1lcmljU3RyaW5nKHRoaXMuZm9ybSgpLCB0aGlzLnNldHRpbmdzLnNlcmlhbGl6ZVNwYWNlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIGluIHN0YW5kYXJkIFVSTC1lbmNvZGVkIG5vdGF0aW9uIHdpdGggdGhlIGZvcm0gaW5wdXQgdmFsdWVzIGJlaW5nIGZvcm1hdHRlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZm9ybUZvcm1hdHRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuX3NlcmlhbGl6ZUZvcm1hdHRlZCh0aGlzLmZvcm0oKSwgdGhpcy5zZXR0aW5ncy5zZXJpYWxpemVTcGFjZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHN0cmluZyBpbiBzdGFuZGFyZCBVUkwtZW5jb2RlZCBub3RhdGlvbiB3aXRoIHRoZSBmb3JtIGlucHV0IHZhbHVlcywgd2l0aCBsb2NhbGl6ZWQgdmFsdWVzLlxuICAgICAqIFRoZSBkZWZhdWx0IG91dHB1dCBmb3JtYXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZyB0aGUgb3B0aW9uIGFzIGEgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudWxsfHN0cmluZ30gZm9yY2VkT3V0cHV0Rm9ybWF0IElmIHNldCB0byBzb21ldGhpbmcgZGlmZmVyZW50IHRoYW4gYG51bGxgLCB0aGVuIHRoaXMgaXMgdXNlZCBhcyBhbiBvdmVycmlkaW5nIG91dHB1dEZvcm1hdCBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZvcm1Mb2NhbGl6ZWQoZm9yY2VkT3V0cHV0Rm9ybWF0ID0gbnVsbCkge1xuICAgICAgICBsZXQgb3V0cHV0Rm9ybWF0VG9Vc2U7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bGwoZm9yY2VkT3V0cHV0Rm9ybWF0KSkge1xuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0VG9Vc2UgPSB0aGlzLnNldHRpbmdzLm91dHB1dEZvcm1hdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdFRvVXNlID0gZm9yY2VkT3V0cHV0Rm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuX3NlcmlhbGl6ZUxvY2FsaXplZCh0aGlzLmZvcm0oKSwgdGhpcy5zZXR0aW5ncy5zZXJpYWxpemVTcGFjZXMsIG91dHB1dEZvcm1hdFRvVXNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBhbiBvYmplY3QgZm9yIGVhY2ggZm9ybSA8aW5wdXQ+IGVsZW1lbnQuXG4gICAgICogVGhvc2Ugb2JqZWN0cyBhcmUgb2YgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmUgYHsgbmFtZTogZm9vLCB2YWx1ZTogJzQyJyB9YCwgd2hlcmUgdGhlIGBuYW1lYCBpcyB0aGUgRE9NIGVsZW1lbnQgbmFtZSwgYW5kIHRoZSBgdmFsdWVgIGlzIGFuIHVuZm9ybWF0dGVkIG51bWVyaWMgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGZvcm1BcnJheU51bWVyaWNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLl9zZXJpYWxpemVOdW1lcmljU3RyaW5nQXJyYXkodGhpcy5mb3JtKCksIHRoaXMuc2V0dGluZ3Muc2VyaWFsaXplU3BhY2VzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBhbiBvYmplY3QgZm9yIGVhY2ggZm9ybSA8aW5wdXQ+IGVsZW1lbnQuXG4gICAgICogVGhvc2Ugb2JqZWN0cyBhcmUgb2YgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmUgYHsgbmFtZTogZm9vLCB2YWx1ZTogJzQyJyB9YCwgd2hlcmUgdGhlIGBuYW1lYCBpcyB0aGUgRE9NIGVsZW1lbnQgbmFtZSwgYW5kIHRoZSBgdmFsdWVgIGlzIHRoZSBmb3JtYXR0ZWQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGZvcm1BcnJheUZvcm1hdHRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuX3NlcmlhbGl6ZUZvcm1hdHRlZEFycmF5KHRoaXMuZm9ybSgpLCB0aGlzLnNldHRpbmdzLnNlcmlhbGl6ZVNwYWNlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgYW4gb2JqZWN0IGZvciBlYWNoIGZvcm0gPGlucHV0PiBlbGVtZW50LlxuICAgICAqIFRob3NlIG9iamVjdHMgYXJlIG9mIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlIGB7IG5hbWU6IGZvbywgdmFsdWU6ICc0MicgfWAsIHdoZXJlIHRoZSBgbmFtZWAgaXMgdGhlIERPTSBlbGVtZW50IG5hbWUsIGFuZCB0aGUgYHZhbHVlYCBpcyB0aGUgbG9jYWxpemVkIG51bWVyaWMgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudWxsfHN0cmluZ30gZm9yY2VkT3V0cHV0Rm9ybWF0IElmIHNldCB0byBzb21ldGhpbmcgZGlmZmVyZW50IHRoYW4gYG51bGxgLCB0aGVuIHRoaXMgaXMgdXNlZCBhcyBhbiBvdmVycmlkaW5nIG91dHB1dEZvcm1hdCBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZm9ybUFycmF5TG9jYWxpemVkKGZvcmNlZE91dHB1dEZvcm1hdCA9IG51bGwpIHtcbiAgICAgICAgbGV0IG91dHB1dEZvcm1hdFRvVXNlO1xuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKGZvcmNlZE91dHB1dEZvcm1hdCkpIHtcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdFRvVXNlID0gdGhpcy5zZXR0aW5ncy5vdXRwdXRGb3JtYXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXRGb3JtYXRUb1VzZSA9IGZvcmNlZE91dHB1dEZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLl9zZXJpYWxpemVMb2NhbGl6ZWRBcnJheSh0aGlzLmZvcm0oKSwgdGhpcy5zZXR0aW5ncy5zZXJpYWxpemVTcGFjZXMsIG91dHB1dEZvcm1hdFRvVXNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBKU09OIHN0cmluZyBjb250YWluaW5nIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGZvcm0gaW5wdXQgdmFsdWVzLlxuICAgICAqIFRoaXMgaXMgYmFzZWQgb24gdGhlIHJlc3VsdCBvZiB0aGUgYGZvcm1BcnJheU51bWVyaWNTdHJpbmcoKWAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZvcm1Kc29uTnVtZXJpY1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuZm9ybUFycmF5TnVtZXJpY1N0cmluZygpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBKU09OIHN0cmluZyBjb250YWluaW5nIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGZvcm0gaW5wdXQgdmFsdWVzLlxuICAgICAqIFRoaXMgaXMgYmFzZWQgb24gdGhlIHJlc3VsdCBvZiB0aGUgYGZvcm1BcnJheUZvcm1hdHRlZCgpYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZm9ybUpzb25Gb3JtYXR0ZWQoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmZvcm1BcnJheUZvcm1hdHRlZCgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBKU09OIHN0cmluZyBjb250YWluaW5nIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGZvcm0gaW5wdXQgdmFsdWVzLlxuICAgICAqIFRoaXMgaXMgYmFzZWQgb24gdGhlIHJlc3VsdCBvZiB0aGUgYGZvcm1BcnJheUxvY2FsaXplZCgpYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVsbHxzdHJpbmd9IGZvcmNlZE91dHB1dEZvcm1hdCBJZiBzZXQgdG8gc29tZXRoaW5nIGRpZmZlcmVudCB0aGFuIGBudWxsYCwgdGhlbiB0aGlzIGlzIHVzZWQgYXMgYW4gb3ZlcnJpZGluZyBvdXRwdXRGb3JtYXQgb3B0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBmb3JtSnNvbkxvY2FsaXplZChmb3JjZWRPdXRwdXRGb3JtYXQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmZvcm1BcnJheUxvY2FsaXplZChmb3JjZWRPdXRwdXRGb3JtYXQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbmZvcm1hdCBhbGwgdGhlIGF1dG9OdW1lcmljLW1hbmFnZWQgZWxlbWVudHMgdGhhdCBhcmUgYSBjaGlsZCBvZiB0aGUgcGFyZW50IDxmb3JtPiBlbGVtZW50IG9mIHRoaXMgRE9NIGVsZW1lbnQsIHRvIG51bWVyaWMgc3RyaW5nc1xuICAgICAqXG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqL1xuICAgIGZvcm1VbmZvcm1hdCgpIHsgLy9GSVhNRSB0ZXN0IHRoaXNcbiAgICAgICAgY29uc3QgaW5wdXRzID0gdGhpcy5jb25zdHJ1Y3Rvci5fZ2V0Q2hpbGRBTklucHV0RWxlbWVudCh0aGlzLmZvcm0oKSk7XG4gICAgICAgIGlucHV0cy5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLmdldEF1dG9OdW1lcmljRWxlbWVudChpbnB1dCkudW5mb3JtYXQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5mb3JtYXQgYWxsIHRoZSBhdXRvTnVtZXJpYy1tYW5hZ2VkIGVsZW1lbnRzIHRoYXQgYXJlIGEgY2hpbGQgb2YgdGhlIHBhcmVudCA8Zm9ybT4gZWxlbWVudCBvZiB0aGlzIERPTSBlbGVtZW50LCB0byBsb2NhbGl6ZWQgc3RyaW5nc1xuICAgICAqXG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqL1xuICAgIGZvcm1VbmZvcm1hdExvY2FsaXplZCgpIHsgLy9GSVhNRSB0ZXN0IHRoaXNcbiAgICAgICAgY29uc3QgaW5wdXRzID0gdGhpcy5jb25zdHJ1Y3Rvci5fZ2V0Q2hpbGRBTklucHV0RWxlbWVudCh0aGlzLmZvcm0oKSk7XG4gICAgICAgIGlucHV0cy5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLmdldEF1dG9OdW1lcmljRWxlbWVudChpbnB1dCkudW5mb3JtYXRMb2NhbGl6ZWQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVmb3JtYXQgYWxsIHRoZSBhdXRvTnVtZXJpYy1tYW5hZ2VkIGVsZW1lbnRzIHRoYXQgYXJlIGEgY2hpbGQgb2YgdGhlIHBhcmVudCA8Zm9ybT4gZWxlbWVudCBvZiB0aGlzIERPTSBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgZm9ybVJlZm9ybWF0KCkgeyAvL0ZJWE1FIHRlc3QgdGhpc1xuICAgICAgICBjb25zdCBpbnB1dHMgPSB0aGlzLmNvbnN0cnVjdG9yLl9nZXRDaGlsZEFOSW5wdXRFbGVtZW50KHRoaXMuZm9ybSgpKTtcbiAgICAgICAgaW5wdXRzLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICAgICAgQXV0b051bWVyaWMuZ2V0QXV0b051bWVyaWNFbGVtZW50KGlucHV0KS5yZWZvcm1hdCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBpbnB1dCB2YWx1ZXMgdG8gbnVtZXJpYyBzdHJpbmdzLCBzdWJtaXQgdGhlIGZvcm0sIHRoZW4gcmVmb3JtYXQgdGhvc2UgYmFjay5cbiAgICAgKiBUaGUgZnVuY3Rpb24gY2FuIGVpdGhlciB0YWtlIGEgY2FsbGJhY2ssIG9yIG5vdC4gSWYgaXQgZG9lc24ndCwgdGhlIGRlZmF1bHQgYGZvcm0uc3VibWl0KClgIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkLlxuICAgICAqIE90aGVyd2lzZSwgaXQgcnVucyBgY2FsbGJhY2sodmFsdWUpYCB3aXRoIGB2YWx1ZWAgYmVpbmcgZXF1YWwgdG8gdGhlIHJlc3VsdCBvZiBgZm9ybU51bWVyaWNTdHJpbmcoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG51bGx9IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqL1xuICAgIGZvcm1TdWJtaXROdW1lcmljU3RyaW5nKGNhbGxiYWNrID0gbnVsbCkgeyAvL0ZJWE1FIHRlc3QgdGhpc1xuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtVW5mb3JtYXQoKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybSgpLnN1Ym1pdCgpO1xuICAgICAgICAgICAgdGhpcy5mb3JtUmVmb3JtYXQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5mb3JtTnVtZXJpY1N0cmluZygpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBnaXZlbiBjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN1Ym1pdCB0aGUgZm9ybSB3aXRoIHRoZSBjdXJyZW50IGZvcm1hdHRlZCB2YWx1ZXMuXG4gICAgICogVGhlIGZ1bmN0aW9uIGNhbiBlaXRoZXIgdGFrZSBhIGNhbGxiYWNrLCBvciBub3QuIElmIGl0IGRvZXNuJ3QsIHRoZSBkZWZhdWx0IGBmb3JtLnN1Ym1pdCgpYCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZC5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHJ1bnMgYGNhbGxiYWNrKHZhbHVlKWAgd2l0aCBgdmFsdWVgIGJlaW5nIGVxdWFsIHRvIHRoZSByZXN1bHQgb2YgYGZvcm1Gb3JtYXR0ZWQoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG51bGx9IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqL1xuICAgIGZvcm1TdWJtaXRGb3JtYXR0ZWQoY2FsbGJhY2sgPSBudWxsKSB7IC8vRklYTUUgdGVzdCB0aGlzXG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bGwoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm0oKS5zdWJtaXQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5mb3JtRm9ybWF0dGVkKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGdpdmVuIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgaW5wdXQgdmFsdWVzIHRvIGxvY2FsaXplZCBzdHJpbmdzLCBzdWJtaXQgdGhlIGZvcm0sIHRoZW4gcmVmb3JtYXQgdGhvc2UgYmFjay5cbiAgICAgKiBUaGUgZnVuY3Rpb24gY2FuIGVpdGhlciB0YWtlIGEgY2FsbGJhY2ssIG9yIG5vdC4gSWYgaXQgZG9lc24ndCwgdGhlIGRlZmF1bHQgYGZvcm0uc3VibWl0KClgIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkLlxuICAgICAqIE90aGVyd2lzZSwgaXQgcnVucyBgY2FsbGJhY2sodmFsdWUpYCB3aXRoIGB2YWx1ZWAgYmVpbmcgZXF1YWwgdG8gdGhlIHJlc3VsdCBvZiBgZm9ybUxvY2FsaXplZCgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVsbHxzdHJpbmd9IGZvcmNlZE91dHB1dEZvcm1hdCBJZiBzZXQgdG8gc29tZXRoaW5nIGRpZmZlcmVudCB0aGFuIGBudWxsYCwgdGhlbiB0aGlzIGlzIHVzZWQgYXMgYW4gb3ZlcnJpZGluZyBvdXRwdXRGb3JtYXQgb3B0aW9uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbnxudWxsfSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBmb3JtU3VibWl0TG9jYWxpemVkKGZvcmNlZE91dHB1dEZvcm1hdCA9IG51bGwsIGNhbGxiYWNrID0gbnVsbCkgeyAvL0ZJWE1FIHRlc3QgdGhpc1xuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtVW5mb3JtYXRMb2NhbGl6ZWQoKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybSgpLnN1Ym1pdCgpO1xuICAgICAgICAgICAgdGhpcy5mb3JtUmVmb3JtYXQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5mb3JtTG9jYWxpemVkKGZvcmNlZE91dHB1dEZvcm1hdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGdpdmVuIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW4gYXJyYXkgb2YgbnVtZXJpYyBzdHJpbmdzIGZyb20gdGhlIGA8aW5wdXQ+YCBlbGVtZW50cywgYW5kIHBhc3MgaXQgdG8gdGhlIGdpdmVuIGNhbGxiYWNrLlxuICAgICAqIFVuZGVyIHRoZSBob29kLCB0aGUgYXJyYXkgaXMgZ2VuZXJhdGVkIHZpYSBhIGNhbGwgdG8gYGZvcm1BcnJheU51bWVyaWNTdHJpbmcoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBmb3JtU3VibWl0QXJyYXlOdW1lcmljU3RyaW5nKGNhbGxiYWNrKSB7IC8vRklYTUUgdGVzdCB0aGlzXG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5mb3JtQXJyYXlOdW1lcmljU3RyaW5nKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGdpdmVuIGNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW4gYXJyYXkgb2YgdGhlIGN1cnJlbnQgZm9ybWF0dGVkIHZhbHVlcyBmcm9tIHRoZSBgPGlucHV0PmAgZWxlbWVudHMsIGFuZCBwYXNzIGl0IHRvIHRoZSBnaXZlbiBjYWxsYmFjay5cbiAgICAgKiBVbmRlciB0aGUgaG9vZCwgdGhlIGFycmF5IGlzIGdlbmVyYXRlZCB2aWEgYSBjYWxsIHRvIGBmb3JtQXJyYXlGb3JtYXR0ZWQoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBmb3JtU3VibWl0QXJyYXlGb3JtYXR0ZWQoY2FsbGJhY2spIHsgLy9GSVhNRSB0ZXN0IHRoaXNcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh0aGlzLmZvcm1BcnJheUZvcm1hdHRlZCgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBnaXZlbiBjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGFuIGFycmF5IG9mIGxvY2FsaXplZCBzdHJpbmdzIGZyb20gdGhlIGA8aW5wdXQ+YCBlbGVtZW50cywgYW5kIHBhc3MgaXQgdG8gdGhlIGdpdmVuIGNhbGxiYWNrLlxuICAgICAqIFVuZGVyIHRoZSBob29kLCB0aGUgYXJyYXkgaXMgZ2VuZXJhdGVkIHZpYSBhIGNhbGwgdG8gYGZvcm1BcnJheUxvY2FsaXplZCgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtudWxsfHN0cmluZ30gZm9yY2VkT3V0cHV0Rm9ybWF0IElmIHNldCB0byBzb21ldGhpbmcgZGlmZmVyZW50IHRoYW4gYG51bGxgLCB0aGVuIHRoaXMgaXMgdXNlZCBhcyBhbiBvdmVycmlkaW5nIG91dHB1dEZvcm1hdCBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgZm9ybVN1Ym1pdEFycmF5TG9jYWxpemVkKGNhbGxiYWNrLCBmb3JjZWRPdXRwdXRGb3JtYXQgPSBudWxsKSB7IC8vRklYTUUgdGVzdCB0aGlzXG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5mb3JtQXJyYXlMb2NhbGl6ZWQoZm9yY2VkT3V0cHV0Rm9ybWF0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgZ2l2ZW4gY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb24uYCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIEpTT04gc3RyaW5nIHdpdGggdGhlIG51bWVyaWMgc3RyaW5ncyB2YWx1ZXMgZnJvbSB0aGUgYDxpbnB1dD5gIGVsZW1lbnRzLCBhbmQgcGFzcyBpdCB0byB0aGUgZ2l2ZW4gY2FsbGJhY2suXG4gICAgICogVW5kZXIgdGhlIGhvb2QsIHRoZSBhcnJheSBpcyBnZW5lcmF0ZWQgdmlhIGEgY2FsbCB0byBgZm9ybUpzb25OdW1lcmljU3RyaW5nKClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgZm9ybVN1Ym1pdEpzb25OdW1lcmljU3RyaW5nKGNhbGxiYWNrKSB7IC8vRklYTUUgdGVzdCB0aGlzXG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5mb3JtSnNvbk51bWVyaWNTdHJpbmcoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgZ2l2ZW4gY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb24uYCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIEpTT04gc3RyaW5nIHdpdGggdGhlIGN1cnJlbnQgZm9ybWF0dGVkIHZhbHVlcyBmcm9tIHRoZSBgPGlucHV0PmAgZWxlbWVudHMsIGFuZCBwYXNzIGl0IHRvIHRoZSBnaXZlbiBjYWxsYmFjay5cbiAgICAgKiBVbmRlciB0aGUgaG9vZCwgdGhlIGFycmF5IGlzIGdlbmVyYXRlZCB2aWEgYSBjYWxsIHRvIGBmb3JtSnNvbkZvcm1hdHRlZCgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqL1xuICAgIGZvcm1TdWJtaXRKc29uRm9ybWF0dGVkKGNhbGxiYWNrKSB7IC8vRklYTUUgdGVzdCB0aGlzXG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5mb3JtSnNvbkZvcm1hdHRlZCgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBnaXZlbiBjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgSlNPTiBzdHJpbmcgd2l0aCB0aGUgbG9jYWxpemVkIHN0cmluZ3MgdmFsdWVzIGZyb20gdGhlIGA8aW5wdXQ+YCBlbGVtZW50cywgYW5kIHBhc3MgaXQgdG8gdGhlIGdpdmVuIGNhbGxiYWNrLlxuICAgICAqIFVuZGVyIHRoZSBob29kLCB0aGUgYXJyYXkgaXMgZ2VuZXJhdGVkIHZpYSBhIGNhbGwgdG8gYGZvcm1Kc29uTG9jYWxpemVkKClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge251bGx8c3RyaW5nfSBmb3JjZWRPdXRwdXRGb3JtYXQgSWYgc2V0IHRvIHNvbWV0aGluZyBkaWZmZXJlbnQgdGhhbiBgbnVsbGAsIHRoZW4gdGhpcyBpcyB1c2VkIGFzIGFuIG92ZXJyaWRpbmcgb3V0cHV0Rm9ybWF0IG9wdGlvblxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBmb3JtU3VibWl0SnNvbkxvY2FsaXplZChjYWxsYmFjaywgZm9yY2VkT3V0cHV0Rm9ybWF0ID0gbnVsbCkgeyAvL0ZJWE1FIHRlc3QgdGhpc1xuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuZm9ybUpzb25Mb2NhbGl6ZWQoZm9yY2VkT3V0cHV0Rm9ybWF0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgZ2l2ZW4gY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb24uYCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVbmZvcm1hdCB0aGUgZ2l2ZW4gQXV0b051bWVyaWMgZWxlbWVudCwgYW5kIHVwZGF0ZSB0aGUgYGhvdmVyZWRXaXRoQWx0YCB2YXJpYWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWN9IGFuRWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF91bmZvcm1hdEFsdEhvdmVyZWQoYW5FbGVtZW50KSB7XG4gICAgICAgIGFuRWxlbWVudC5ob3ZlcmVkV2l0aEFsdCA9IHRydWU7XG4gICAgICAgIGFuRWxlbWVudC51bmZvcm1hdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZm9ybWF0IHRoZSBnaXZlbiBBdXRvTnVtZXJpYyBlbGVtZW50LCBhbmQgdXBkYXRlIHRoZSBgaG92ZXJlZFdpdGhBbHRgIHZhcmlhYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY30gYW5FbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX3JlZm9ybWF0QWx0SG92ZXJlZChhbkVsZW1lbnQpIHtcbiAgICAgICAgYW5FbGVtZW50LmhvdmVyZWRXaXRoQWx0ID0gZmFsc2U7XG4gICAgICAgIGFuRWxlbWVudC5yZWZvcm1hdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiBhdXRvTnVtZXJpYyBlbGVtZW50cywgY2hpbGQgb2YgdGhlIDxmb3JtPiBlbGVtZW50IHBhc3NlZCBhcyBhIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGZvcm1Ob2RlXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9nZXRDaGlsZEFOSW5wdXRFbGVtZW50KGZvcm1Ob2RlKSB7IC8vRklYTUUgdGVzdCB0aGlzXG4gICAgICAgIGNvbnN0IGlucHV0TGlzdCA9IGZvcm1Ob2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpO1xuXG4gICAgICAgIC8vIExvb3AgdGhpcyBsaXN0IGFuZCBrZWVwIG9ubHkgdGhlIGlucHV0cyB0aGF0IGFyZSBtYW5hZ2VkIGJ5IEF1dG9OdW1lcmljXG4gICAgICAgIGNvbnN0IGF1dG9OdW1lcmljSW5wdXRzID0gW107XG4gICAgICAgIGNvbnN0IGlucHV0RWxlbWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpbnB1dExpc3QsIDApO1xuICAgICAgICBpbnB1dEVsZW1lbnRzLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMudGVzdChpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICBhdXRvTnVtZXJpY0lucHV0cy5wdXNoKGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGF1dG9OdW1lcmljSW5wdXRzO1xuICAgIH1cblxuICAgIC8vIFN0YXRpYyBtZXRob2RzXG4gICAgLyoqXG4gICAgICogVGVzdCBpZiB0aGUgZ2l2ZW4gZG9tRWxlbWVudCBpcyBhbHJlYWR5IG1hbmFnZWQgYnkgQXV0b051bWVyaWMgKGlmIGl0IGhhcyBiZWVuIGluaXRpYWxpemVkIG9uIHRoZSBjdXJyZW50IHBhZ2UpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tRWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyB0ZXN0KGRvbUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzSW5HbG9iYWxMaXN0KGRvbUVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFdlYWtNYXAgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3ZWFrTWFwTmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9jcmVhdGVXZWFrTWFwKHdlYWtNYXBOYW1lKSB7XG4gICAgICAgIHdpbmRvd1t3ZWFrTWFwTmFtZV0gPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGxpc3Qgb2YgYWxsIHRoZSBBdXRvTnVtZXJpYyBlbGVtZW50cyB0aGF0IGFyZSBpbml0aWFsaXplZCBvbiB0aGUgY3VycmVudCBwYWdlLlxuICAgICAqIFRoaXMgaXMgbmVlZGVkIGluIG9yZGVyIHRvIGRldGVybWluZSBpZiBhIGdpdmVuIGRvbSBlbGVtZW50IGlzIGFscmVhZHkgbWFuYWdlZCBieSBhdXRvTnVtZXJpYy5cbiAgICAgKiBUaGlzIHVzZXMgYSBXZWFrTWFwIGluIG9yZGVyIHRvIGxpbWl0IHBvdGVudGlhbCBnYXJiYWdlIGNvbGxlY3Rpb24gcHJvYmxlbXMuXG4gICAgICogKGNmLiBteSB0ZXN0cyBvbiBodHRwOi8vY29kZXBlbi5pby9Bbm90aGVyTGludXhVc2VyL3Blbi9wUlFHYU0/ZWRpdG9ycz0xMDExKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9jcmVhdGVHbG9iYWxMaXN0KCkge1xuICAgICAgICAvLyBUaGUgY2hlY2sgdGhhdCB0aGlzIGdsb2JhbCBsaXN0IGRvZXMgbm90IGV4aXN0cyBhbHJlYWR5IGlzIGRvbmUgaW4gdGhlIGFkZCBhbmQgcmVtb3ZlIGZ1bmN0aW9ucyBhbHJlYWR5XG4gICAgICAgIHRoaXMuYXV0b051bWVyaWNHbG9iYWxMaXN0TmFtZSA9ICdhdXRvTnVtZXJpY0dsb2JhbExpc3QnOyAvL1hYWCBUaGlzIGxvb2tzIHdlaXJkIHRvIHNldCBhIHZhcmlhYmxlIG9uIGB0aGlzLmAgaW4gYSBzdGF0aWMgbWV0aG9kLCBidXQgdGhhdCByZWFsbHkgZGVjbGFyZSB0aGF0IHZhcmlhYmxlIGxpa2UgYSBzdGF0aWMgcHJvcGVydHlcbiAgICAgICAgLy8gTm90ZTogSSBzaG91bGQgbm90IGdldCBhbnkgbWVtb3J5IGxlYWtzIGZvciByZWZlcmVuY2luZyB0aGUgRE9NIGVsZW1lbnQgaW4gdGhlIGB2YWx1ZWAsIHRoaXMgRE9NIGVsZW1lbnQgYWxzbyBiZWluZyB0aGUgYGtleWAsIGFjY29yZGluZyB0byB0aGUgc3BlYyA6IGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy13ZWFrbWFwLW9iamVjdHNcbiAgICAgICAgdGhpcy5fY3JlYXRlV2Vha01hcCh0aGlzLmF1dG9OdW1lcmljR2xvYmFsTGlzdE5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGdsb2JhbCBBdXRvTnVtZXJpYyBlbGVtZW50IGxpc3QgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX2RvZXNHbG9iYWxMaXN0RXhpc3RzKCkge1xuICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHdpbmRvd1t0aGlzLmF1dG9OdW1lcmljR2xvYmFsTGlzdE5hbWVdO1xuICAgICAgICByZXR1cm4gdHlwZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgIHR5cGUgPT09ICdvYmplY3QnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgZ2l2ZW4gb2JqZWN0IHRvIHRoZSBnbG9iYWwgQXV0b051bWVyaWMgZWxlbWVudCBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY30gYXV0b051bWVyaWNPYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBfYWRkVG9HbG9iYWxMaXN0KGF1dG9OdW1lcmljT2JqZWN0KSB7XG4gICAgICAgIGlmICghdGhpcy5fZG9lc0dsb2JhbExpc3RFeGlzdHMoKSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlR2xvYmFsTGlzdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGF1dG9OdW1lcmljT2JqZWN0Lm5vZGUoKTtcbiAgICAgICAgLy8gVGhpcyBjaGVja3MgaWYgdGhlIG9iamVjdCBpcyBub3QgYWxyZWFkeSBpbiB0aGUgZ2xvYmFsIGxpc3QgYmVmb3JlIGFkZGluZyBpdC5cbiAgICAgICAgLy8gVGhpcyBjb3VsZCBoYXBwZW4gaWYgYW4gQXV0b051bWVyaWMgZWxlbWVudCBpcyBpbml0aWFsaXplZCwgdGhlbiB0aGUgRE9NIGVsZW1lbnQgaXMgcmVtb3ZlZCBkaXJlY3RseSB2aWEgYHJlbW92ZUNoaWxkYCAoaGVuY2UgdGhlIHJlZmVyZW5jZSBkb2VzIG5vdCBnZXQgcmVtb3ZlZCBmcm9tIHRoZSBnbG9iYWwgbGlzdCksIHRoZW4gaXQgZ2V0IHJlY3JlYXRlZCBhbmQgaW5pdGlhbGl6ZWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMuX2lzSW5HbG9iYWxMaXN0KGRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZ2V0RnJvbUdsb2JhbExpc3QoZG9tRWxlbWVudCkgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWRkIHRoaXMgQXV0b051bWVyaWMgb2JqZWN0IGFnYWluIHNpbmNlIGl0J3MgYWxyZWFkeSBpbiB0aGF0IGdsb2JhbCBsaXN0XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBQcmludCBhIHdhcm5pbmcgdG8gd2FybiB0aGF0IHRoZSBkb21FbGVtZW50IGFscmVhZHkgaGFzIGEgcmVmZXJlbmNlIGluIHRoZSBnbG9iYWwgbWFwIChidXQgd2UgY2Fubm90IGZvciBzdXJlIHN0YXJ0cyBkZWxldGluZyB0aG9zZSBvbGQgcmVmZXJlbmNlcyBzaW5jZSB0aGV5IGNvdWxkIHN0aWxsIGJlIHVzZWQgYnkgYW5vdGhlciBBdXRvTnVtZXJpYyBvYmplY3QpXG4gICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIud2FybmluZyhgQSByZWZlcmVuY2UgdG8gdGhlIERPTSBlbGVtZW50IHlvdSBqdXN0IGluaXRpYWxpemVkIGFscmVhZHkgZXhpc3RzIGluIHRoZSBnbG9iYWwgQXV0b051bWVyaWMgZWxlbWVudCBsaXN0LiBQbGVhc2UgbWFrZSBzdXJlIHRvIG5vdCBpbml0aWFsaXplIHRoZSBzYW1lIERPTSBlbGVtZW50IG11bHRpcGxlIHRpbWVzLmAsIGF1dG9OdW1lcmljT2JqZWN0LmdldFNldHRpbmdzKCkuc2hvd1dhcm5pbmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvd1t0aGlzLmF1dG9OdW1lcmljR2xvYmFsTGlzdE5hbWVdLnNldChkb21FbGVtZW50LCBhdXRvTnVtZXJpY09iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBnaXZlbiBvYmplY3QgZnJvbSB0aGUgZ2xvYmFsIEF1dG9OdW1lcmljIGVsZW1lbnQgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWN9IGF1dG9OdW1lcmljT2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX3JlbW92ZUZyb21HbG9iYWxMaXN0KGF1dG9OdW1lcmljT2JqZWN0KSB7IC8vRklYTUUgdGVzdCB0aGlzXG4gICAgICAgIGlmICh0aGlzLl9kb2VzR2xvYmFsTGlzdEV4aXN0cygpKSB7XG4gICAgICAgICAgICB3aW5kb3dbdGhpcy5hdXRvTnVtZXJpY0dsb2JhbExpc3ROYW1lXS5kZWxldGUoYXV0b051bWVyaWNPYmplY3Qubm9kZSgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgYXNzb2NpYXRlZCB0byB0aGUga2V5IGBkb21FbGVtZW50YCBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuXG4gICAgICogVGhlIHZhbHVlIGlzIHRoZSBBdXRvTnVtZXJpYyBvYmplY3QgdGhhdCBtYW5hZ2VzIHRoZSBET00gZWxlbWVudCBgZG9tRWxlbWVudGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fEhUTUxJbnB1dEVsZW1lbnR9IGRvbUVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7bnVsbHxBdXRvTnVtZXJpY31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBfZ2V0RnJvbUdsb2JhbExpc3QoZG9tRWxlbWVudCkgeyAvL0ZJWE1FIHRlc3QgdGhpc1xuICAgICAgICBpZiAodGhpcy5fZG9lc0dsb2JhbExpc3RFeGlzdHMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1t0aGlzLmF1dG9OdW1lcmljR2xvYmFsTGlzdE5hbWVdLmdldChkb21FbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBET00gZWxlbWVudCBpcyBpbiB0aGUgZ2xvYmFsIEF1dG9OdW1lcmljIGVsZW1lbnQgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTElucHV0RWxlbWVudH0gZG9tRWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9pc0luR2xvYmFsTGlzdChkb21FbGVtZW50KSB7IC8vRklYTUUgdGVzdCB0aGlzXG4gICAgICAgIGlmICghdGhpcy5fZG9lc0dsb2JhbExpc3RFeGlzdHMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHdpbmRvd1t0aGlzLmF1dG9OdW1lcmljR2xvYmFsTGlzdE5hbWVdLmhhcyhkb21FbGVtZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBgTWFwYCB0aGF0IHdpbGwgc3RvcmVzIGFsbCB0aGUgYXV0b051bWVyaWMgZWxlbWVudHMgdGhhdCBhcmUgaW5pdGlhbGl6ZWQgZnJvbSB0aGlzIGN1cnJlbnQgZWxlbWVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVMb2NhbExpc3QoKSB7XG4gICAgICAgIHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3QgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2FkZFRvTG9jYWxMaXN0KHRoaXMuZG9tRWxlbWVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW4gc29tZSByYXJlIGNhc2VzLCB5b3UgY291bGQgd2FudCB0byBkZWxldGUgdGhlIGxvY2FsIGxpc3QgZ2VuZXJhdGVkIGR1cmluZyB0aGUgZWxlbWVudCBpbml0aWFsaXphdGlvbiAoaW4gb3JkZXIgdG8gdXNlIGFub3RoZXIgb25lIGluc3RlYWQgZm9yIGluc3RhbmNlKS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVMb2NhbExpc3QoKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbG9jYWwgbGlzdCB3aXRoIHRoZSBnaXZlbiBNYXAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtNYXB9IGxvY2FsTGlzdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldExvY2FsTGlzdChsb2NhbExpc3QpIHtcbiAgICAgICAgdGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdCA9IGxvY2FsTGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGxvY2FsIGxpc3QgTWFwIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsqfE1hcH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRMb2NhbExpc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIEF1dG9OdW1lcmljIG9iamVjdCBoYXMgYSBsb2NhbCBsaXN0IGRlZmluZWQgYWxyZWFkeSBhbmQgaGFzIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIGl0IChpdHNlbGYgdXN1YWxseSkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oYXNMb2NhbExpc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0IGluc3RhbmNlb2YgTWFwICYmIHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3Quc2l6ZSAhPT0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIGdpdmVuIG9iamVjdCB0byB0aGUgbG9jYWwgYXV0b051bWVyaWMgZWxlbWVudCBsaXN0LlxuICAgICAqIE5vdGU6IGluIG9yZGVyIHRvIGtlZXAgYSBjb2hlcmVudCBsaXN0LCB3ZSBvbmx5IGFkZCBET00gZWxlbWVudHMgaW4gaXQsIG5vdCB0aGUgYXV0b051bWVyaWMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MSW5wdXRFbGVtZW50fSBkb21FbGVtZW50XG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY30gYXV0b051bWVyaWNPYmplY3QgQSByZWZlcmVuY2UgdG8gdGhlIEF1dG9OdW1lcmljIG9iamVjdCB0aGF0IG1hbmFnZSB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnRcbiAgICAgKiBAdGhyb3dzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkVG9Mb2NhbExpc3QoZG9tRWxlbWVudCwgYXV0b051bWVyaWNPYmplY3QgPSBudWxsKSB7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bGwoYXV0b051bWVyaWNPYmplY3QpKSB7XG4gICAgICAgICAgICBhdXRvTnVtZXJpY09iamVjdCA9IHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkKHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3QpKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9OdW1lcmljTG9jYWxMaXN0LnNldChkb21FbGVtZW50LCBhdXRvTnVtZXJpY09iamVjdCk7IC8vIFVzZSB0aGUgRE9NIGVsZW1lbnQgYXMga2V5LCBhbmQgdGhlIEF1dG9OdW1lcmljIG9iamVjdCBhcyB0aGUgdmFsdWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBsb2NhbCBsaXN0IHByb3ZpZGVkIGRvZXMgbm90IGV4aXN0cyB3aGVuIHRyeWluZyB0byBhZGQgYW4gZWxlbWVudC4gWyR7dGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdH1dIGdpdmVuLmApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBnaXZlbiBvYmplY3QgZnJvbSB0aGUgbG9jYWwgYXV0b051bWVyaWMgZWxlbWVudCBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MSW5wdXRFbGVtZW50fSBkb21FbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlRnJvbUxvY2FsTGlzdChkb21FbGVtZW50KSB7XG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWQodGhpcy5hdXRvTnVtZXJpY0xvY2FsTGlzdCkpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b051bWVyaWNMb2NhbExpc3QuZGVsZXRlKGRvbUVsZW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MuY3JlYXRlTG9jYWxMaXN0KSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgbG9jYWwgbGlzdCBwcm92aWRlZCBkb2VzIG5vdCBleGlzdHMgd2hlbiB0cnlpbmcgdG8gcmVtb3ZlIGFuIGVsZW1lbnQuIFske3RoaXMuYXV0b051bWVyaWNMb2NhbExpc3R9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlIHRoZSBgbmV3U2V0dGluZ3NgIGdpdmVuIGFzIHBhcmFtZXRlcnMgaW50byB0aGUgY3VycmVudCBlbGVtZW50IHNldHRpbmdzLlxuICAgICAqXG4gICAgICogV0FSTklORzogVXNpbmcgYE9iamVjdC5hc3NpZ24oKWAgaGVyZSBtZWFucyB0aGUgbWVyZ2UgaXMgbm90IHJlY3Vyc2l2ZSBhbmQgb25seSBvbmUgZGVwdGggaXMgbWVyZ2VkLlxuICAgICAqIGNmLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTE4ODEwOC8yODM0ODk4XG4gICAgICogY2YuIHRlc3RzIG9uIGh0dHA6Ly9jb2RlcGVuLmlvL0Fub3RoZXJMaW51eFVzZXIvcGVuL0thSk9ScT9lZGl0b3JzPTAwMTFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdTZXR0aW5nc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21lcmdlU2V0dGluZ3MoLi4ubmV3U2V0dGluZ3MpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnNldHRpbmdzLCAuLi5uZXdTZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBjdXJyZW50IGVsZW1lbnQgc2V0dGluZ3MgbWVyZ2VkIHdpdGggdGhlIG5ldyBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdTZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2xvbmVBbmRNZXJnZVNldHRpbmdzKC4uLm5ld1NldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgdGhpcy5zZXR0aW5ncywgLi4ubmV3U2V0dGluZ3MpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgdGhlIGdpdmVuIG9wdGlvbiBvYmplY3QuXG4gICAgICogSWYgdGhlIG9wdGlvbnMgYXJlIHZhbGlkLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgbm90aGluZywgb3RoZXJ3aXNlIGlmIHRoZSBvcHRpb25zIGFyZSBpbnZhbGlkLCB0aGlzIGZ1bmN0aW9uIHRocm93cyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIFRoaXMgdGVzdHMgaWYgdGhlIG9wdGlvbnMgYXJlIG5vdCBjb25mbGljdGluZyBhbmQgYXJlIHdlbGwgZm9ybWF0dGVkLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGVuaWVudCBzaW5jZSBpdCBvbmx5IHRlc3RzIHRoZSBzZXR0aW5ncyBwcm9wZXJ0aWVzIDsgaXQgaWdub3JlcyBhbnkgb3RoZXIgcHJvcGVydGllcyB0aGUgb3B0aW9ucyBvYmplY3QgY291bGQgaGF2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdXNlck9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zIElmIGB0cnVlYCwgdGhlbiB0aGlzIGZ1bmN0aW9uIHdpbGwgZXh0ZW5kcyB0aGUgYHVzZXJPcHRpb25zYCBwYXNzZWQgYnkgdGhlIHVzZXIsIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBvcmlnaW5hbE9wdGlvbnMgVGhlIHVzZXIgY2FuIHBhc3MgdGhlIG9yaWdpbmFsIG9wdGlvbnMgKGFuZCBub3QgdGhlIG9uZSB0aGF0IGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgZGVmYXVsdCBzZXR0aW5ncyBhbmQgdGhlIHZhcmlvdXMgdXNhYmlsaXR5IGNvcnJlY3Rpb25zKSwgaW4gb3JkZXIgdG8gYWRkIGNvbXBhdGliaWxpdHkgYW5kIGNvbmZsaWN0cyBjaGVja3MuXG4gICAgICogQHRocm93cyBFcnJvciBUaGlzIHRocm93cyBpZiB0aGUgYHVzZXJPcHRpb25zYCBhcmUgbm90IHZhbGlkXG4gICAgICovXG4gICAgc3RhdGljIHZhbGlkYXRlKHVzZXJPcHRpb25zLCBzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucyA9IHRydWUsIG9yaWdpbmFsT3B0aW9ucyA9IG51bGwpIHtcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSh1c2VyT3B0aW9ucykgfHwgIUF1dG9OdW1lcmljSGVscGVyLmlzT2JqZWN0KHVzZXJPcHRpb25zKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIHVzZXJPcHRpb25zIGFyZSBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgdmFsaWQgb2JqZWN0LCBbJHt1c2VyT3B0aW9uc31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNPcmlnaW5hbE9wdGlvbkFuT2JqZWN0ID0gQXV0b051bWVyaWNIZWxwZXIuaXNPYmplY3Qob3JpZ2luYWxPcHRpb25zKTtcbiAgICAgICAgaWYgKCFpc09yaWdpbmFsT3B0aW9uQW5PYmplY3QgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcmlnaW5hbE9wdGlvbnMpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgJ29yaWdpbmFsT3B0aW9ucycgcGFyYW1ldGVyIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlIGEgdmFsaWQgb3B0aW9uIG9iamVjdCBvciBcXGBudWxsXFxgLCBbJHt1c2VyT3B0aW9uc31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgdXNlZCBvbGQgb3B0aW9ucywgd2UgY29udmVydCB0aGVtIHRvIG5ldyBvbmVzXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKHVzZXJPcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5fY29udmVydE9sZE9wdGlvbnNUb05ld09uZXModXNlck9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHVzZXIgY2FuIGNob29zZSBpZiB0aGUgYHVzZXJPcHRpb25zYCBoYXMgYWxyZWFkeSBiZWVuIGV4dGVuZGVkIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucywgb3Igbm90XG4gICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICBpZiAoc2hvdWxkRXh0ZW5kRGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdldERlZmF1bHRDb25maWcoKSwgdXNlck9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHVzZXJPcHRpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QgdGhpbmdzIGZpcnN0LCB3ZSB0ZXN0IHRoYXQgdGhlIGBzaG93V2FybmluZ3NgIG9wdGlvbiBpcyB2YWxpZFxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5zaG93V2FybmluZ3MpICYmICFBdXRvTnVtZXJpY0hlbHBlci5pc0Jvb2xlYW4ob3B0aW9ucy5zaG93V2FybmluZ3MpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgZGVidWcgb3B0aW9uICdzaG93V2FybmluZ3MnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLnNob3dXYXJuaW5nc31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIHRoZSByZWd1bGFyIGV4cHJlc3Npb25zIG5lZWRlZCBmb3IgdGhlIGZvbGxvd2luZyB0ZXN0c1xuICAgICAgICBjb25zdCB0ZXN0UG9zaXRpdmVJbnRlZ2VyID0gL15bMC05XSskLztcbiAgICAgICAgY29uc3QgdGVzdE51bWVyaWNhbENoYXJhY3RlcnMgPSAvWzAtOV0rLztcbiAgICAgICAgLy8gY29uc3QgdGVzdEZsb2F0QW5kUG9zc2libGVOZWdhdGl2ZVNpZ24gPSAvXi0/WzAtOV0rKFxcLj9bMC05XSspJC87XG4gICAgICAgIGNvbnN0IHRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduID0gL14tP1swLTldKyhcXC4/WzAtOV0rKT8kLztcbiAgICAgICAgY29uc3QgdGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIgPSAvXlswLTldKyhcXC4/WzAtOV0rKT8kLztcblxuICAgICAgICAvLyBUaGVuIHRlc3RzIHRoZSBvcHRpb25zIGluZGl2aWR1YWxseVxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nKSAmJlxuICAgICAgICAgICAgIUF1dG9OdW1lcmljSGVscGVyLmlzQm9vbGVhbihvcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmcpICYmXG4gICAgICAgICAgICBvcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmcgIT09IEF1dG9OdW1lcmljLm9wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZy5mbG9hdHMpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBkZWNpbWFsIHBhZGRpbmcgb3B0aW9uICdhbGxvd0RlY2ltYWxQYWRkaW5nJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSBcXGBmYWxzZVxcYCwgXFxgdHJ1ZVxcYCBvciBcXGAnZmxvYXRzJ1xcYCwgWyR7b3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKG9wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nLm5ldmVyIHx8XG4gICAgICAgICAgICBvcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmcgPT09ICdmYWxzZScgfHwgLy9UT0RPIE1ha2Ugc3VyZSBmb3IgdGhlIG90aGVyIG9wdGlvbnMgdGhhdCAnZmFsc2UnIGFuZCAndHJ1ZScgYXJlIGNvcnJlY3RseSB0YWtlbiBpbnRvIGFjY291bnRcbiAgICAgICAgICAgIG9wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nLmZsb2F0cykgJiZcbiAgICAgICAgICAgIChvcHRpb25zLmRlY2ltYWxQbGFjZXMgIT09IEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbFBsYWNlcy5ub25lIHx8XG4gICAgICAgICAgICBvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uQmx1ciAhPT0gQXV0b051bWVyaWMub3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkJsdXIubm9uZSB8fFxuICAgICAgICAgICAgb3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICE9PSBBdXRvTnVtZXJpYy5vcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMubm9uZSkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLndhcm5pbmcoYFNldHRpbmcgJ2FsbG93RGVjaW1hbFBhZGRpbmcnIHRvIFske29wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZ31dIHdpbGwgb3ZlcnJpZGUgdGhlIGN1cnJlbnQgJ2RlY2ltYWxQbGFjZXMqJyBzZXR0aW5ncyBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXN9LCAke29wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25CbHVyfSBhbmQgJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXN9XS5gLCBvcHRpb25zLnNob3dXYXJuaW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zLmNhcmV0UG9zaXRpb25PbkZvY3VzKSAmJiAhQXV0b051bWVyaWNIZWxwZXIuaXNJbkFycmF5KG9wdGlvbnMuY2FyZXRQb3NpdGlvbk9uRm9jdXMsIFtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuY2FyZXRQb3NpdGlvbk9uRm9jdXMuc3RhcnQsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLmNhcmV0UG9zaXRpb25PbkZvY3VzLmVuZCxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuY2FyZXRQb3NpdGlvbk9uRm9jdXMuZGVjaW1hbExlZnQsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLmNhcmV0UG9zaXRpb25PbkZvY3VzLmRlY2ltYWxSaWdodCxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBkaXNwbGF5IG9uIGVtcHR5IHN0cmluZyBvcHRpb24gJ2NhcmV0UG9zaXRpb25PbkZvY3VzJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSBcXGBudWxsXFxgLCAnZm9jdXMnLCAncHJlc3MnLCAnYWx3YXlzJyBvciAnemVybycsIFske29wdGlvbnMuY2FyZXRQb3NpdGlvbk9uRm9jdXN9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBoZXJlIGZvciBgY2FyZXRQb3NpdGlvbk9uRm9jdXNgIGFuZCBgc2VsZWN0T25Gb2N1c2Agd2hlcmUgd2UgbmVlZCB0byBjaGVjayB0aGUgb3JpZ2luYWwgbm9uLXRlbXBlcmVkIHZlcnNpb24gb2YgdGhlIG9wdGlvbnMgaW4gb3JkZXIgdG8gY2hlY2sgZm9yIGNvbmZsaWN0cywgc2luY2UgdXNpbmcgdGhlIGRlZmF1bHQgc2V0dGluZ3MgcmVtb3ZlIHRob3NlIGFuZCB3b3VsZCBwcmV2ZW50IHVzIHdhcm5pbmcgdGhlIHVzZXIgdGhhdCBoaXMgb3B0aW9uIG9iamVjdCBpcyBub3QgY29ycmVjdC5cbiAgICAgICAgbGV0IG9wdGlvbnNUb1VzZTtcbiAgICAgICAgaWYgKGlzT3JpZ2luYWxPcHRpb25Bbk9iamVjdCkge1xuICAgICAgICAgICAgb3B0aW9uc1RvVXNlID0gb3JpZ2luYWxPcHRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9uc1RvVXNlID0gdGhpcy5fY29ycmVjdENhcmV0UG9zaXRpb25PbkZvY3VzQW5kU2VsZWN0T25Gb2N1c09wdGlvbnModXNlck9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9uc1RvVXNlKSAmJlxuICAgICAgICAgICAgKChvcHRpb25zVG9Vc2UuY2FyZXRQb3NpdGlvbk9uRm9jdXMgIT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY2FyZXRQb3NpdGlvbk9uRm9jdXMuZG9Ob0ZvcmNlQ2FyZXRQb3NpdGlvbiAmJlxuICAgICAgICAgICAgb3B0aW9uc1RvVXNlLnNlbGVjdE9uRm9jdXMgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuc2VsZWN0T25Gb2N1cy5zZWxlY3QpKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIud2FybmluZyhgVGhlICdzZWxlY3RPbkZvY3VzJyBvcHRpb24gaXMgc2V0IHRvICdzZWxlY3QnLCB3aGljaCBpcyBpbiBjb25mbGljdCB3aXRoIHRoZSAnY2FyZXRQb3NpdGlvbk9uRm9jdXMnIHdoaWNoIGlzIHNldCB0byAnJHtvcHRpb25zVG9Vc2UuY2FyZXRQb3NpdGlvbk9uRm9jdXN9Jy4gQXMgYSByZXN1bHQsIGlmIHRoaXMgaGFzIGJlZW4gY2FsbGVkIHdoZW4gaW5zdGFudGlhdGluZyBhbiBBdXRvTnVtZXJpYyBvYmplY3QsIHRoZSAnc2VsZWN0T25Gb2N1cycgb3B0aW9uIGlzIGZvcmNlZCB0byAnZG9Ob3RTZWxlY3QnLmAsIG9wdGlvbnMuc2hvd1dhcm5pbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNJbkFycmF5KG9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvciwgW1xuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLmNvbW1hLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLmRvdCxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvci5ub3JtYWxTcGFjZSxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvci50aGluU3BhY2UsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3IubmFycm93Tm9CcmVha1NwYWNlLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLm5vQnJlYWtTcGFjZSxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvci5ub1NlcGFyYXRvcixcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvci5hcG9zdHJvcGhlLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLmFyYWJpY1Rob3VzYW5kc1NlcGFyYXRvcixcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvci5kb3RBYm92ZSxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSB0aG91c2FuZCBzZXBhcmF0b3IgY2hhcmFjdGVyIG9wdGlvbiAnZGlnaXRHcm91cFNlcGFyYXRvcicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSAnLCcsICcuJywgJ9msJywgJ8uZJywgXCInXCIsICcgJywgJ1xcdTIwMDknLCAnXFx1MjAyZicsICdcXHUwMGEwJyBvciBlbXB0eSAoJycpLCBbJHtvcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3J9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnNob3dPbmx5TnVtYmVyc09uRm9jdXMpICYmICFBdXRvTnVtZXJpY0hlbHBlci5pc0Jvb2xlYW4ob3B0aW9ucy5zaG93T25seU51bWJlcnNPbkZvY3VzKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlICdzaG93T25seU51bWJlcnNPbkZvY3VzJyBvcHRpb24gaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuc2hvd09ubHlOdW1iZXJzT25Gb2N1c31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5kaWdpdGFsR3JvdXBTcGFjaW5nKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGRpZ2l0YWwgZ3JvdXBpbmcgZm9yIHRob3VzYW5kIHNlcGFyYXRvciBvcHRpb24gJ2RpZ2l0YWxHcm91cFNwYWNpbmcnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLmRpZ2l0YWxHcm91cFNwYWNpbmd9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNJbkFycmF5KG9wdGlvbnMuZGVjaW1hbENoYXJhY3RlciwgW1xuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyLmNvbW1hLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyLmRvdCxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbENoYXJhY3Rlci5taWRkbGVEb3QsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXIuYXJhYmljRGVjaW1hbFNlcGFyYXRvcixcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbENoYXJhY3Rlci5kZWNpbWFsU2VwYXJhdG9yS2V5U3ltYm9sLFxuICAgICAgICBdKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGRlY2ltYWwgc2VwYXJhdG9yIGNoYXJhY3RlciBvcHRpb24gJ2RlY2ltYWxDaGFyYWN0ZXInIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgJy4nLCAnLCcsICfCtycsICfijpYnIG9yICfZqycsIFske29wdGlvbnMuZGVjaW1hbENoYXJhY3Rlcn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBkZWNpbWFsIGFuZCB0aG91c2FuZCBjaGFyYWN0ZXJzIGFyZSB0aGUgc2FtZVxuICAgICAgICBpZiAob3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyID09PSBvcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYGF1dG9OdW1lcmljIHdpbGwgbm90IGZ1bmN0aW9uIHByb3Blcmx5IHdoZW4gdGhlIGRlY2ltYWwgY2hhcmFjdGVyICdkZWNpbWFsQ2hhcmFjdGVyJyBbJHtvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXJ9XSBhbmQgdGhlIHRob3VzYW5kIHNlcGFyYXRvciAnZGlnaXRHcm91cFNlcGFyYXRvcicgWyR7b3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yfV0gYXJlIHRoZSBzYW1lIGNoYXJhY3Rlci5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKG9wdGlvbnMuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSAmJiAhQXV0b051bWVyaWNIZWxwZXIuaXNTdHJpbmcob3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgYWx0ZXJuYXRlIGRlY2ltYWwgc2VwYXJhdG9yIGNoYXJhY3RlciBvcHRpb24gJ2RlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZywgWyR7b3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmN1cnJlbmN5U3ltYm9sICE9PSAnJyAmJiAhQXV0b051bWVyaWNIZWxwZXIuaXNTdHJpbmcob3B0aW9ucy5jdXJyZW5jeVN5bWJvbCkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBjdXJyZW5jeSBzeW1ib2wgb3B0aW9uICdjdXJyZW5jeVN5bWJvbCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZywgWyR7b3B0aW9ucy5jdXJyZW5jeVN5bWJvbH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc0luQXJyYXkob3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCwgW1xuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5wcmVmaXgsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnN1ZmZpeCxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBwbGFjZW1lbnQgb2YgdGhlIGN1cnJlbmN5IHNpZ24gb3B0aW9uICdjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ3AnIChwcmVmaXgpIG9yICdzJyAoc3VmZml4KSwgWyR7b3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc0luQXJyYXkob3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCwgW1xuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5wcmVmaXgsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnN1ZmZpeCxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQubGVmdCxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucmlnaHQsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50Lm5vbmUsXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgcGxhY2VtZW50IG9mIHRoZSBuZWdhdGl2ZSBzaWduIG9wdGlvbiAnbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdwJyAocHJlZml4KSwgJ3MnIChzdWZmaXgpLCAnbCcgKGxlZnQpLCAncicgKHJpZ2h0KSBvciAnbnVsbCcsIFske29wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnR9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnNob3dQb3NpdGl2ZVNpZ24pICYmICFBdXRvTnVtZXJpY0hlbHBlci5pc0Jvb2xlYW4ob3B0aW9ucy5zaG93UG9zaXRpdmVTaWduKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIHNob3cgcG9zaXRpdmUgc2lnbiBvcHRpb24gJ3Nob3dQb3NpdGl2ZVNpZ24nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLnNob3dQb3NpdGl2ZVNpZ259XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNTdHJpbmcob3B0aW9ucy5zdWZmaXhUZXh0KSB8fCAob3B0aW9ucy5zdWZmaXhUZXh0ICE9PSAnJyAmJiAoQXV0b051bWVyaWNIZWxwZXIuaXNOZWdhdGl2ZShvcHRpb25zLnN1ZmZpeFRleHQpIHx8IHRlc3ROdW1lcmljYWxDaGFyYWN0ZXJzLnRlc3Qob3B0aW9ucy5zdWZmaXhUZXh0KSkpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgYWRkaXRpb25hbCBzdWZmaXggb3B0aW9uICdzdWZmaXhUZXh0JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIG5vdCBjb250YWlucyB0aGUgbmVnYXRpdmUgc2lnbiAnLScgbm9yIGFueSBudW1lcmljYWwgY2hhcmFjdGVycywgWyR7b3B0aW9ucy5zdWZmaXhUZXh0fV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zLm92ZXJyaWRlTWluTWF4TGltaXRzKSAmJiAhQXV0b051bWVyaWNIZWxwZXIuaXNJbkFycmF5KG9wdGlvbnMub3ZlcnJpZGVNaW5NYXhMaW1pdHMsIFtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMub3ZlcnJpZGVNaW5NYXhMaW1pdHMuY2VpbGluZyxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMub3ZlcnJpZGVNaW5NYXhMaW1pdHMuZmxvb3IsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm92ZXJyaWRlTWluTWF4TGltaXRzLmlnbm9yZSxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBvdmVycmlkZSBtaW4gJiBtYXggbGltaXRzIG9wdGlvbiAnb3ZlcnJpZGVNaW5NYXhMaW1pdHMnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdjZWlsaW5nJywgJ2Zsb29yJyBvciAnaWdub3JlJywgWyR7b3B0aW9ucy5vdmVycmlkZU1pbk1heExpbWl0c31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1N0cmluZyhvcHRpb25zLm1heGltdW1WYWx1ZSkgfHwgIXRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduLnRlc3Qob3B0aW9ucy5tYXhpbXVtVmFsdWUpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gJ21heGltdW1WYWx1ZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMubWF4aW11bVZhbHVlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzU3RyaW5nKG9wdGlvbnMubWluaW11bVZhbHVlKSB8fCAhdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24udGVzdChvcHRpb25zLm1pbmltdW1WYWx1ZSkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiAnbWluaW11bVZhbHVlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIG51bWJlciwgWyR7b3B0aW9ucy5taW5pbXVtVmFsdWV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZUZsb2F0KG9wdGlvbnMubWluaW11bVZhbHVlKSA+IHBhcnNlRmxvYXQob3B0aW9ucy5tYXhpbXVtVmFsdWUpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiA7ICdtaW5pbXVtVmFsdWUnIFske29wdGlvbnMubWluaW11bVZhbHVlfV0gc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiAnbWF4aW11bVZhbHVlJyBbJHtvcHRpb25zLm1heGltdW1WYWx1ZX1dLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoKEF1dG9OdW1lcmljSGVscGVyLmlzSW50KG9wdGlvbnMuZGVjaW1hbFBsYWNlcykgJiYgb3B0aW9ucy5kZWNpbWFsUGxhY2VzID49IDApIHx8IC8vIElmIGludGVnZXIgb3B0aW9uXG4gICAgICAgICAgICAoQXV0b051bWVyaWNIZWxwZXIuaXNTdHJpbmcob3B0aW9ucy5kZWNpbWFsUGxhY2VzKSAmJiB0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5kZWNpbWFsUGxhY2VzKSkpIC8vIElmIHN0cmluZyBvcHRpb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9wdGlvbiAnZGVjaW1hbFBsYWNlcycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlKSB8fFxuICAgICAgICAgICAgKEF1dG9OdW1lcmljSGVscGVyLmlzSW50KG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlKSAmJiBvcHRpb25zLmRlY2ltYWxQbGFjZXNSYXdWYWx1ZSA+PSAwKSB8fCAvLyBJZiBpbnRlZ2VyIG9wdGlvblxuICAgICAgICAgICAgKEF1dG9OdW1lcmljSGVscGVyLmlzU3RyaW5nKG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlKSAmJiB0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5kZWNpbWFsUGxhY2VzUmF3VmFsdWUpKSkgLy8gSWYgc3RyaW5nIG9wdGlvblxuICAgICAgICApIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIHRoZSByYXcgdmFsdWUgb3B0aW9uICdkZWNpbWFsUGxhY2VzUmF3VmFsdWUnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIFxcYG51bGxcXGAsIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVja3MgaWYgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgdGhlIHJhdyB2YWx1ZSBpcyBsb3dlciB0aGFuIHRoZSBgZGVjaW1hbFBsYWNlc2AsIGBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzYCBhbmQvb3IgYGRlY2ltYWxQbGFjZXNTaG93bk9uQmx1cmAgb3B0aW9uc1xuICAgICAgICB0aGlzLl92YWxpZGF0ZURlY2ltYWxQbGFjZXNSYXdWYWx1ZShvcHRpb25zKTtcblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpICYmXG4gICAgICAgICAgICAhdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KFN0cmluZyhvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIG51bWJlciBvZiBleHBhbmRlZCBkZWNpbWFsIHBsYWNlcyBvcHRpb24gJ2RlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIFxcYG51bGxcXGAsIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlcyBcImRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXNcIiBpcyBncmVhdGVyIHRoYW4gdGhlIGRlY2ltYWwgcGxhY2VzIG51bWJlciBgZGVjaW1hbFBsYWNlc2BcbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSAmJiBOdW1iZXIob3B0aW9ucy5kZWNpbWFsUGxhY2VzKSA+IE51bWJlcihvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci53YXJuaW5nKGBUaGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXMgJ2RlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMnIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c31dIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gdGhlICdkZWNpbWFsUGxhY2VzJyBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXN9XSB2YWx1ZS4gQ3VycmVudGx5LCB0aGlzIHdpbGwgbGltaXQgdGhlIGFiaWxpdHkgb2YgeW91ciB1c2VyIHRvIG1hbnVhbGx5IGNoYW5nZSBzb21lIG9mIHRoZSBkZWNpbWFsIHBsYWNlcy4gRG8geW91IHJlYWxseSB3YW50IHRvIGRvIHRoYXQ/YCwgb3B0aW9ucy5zaG93V2FybmluZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9ucy5kaXZpc29yV2hlblVuZm9jdXNlZCkgJiZcbiAgICAgICAgICAgICF0ZXN0UG9zaXRpdmVGbG9hdE9ySW50ZWdlci50ZXN0KG9wdGlvbnMuZGl2aXNvcldoZW5VbmZvY3VzZWQpIHx8XG4gICAgICAgICAgICBvcHRpb25zLmRpdmlzb3JXaGVuVW5mb2N1c2VkID09PSAwIHx8IG9wdGlvbnMuZGl2aXNvcldoZW5VbmZvY3VzZWQgPT09ICcwJyB8fFxuICAgICAgICAgICAgb3B0aW9ucy5kaXZpc29yV2hlblVuZm9jdXNlZCA9PT0gMSB8fCBvcHRpb25zLmRpdmlzb3JXaGVuVW5mb2N1c2VkID09PSAnMScpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBkaXZpc29yIG9wdGlvbiAnZGl2aXNvcldoZW5VbmZvY3VzZWQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBudW1iZXIgaGlnaGVyIHRoYW4gb25lLCBwcmVmZXJhYmx5IGFuIGludGVnZXIsIFske29wdGlvbnMuZGl2aXNvcldoZW5VbmZvY3VzZWR9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25CbHVyKSAmJiAhdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25CbHVyKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIG51bWJlciBvZiBkZWNpbWFscyBzaG93biB3aGVuIHVuZm9jdXNlZCBvcHRpb24gJ2RlY2ltYWxQbGFjZXNTaG93bk9uQmx1cicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgXFxgbnVsbFxcYCwgWyR7b3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkJsdXJ9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKG9wdGlvbnMuc3ltYm9sV2hlblVuZm9jdXNlZCkgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzU3RyaW5nKG9wdGlvbnMuc3ltYm9sV2hlblVuZm9jdXNlZCkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBzeW1ib2wgdG8gc2hvdyB3aGVuIHVuZm9jdXNlZCBvcHRpb24gJ3N5bWJvbFdoZW5VbmZvY3VzZWQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcsIFske29wdGlvbnMuc3ltYm9sV2hlblVuZm9jdXNlZH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzQm9vbGVhbihvcHRpb25zLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgc2F2ZSB0byBzZXNzaW9uIHN0b3JhZ2Ugb3B0aW9uICdzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzSW5BcnJheShvcHRpb25zLm9uSW52YWxpZFBhc3RlLCBbXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm9uSW52YWxpZFBhc3RlLmVycm9yLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5vbkludmFsaWRQYXN0ZS5pZ25vcmUsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm9uSW52YWxpZFBhc3RlLmNsYW1wLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5vbkludmFsaWRQYXN0ZS50cnVuY2F0ZSxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMub25JbnZhbGlkUGFzdGUucmVwbGFjZSxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBwYXN0ZSBiZWhhdmlvciBvcHRpb24gJ29uSW52YWxpZFBhc3RlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnZXJyb3InLCAnaWdub3JlJywgJ2NsYW1wJywgJ3RydW5jYXRlJyBvciAncmVwbGFjZScgKGNmLiBkb2N1bWVudGF0aW9uKSwgWyR7b3B0aW9ucy5vbkludmFsaWRQYXN0ZX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc0luQXJyYXkob3B0aW9ucy5yb3VuZGluZ01ldGhvZCwgW1xuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC5oYWxmVXBTeW1tZXRyaWMsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLnJvdW5kaW5nTWV0aG9kLmhhbGZVcEFzeW1tZXRyaWMsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLnJvdW5kaW5nTWV0aG9kLmhhbGZEb3duU3ltbWV0cmljLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC5oYWxmRG93bkFzeW1tZXRyaWMsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLnJvdW5kaW5nTWV0aG9kLmhhbGZFdmVuQmFua2Vyc1JvdW5kaW5nLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC51cFJvdW5kQXdheUZyb21aZXJvLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC5kb3duUm91bmRUb3dhcmRaZXJvLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC50b0NlaWxpbmdUb3dhcmRQb3NpdGl2ZUluZmluaXR5LFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC50b0Zsb29yVG93YXJkTmVnYXRpdmVJbmZpbml0eSxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QudG9OZWFyZXN0MDUsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLnJvdW5kaW5nTWV0aG9kLnRvTmVhcmVzdDA1QWx0LFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC51cFRvTmV4dDA1LFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC5kb3duVG9OZXh0MDUsXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgcm91bmRpbmcgbWV0aG9kIG9wdGlvbiAncm91bmRpbmdNZXRob2QnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdTJywgJ0EnLCAncycsICdhJywgJ0InLCAnVScsICdEJywgJ0MnLCAnRicsICdOMDUnLCAnQ0hGJywgJ1UwNScgb3IgJ0QwNScgKGNmLiBkb2N1bWVudGF0aW9uKSwgWyR7b3B0aW9ucy5yb3VuZGluZ01ldGhvZH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9ucy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cikgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzSW5BcnJheShvcHRpb25zLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyLCBbXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyLnBhcmVudGhlc2VzLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ci5icmFja2V0cyxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIuY2hldnJvbnMsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyLmN1cmx5QnJhY2VzLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ci5hbmdsZUJyYWNrZXRzLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ci5qYXBhbmVzZVF1b3RhdGlvbk1hcmtzLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ci5oYWxmQnJhY2tldHMsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyLndoaXRlU3F1YXJlQnJhY2tldHMsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyLnF1b3RhdGlvbk1hcmtzLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ci5ndWlsbGVtZXRzLFxuICAgICAgICBdKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGJyYWNrZXRzIGZvciBuZWdhdGl2ZSB2YWx1ZXMgb3B0aW9uICduZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJygsKScsICdbLF0nLCAnPCw+JywgJ3ssfScsICfjgIgs44CJJywgJ++9oizvvaMnLCAn4rikLOK4pScsICfin6Ys4p+nJywgJ+KAuSzigLonIG9yICfCqyzCuycsIFske29wdGlvbnMubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXJ9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNJbkFycmF5KG9wdGlvbnMuZW1wdHlJbnB1dEJlaGF2aW9yLCBbXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvci5mb2N1cyxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuZW1wdHlJbnB1dEJlaGF2aW9yLnByZXNzLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3IuYWx3YXlzLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3IuemVybyxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuZW1wdHlJbnB1dEJlaGF2aW9yLm51bGwsXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgZGlzcGxheSBvbiBlbXB0eSBzdHJpbmcgb3B0aW9uICdlbXB0eUlucHV0QmVoYXZpb3InIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdmb2N1cycsICdwcmVzcycsICdhbHdheXMnLCAnemVybycgb3IgJ251bGwnLCBbJHtvcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvcn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZW1wdHlJbnB1dEJlaGF2aW9yID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvci56ZXJvICYmXG4gICAgICAgICAgICAob3B0aW9ucy5taW5pbXVtVmFsdWUgPiAwIHx8IG9wdGlvbnMubWF4aW11bVZhbHVlIDwgMCkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSAnZW1wdHlJbnB1dEJlaGF2aW9yJyBvcHRpb24gaXMgc2V0IHRvICd6ZXJvJywgYnV0IHRoaXMgdmFsdWUgaXMgb3V0c2lkZSBvZiB0aGUgcmFuZ2UgZGVmaW5lZCBieSAnbWluaW11bVZhbHVlJyBhbmQgJ21heGltdW1WYWx1ZScgWyR7b3B0aW9ucy5taW5pbXVtVmFsdWV9LCAke29wdGlvbnMubWF4aW11bVZhbHVlfV0uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzSW5BcnJheShvcHRpb25zLmxlYWRpbmdaZXJvLCBbXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLmxlYWRpbmdaZXJvLmFsbG93LFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5sZWFkaW5nWmVyby5kZW55LFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5sZWFkaW5nWmVyby5rZWVwLFxuICAgICAgICBdKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGxlYWRpbmcgemVybyBiZWhhdmlvciBvcHRpb24gJ2xlYWRpbmdaZXJvJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnYWxsb3cnLCAnZGVueScgb3IgJ2tlZXAnLCBbJHtvcHRpb25zLmxlYWRpbmdaZXJvfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5mb3JtYXRPblBhZ2VMb2FkKSAmJiAhQXV0b051bWVyaWNIZWxwZXIuaXNCb29sZWFuKG9wdGlvbnMuZm9ybWF0T25QYWdlTG9hZCkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBmb3JtYXQgb24gaW5pdGlhbGl6YXRpb24gb3B0aW9uICdmb3JtYXRPblBhZ2VMb2FkJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5mb3JtYXRPblBhZ2VMb2FkfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRlc3RQb3NpdGl2ZUludGVnZXIudGVzdChvcHRpb25zLmhpc3RvcnlTaXplKSB8fCBvcHRpb25zLmhpc3RvcnlTaXplID09PSAwKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgaGlzdG9yeSBzaXplIG9wdGlvbiAnaGlzdG9yeVNpemUnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLmhpc3RvcnlTaXplfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5zZWxlY3ROdW1iZXJPbmx5KSAmJiAhQXV0b051bWVyaWNIZWxwZXIuaXNCb29sZWFuKG9wdGlvbnMuc2VsZWN0TnVtYmVyT25seSkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBzZWxlY3QgbnVtYmVyIG9ubHkgb3B0aW9uICdzZWxlY3ROdW1iZXJPbmx5JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5zZWxlY3ROdW1iZXJPbmx5fV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5zZWxlY3RPbkZvY3VzKSAmJiAhQXV0b051bWVyaWNIZWxwZXIuaXNCb29sZWFuKG9wdGlvbnMuc2VsZWN0T25Gb2N1cykpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBzZWxlY3Qgb24gZm9jdXMgb3B0aW9uICdzZWxlY3RPbkZvY3VzJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5zZWxlY3RPbkZvY3VzfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zLmRlZmF1bHRWYWx1ZU92ZXJyaWRlKSAmJiAob3B0aW9ucy5kZWZhdWx0VmFsdWVPdmVycmlkZSAhPT0gJycgJiYgIXRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduLnRlc3Qob3B0aW9ucy5kZWZhdWx0VmFsdWVPdmVycmlkZSkpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgdW5mb3JtYXR0ZWQgZGVmYXVsdCB2YWx1ZSBvcHRpb24gJ2RlZmF1bHRWYWx1ZU92ZXJyaWRlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIG51bWJlciwgWyR7b3B0aW9ucy5kZWZhdWx0VmFsdWVPdmVycmlkZX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMudW5mb3JtYXRPblN1Ym1pdCkgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzQm9vbGVhbihvcHRpb25zLnVuZm9ybWF0T25TdWJtaXQpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgcmVtb3ZlIGZvcm1hdHRpbmcgb24gc3VibWl0IG9wdGlvbiAndW5mb3JtYXRPblN1Ym1pdCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMudW5mb3JtYXRPblN1Ym1pdH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9ucy52YWx1ZXNUb1N0cmluZ3MpICYmXG4gICAgICAgICAgICAhKEF1dG9OdW1lcmljSGVscGVyLmlzT2JqZWN0KG9wdGlvbnMudmFsdWVzVG9TdHJpbmdzKSkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBvcHRpb24gJ3ZhbHVlc1RvU3RyaW5ncycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhbiBvYmplY3QsIGlkZWFsbHkgd2l0aCAna2V5IC0+IHZhbHVlJyBlbnRyaWVzLCBbJHtvcHRpb25zLnZhbHVlc1RvU3RyaW5nc31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9ucy5vdXRwdXRGb3JtYXQpICYmICFBdXRvTnVtZXJpY0hlbHBlci5pc0luQXJyYXkob3B0aW9ucy5vdXRwdXRGb3JtYXQsIFtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMub3V0cHV0Rm9ybWF0LnN0cmluZyxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMub3V0cHV0Rm9ybWF0Lm51bWJlcixcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMub3V0cHV0Rm9ybWF0LmRvdCxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMub3V0cHV0Rm9ybWF0Lm5lZ2F0aXZlRG90LFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5vdXRwdXRGb3JtYXQuY29tbWEsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm91dHB1dEZvcm1hdC5uZWdhdGl2ZUNvbW1hLFxuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5vdXRwdXRGb3JtYXQuZG90TmVnYXRpdmUsXG4gICAgICAgICAgICBBdXRvTnVtZXJpYy5vcHRpb25zLm91dHB1dEZvcm1hdC5jb21tYU5lZ2F0aXZlLFxuICAgICAgICBdKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGN1c3RvbSBsb2NhbGUgZm9ybWF0IG9wdGlvbiAnb3V0cHV0Rm9ybWF0JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSBudWxsLCAnc3RyaW5nJywgJ251bWJlcicsICcuJywgJy0uJywgJywnLCAnLSwnLCAnLi0nIG9yICcsLScsIFske29wdGlvbnMub3V0cHV0Rm9ybWF0fV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5pc0NhbmNlbGxhYmxlKSAmJiAhQXV0b051bWVyaWNIZWxwZXIuaXNCb29sZWFuKG9wdGlvbnMuaXNDYW5jZWxsYWJsZSkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBjYW5jZWxsYWJsZSBiZWhhdmlvciBvcHRpb24gJ2lzQ2FuY2VsbGFibGUnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmlzQ2FuY2VsbGFibGV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLm1vZGlmeVZhbHVlT25XaGVlbCkgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzQm9vbGVhbihvcHRpb25zLm1vZGlmeVZhbHVlT25XaGVlbCkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBpbmNyZW1lbnQvZGVjcmVtZW50IG9uIG1vdXNlIHdoZWVsIG9wdGlvbiAnbW9kaWZ5VmFsdWVPbldoZWVsJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5tb2RpZnlWYWx1ZU9uV2hlZWx9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKEF1dG9OdW1lcmljSGVscGVyLmlzU3RyaW5nKG9wdGlvbnMud2hlZWxTdGVwKSB8fCBBdXRvTnVtZXJpY0hlbHBlci5pc051bWJlcihvcHRpb25zLndoZWVsU3RlcCkpIHx8XG4gICAgICAgICAgICAob3B0aW9ucy53aGVlbFN0ZXAgIT09ICdwcm9ncmVzc2l2ZScgJiYgIXRlc3RQb3NpdGl2ZUZsb2F0T3JJbnRlZ2VyLnRlc3Qob3B0aW9ucy53aGVlbFN0ZXApKSB8fFxuICAgICAgICAgICAgTnVtYmVyKG9wdGlvbnMud2hlZWxTdGVwKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQSBzdGVwIGVxdWFsIHRvICcwJyBpcyByZWplY3RlZFxuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIHdoZWVsIHN0ZXAgdmFsdWUgb3B0aW9uICd3aGVlbFN0ZXAnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlIHRoZSBzdHJpbmcgJ3Byb2dyZXNzaXZlJywgb3IgYSBudW1iZXIgb3IgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgcG9zaXRpdmUgbnVtYmVyIChleGNsdWRpbmcgemVybyksIFske29wdGlvbnMud2hlZWxTdGVwfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzSW5BcnJheShvcHRpb25zLnNlcmlhbGl6ZVNwYWNlcywgW1xuICAgICAgICAgICAgQXV0b051bWVyaWMub3B0aW9ucy5zZXJpYWxpemVTcGFjZXMucGx1cyxcbiAgICAgICAgICAgIEF1dG9OdW1lcmljLm9wdGlvbnMuc2VyaWFsaXplU3BhY2VzLnBlcmNlbnQsXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgc3BhY2UgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIG9wdGlvbiAnc2VyaWFsaXplU3BhY2VzJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnKycgb3IgJyUyMCcsIFske29wdGlvbnMuc2VyaWFsaXplU3BhY2VzfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5ub0V2ZW50TGlzdGVuZXJzKSAmJiAhQXV0b051bWVyaWNIZWxwZXIuaXNCb29sZWFuKG9wdGlvbnMubm9FdmVudExpc3RlbmVycykpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBvcHRpb24gJ25vRXZlbnRMaXN0ZW5lcnMnIHRoYXQgcHJldmVudCB0aGUgY3JlYXRpb24gb2YgZXZlbnQgbGlzdGVuZXJzIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLm5vRXZlbnRMaXN0ZW5lcnN9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKG9wdGlvbnMuc3R5bGVSdWxlcykgJiZcbiAgICAgICAgICAgICEoQXV0b051bWVyaWNIZWxwZXIuaXNPYmplY3Qob3B0aW9ucy5zdHlsZVJ1bGVzKSAmJlxuICAgICAgICAgICAgKChvcHRpb25zLnN0eWxlUnVsZXMuaGFzT3duUHJvcGVydHkoJ3Bvc2l0aXZlJykgfHxcbiAgICAgICAgICAgIG9wdGlvbnMuc3R5bGVSdWxlcy5oYXNPd25Qcm9wZXJ0eSgnbmVnYXRpdmUnKSB8fFxuICAgICAgICAgICAgb3B0aW9ucy5zdHlsZVJ1bGVzLmhhc093blByb3BlcnR5KCdyYW5nZXMnKSB8fFxuICAgICAgICAgICAgb3B0aW9ucy5zdHlsZVJ1bGVzLmhhc093blByb3BlcnR5KCd1c2VyRGVmaW5lZCcpKSkpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgb3B0aW9uICdzdHlsZVJ1bGVzJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgY29ycmVjdGx5IHN0cnVjdHVyZWQgb2JqZWN0LCB3aXRoIG9uZSBvciBtb3JlICdwb3NpdGl2ZScsICduZWdhdGl2ZScsICdyYW5nZXMnIG9yICd1c2VyRGVmaW5lZCcgYXR0cmlidXRlcywgWyR7b3B0aW9ucy5zdHlsZVJ1bGVzfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWVwZXIgdGVzdHMgb2YgdGhlIGBzdHlsZVJ1bGVzYCBvYmplY3QgOiBDaGVjayB0aGF0IHRoZSBjYWxsYmFjaywgaWYgZGVmaW5lZCwgaXMgYSBmdW5jdGlvblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zLnN0eWxlUnVsZXMpICYmXG4gICAgICAgICAgICBvcHRpb25zLnN0eWxlUnVsZXMuaGFzT3duUHJvcGVydHkoJ3VzZXJEZWZpbmVkJykgJiZcbiAgICAgICAgICAgICFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9ucy5zdHlsZVJ1bGVzLnVzZXJEZWZpbmVkKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5zdHlsZVJ1bGVzLnVzZXJEZWZpbmVkLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuaGFzT3duUHJvcGVydHkoJ2NhbGxiYWNrJykgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzRnVuY3Rpb24ocnVsZS5jYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGNhbGxiYWNrIGRlZmluZWQgaW4gdGhlIFxcYHVzZXJEZWZpbmVkXFxgIGF0dHJpYnV0ZSBpcyBub3QgYSBmdW5jdGlvbiwgJHt0eXBlb2YgcnVsZS5jYWxsYmFja30gZ2l2ZW4uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zLnJhd1ZhbHVlRGl2aXNvcikgJiZcbiAgICAgICAgICAgICF0ZXN0UG9zaXRpdmVGbG9hdE9ySW50ZWdlci50ZXN0KG9wdGlvbnMucmF3VmFsdWVEaXZpc29yKSB8fFxuICAgICAgICAgICAgb3B0aW9ucy5yYXdWYWx1ZURpdmlzb3IgPT09IDAgfHwgb3B0aW9ucy5yYXdWYWx1ZURpdmlzb3IgPT09ICcwJyB8fFxuICAgICAgICAgICAgb3B0aW9ucy5yYXdWYWx1ZURpdmlzb3IgPT09IDEgfHwgb3B0aW9ucy5yYXdWYWx1ZURpdmlzb3IgPT09ICcxJykge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIHJhdyB2YWx1ZSBkaXZpc29yIG9wdGlvbiAncmF3VmFsdWVEaXZpc29yJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgbnVtYmVyIGhpZ2hlciB0aGFuIG9uZSwgcHJlZmVyYWJseSBhbiBpbnRlZ2VyLCBbJHtvcHRpb25zLnJhd1ZhbHVlRGl2aXNvcn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMucmVhZE9ubHkpICYmICFBdXRvTnVtZXJpY0hlbHBlci5pc0Jvb2xlYW4ob3B0aW9ucy5yZWFkT25seSkpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBvcHRpb24gJ3JlYWRPbmx5JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5yZWFkT25seX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMudW5mb3JtYXRPbkhvdmVyKSAmJiAhQXV0b051bWVyaWNIZWxwZXIuaXNCb29sZWFuKG9wdGlvbnMudW5mb3JtYXRPbkhvdmVyKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIG9wdGlvbiAndW5mb3JtYXRPbkhvdmVyJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy51bmZvcm1hdE9uSG92ZXJ9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLmZhaWxPblVua25vd25PcHRpb24pICYmICFBdXRvTnVtZXJpY0hlbHBlci5pc0Jvb2xlYW4ob3B0aW9ucy5mYWlsT25Vbmtub3duT3B0aW9uKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGRlYnVnIG9wdGlvbiAnZmFpbE9uVW5rbm93bk9wdGlvbicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuZmFpbE9uVW5rbm93bk9wdGlvbn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuY3JlYXRlTG9jYWxMaXN0KSAmJiAhQXV0b051bWVyaWNIZWxwZXIuaXNCb29sZWFuKG9wdGlvbnMuY3JlYXRlTG9jYWxMaXN0KSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGRlYnVnIG9wdGlvbiAnY3JlYXRlTG9jYWxMaXN0JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5jcmVhdGVMb2NhbExpc3R9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoZSBgZGVjaW1hbFBsYWNlcypgIG9wdGlvbnMgYW5kIG91dHB1dCB0aGUgcmVsZXZhbnQgd2FybmluZ3MgaWYgc29tZSBvZiB0aG9zZSB3aWxsIGdldCBvdmVyd3JpdHRlbiBkdXJpbmcgdGhlIGluaXRpYWxpemF0aW9uIG9yIHNldHRpbmdzIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX3ZhbGlkYXRlRGVjaW1hbFBsYWNlc1Jhd1ZhbHVlKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIHRoZSByYXcgdmFsdWUgaXMgbG93ZXIgdGhhbiB0aGUgYGRlY2ltYWxQbGFjZXNgLCBgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c2AgYW5kL29yIGBkZWNpbWFsUGxhY2VzU2hvd25PbkJsdXJgIG9wdGlvbnNcbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9ucy5kZWNpbWFsUGxhY2VzUmF3VmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWNpbWFsUGxhY2VzUmF3VmFsdWUgPCBvcHRpb25zLmRlY2ltYWxQbGFjZXMpIHtcbiAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci53YXJuaW5nKGBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRvIHN0b3JlIGluIHRoZSByYXcgdmFsdWUgWyR7b3B0aW9ucy5kZWNpbWFsUGxhY2VzUmF3VmFsdWV9XSBpcyBsb3dlciB0aGFuIHRoZSBvbmVzIHRvIGRpc3BsYXkgWyR7b3B0aW9ucy5kZWNpbWFsUGxhY2VzfV0uIFRoaXMgd2lsbCBsaWtlbHkgY29uZnVzZSB5b3VyIHVzZXJzLlxuVG8gc29sdmUgdGhhdCwgeW91J2QgbmVlZCB0byBlaXRoZXIgc2V0IFxcYGRlY2ltYWxQbGFjZXNSYXdWYWx1ZVxcYCB0byBcXGBudWxsXFxgLCBvciBzZXQgYSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIHRoZSByYXcgdmFsdWUgZXF1YWwgb2YgYmlnZ2VyIHRoYW4gXFxgZGVjaW1hbFBsYWNlc1xcYC5gLCBvcHRpb25zLnNob3dXYXJuaW5ncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlY2ltYWxQbGFjZXNSYXdWYWx1ZSA8IG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykge1xuICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLndhcm5pbmcoYFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdG8gc3RvcmUgaW4gdGhlIHJhdyB2YWx1ZSBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNSYXdWYWx1ZX1dIGlzIGxvd2VyIHRoYW4gdGhlIG9uZXMgc2hvd24gb24gZm9jdXMgWyR7b3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzfV0uIFRoaXMgd2lsbCBsaWtlbHkgY29uZnVzZSB5b3VyIHVzZXJzLlxuVG8gc29sdmUgdGhhdCwgeW91J2QgbmVlZCB0byBlaXRoZXIgc2V0IFxcYGRlY2ltYWxQbGFjZXNSYXdWYWx1ZVxcYCB0byBcXGBudWxsXFxgLCBvciBzZXQgYSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIHRoZSByYXcgdmFsdWUgZXF1YWwgb2YgYmlnZ2VyIHRoYW4gXFxgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c1xcYC5gLCBvcHRpb25zLnNob3dXYXJuaW5ncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlY2ltYWxQbGFjZXNSYXdWYWx1ZSA8IG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25CbHVyKSB7XG4gICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIud2FybmluZyhgVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0byBzdG9yZSBpbiB0aGUgcmF3IHZhbHVlIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlfV0gaXMgbG93ZXIgdGhhbiB0aGUgb25lcyBzaG93biB3aGVuIHVuZm9jdXNlZCBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uQmx1cn1dLiBUaGlzIHdpbGwgbGlrZWx5IGNvbmZ1c2UgeW91ciB1c2Vycy5cblRvIHNvbHZlIHRoYXQsIHlvdSdkIG5lZWQgdG8gZWl0aGVyIHNldCBcXGBkZWNpbWFsUGxhY2VzUmF3VmFsdWVcXGAgdG8gXFxgbnVsbFxcYCwgb3Igc2V0IGEgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciB0aGUgcmF3IHZhbHVlIGVxdWFsIG9mIGJpZ2dlciB0aGFuIFxcYGRlY2ltYWxQbGFjZXNTaG93bk9uQmx1clxcYC5gLCBvcHRpb25zLnNob3dXYXJuaW5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBzZXR0aW5ncy9vcHRpb25zIGFyZSB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBhcmVTZXR0aW5nc1ZhbGlkKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZShvcHRpb25zLCB0cnVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc1ZhbGlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZGVmYXVsdCBhdXRvTnVtZXJpYyBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgc3RhdGljIGdldERlZmF1bHRDb25maWcoKSB7XG4gICAgICAgIHJldHVybiBBdXRvTnVtZXJpYy5kZWZhdWx0U2V0dGluZ3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFsbCB0aGUgcHJlZGVmaW5lZCBsYW5ndWFnZSBvcHRpb25zIGluIG9uZSBvYmplY3QuXG4gICAgICogWW91IGNhbiBhbHNvIGFjY2VzcyBhIHNwZWNpZmljIGxhbmd1YWdlIG9iamVjdCBkaXJlY3RseSBieSB1c2luZyBgQXV0b051bWVyaWMuZ2V0UHJlZGVmaW5lZE9wdGlvbnMoKS5GcmVuY2hgIGZvciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgc3RhdGljIGdldFByZWRlZmluZWRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gQXV0b051bWVyaWMucHJlZGVmaW5lZE9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5hbHlzZSB0aGUgZ2l2ZW4gYXJyYXkgYG9wdGlvbnNgIGFuZCByZXR1cm4gYSBzaW5nbGUgJ21lcmdlZCcgb3B0aW9uIG9iamV0LlxuICAgICAqIGBvcHRpb25zYCBjYW4gYmUgYG51bGxgLCBvciBhbiBhcnJheSBvZiBhbiBvcHRpb24gb2JqZWN0cywgb3IgYW4gYXJyYXkgY29udGFpbmluZyBhbm90aGVyIGFycmF5IG9mIG9wdGlvbiBvYmplY3RzIC8gc3RyaW5ncyAocHJlLWRlZmluZWQgb3B0aW9uIG5hbWVzKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudWxsfEFycmF5PG9iamVjdHxzdHJpbmd8QXJyYXk8c3RyaW5nfG9iamVjdD4+fSBvcHRpb25zXG4gICAgICogQHJldHVybnMge251bGx8b2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9nZW5lcmF0ZU9wdGlvbnNPYmplY3RGcm9tT3B0aW9uc0FycmF5KG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IG9wdGlvbnNSZXN1bHQ7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkob3B0aW9ucykgfHwgb3B0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG9wdGlvbnNSZXN1bHQgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9uc1Jlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkob3B0aW9uc1swXSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zWzBdLmZvckVhY2gob3B0aW9uT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNpbmcgYF9nZXRPcHRpb25PYmplY3QoKWAgYWxsb3dzIHVzaW5nIHByZS1kZWZpbmVkIG5hbWVzIGluIHRoZSBgb3B0aW9uc2AgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zUmVzdWx0LCB0aGlzLl9nZXRPcHRpb25PYmplY3Qob3B0aW9uT2JqZWN0KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubGVuZ3RoID49IDEpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZvckVhY2gob3B0aW9uT2JqZWN0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zUmVzdWx0LCB0aGlzLl9nZXRPcHRpb25PYmplY3Qob3B0aW9uT2JqZWN0KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3B0aW9uc1Jlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgdGhlIGdpdmVuIG51bWJlciAob3IgbnVtZXJpYyBzdHJpbmcpIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuIFRoaXMgcmV0dXJucyB0aGUgZm9ybWF0dGVkIHZhbHVlIGFzIGEgc3RyaW5nLlxuICAgICAqIFRoaXMgY2FuIGFsc28gZm9ybWF0IHRoZSBnaXZlbiBET00gZWxlbWVudCB2YWx1ZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zIGFuZCByZXR1cm5zIHRoZSBmb3JtYXR0ZWQgdmFsdWUgYXMgYSBzdHJpbmcuXG4gICAgICogTm90ZSA6IFRoaXMgZnVuY3Rpb24gZG9lcyAqbm90KiB1cGRhdGUgdGhhdCBlbGVtZW50IHZhbHVlIHdpdGggdGhlIG5ld2x5IGZvcm1hdHRlZCB2YWx1ZS5cbiAgICAgKiBUaGlzIGJhc2ljYWxseSBhbGxvd3MgdG8gZ2V0IHRoZSBmb3JtYXR0ZWQgdmFsdWUgd2l0aG91dCBmaXJzdCBoYXZpbmcgdG8gaW5pdGlhbGl6ZSBhbiBBdXRvTnVtZXJpYyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8SFRNTEVsZW1lbnR8SFRNTElucHV0RWxlbWVudH0gbnVtZXJpY1N0cmluZ09yRG9tRWxlbWVudCBBIG51bWJlciwgb3IgYSBzdHJpbmcgdGhhdCByZXByZXNlbnQgYSBqYXZhc2NyaXB0IG51bWJlciwgb3IgYSBET00gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fG51bGx9IG9wdGlvbnMgTXVsdGlwbGUgb2JqZWN0cyBjYW4gYmUgcGFzc2VkLCB0aGUgbGF0dGVyIG92ZXJ3cml0aW5nIHRoZSBzZXR0aW5ncyBmcm9tIHRoZSBmb3JtZXIgb25lc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZm9ybWF0KG51bWVyaWNTdHJpbmdPckRvbUVsZW1lbnQsIC4uLm9wdGlvbnMpIHtcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkKG51bWVyaWNTdHJpbmdPckRvbUVsZW1lbnQpIHx8IG51bWVyaWNTdHJpbmdPckRvbUVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0cmlldmUgdGhlIHZhbHVlIHRvIGZvcm1hdFxuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc0VsZW1lbnQobnVtZXJpY1N0cmluZ09yRG9tRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKG51bWVyaWNTdHJpbmdPckRvbUVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBudW1lcmljU3RyaW5nT3JEb21FbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1N0cmluZyh2YWx1ZSkgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIHZhbHVlIFwiJHt2YWx1ZX1cIiBiZWluZyBcInNldFwiIGlzIG5vdCBudW1lcmljIGFuZCB0aGVyZWZvcmUgY2Fubm90IGJlIHVzZWQgYXBwcm9wcmlhdGVseS5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1hbmFnZSBvcHRpb25zXG4gICAgICAgIGNvbnN0IG9wdGlvbnNUb1VzZSA9IHRoaXMuX2dlbmVyYXRlT3B0aW9uc09iamVjdEZyb21PcHRpb25zQXJyYXkob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gSW5pdGlhdGUgYSB2ZXJ5IGJhc2ljIHNldHRpbmdzIG9iamVjdFxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0RGVmYXVsdENvbmZpZygpLCBvcHRpb25zVG9Vc2UpO1xuICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgPSAnLSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlZ2V4ID0ge307XG4gICAgICAgIHRoaXMuX2NhY2hlc1VzdWFsUmVndWxhckV4cHJlc3Npb25zKHNldHRpbmdzLCByZWdleCk7IC8vIFRoaXMgaXMgbmVlZGVkIGJ5IGBfc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzYCB0aGF0IHVzZXMgdGhvc2UgcmVnZXhcblxuICAgICAgICAvLyBDaGVjayB0aGUgdmFsaWRpdHkgb2YgdGhlIGB2YWx1ZWAgcGFyYW1ldGVyXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIGEgbnVtZXJpYyBzdHJpbmcsIHN0cmlwcGluZyB1bm5lY2Vzc2FyeSBjaGFyYWN0ZXJzIGluIHRoZSBwcm9jZXNzXG4gICAgICAgIGxldCB2YWx1ZVN0cmluZyA9IHRoaXMuX3RvTnVtZXJpY1ZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIGlmIChpc05hTihOdW1iZXIodmFsdWVTdHJpbmcpKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIHZhbHVlIFske3ZhbHVlU3RyaW5nfV0gdGhhdCB5b3UgYXJlIHRyeWluZyB0byBmb3JtYXQgaXMgbm90IGEgcmVjb2duaXplZCBudW1iZXIuYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCYXNpYyB0ZXN0cyB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWVTdHJpbmcgaXMgdmFsaWRcbiAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gdGhpcy5fY2hlY2tJZkluUmFuZ2VXaXRoT3ZlcnJpZGVPcHRpb24odmFsdWVTdHJpbmcsIHNldHRpbmdzKTtcbiAgICAgICAgaWYgKCFtaW5UZXN0IHx8ICFtYXhUZXN0KSB7XG4gICAgICAgICAgICAvLyBUaHJvdyBhIGN1c3RvbSBldmVudFxuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudHJpZ2dlckV2ZW50KEF1dG9OdW1lcmljLmV2ZW50cy5mb3JtYXR0ZWQsIGRvY3VtZW50LCAnUmFuZ2UgdGVzdCBmYWlsZWQnKTtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHt2YWx1ZVN0cmluZ31dIGJlaW5nIHNldCBmYWxscyBvdXRzaWRlIG9mIHRoZSBtaW5pbXVtVmFsdWUgWyR7c2V0dGluZ3MubWluaW11bVZhbHVlfV0gYW5kIG1heGltdW1WYWx1ZSBbJHtzZXR0aW5ncy5tYXhpbXVtVmFsdWV9XSByYW5nZSBzZXQgZm9yIHRoaXMgZWxlbWVudGApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgdGhlIGBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudGAgb3B0aW9uIGFzIG5lZWRlZFxuICAgICAgICB0aGlzLl9jb3JyZWN0TmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRPcHRpb24oc2V0dGluZ3MpO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG5lZWRlZCBkZWNpbWFsIHBsYWNlc1xuICAgICAgICB0aGlzLl9jYWxjdWxhdGVEZWNpbWFsUGxhY2VzT25Jbml0KHNldHRpbmdzKTtcblxuICAgICAgICAvLyBNdWx0aXBseSB0aGUgcmF3IHZhbHVlIHdpdGggYHJhd1ZhbHVlRGl2aXNvcmAgaWYgZGVmaW5lZFxuICAgICAgICBpZiAoKCFBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkoc2V0dGluZ3MucmF3VmFsdWVEaXZpc29yKSAmJiBzZXR0aW5ncy5yYXdWYWx1ZURpdmlzb3IgIT09IDApICYmIC8vIE9ubHkgZGl2aWRlIGlmIHRoZSBgcmF3VmFsdWVEaXZpc29yYCBvcHRpb24gaXMgc2V0XG4gICAgICAgICAgICB2YWx1ZVN0cmluZyAhPT0gJycgJiYgdmFsdWVTdHJpbmcgIT09IG51bGwpIHsgLy8gRG8gbm90IG1vZGlmeSB0aGUgYHZhbHVlU3RyaW5nYCBpZiBpdCdzIGFuIGVtcHR5IHN0cmluZyBvciBudWxsXG4gICAgICAgICAgICB2YWx1ZVN0cmluZyAqPSBzZXR0aW5ncy5yYXdWYWx1ZURpdmlzb3I7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFdmVyeXRoaW5nIGlzIG9rLCBwcm9jZWVkIHRvIHJvdW5kaW5nLCBmb3JtYXR0aW5nIGFuZCBncm91cGluZ1xuICAgICAgICB2YWx1ZVN0cmluZyA9IHRoaXMuX3JvdW5kRm9ybWF0dGVkVmFsdWVTaG93bk9uRm9jdXModmFsdWVTdHJpbmcsIHNldHRpbmdzKTtcbiAgICAgICAgdmFsdWVTdHJpbmcgPSB0aGlzLl9tb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yRm9ybWF0dGVkVmFsdWUodmFsdWVTdHJpbmcsIHNldHRpbmdzKTtcbiAgICAgICAgdmFsdWVTdHJpbmcgPSB0aGlzLl9hZGRHcm91cFNlcGFyYXRvcnModmFsdWVTdHJpbmcsIHNldHRpbmdzLCBmYWxzZSwgdmFsdWVTdHJpbmcpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZVN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgdGhlIGdpdmVuIERPTSBlbGVtZW50IHZhbHVlLCBhbmQgc2V0IHRoZSByZXN1bHRpbmcgdmFsdWUgYmFjayBhcyB0aGUgZWxlbWVudCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTElucHV0RWxlbWVudH0gZG9tRWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHN0YXRpYyBmb3JtYXRBbmRTZXQoZG9tRWxlbWVudCwgb3B0aW9ucyA9IG51bGwpIHsgLy9GSVhNRSB0ZXN0IHRoaXNcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkVmFsdWUgPSB0aGlzLmZvcm1hdChkb21FbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuc2V0RWxlbWVudFZhbHVlKGRvbUVsZW1lbnQsIGZvcm1hdHRlZFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5mb3JtYXQgdGhlIGdpdmVuIGZvcm1hdHRlZCBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy4gVGhpcyByZXR1cm5zIGEgbnVtZXJpYyBzdHJpbmcuXG4gICAgICogSXQgY2FuIGFsc28gdW5mb3JtYXQgdGhlIGdpdmVuIERPTSBlbGVtZW50IHZhbHVlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMgYW5kIHJldHVybnMgdGhlIHVuZm9ybWF0dGVkIG51bWVyaWMgc3RyaW5nLlxuICAgICAqIE5vdGU6IFRoaXMgZG9lcyAqbm90KiB1cGRhdGUgdGhhdCBlbGVtZW50IHZhbHVlLlxuICAgICAqIFRoaXMgYmFzaWNhbGx5IGFsbG93cyB0byBnZXQgdGhlIHVuZm9ybWF0dGVkIHZhbHVlIHdpdGhvdXQgZmlyc3QgaGF2aW5nIHRvIGluaXRpYWxpemUgYW4gQXV0b051bWVyaWMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfEhUTUxFbGVtZW50fEhUTUxJbnB1dEVsZW1lbnR9IG51bWVyaWNTdHJpbmdPckRvbUVsZW1lbnQgQSBudW1iZXIsIG9yIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50IGEgamF2YXNjcmlwdCBudW1iZXIsIG9yIGEgRE9NIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBvcHRpb25zIE11bHRpcGxlIG9iamVjdHMgY2FuIGJlIHBhc3NlZCwgdGhlIGxhdHRlciBvdmVyd3JpdGluZyB0aGUgc2V0dGluZ3MgZnJvbSB0aGUgZm9ybWVyIG9uZXNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bWJlcnxOYU59XG4gICAgICovXG4gICAgc3RhdGljIHVuZm9ybWF0KG51bWVyaWNTdHJpbmdPckRvbUVsZW1lbnQsIC4uLm9wdGlvbnMpIHtcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVtYmVyU3RyaWN0KG51bWVyaWNTdHJpbmdPckRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgICAvLyBHaXZpbmcgYW4gdW5mb3JtYXR0ZWQgdmFsdWUgc2hvdWxkIHJldHVybiB0aGUgc2FtZSB1bmZvcm1hdHRlZCB2YWx1ZSwgd2hhdGV2ZXIgdGhlIG9wdGlvbnMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyXG4gICAgICAgICAgICByZXR1cm4gbnVtZXJpY1N0cmluZ09yRG9tRWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHJpZXZlIHRoZSB2YWx1ZSB0byB1bmZvcm1hdFxuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc0VsZW1lbnQobnVtZXJpY1N0cmluZ09yRG9tRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKG51bWVyaWNTdHJpbmdPckRvbUVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBudW1lcmljU3RyaW5nT3JEb21FbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNBcnJheSh2YWx1ZSkgfHwgQXV0b051bWVyaWNIZWxwZXIuaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgdmFsaWRpdHkgb2YgdGhlIGB2YWx1ZWAgcGFyYW1ldGVyXG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBBIG51bWJlciBvciBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBudW1iZXIgaXMgbmVlZGVkIHRvIGJlIGFibGUgdG8gdW5mb3JtYXQgaXQsIFske3ZhbHVlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYW5hZ2Ugb3B0aW9uc1xuICAgICAgICBjb25zdCBvcHRpb25zVG9Vc2UgPSB0aGlzLl9nZW5lcmF0ZU9wdGlvbnNPYmplY3RGcm9tT3B0aW9uc0FycmF5KG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIEdlbmVyYXRlIHRoZSBzZXR0aW5nc1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0RGVmYXVsdENvbmZpZygpLCBvcHRpb25zVG9Vc2UpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgLy8gVGhpcyBjaGVja3MgaWYgYSBuZWdhdGl2ZSBzaWduIGlzIGFueXdoZXJlIGluIHRoZSBgdmFsdWVgLCBub3QganVzdCBvbiB0aGUgdmVyeSBmaXJzdCBjaGFyYWN0ZXIgKGllLiAnMTIzNDUuNjctJylcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTmVnYXRpdmUodmFsdWUpKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgPSAnLSc7XG4gICAgICAgIH0gZWxzZSBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cikpIHtcbiAgICAgICAgICAgIFtzZXR0aW5ncy5maXJzdEJyYWNrZXQsIHNldHRpbmdzLmxhc3RCcmFja2V0XSA9IHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBpZiAodmFsdWUuY2hhckF0KDApID09PSBzZXR0aW5ncy5maXJzdEJyYWNrZXQgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZS5jaGFyQXQodmFsdWUubGVuZ3RoIC0gMSkgPT09IHNldHRpbmdzLmxhc3RCcmFja2V0KSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyID0gJy0nO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fcmVtb3ZlQnJhY2tldHModmFsdWUsIHNldHRpbmdzLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHRoaXMuX2NvbnZlcnRUb051bWVyaWNTdHJpbmcodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgY29uc3QgdW53YW50ZWRDaGFyYWN0ZXJzID0gbmV3IFJlZ0V4cChgW14rLTAxMjM0NTY3ODkuXWAsICdnaScpO1xuICAgICAgICBpZiAodW53YW50ZWRDaGFyYWN0ZXJzLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgdGhlIGBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudGAgb3B0aW9uIGFzIG5lZWRlZFxuICAgICAgICB0aGlzLl9jb3JyZWN0TmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRPcHRpb24oc2V0dGluZ3MpO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG5lZWRlZCBkZWNpbWFsIHBsYWNlc1xuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlKSB7IC8vIGBvcmlnaW5hbERlY2ltYWxQbGFjZXNSYXdWYWx1ZWAgbmVlZHMgdG8gYmUgZGVmaW5lZFxuICAgICAgICAgICAgc2V0dGluZ3Mub3JpZ2luYWxEZWNpbWFsUGxhY2VzUmF3VmFsdWUgPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzUmF3VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5vcmlnaW5hbERlY2ltYWxQbGFjZXNSYXdWYWx1ZSA9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVEZWNpbWFsUGxhY2VzT25Jbml0KHNldHRpbmdzKTtcblxuICAgICAgICAvLyBEaXZpZGUgdGhlIHJhdyB2YWx1ZSB3aXRoIGByYXdWYWx1ZURpdmlzb3JgIGlmIGRlZmluZWRcbiAgICAgICAgaWYgKCghQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHNldHRpbmdzLnJhd1ZhbHVlRGl2aXNvcikgJiYgc2V0dGluZ3MucmF3VmFsdWVEaXZpc29yICE9PSAwKSAmJiAvLyBPbmx5IGRpdmlkZSBpZiB0aGUgYHJhd1ZhbHVlRGl2aXNvcmAgb3B0aW9uIGlzIHNldFxuICAgICAgICAgICAgdmFsdWUgIT09ICcnICYmIHZhbHVlICE9PSBudWxsKSB7IC8vIERvIG5vdCBtb2RpZnkgdGhlIGB2YWx1ZWAgaWYgaXQncyBhbiBlbXB0eSBzdHJpbmcgb3IgbnVsbFxuICAgICAgICAgICAgdmFsdWUgLz0gc2V0dGluZ3MucmF3VmFsdWVEaXZpc29yO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YWx1ZSA9IHRoaXMuX3JvdW5kUmF3VmFsdWUodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIsICcuJyk7IC8vIEhlcmUgd2UgbmVlZCB0byBjb252ZXJ0IGJhY2sgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIHRvIGEgcGVyaW9kIHNpbmNlIGBfcm91bmRWYWx1ZWAgYWRkcyBpdCBpbiBzb21lIGNhc2VzXG4gICAgICAgIHZhbHVlID0gdGhpcy5fdG9Mb2NhbGUodmFsdWUsIHNldHRpbmdzLm91dHB1dEZvcm1hdCk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVuZm9ybWF0IHRoZSBnaXZlbiBET00gZWxlbWVudCB2YWx1ZSwgYW5kIHNldCB0aGUgcmVzdWx0aW5nIHZhbHVlIGJhY2sgYXMgdGhlIGVsZW1lbnQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fEhUTUxJbnB1dEVsZW1lbnR9IGRvbUVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHN0YXRpYyB1bmZvcm1hdEFuZFNldChkb21FbGVtZW50LCBvcHRpb25zID0gbnVsbCkgeyAvL0ZJWE1FIHRlc3QgdGhpc1xuICAgICAgICBjb25zdCB1bmZvcm1hdHRlZFZhbHVlID0gdGhpcy51bmZvcm1hdChkb21FbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuc2V0RWxlbWVudFZhbHVlKGRvbUVsZW1lbnQsIHVuZm9ybWF0dGVkVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiB1bmZvcm1hdHRlZFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVuZm9ybWF0IGFuZCBsb2NhbGl6ZSB0aGUgZ2l2ZW4gZm9ybWF0dGVkIHN0cmluZyB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLiBUaGlzIHJldHVybnMgYSBudW1lcmljIHN0cmluZy5cbiAgICAgKiBJdCBjYW4gYWxzbyB1bmZvcm1hdCBhbmQgbG9jYWxpemUgdGhlIGdpdmVuIERPTSBlbGVtZW50IHZhbHVlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMgYW5kIHJldHVybnMgdGhlIHVuZm9ybWF0dGVkIG51bWVyaWMgc3RyaW5nLlxuICAgICAqIE5vdGU6IFRoaXMgZG9lcyAqbm90KiB1cGRhdGUgdGhhdCBlbGVtZW50IHZhbHVlLlxuICAgICAqIFRoaXMgYmFzaWNhbGx5IGFsbG93cyB0byBnZXQgdGhlIGxvY2FsaXplZCB2YWx1ZSB3aXRob3V0IGZpcnN0IGhhdmluZyB0byBpbml0aWFsaXplIGFuIEF1dG9OdW1lcmljIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxIVE1MRWxlbWVudHxIVE1MSW5wdXRFbGVtZW50fSBudW1lcmljU3RyaW5nT3JEb21FbGVtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzdGF0aWMgbG9jYWxpemUobnVtZXJpY1N0cmluZ09yRG9tRWxlbWVudCwgb3B0aW9ucyA9IG51bGwpIHtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNFbGVtZW50KG51bWVyaWNTdHJpbmdPckRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZShudW1lcmljU3RyaW5nT3JEb21FbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVtZXJpY1N0cmluZ09yRG9tRWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9ucykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBBdXRvTnVtZXJpYy5kZWZhdWx0U2V0dGluZ3M7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHRoaXMudW5mb3JtYXQodmFsdWUsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vWFhYIFRoZSBmb2xsb3dpbmcgY29kZSBpcyBwcmV0dHkgY2xvc2UgdG8gdGhlIG9uZSB5b3UgY2FuIGZpbmQgaW4gYGdldExvY2FsaXplZCgpYCwgYnV0IGRpZmZlcmVudCBlbm91Z2ggc28gd2Ugd29uJ3QgcmVmYWN0b3IgaXQuXG4gICAgICAgIGlmIChOdW1iZXIodmFsdWUpID09PSAwICYmIG9wdGlvbnMubGVhZGluZ1plcm8gIT09IEF1dG9OdW1lcmljLm9wdGlvbnMubGVhZGluZ1plcm8ua2VlcCkge1xuICAgICAgICAgICAgdmFsdWUgPSAnMCc7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3V0cHV0Rm9ybWF0VG9Vc2U7XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9ucykpIHtcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdFRvVXNlID0gb3B0aW9ucy5vdXRwdXRGb3JtYXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXRGb3JtYXRUb1VzZSA9IEF1dG9OdW1lcmljLmRlZmF1bHRTZXR0aW5ncy5vdXRwdXRGb3JtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fdG9Mb2NhbGUodmFsdWUsIG91dHB1dEZvcm1hdFRvVXNlKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbG9jYWxpemVBbmRTZXQoZG9tRWxlbWVudCwgb3B0aW9ucyA9IG51bGwpIHsgLy9GSVhNRSB0ZXN0IHRoaXNcbiAgICAgICAgY29uc3QgbG9jYWxpemVkVmFsdWUgPSB0aGlzLmxvY2FsaXplKGRvbUVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5zZXRFbGVtZW50VmFsdWUoZG9tRWxlbWVudCwgbG9jYWxpemVkVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBsb2NhbGl6ZWRWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBnaXZlbiBET00gZWxlbWVudCBoYXMgYW4gQXV0b051bWVyaWMgb2JqZWN0IHRoYXQgbWFuYWdlcyBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbUVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNNYW5hZ2VkQnlBdXRvTnVtZXJpYyhkb21FbGVtZW50KSB7IC8vRklYTUUgdGVzdCB0aGlzXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0luR2xvYmFsTGlzdChkb21FbGVtZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIEF1dG9OdW1lcmljIG9iamVjdCB0aGF0IG1hbmFnZXMgdGhlIGdpdmVuIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tRWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtudWxsfEF1dG9OdW1lcmljfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRBdXRvTnVtZXJpY0VsZW1lbnQoZG9tRWxlbWVudCkgeyAvL0ZJWE1FIHRlc3QgdGhpc1xuICAgICAgICBpZiAoIXRoaXMuaXNNYW5hZ2VkQnlBdXRvTnVtZXJpYyhkb21FbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RnJvbUdsb2JhbExpc3QoZG9tRWxlbWVudCk7XG4gICAgfVxuXG5cbiAgICAvLyBQcmUtZGVmaW5lZCBvcHRpb25zIGNhbiBiZSBjYWxsZWQgdG8gdXBkYXRlIHRoZSBjdXJyZW50IGRlZmF1bHQgb3B0aW9ucyB3aXRoIHRoZWlyIHNwZWNpZmljaXRpZXNcbiAgICAvL1hYWCBBIGJldHRlciB3YXkgd291bGQgYmUgdG8gbm90IGluaXRpYWxpemUgZmlyc3QsIGJ1dCB0aGF0J3Mgbm90IHBvc3NpYmxlIHNpbmNlIGBuZXdgIGlzIGNhbGxlZCBmaXJzdCBhbmQgd2UgZG8gbm90IHBhc3MgdGhlIGxhbmd1YWdlIG9wdGlvbnMgKGllLiBgRnJlbmNoYCkgdG8gdGhlIGNvbnN0cnVjdG9yXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIEF1dG9OdW1lcmljIG9iamVjdCB3aXRoIHRoZSBwcmVkZWZpbmVkIG9wdGlvbnMsIGFuZCBwb3NzaWJseSBzb21lIG9wdGlvbiBvdmVycmlkZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJlZGVmaW5lZE9wdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25PdmVycmlkZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqL1xuICAgIF91cGRhdGVQcmVkZWZpbmVkT3B0aW9ucyhwcmVkZWZpbmVkT3B0aW9uLCBvcHRpb25PdmVycmlkZSA9IG51bGwpIHtcbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9uT3ZlcnJpZGUpKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXJnZVNldHRpbmdzKHByZWRlZmluZWRPcHRpb24sIG9wdGlvbk92ZXJyaWRlKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUocHJlZGVmaW5lZE9wdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHNldHRpbmdzIHRvIHVzZSB0aGUgRnJlbmNoIHByZS1kZWZpbmVkIGxhbmd1YWdlIG9wdGlvbnMuXG4gICAgICogVGhvc2UgcHJlLWRlZmluZWQgb3B0aW9ucyBjYW4gYmUgb3ZlcnJpZGRlbiBieSBwYXNzaW5nIGFuIG9wdGlvbiBvYmplY3QgYXMgYSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uT3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgZnJlbmNoKG9wdGlvbk92ZXJyaWRlID0gbnVsbCkge1xuICAgICAgICB0aGlzLl91cGRhdGVQcmVkZWZpbmVkT3B0aW9ucyhBdXRvTnVtZXJpYy5nZXRQcmVkZWZpbmVkT3B0aW9ucygpLkZyZW5jaCwgb3B0aW9uT3ZlcnJpZGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgc2V0dGluZ3MgdG8gdXNlIHRoZSBOb3J0aCBBbWVyaWNhbiBwcmUtZGVmaW5lZCBsYW5ndWFnZSBvcHRpb25zLlxuICAgICAqIFRob3NlIHByZS1kZWZpbmVkIG9wdGlvbnMgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZyBhbiBvcHRpb24gb2JqZWN0IGFzIGEgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbk92ZXJyaWRlXG4gICAgICogQHJldHVybnMge0F1dG9OdW1lcmljfVxuICAgICAqL1xuICAgIG5vcnRoQW1lcmljYW4ob3B0aW9uT3ZlcnJpZGUgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVByZWRlZmluZWRPcHRpb25zKEF1dG9OdW1lcmljLmdldFByZWRlZmluZWRPcHRpb25zKCkuTm9ydGhBbWVyaWNhbiwgb3B0aW9uT3ZlcnJpZGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgc2V0dGluZ3MgdG8gdXNlIHRoZSBCcml0aXNoIHByZS1kZWZpbmVkIGxhbmd1YWdlIG9wdGlvbnMuXG4gICAgICogVGhvc2UgcHJlLWRlZmluZWQgb3B0aW9ucyBjYW4gYmUgb3ZlcnJpZGRlbiBieSBwYXNzaW5nIGFuIG9wdGlvbiBvYmplY3QgYXMgYSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uT3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgYnJpdGlzaChvcHRpb25PdmVycmlkZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUHJlZGVmaW5lZE9wdGlvbnMoQXV0b051bWVyaWMuZ2V0UHJlZGVmaW5lZE9wdGlvbnMoKS5Ccml0aXNoLCBvcHRpb25PdmVycmlkZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzZXR0aW5ncyB0byB1c2UgdGhlIFN3aXNzIHByZS1kZWZpbmVkIGxhbmd1YWdlIG9wdGlvbnMuXG4gICAgICogVGhvc2UgcHJlLWRlZmluZWQgb3B0aW9ucyBjYW4gYmUgb3ZlcnJpZGRlbiBieSBwYXNzaW5nIGFuIG9wdGlvbiBvYmplY3QgYXMgYSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uT3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgc3dpc3Mob3B0aW9uT3ZlcnJpZGUgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVByZWRlZmluZWRPcHRpb25zKEF1dG9OdW1lcmljLmdldFByZWRlZmluZWRPcHRpb25zKCkuU3dpc3MsIG9wdGlvbk92ZXJyaWRlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHNldHRpbmdzIHRvIHVzZSB0aGUgSmFwYW5lc2UgcHJlLWRlZmluZWQgbGFuZ3VhZ2Ugb3B0aW9ucy5cbiAgICAgKiBUaG9zZSBwcmUtZGVmaW5lZCBvcHRpb25zIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3NpbmcgYW4gb3B0aW9uIG9iamVjdCBhcyBhIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25PdmVycmlkZVxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBqYXBhbmVzZShvcHRpb25PdmVycmlkZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUHJlZGVmaW5lZE9wdGlvbnMoQXV0b051bWVyaWMuZ2V0UHJlZGVmaW5lZE9wdGlvbnMoKS5KYXBhbmVzZSwgb3B0aW9uT3ZlcnJpZGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgc2V0dGluZ3MgdG8gdXNlIHRoZSBTcGFuaXNoIHByZS1kZWZpbmVkIGxhbmd1YWdlIG9wdGlvbnMuXG4gICAgICogVGhvc2UgcHJlLWRlZmluZWQgb3B0aW9ucyBjYW4gYmUgb3ZlcnJpZGRlbiBieSBwYXNzaW5nIGFuIG9wdGlvbiBvYmplY3QgYXMgYSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uT3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgc3BhbmlzaChvcHRpb25PdmVycmlkZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUHJlZGVmaW5lZE9wdGlvbnMoQXV0b051bWVyaWMuZ2V0UHJlZGVmaW5lZE9wdGlvbnMoKS5TcGFuaXNoLCBvcHRpb25PdmVycmlkZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzZXR0aW5ncyB0byB1c2UgdGhlIENoaW5lc2UgcHJlLWRlZmluZWQgbGFuZ3VhZ2Ugb3B0aW9ucy5cbiAgICAgKiBUaG9zZSBwcmUtZGVmaW5lZCBvcHRpb25zIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3NpbmcgYW4gb3B0aW9uIG9iamVjdCBhcyBhIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25PdmVycmlkZVxuICAgICAqIEByZXR1cm5zIHtBdXRvTnVtZXJpY31cbiAgICAgKi9cbiAgICBjaGluZXNlKG9wdGlvbk92ZXJyaWRlID0gbnVsbCkge1xuICAgICAgICB0aGlzLl91cGRhdGVQcmVkZWZpbmVkT3B0aW9ucyhBdXRvTnVtZXJpYy5nZXRQcmVkZWZpbmVkT3B0aW9ucygpLkNoaW5lc2UsIG9wdGlvbk92ZXJyaWRlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHNldHRpbmdzIHRvIHVzZSB0aGUgQnJhemlsaWFuIHByZS1kZWZpbmVkIGxhbmd1YWdlIG9wdGlvbnMuXG4gICAgICogVGhvc2UgcHJlLWRlZmluZWQgb3B0aW9ucyBjYW4gYmUgb3ZlcnJpZGRlbiBieSBwYXNzaW5nIGFuIG9wdGlvbiBvYmplY3QgYXMgYSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uT3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJucyB7QXV0b051bWVyaWN9XG4gICAgICovXG4gICAgYnJhemlsaWFuKG9wdGlvbk92ZXJyaWRlID0gbnVsbCkge1xuICAgICAgICB0aGlzLl91cGRhdGVQcmVkZWZpbmVkT3B0aW9ucyhBdXRvTnVtZXJpYy5nZXRQcmVkZWZpbmVkT3B0aW9ucygpLkJyYXppbGlhbiwgb3B0aW9uT3ZlcnJpZGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgLy8gSW50ZXJuYWwgcHJpdmF0ZSBmdW5jdGlvbnNcbiAgICAvKipcbiAgICAgKiBSdW4gYW55IGNhbGxiYWNrcyBmb3VuZCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0IGluIG9yZGVyIHRvIHNldCB0aGUgc2V0dGluZ3MgdmFsdWUgYmFjay5cbiAgICAgKiBBbnkgcGFyYW1ldGVyIGNhbiBoYXZlIGEgY2FsbGJhY2sgZGVmaW5lZC5cbiAgICAgKiBUaGUgY2FsbGJhY2sgdGFrZXMgdGhlIGN1cnJlbnQgQXV0b051bWVyaWMgZWxlbWVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIGFuZCB0aGUga2V5IG5hbWUgYXMgdGhlIHNlY29uZC5cbiAgICAgKiBAZXhhbXBsZSBjYWxsYmFjayh0aGlzLCAnY3VycmVuY3lTeW1ib2wnKVxuICAgICAqL1xuICAgIF9ydW5DYWxsYmFja3NGb3VuZEluVGhlU2V0dGluZ3NPYmplY3QoKSB7IC8vRklYTUUgdGVzdCB0aGlzXG4gICAgICAgIC8vIExvb3BzIHRocm91Z2ggdGhlIHRoaXMuc2V0dGluZ3Mgb2JqZWN0IChvcHRpb24gYXJyYXkpIHRvIGZpbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLnNldHRpbmdzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnNldHRpbmdzW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Nba2V5XSA9IHZhbHVlKHRoaXMsIGtleSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbHMgdGhlIGF0dGFjaGVkIGZ1bmN0aW9uIGZyb20gdGhlIGh0bWw1IGRhdGEuIEZvciBpbnN0YW5jZTogPHRhZyBkYXRhLWN1cnJlbmN5LXN5bWJvbD1cImZ1bmN0aW9uTmFtZVwiPjwvdGFnPlxuICAgICAgICAgICAgICAgICAgICBsZXQgaHRtbEF0dHJpYnV0ZSA9IHRoaXMuZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoa2V5KTsgLy9UT0RPIFVzZSBgZGF0YXNldGAgaW5zdGVhZCBvZiBgZ2V0QXR0cmlidXRlYCB3aGVuIHdlIHdvbid0IG5lZWQgdG8gc3VwcG9ydCBvYnNvbGV0ZSBicm93c2Vyc1xuICAgICAgICAgICAgICAgICAgICBodG1sQXR0cmlidXRlID0gQXV0b051bWVyaWNIZWxwZXIuY2FtZWxpemUoaHRtbEF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5zZXR0aW5nc1todG1sQXR0cmlidXRlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nc1trZXldID0gaHRtbEF0dHJpYnV0ZSh0aGlzLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogS2VlcCB0cmFjayBpZiB0aGUgc2V0dGluZ3MgY29uZmlndXJhdGlvbiBsZWFkcyB0byBhIHRyYWlsaW5nIG5lZ2F0aXZlIHNpZ24gKG9ubHkgd2hlbiB0aGUgcmF3IHZhbHVlIGlzIG5lZ2F0aXZlKSwgc28gd2UgZG8gbm90IGhhdmUgdG8gdGVzdCB0aGUgc2V0dGluZ3MgdmFsdWVzIGV2ZXJ5IHRpbWUgd2UgbmVlZCB0byBrbm93IHRoYXQuXG4gICAgICogYGlzVHJhaWxpbmdOZWdhdGl2ZWAgaXMgc2V0IHRvIGB0cnVlYCBpZiB0aGUgc2V0dGluZ3MgcmVzdWx0IGluIGEgdHJhaWxpbmcgbmVnYXRpdmUgY2hhcmFjdGVyLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKiBOb3RlOiBUaGlzIHJldHVybnMgYHRydWVgIGV2ZW4gaWYgdGhlIHJhdyB2YWx1ZSBpcyBwb3NpdGl2ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRUcmFpbGluZ05lZ2F0aXZlU2lnbkluZm8oKSB7XG4gICAgICAgIHRoaXMuaXNUcmFpbGluZ05lZ2F0aXZlID0gKHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQucHJlZml4ICYmIHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQuc3VmZml4KSB8fFxuICAgICAgICAodGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5zdWZmaXggJiZcbiAgICAgICAgKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQubGVmdCB8fCB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnJpZ2h0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RyaXAgYWxsIHVud2FudGVkIG5vbi1udW1iZXIgY2hhcmFjdGVycy5cbiAgICAgKiBUaGlzIGtlZXBzIHRoZSBudW1iZXJzLCB0aGUgbmVnYXRpdmUgc2lnbiBhcyB3ZWxsIGFzIHRoZSBjdXN0b20gZGVjaW1hbCBjaGFyYWN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RyaXBaZXJvcyBJZiBzZXQgdG8gYGZhbHNlYCwgdGhlbiB0aGUgbGVhZGluZyB6ZXJvKHMpIGFyZSBub3Qgc3RyaXBwZWQsIG90aGVyd2lzZSBpZiBzZXQgdG8gYHRydWVgLCB0aGUgYGxlYWRpbmdaZXJvYCBvcHRpb24gaXMgZm9sbG93ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRm9jdXNlZCBJZiB0aGUgZWxlbWVudCBpcyBmb2N1c2VkLCB0aGVuIHRoaXMgaXMgYHRydWVgXG4gICAgICogQHJldHVybnMge3N0cmluZ3wqfVxuICAgICAqL1xuICAgIHN0YXRpYyBfc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHMsIHNldHRpbmdzLCBzdHJpcFplcm9zLCBpc0ZvY3VzZWQpIHtcbiAgICAgICAgLy9YWFggTm90ZTsgdGhpcyBmdW5jdGlvbiBpcyBzdGF0aWMgc2luY2Ugd2UgbmVlZCB0byBwYXNzIGEgYHNldHRpbmdzYCBvYmplY3Qgd2hlbiBjYWxsaW5nIHRoZSBzdGF0aWMgYEF1dG9OdW1lcmljLmZvcm1hdCgpYCBtZXRob2RcbiAgICAgICAgLy9UT0RPIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIDEwIHRpbWVzIChzaWMhKSBvbiBlYWNoIGtleSBpbnB1dCwgY291bGRuJ3Qgd2UgbG93ZXIgdGhhdCBudW1iZXI/IGNmLiBpc3N1ZSAjMzI1XG4gICAgICAgIC8vVE9ETyBSZWZhY3RvciB0aGlzIHdpdGggYGNvbnZlcnRUb051bWVyaWNTdHJpbmcoKWAgaWYgcG9zc2libGU/XG4gICAgICAgIHMgPSBTdHJpbmcocyk7IC8vIFR5cGVjYXN0IHRvIHRvIGEgc3RyaW5nLCBpbiBjYXNlIHRoYXQgdGhlIGluaXRpYWxWYWx1ZSBpcyBhIG51bWJlclxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCAhPT0gJycpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBjdXJyZW5jeSBzaWduXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3Muc3VmZml4VGV4dCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHN1ZmZpeFxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5zdWZmaXhUZXh0LCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL1RPRE8gUmVtb3ZlIHRoZSBwb3NpdGl2ZSBzaWduIHRvbz9cblxuICAgICAgICAvLyBGaXJzdCByZXBsYWNlIGFueXRoaW5nIGJlZm9yZSBkaWdpdHNcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5za2lwRmlyc3RBdXRvU3RyaXAsICckMSQyJyk7XG5cbiAgICAgICAgLy8gVGhlbiByZXBsYWNlIGFueXRoaW5nIGFmdGVyIGRpZ2l0c1xuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnNraXBMYXN0QXV0b1N0cmlwLCAnJDEnKTtcblxuICAgICAgICAvLyBUaGVuIHJlbW92ZSBhbnkgdW5pbnRlcmVzdGluZyBjaGFyYWN0ZXJzXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYWxsb3dlZEF1dG9TdHJpcCwgJycpO1xuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSwgc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgb25seSBudW1iZXIgc3RyaW5nXG4gICAgICAgIGNvbnN0IG0gPSBzLm1hdGNoKHNldHRpbmdzLm51bVJlZ0F1dG9TdHJpcCk7XG4gICAgICAgIHMgPSBtID8gW21bMV0sIG1bMl0sIG1bM11dLmpvaW4oJycpIDogJyc7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmxlYWRpbmdaZXJvID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmxlYWRpbmdaZXJvLmFsbG93IHx8IHNldHRpbmdzLmxlYWRpbmdaZXJvID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmxlYWRpbmdaZXJvLmtlZXApIHtcbiAgICAgICAgICAgIGxldCBuZWdhdGl2ZVNpZ24gPSAnJztcbiAgICAgICAgICAgIGNvbnN0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gcy5zcGxpdChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcbiAgICAgICAgICAgIGxldCBtb2RpZmllZEludGVnZXJQYXJ0ID0gaW50ZWdlclBhcnQ7XG4gICAgICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuY29udGFpbnMobW9kaWZpZWRJbnRlZ2VyUGFydCwgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgIG5lZ2F0aXZlU2lnbiA9IHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcjtcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5yZXBsYWNlKHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciwgJycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdHJpcCBsZWFkaW5nIHplcm8gb24gcG9zaXRpdmUgdmFsdWUgaWYgbmVlZFxuICAgICAgICAgICAgaWYgKG5lZ2F0aXZlU2lnbiA9PT0gJycgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tSW50UG9zICYmIG1vZGlmaWVkSW50ZWdlclBhcnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyB6ZXJvIG9uIG5lZ2F0aXZlIHZhbHVlIGlmIG5lZWRcbiAgICAgICAgICAgIGlmIChuZWdhdGl2ZVNpZ24gIT09ICcnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQubGVuZ3RoID4gc2V0dGluZ3MubUludE5lZyAmJiBtb2RpZmllZEludGVnZXJQYXJ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IG1vZGlmaWVkSW50ZWdlclBhcnQuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHMgPSBgJHtuZWdhdGl2ZVNpZ259JHttb2RpZmllZEludGVnZXJQYXJ0fSR7QXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpPycnOnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgKyBkZWNpbWFsUGFydH1gO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChzdHJpcFplcm9zICYmIHNldHRpbmdzLmxlYWRpbmdaZXJvID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmxlYWRpbmdaZXJvLmRlbnkpIHx8XG4gICAgICAgICAgICAoIWlzRm9jdXNlZCAmJiBzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5sZWFkaW5nWmVyby5hbGxvdykpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3Muc3RyaXBSZWcsICckMSQyJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9yIHJlbW92ZXMgYnJhY2tldHMgb24gbmVnYXRpdmUgdmFsdWVzLCBkZXBlbmRpbmcgb24gdGhlIGZvY3VzIHN0YXRlLCB3aGljaCBpcyBwYXNzZWQgYXMgYGlzRm9jdXNlZGAuXG4gICAgICogVGhlIGZvY3VzIHN0YXRlIGlzICdzdG9yZWQnIGluIHRoYXQgb2JqZWN0IHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0ZvY3VzZWRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzdGF0aWMgX3RvZ2dsZU5lZ2F0aXZlQnJhY2tldCh2YWx1ZSwgc2V0dGluZ3MsIGlzRm9jdXNlZCkge1xuICAgICAgICAvL1hYWCBOb3RlOyB0aGlzIGZ1bmN0aW9uIGlzIHN0YXRpYyBzaW5jZSB3ZSBuZWVkIHRvIHBhc3MgYSBgc2V0dGluZ3NgIG9iamVjdCB3aGVuIGNhbGxpbmcgdGhlIHN0YXRpYyBgQXV0b051bWVyaWMuZm9ybWF0KClgIG1ldGhvZFxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9yZW1vdmVCcmFja2V0cyh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fYWRkQnJhY2tldHModmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBicmFja2V0IHR5cGVzIHNwZWNpZmllZCBpbiB0aGUgYHNldHRpbmdzYCBvYmplY3QsIHRvIHRoZSBnaXZlbiBzdHJpbmcgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX2FkZEJyYWNrZXRzKHZhbHVlLCBzZXR0aW5ncykge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGAke3NldHRpbmdzLmZpcnN0QnJhY2tldH0ke3ZhbHVlLnJlcGxhY2Uoc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyLCAnJyl9JHtzZXR0aW5ncy5sYXN0QnJhY2tldH1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgYnJhY2tldCB0eXBlcyBzcGVjaWZpZWQgaW4gdGhlIGBzZXR0aW5nc2Agb2JqZWN0LCBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVhcnJhbmdlU2lnbnNBbmRWYWx1ZU9yZGVyIElmIHNldCB0byBgdHJ1ZWAsIHRoZW4gb25seSB0aGUgYnJhY2tldHMgYXJlIHJlbW92ZSBhbmQgYSBuZWdhdGl2ZSBzaWduIGlzIGFkZGVkLCB3aXRob3V0IHJlb3JkZXJpbmcgdGhlIG5lZ2F0aXZlIHNpZ24sIGN1cnJlbmN5IHN5bWJvbCBhbmQgdmFsdWUgYWNjb3JkaW5nIHRvIHRoZSBzZXR0aW5ncy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9yZW1vdmVCcmFja2V0cyh2YWx1ZSwgc2V0dGluZ3MsIHJlYXJyYW5nZVNpZ25zQW5kVmFsdWVPcmRlciA9IHRydWUpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwoc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIpICYmIHZhbHVlLmNoYXJBdCgwKSA9PT0gc2V0dGluZ3MuZmlyc3RCcmFja2V0KSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGJyYWNrZXRzIGlmIHRoZXkgYXJlIHByZXNlbnRcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLnJlcGxhY2Uoc2V0dGluZ3MuZmlyc3RCcmFja2V0LCAnJyk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShzZXR0aW5ncy5sYXN0QnJhY2tldCwgJycpO1xuXG4gICAgICAgICAgICAvLyBBZGQgYmFjayB0aGUgbmVnYXRpdmUgc2lnbiBhdCB0aGUgcmlnaHQgcGxhY2VcbiAgICAgICAgICAgIGlmIChyZWFycmFuZ2VTaWduc0FuZFZhbHVlT3JkZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgY3VycmVuY3kgc3ltYm9sIGZyb20gdGhlIHZhbHVlLCBzaW5jZSB3ZSB3YW50IHRvIGJlIGFibGUgdG8gYWRkIGJhY2sgdGhlIG5lZ2F0aXZlIHNpZ24gYXQgdGhlIHJpZ2h0IHBsYWNlIChpbmNsdWRpbmcgYmV0d2VlbiB0aGUgdmFsdWUgYW5kIHRoZSBjdXJyZW5jeSBzaWduKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sLCAnJyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWVyZ2VDdXJyZW5jeVNpZ25OZWdhdGl2ZVBvc2l0aXZlU2lnbkFuZFZhbHVlKHJlc3VsdCwgc2V0dGluZ3MsIHRydWUsIGZhbHNlKTsgLy9UT0RPIFRoaXMgYXNzdW1lIHRoZSB2YWx1ZSBpcyBuZWdhdGl2ZSBhbmQgbm9uLWVtcHR5LiBJcyB0aGlzIGFsd2F5cyB0aGUgY2FzZT9cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSGVyZSB3ZSBvbmx5IHdhbnQgdG8gYWRkIHRoZSBuZWdhdGl2ZSBzaWduIHNpbmNlIHdlIHJlbW92ZWQgdGhlIGJyYWNrZXRzLCB3aXRob3V0IHJlb3JkZXJpbmdcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnLScgKyByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5hbHl6ZSB0aGUgYG5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyYCBvcHRpb25zIGFuZCBrZWVwIHRyYWNrIG9mIHRoZSBmaXJzdCBhbmQgbGFzdCBicmFja2V0IGNoYXJhY3RlcnMgdG8gdXNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldEJyYWNrZXRzKCkge1xuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbCh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyKSkge1xuICAgICAgICAgICAgW3RoaXMuc2V0dGluZ3MuZmlyc3RCcmFja2V0LCB0aGlzLnNldHRpbmdzLmxhc3RCcmFja2V0XSA9IHRoaXMuc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIuc3BsaXQoJywnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuZmlyc3RCcmFja2V0ID0gJyc7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLmxhc3RCcmFja2V0ID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBudW1iZXIgYXMgYSBudW1lcmljIHN0cmluZyB0aGF0IGNhbiBiZSB0eXBlY2FzdCB0byBhIE51bWJlciB0aGF0IEphdmFzY3JpcHQgd2lsbCB1bmRlcnN0YW5kLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiByZXR1cm4gdGhlIGdpdmVuIHN0cmluZyBieSBzdHJpcHBpbmcgdGhlIGN1cnJlbmN5IHNpZ24gKGN1cnJlbmN5U3ltYm9sKSwgdGhlIGdyb3VwaW5nIHNlcGFyYXRvcnMgKGRpZ2l0YWxHcm91cFNwYWNpbmcpIGFuZCBieSByZXBsYWNpbmcgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIChkZWNpbWFsQ2hhcmFjdGVyKSBieSBhIGRvdC5cbiAgICAgKiBMYXN0bHksIGl0IGFsc28gcHV0IHRoZSBuZWdhdGl2ZSBzaWduIGJhY2sgdG8gaXRzIG5vcm1hbCBwb3NpdGlvbiBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dm9pZHxYTUx8Kn1cbiAgICAgKi9cbiAgICBzdGF0aWMgX2NvbnZlcnRUb051bWVyaWNTdHJpbmcocywgc2V0dGluZ3MpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBjdXJyZW5jeSBzeW1ib2xcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCwgJycpO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZ3JvdXBpbmcgc2VwYXJhdG9ycyAodGhvdXNhbmRzIHNlcGFyYXRvcnMgdXN1YWxseSlcbiAgICAgICAgcyA9IHMucmVwbGFjZShuZXcgUmVnRXhwKGBbJHtzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yfV1gLCAnZycpLCAnJyk7XG5cbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgYnkgYSBkb3RcbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgIT09ICcuJykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyLCAnLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBzdWZmaXhUZXh0XG4gICAgICAgIGlmIChzZXR0aW5ncy5zdWZmaXhUZXh0ICE9PSBBdXRvTnVtZXJpYy5vcHRpb25zLnN1ZmZpeFRleHQubm9uZSkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5zdWZmaXhUZXh0LCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNb3ZlIHRoZSB0cmFpbGluZyBuZWdhdGl2ZSBzaWduIHRvIHRoZSByaWdodCBwb3NpdGlvbiwgaWYgYW55XG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc05lZ2F0aXZlKHMpICYmIHMubGFzdEluZGV4T2YoJy0nKSA9PT0gcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICAgICAgcyA9ICctJyArIHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IGFyYWJpYyBudW1iZXJzIHRvIGxhdGluIG9uZXMsIGlmIGFueVxuICAgICAgICBjb25zdCBjb252ZXJ0VG9OdW1iZXIgPSBzZXR0aW5ncy5sZWFkaW5nWmVybyAhPT0gQXV0b051bWVyaWMub3B0aW9ucy5sZWFkaW5nWmVyby5rZWVwO1xuICAgICAgICBjb25zdCB0ZW1wID0gQXV0b051bWVyaWNIZWxwZXIuYXJhYmljVG9MYXRpbk51bWJlcnMocywgY29udmVydFRvTnVtYmVyLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBpZiAoIWlzTmFOKHRlbXApKSB7XG4gICAgICAgICAgICBzID0gdGVtcC50b1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIElTTyBudW1lcmljIHN0cmluZyB0byB0aGUgbG9jYWxlIGRlY2ltYWwgYW5kIG1pbnVzIHNpZ24gcGxhY2VtZW50LlxuICAgICAqIFNlZSB0aGUgXCJvdXRwdXRGb3JtYXRcIiBvcHRpb24gZGVmaW5pdGlvbiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBsb2NhbGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzdGF0aWMgX3RvTG9jYWxlKHZhbHVlLCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChsb2NhbGUpIHx8IGxvY2FsZSA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5vdXRwdXRGb3JtYXQuc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBzd2l0Y2ggKGxvY2FsZSkge1xuICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm91dHB1dEZvcm1hdC5udW1iZXI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5vdXRwdXRGb3JtYXQuZG90TmVnYXRpdmU6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNIZWxwZXIuaXNOZWdhdGl2ZSh2YWx1ZSkgPyB2YWx1ZS5yZXBsYWNlKCctJywgJycpICsgJy0nIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMub3V0cHV0Rm9ybWF0LmNvbW1hOlxuICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm91dHB1dEZvcm1hdC5uZWdhdGl2ZUNvbW1hOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLnJlcGxhY2UoJy4nLCAnLCcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm91dHB1dEZvcm1hdC5jb21tYU5lZ2F0aXZlOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLnJlcGxhY2UoJy4nLCAnLCcpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljSGVscGVyLmlzTmVnYXRpdmUocmVzdWx0KSA/IHJlc3VsdC5yZXBsYWNlKCctJywgJycpICsgJy0nIDogcmVzdWx0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgY2FzZVxuICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm91dHB1dEZvcm1hdC5kb3Q6XG4gICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMub3V0cHV0Rm9ybWF0Lm5lZ2F0aXZlRG90OlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIGdpdmVuIG91dHB1dEZvcm1hdCBbJHtsb2NhbGV9XSBvcHRpb24gaXMgbm90IHJlY29nbml6ZWQuYCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vZGlmeSB0aGUgbmVnYXRpdmUgc2lnbiBhbmQgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIG9mIHRoZSBnaXZlbiBzdHJpbmcgdmFsdWUgdG8gYW4gaHlwaGVuICgtKSBhbmQgYSBkb3QgKC4pIGluIG9yZGVyIHRvIG1ha2UgdGhhdCB2YWx1ZSAndHlwZWNhc3RhYmxlJyB0byBhIHJlYWwgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIF9tb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yUmF3VmFsdWUocykge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyICE9PSAnLicpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UodGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyLCAnLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnLScgJiYgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyLCAnLScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzLm1hdGNoKC9cXGQvKSkge1xuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgcmV0dXJuZWQgYnkgYGdldGAgaXMgbm90IGZvcm1hdHRlZCB3aXRoIGRlY2ltYWxzXG4gICAgICAgICAgICBzICs9ICcwJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vZGlmeSB0aGUgbmVnYXRpdmUgc2lnbiBhbmQgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIHRvIHVzZSB0aG9zZSBkZWZpbmVkIGluIHRoZSBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgX21vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JGb3JtYXR0ZWRWYWx1ZShzLCBzZXR0aW5ncykge1xuICAgICAgICAvL1hYWCBOb3RlOyB0aGlzIGZ1bmN0aW9uIGlzIHN0YXRpYyBzaW5jZSB3ZSBuZWVkIHRvIHBhc3MgYSBgc2V0dGluZ3NgIG9iamVjdCB3aGVuIGNhbGxpbmcgdGhlIHN0YXRpYyBgQXV0b051bWVyaWMuZm9ybWF0KClgIG1ldGhvZFxuICAgICAgICBpZiAoc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnLScgJiYgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnJykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnLScsIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciAhPT0gJy4nKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCcuJywgc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBlbXB0eSBvciBpcyBlcXVhbCB0byB0aGUgbmVnYXRpdmUgc2lnbiBjaGFyYWN0ZXIgZGVmaW5lZCBpbiB0aGUgZ2l2ZW4gc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBfaXNFbGVtZW50VmFsdWVFbXB0eU9yT25seVRoZU5lZ2F0aXZlU2lnbih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgd2l0aCB0aGUgY3VycmVuY3kgc3ltYm9sIGFuZCB0aGUgc3VmZml4IHRleHQgb3JkZXJlZCBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzaWduT25FbXB0eVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9vcmRlclZhbHVlQ3VycmVuY3lTeW1ib2xBbmRTdWZmaXhUZXh0KHZhbHVlLCBzZXR0aW5ncywgc2lnbk9uRW1wdHkpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3IuYWx3YXlzIHx8IHNpZ25PbkVtcHR5KSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQubGVmdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlICsgc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgKyBzZXR0aW5ncy5zdWZmaXhUZXh0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCArIHZhbHVlICsgc2V0dGluZ3Muc3VmZml4VGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgdGhlIGlucHV0IHZhbHVlIGJ5IGFkZGluZyB0aGUgZ3JvdXAgc2VwYXJhdG9ycywgYXMgZGVmaW5lZCBpbiB0aGUgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRWYWx1ZSBUaGUgZm9ybWF0dGVkIHZhbHVlIChpZS4gd2l0aCB0aGUgYGRlY2ltYWxDaGFyYWN0ZXJgIGRlZmluZWQgaW4gdGhlIHNldHRpbmdzLCBub3QgdGhlIHJhdyB2YWx1ZSlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRm9jdXNlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xudWxsfSBjdXJyZW50UmF3VmFsdWUgVGhlIG9iamVjdCBjdXJyZW50IHJhdyB2YWx1ZSAoYHRoaXMucmF3VmFsdWVgKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xudWxsfSBmb3JjZWRSYXdWYWx1ZSBJZiB0aGlzIGlzIHNldCwgdGhlbiB0aGlzIHJhd1ZhbHVlIGlzIHVzZWQgaW5zdGVhZCBvZiB0aGUgb25lIHBhc3NlZCB0aHJvdWdoIHRoZSBgc2V0dGluZ3NgIG9iamVjdC4gVGhpcyBpcyB1c2VmdWwgaXMgc29tZSB2ZXJ5IHNwZWNpZmljIGNhc2VzIHdoZXJlIHdlIG5lZWQgdG8gc2V0IHRoZSByYXcgdmFsdWUgKmFmdGVyKiBzZXR0aW5ncyB0aGUgZm9ybWF0dGVkIHZhbHVlLCB1c2luZyB0aGUgYF9hZGRHcm91cFNlcGFyYXRvcnMoKWAgbWV0aG9kLlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHN0YXRpYyBfYWRkR3JvdXBTZXBhcmF0b3JzKGlucHV0VmFsdWUsIHNldHRpbmdzLCBpc0ZvY3VzZWQsIGN1cnJlbnRSYXdWYWx1ZSwgZm9yY2VkUmF3VmFsdWUgPSBudWxsKSB7XG4gICAgICAgIC8vVE9ETyBUZXN0IGlmIGBpbnB1dFZhbHVlYCA9PT0gJycsIGFuZCByZXR1cm4gJycgZGlyZWN0bHkgaWYgdGhhdCdzIHRoZSBjYXNlLFxuICAgICAgICAvL1hYWCBOb3RlOyB0aGlzIGZ1bmN0aW9uIGlzIHN0YXRpYyBzaW5jZSB3ZSBuZWVkIHRvIHBhc3MgYSBgc2V0dGluZ3NgIG9iamVjdCB3aGVuIGNhbGxpbmcgdGhlIHN0YXRpYyBgQXV0b051bWVyaWMuZm9ybWF0KClgIG1ldGhvZFxuICAgICAgICBjb25zdCBpc1ZhbHVlTmVnYXRpdmUgPSBBdXRvTnVtZXJpY0hlbHBlci5pc05lZ2F0aXZlKGlucHV0VmFsdWUpIHx8IEF1dG9OdW1lcmljSGVscGVyLmlzTmVnYXRpdmVXaXRoQnJhY2tldHMoaW5wdXRWYWx1ZSwgc2V0dGluZ3MuZmlyc3RCcmFja2V0LCBzZXR0aW5ncy5sYXN0QnJhY2tldCk7IC8vIFRlc3QgaWYgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlIGJlZm9yZSByZW1vdmluZyB0aGUgbmVnYXRpdmUgc2lnblxuXG4gICAgICAgIGlucHV0VmFsdWUgPSB0aGlzLl9zdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMoaW5wdXRWYWx1ZSwgc2V0dGluZ3MsIGZhbHNlLCBpc0ZvY3VzZWQpO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc0VsZW1lbnRWYWx1ZUVtcHR5T3JPbmx5VGhlTmVnYXRpdmVTaWduKGlucHV0VmFsdWUsIHNldHRpbmdzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yZGVyVmFsdWVDdXJyZW5jeVN5bWJvbEFuZFN1ZmZpeFRleHQoaW5wdXRWYWx1ZSwgc2V0dGluZ3MsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNaZXJvT3JIYXNOb1ZhbHVlID0gQXV0b051bWVyaWNIZWxwZXIuaXNaZXJvT3JIYXNOb1ZhbHVlKGlucHV0VmFsdWUpO1xuXG4gICAgICAgIC8vIFRlbXBvcmFyaWx5IHJlbW92ZSB0aGUgbmVnYXRpdmUgc2lnbiBpZiBwcmVzZW50XG4gICAgICAgIGlmIChpc1ZhbHVlTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0aW5ncy5kaWdpdGFsR3JvdXBTcGFjaW5nID0gc2V0dGluZ3MuZGlnaXRhbEdyb3VwU3BhY2luZy50b1N0cmluZygpO1xuICAgICAgICBsZXQgZGlnaXRhbEdyb3VwO1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLmRpZ2l0YWxHcm91cFNwYWNpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdGFsR3JvdXBTcGFjaW5nLnR3bzpcbiAgICAgICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKFxcZCkoXFxkezJ9PykrKSQvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLmRpZ2l0YWxHcm91cFNwYWNpbmcudHdvU2NhbGVkOlxuICAgICAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoPzpcXGR7Mn0pezAsMn1cXGR7M30oPzooPzpcXGR7Mn0pezJ9XFxkezN9KSo/KSQvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLmRpZ2l0YWxHcm91cFNwYWNpbmcuZm91cjpcbiAgICAgICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKFxcZHs0fT8pKykkLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdGFsR3JvdXBTcGFjaW5nLnRocmVlOlxuICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGR7M30/KSspJC87XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTcGxpdHMgdGhlIHN0cmluZyBhdCB0aGUgZGVjaW1hbCBzdHJpbmdcbiAgICAgICAgbGV0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gaW5wdXRWYWx1ZS5zcGxpdChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSAmJiBBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gaW5wdXRWYWx1ZS5zcGxpdChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgIT09ICcnKSB7XG4gICAgICAgICAgICAvLyBSZS1pbnNlcnRzIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgdmlhIGEgcmVndWxhciBleHByZXNzaW9uXG4gICAgICAgICAgICB3aGlsZSAoZGlnaXRhbEdyb3VwLnRlc3QoaW50ZWdlclBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaW50ZWdlclBhcnQgPSBpbnRlZ2VyUGFydC5yZXBsYWNlKGRpZ2l0YWxHcm91cCwgYCQxJHtzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yfSQyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIG91dCBob3cgbWFueSBkZWNpbWFsIHBsYWNlcyBzaG91bGQgYmUga2VwdCwgZGVwZW5kaW5nIG9uIHRoZSBvYmplY3Qgc3RhdGUgKGlzRm9jdXNlZClcbiAgICAgICAgbGV0IGRlY2ltYWxQbGFjZXNUb1JvdW5kVG87XG4gICAgICAgIGlmIChpc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgIGRlY2ltYWxQbGFjZXNUb1JvdW5kVG8gPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVjaW1hbFBsYWNlc1RvUm91bmRUbyA9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uQmx1cjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWNpbWFsUGxhY2VzVG9Sb3VuZFRvICE9PSAwICYmICFBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIGlmIChkZWNpbWFsUGFydC5sZW5ndGggPiBkZWNpbWFsUGxhY2VzVG9Sb3VuZFRvKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJpbSB0aGUgZXhjZXNzaXZlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICAgICAgICAgICAgICAgIGRlY2ltYWxQYXJ0ID0gZGVjaW1hbFBhcnQuc3Vic3RyaW5nKDAsIGRlY2ltYWxQbGFjZXNUb1JvdW5kVG8pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBKb2lucyB0aGUgd2hvbGUgbnVtYmVyIHdpdGggdGhlIGRlY2ltYWwgdmFsdWVcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBgJHtpbnRlZ2VyUGFydH0ke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9JHtkZWNpbWFsUGFydH1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGlmIGl0J3MgYW4gaW50ZWdlclxuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGludGVnZXJQYXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGJhY2sgdGhlIG5lZ2F0aXZlL3Bvc2l0aXZlIHNpZ24gYW5kIHRoZSBjdXJyZW5jeSBzeW1ib2wsIGF0IHRoZSByaWdodCBwb3NpdGlvbnNcbiAgICAgICAgaW5wdXRWYWx1ZSA9IEF1dG9OdW1lcmljLl9tZXJnZUN1cnJlbmN5U2lnbk5lZ2F0aXZlUG9zaXRpdmVTaWduQW5kVmFsdWUoaW5wdXRWYWx1ZSwgc2V0dGluZ3MsIGlzVmFsdWVOZWdhdGl2ZSwgaXNaZXJvT3JIYXNOb1ZhbHVlKTsgLy9UT0RPIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFnYWluIGluIGBfdG9nZ2xlTmVnYXRpdmVCcmFja2V0YCBpZiB0aGUgYnJhY2tldHMgYXJlIHJlbW92ZWQ7IGxldCdzIERSWSB0aGlzXG5cbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChmb3JjZWRSYXdWYWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSByYXcgdmFsdWUgaXMgbm90IGZvcmNlZCwgdXNlIHRoZSBkZWZhdWx0IG9uZSBmcm9tIHRoZSBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICAgIGZvcmNlZFJhd1ZhbHVlID0gY3VycmVudFJhd1ZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG9nZ2xlIHRoZSBuZWdhdGl2ZSBzaWduIGFuZCBicmFja2V0c1xuICAgICAgICBpZiAoc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgIT09IG51bGwgJiYgKGZvcmNlZFJhd1ZhbHVlIDwgMCB8fCBBdXRvTnVtZXJpY0hlbHBlci5pc05lZ2F0aXZlU3RyaWN0KGlucHV0VmFsdWUpKSkge1xuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHRoaXMuX3RvZ2dsZU5lZ2F0aXZlQnJhY2tldChpbnB1dFZhbHVlLCBzZXR0aW5ncywgaXNGb2N1c2VkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChzZXR0aW5ncy5zdWZmaXhUZXh0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBgJHtpbnB1dFZhbHVlfSR7c2V0dGluZ3Muc3VmZml4VGV4dH1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgc2VtaS1mb3JtYXR0ZWQgc3RyaW5nIHdoZXJlIHRoZSBpbnB1dCB2YWx1ZSwgdGhlIG5lZ2F0aXZlIG9yIHBvc2l0aXZlIHNpZ24sIGFuZCB0aGUgY3VycmVuY3kgc3ltYm9sIGFyZSBzdGl0Y2hlZCB0b2dldGhlciBhdCB0aGUgcmlnaHQgcG9zaXRpb25zLCB1c2luZyB0aGUgb3B0aW9ucyBzZXQgaW4gdGhlIGBzZXR0aW5nc2Agb2JqZWN0LlxuICAgICAqIE5vdGUgOiB0aGUgYGlucHV0VmFsdWVgIGlzIHVzdWFsbHkgbm90IGEgbnVtZXJpYyBzdHJpbmcgc2luY2UgdGhlIGdyb3VwaW5nIHN5bWJvbHMgYXJlIGFscmVhZHkgYWRkZWQgdG8gaXQgYXQgdGhpcyBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1ZhbHVlTmVnYXRpdmVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzWmVyb09ySGFzTm9WYWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEB0aHJvd3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBfbWVyZ2VDdXJyZW5jeVNpZ25OZWdhdGl2ZVBvc2l0aXZlU2lnbkFuZFZhbHVlKGlucHV0VmFsdWUsIHNldHRpbmdzLCBpc1ZhbHVlTmVnYXRpdmUsIGlzWmVyb09ySGFzTm9WYWx1ZSkge1xuICAgICAgICBsZXQgc2lnblRvVXNlID0gJyc7XG4gICAgICAgIGlmIChpc1ZhbHVlTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIHNpZ25Ub1VzZSA9IHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcjtcbiAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5zaG93UG9zaXRpdmVTaWduICYmICFpc1plcm9Pckhhc05vVmFsdWUpIHtcbiAgICAgICAgICAgIHNpZ25Ub1VzZSA9IHNldHRpbmdzLnBvc2l0aXZlU2lnbkNoYXJhY3RlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5wcmVmaXgpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCAhPT0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5ub25lICYmXG4gICAgICAgICAgICAgICAgKGlzVmFsdWVOZWdhdGl2ZSB8fCAoIWlzVmFsdWVOZWdhdGl2ZSAmJiBzZXR0aW5ncy5zaG93UG9zaXRpdmVTaWduICYmICFpc1plcm9Pckhhc05vVmFsdWUpKSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnByZWZpeDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LmxlZnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBgJHtzaWduVG9Vc2V9JHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH0ke2lucHV0VmFsdWV9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBgJHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH0ke3NpZ25Ub1VzZX0ke2lucHV0VmFsdWV9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQuc3VmZml4OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYCR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9JHtpbnB1dFZhbHVlfSR7c2lnblRvVXNlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICsgaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5zdWZmaXgpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCAhPT0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5ub25lICYmXG4gICAgICAgICAgICAgICAgKGlzVmFsdWVOZWdhdGl2ZSB8fCAoIWlzVmFsdWVOZWdhdGl2ZSAmJiBzZXR0aW5ncy5zaG93UG9zaXRpdmVTaWduICYmICFpc1plcm9Pckhhc05vVmFsdWUpKSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnN1ZmZpeDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnJpZ2h0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYCR7aW5wdXRWYWx1ZX0ke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfSR7c2lnblRvVXNlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LmxlZnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBgJHtpbnB1dFZhbHVlfSR7c2lnblRvVXNlfSR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucHJlZml4OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYCR7c2lnblRvVXNlfSR7aW5wdXRWYWx1ZX0ke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0VmFsdWUgKyBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHdoZXJlIHRvIHB1dCB0aGUgY2FyZXQgcG9zaXRpb24gb24gZm9jdXMgaWYgdGhlIGVsZW1lbnQgY29udGVudCBpcyBub3Qgc2VsZWN0ZWQuXG4gICAgICogVGhpcyBjYWxjdWxhdGlvbiBpcyBhZmZlY3RlZCBieSB0aGUgYGNhcmV0UG9zaXRpb25PbkZvY3VzYCBvcHRpb24gd2hpY2ggY2FuIGJlIGVpdGhlciBgbnVsbGAsIGAnc3RhcnQnYCwgYCdlbmQnYCwgYCdkZWNpbWFsTGVmdCdgIG9yICdkZWNpbWFsUmlnaHQnYCwgYW5kIHdpbGwgZGVjaWRlIHdoZXJlIHRvIHB1dCB0aGUgY2FyZXQgKG9uIHRoZSBsZWZ0IG9yIHJpZ2h0IG9mIHRoZSB2YWx1ZSBvciB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIsIHJlc3BlY3RpdmVseSkgOlxuICAgICAqIC0gYG51bGxgIDogdGhlIGNhcmV0IHBvc2l0aW9uIGlzIG5vdCBmb3JjZWRcbiAgICAgKiAtIGAnc3RhcnQnYCA6IHRoZSBjYXJldCBpcyBwb3NpdGlvbmVkIG9uIHRoZSBsZWZ0IGhhbmQgc2lkZSBvZiB0aGUgdmFsdWVcbiAgICAgKiAtIGAnZW5kJ2AgOiB0aGUgY2FyZXQgaXMgcG9zaXRpb25lZCBvbiB0aGUgcmlnaHQgaGFuZCBzaWRlIG9mIHRoZSB2YWx1ZVxuICAgICAqIC0gYCdkZWNpbWFsTGVmdCdgIDogdGhlIGNhcmV0IGlzIHBvc2l0aW9uZWQgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgKiAtIGAnZGVjaW1hbFJpZ2h0J2AgOiB0aGUgY2FyZXQgaXMgcG9zaXRpb25lZCBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgZm9ybWF0dGVkIHN0cmluZyBzdHJpcHBlZCBvZiB0aGUgY3VycmVuY3kgc3ltYm9sIGFuZCBuZWdhdGl2ZS9wb3NpdGl2ZSBzaWduXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAdGhyb3dzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdGlhbENhcmV0UG9zaXRpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVsbCh0aGlzLnNldHRpbmdzLmNhcmV0UG9zaXRpb25PbkZvY3VzKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcignYF9pbml0aWFsQ2FyZXRQb3NpdGlvbigpYCBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIHdoZW4gdGhlIGBjYXJldFBvc2l0aW9uT25Gb2N1c2Agb3B0aW9uIGlzIGBudWxsYC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzVmFsdWVOZWdhdGl2ZSA9IHRoaXMucmF3VmFsdWUgPCAwO1xuICAgICAgICBjb25zdCBpc1plcm9Pckhhc05vVmFsdWUgPSBBdXRvTnVtZXJpY0hlbHBlci5pc1plcm9Pckhhc05vVmFsdWUodmFsdWUpO1xuICAgICAgICBjb25zdCB0b3RhbExlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICAgICAgICBsZXQgdmFsdWVTaXplID0gMDtcbiAgICAgICAgbGV0IGludGVnZXJTaXplID0gMDtcbiAgICAgICAgbGV0IGhhc0RlY2ltYWxDaGFyID0gZmFsc2U7XG4gICAgICAgIGxldCBvZmZzZXREZWNpbWFsQ2hhciA9IDA7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNhcmV0UG9zaXRpb25PbkZvY3VzICE9PSBBdXRvTnVtZXJpYy5vcHRpb25zLmNhcmV0UG9zaXRpb25PbkZvY3VzLnN0YXJ0KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJysnLCAnJyk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UodGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCwgJycpO1xuICAgICAgICAgICAgdmFsdWVTaXplID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaGFzRGVjaW1hbENoYXIgPSBBdXRvTnVtZXJpY0hlbHBlci5jb250YWlucyh2YWx1ZSwgdGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2FyZXRQb3NpdGlvbk9uRm9jdXMgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY2FyZXRQb3NpdGlvbk9uRm9jdXMuZGVjaW1hbExlZnQgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmNhcmV0UG9zaXRpb25PbkZvY3VzID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmNhcmV0UG9zaXRpb25PbkZvY3VzLmRlY2ltYWxSaWdodCkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNEZWNpbWFsQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICBpbnRlZ2VyU2l6ZSA9IHZhbHVlLmluZGV4T2YodGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0RGVjaW1hbENoYXIgPSB0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVnZXJTaXplID0gdmFsdWVTaXplO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXREZWNpbWFsQ2hhciA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNpZ25Ub1VzZSA9ICcnO1xuICAgICAgICBpZiAoaXNWYWx1ZU5lZ2F0aXZlKSB7XG4gICAgICAgICAgICBzaWduVG9Vc2UgPSB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLnNob3dQb3NpdGl2ZVNpZ24gJiYgIWlzWmVyb09ySGFzTm9WYWx1ZSkge1xuICAgICAgICAgICAgc2lnblRvVXNlID0gdGhpcy5zZXR0aW5ncy5wb3NpdGl2ZVNpZ25DaGFyYWN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHBvc2l0aXZlTmVnYXRpdmVTaWduU2l6ZSA9IHNpZ25Ub1VzZS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGN1cnJlbmN5U3ltYm9sU2l6ZSA9IHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wubGVuZ3RoO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgY2FyZXQgcG9zaXRpb24gYmFzZWQgb24gYGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50YCwgYG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50YCBhbmQgYGNhcmV0UG9zaXRpb25PbkZvY3VzYFxuICAgICAgICBsZXQgY2FyZXRQb3NpdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQucHJlZml4KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5jYXJldFBvc2l0aW9uT25Gb2N1cyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jYXJldFBvc2l0aW9uT25Gb2N1cy5zdGFydCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50Lm5vbmUgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlzVmFsdWVOZWdhdGl2ZSB8fCAoIWlzVmFsdWVOZWdhdGl2ZSAmJiB0aGlzLnNldHRpbmdzLnNob3dQb3NpdGl2ZVNpZ24gJiYgIWlzWmVyb09ySGFzTm9WYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnByZWZpeDogLy8gK+KCrHwxMi4zNFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LmxlZnQ6ICAgLy8gK+KCrHwxMi4zNFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnJpZ2h0OiAgLy8g4oKsK3wxMi4zNFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSBwb3NpdGl2ZU5lZ2F0aXZlU2lnblNpemUgKyBjdXJyZW5jeVN5bWJvbFNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQuc3VmZml4OiAvLyDigqx8MTIuMzQrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IGN1cnJlbmN5U3ltYm9sU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g4oKsfDEyLjM0XG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSBjdXJyZW5jeVN5bWJvbFNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLmNhcmV0UG9zaXRpb25PbkZvY3VzID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmNhcmV0UG9zaXRpb25PbkZvY3VzLmVuZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50Lm5vbmUgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlzVmFsdWVOZWdhdGl2ZSB8fCAoIWlzVmFsdWVOZWdhdGl2ZSAmJiB0aGlzLnNldHRpbmdzLnNob3dQb3NpdGl2ZVNpZ24gJiYgIWlzWmVyb09ySGFzTm9WYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnByZWZpeDogLy8gK+KCrDEyLjM0fFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LmxlZnQ6ICAgLy8gK+KCrDEyLjM0fFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnJpZ2h0OiAgLy8g4oKsKzEyLjM0fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSB0b3RhbExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5zdWZmaXg6IC8vIOKCrDEyLjM0fCtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uID0gY3VycmVuY3lTeW1ib2xTaXplICsgdmFsdWVTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDigqwxMi4zNHxcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IHRvdGFsTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5jYXJldFBvc2l0aW9uT25Gb2N1cyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jYXJldFBvc2l0aW9uT25Gb2N1cy5kZWNpbWFsTGVmdCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50Lm5vbmUgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlzVmFsdWVOZWdhdGl2ZSB8fCAoIWlzVmFsdWVOZWdhdGl2ZSAmJiB0aGlzLnNldHRpbmdzLnNob3dQb3NpdGl2ZVNpZ24gJiYgIWlzWmVyb09ySGFzTm9WYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnByZWZpeDogLy8gK+KCrDEyfC4zNFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LmxlZnQ6ICAgLy8gK+KCrDEyfC4zNFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnJpZ2h0OiAgLy8g4oKsKzEyfC4zNFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSBwb3NpdGl2ZU5lZ2F0aXZlU2lnblNpemUgKyBjdXJyZW5jeVN5bWJvbFNpemUgKyBpbnRlZ2VyU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5zdWZmaXg6IC8vIOKCrDEyfC4zNCtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uID0gY3VycmVuY3lTeW1ib2xTaXplICsgaW50ZWdlclNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOKCrDEyfC4zNFxuICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uID0gY3VycmVuY3lTeW1ib2xTaXplICsgaW50ZWdlclNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLmNhcmV0UG9zaXRpb25PbkZvY3VzID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmNhcmV0UG9zaXRpb25PbkZvY3VzLmRlY2ltYWxSaWdodCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50Lm5vbmUgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlzVmFsdWVOZWdhdGl2ZSB8fCAoIWlzVmFsdWVOZWdhdGl2ZSAmJiB0aGlzLnNldHRpbmdzLnNob3dQb3NpdGl2ZVNpZ24gJiYgIWlzWmVyb09ySGFzTm9WYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnByZWZpeDogLy8gK+KCrDEyLnwzNFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LmxlZnQ6ICAgLy8gK+KCrDEyLnwzNFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnJpZ2h0OiAgLy8g4oKsKzEyLnwzNFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSBwb3NpdGl2ZU5lZ2F0aXZlU2lnblNpemUgKyBjdXJyZW5jeVN5bWJvbFNpemUgKyBpbnRlZ2VyU2l6ZSArIG9mZnNldERlY2ltYWxDaGFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnN1ZmZpeDogLy8g4oKsMTIufDM0K1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSBjdXJyZW5jeVN5bWJvbFNpemUgKyBpbnRlZ2VyU2l6ZSArIG9mZnNldERlY2ltYWxDaGFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDigqwxMi58MzRcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IGN1cnJlbmN5U3ltYm9sU2l6ZSArIGludGVnZXJTaXplICsgb2Zmc2V0RGVjaW1hbENoYXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQuc3VmZml4KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5jYXJldFBvc2l0aW9uT25Gb2N1cyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jYXJldFBvc2l0aW9uT25Gb2N1cy5zdGFydCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50Lm5vbmUgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlzVmFsdWVOZWdhdGl2ZSB8fCAoIWlzVmFsdWVOZWdhdGl2ZSAmJiB0aGlzLnNldHRpbmdzLnNob3dQb3NpdGl2ZVNpZ24gJiYgIWlzWmVyb09ySGFzTm9WYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnN1ZmZpeDogLy8gfDEyLjM04oKsK1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnJpZ2h0OiAgLy8gfDEyLjM04oKsK1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LmxlZnQ6ICAgLy8gfDEyLjM0K+KCrFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnByZWZpeDogLy8gK3wxMi4zNOKCrFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSBwb3NpdGl2ZU5lZ2F0aXZlU2lnblNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwxMi4zNOKCrFxuICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MuY2FyZXRQb3NpdGlvbk9uRm9jdXMgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY2FyZXRQb3NpdGlvbk9uRm9jdXMuZW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgIT09IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQubm9uZSAmJlxuICAgICAgICAgICAgICAgICAgICAoaXNWYWx1ZU5lZ2F0aXZlIHx8ICghaXNWYWx1ZU5lZ2F0aXZlICYmIHRoaXMuc2V0dGluZ3Muc2hvd1Bvc2l0aXZlU2lnbiAmJiAhaXNaZXJvT3JIYXNOb1ZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQuc3VmZml4OiAvLyAxMi4zNHzigqwrXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucmlnaHQ6ICAvLyAxMi4zNHzigqwrXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQubGVmdDogICAvLyAxMi4zNHwr4oKsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IHZhbHVlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5wcmVmaXg6IC8vICsxMi4zNHzigqxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uID0gcG9zaXRpdmVOZWdhdGl2ZVNpZ25TaXplICsgdmFsdWVTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxMi4zNHzigqxcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IHZhbHVlU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MuY2FyZXRQb3NpdGlvbk9uRm9jdXMgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY2FyZXRQb3NpdGlvbk9uRm9jdXMuZGVjaW1hbExlZnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCAhPT0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5ub25lICYmXG4gICAgICAgICAgICAgICAgICAgIChpc1ZhbHVlTmVnYXRpdmUgfHwgKCFpc1ZhbHVlTmVnYXRpdmUgJiYgdGhpcy5zZXR0aW5ncy5zaG93UG9zaXRpdmVTaWduICYmICFpc1plcm9Pckhhc05vVmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5zdWZmaXg6IC8vIDEyfC4zNOKCrCtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5yaWdodDogIC8vIDEyfC4zNOKCrCtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5sZWZ0OiAgIC8vIDEyfC4zNCvigqxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uID0gaW50ZWdlclNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucHJlZml4OiAvLyArMTJ8LjM04oKsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IHBvc2l0aXZlTmVnYXRpdmVTaWduU2l6ZSArIGludGVnZXJTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxMnwuMzTigqxcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbiA9IGludGVnZXJTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5jYXJldFBvc2l0aW9uT25Gb2N1cyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jYXJldFBvc2l0aW9uT25Gb2N1cy5kZWNpbWFsUmlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCAhPT0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5ub25lICYmXG4gICAgICAgICAgICAgICAgICAgIChpc1ZhbHVlTmVnYXRpdmUgfHwgKCFpc1ZhbHVlTmVnYXRpdmUgJiYgdGhpcy5zZXR0aW5ncy5zaG93UG9zaXRpdmVTaWduICYmICFpc1plcm9Pckhhc05vVmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5zdWZmaXg6IC8vIDEyLnwzNOKCrCtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5yaWdodDogIC8vIDEyLnwzNOKCrCtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5sZWZ0OiAgIC8vIDEyLnwzNCvigqxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uID0gaW50ZWdlclNpemUgKyBvZmZzZXREZWNpbWFsQ2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5wcmVmaXg6IC8vICsxMi58MzTigqxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uID0gcG9zaXRpdmVOZWdhdGl2ZVNpZ25TaXplICsgaW50ZWdlclNpemUgKyBvZmZzZXREZWNpbWFsQ2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMTIufDM04oKsXG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb24gPSBpbnRlZ2VyU2l6ZSArIG9mZnNldERlY2ltYWxDaGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYXJldFBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlIHRoZSB0cmFpbGluZyB6ZXJvZXMgdG8gdGhlIGdpdmVuIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJvdW5kZWRJbnB1dFZhbHVlXG4gICAgICogQHBhcmFtIHtpbnR9IGRlY2ltYWxQbGFjZXNOZWVkZWQgVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0byBrZWVwXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgX3RydW5jYXRlWmVyb3Mocm91bmRlZElucHV0VmFsdWUsIGRlY2ltYWxQbGFjZXNOZWVkZWQpIHtcbiAgICAgICAgbGV0IHJlZ2V4O1xuICAgICAgICBzd2l0Y2ggKGRlY2ltYWxQbGFjZXNOZWVkZWQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBwYWRkaW5nIC0gcmVtb3ZlcyB0cmFpbGluZyB6ZXJvcyB1bnRpbCB0aGUgZmlyc3Qgc2lnbmlmaWNhbnQgZGlnaXQgaXMgZW5jb3VudGVyZWRcbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwuKD86XFxkKlsxLTldKT8pMCokLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAvLyBBbGxvd3MgcGFkZGluZyB3aGVuIGRlY2ltYWxQbGFjZXNOZWVkZWQgZXF1YWxzIG9uZSAtIGxlYXZlcyBvbmUgemVybyB0cmFpbGluZyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwuXFxkKD86XFxkKlsxLTldKT8pMCokLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZXMgc3VwZXJmbHVvdXMgemVyb3MgYWZ0ZXIgdGhlIGRlY2ltYWxQbGFjZXNOZWVkZWQgbGVuZ3RoXG4gICAgICAgICAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKGAoXFxcXC5cXFxcZHske2RlY2ltYWxQbGFjZXNOZWVkZWR9fSg/OlxcXFxkKlsxLTldKT8pMCpgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBkZWNpbWFsIHBsYWNlcywgd2UgZG9uJ3QgbmVlZCBhIGRlY2ltYWwgcG9pbnQgYXQgdGhlIGVuZFxuICAgICAgICByb3VuZGVkSW5wdXRWYWx1ZSA9IHJvdW5kZWRJbnB1dFZhbHVlLnJlcGxhY2UocmVnZXgsICckMScpO1xuICAgICAgICBpZiAoZGVjaW1hbFBsYWNlc05lZWRlZCA9PT0gMCkge1xuICAgICAgICAgICAgcm91bmRlZElucHV0VmFsdWUgPSByb3VuZGVkSW5wdXRWYWx1ZS5yZXBsYWNlKC9cXC4kLywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJvdW5kZWRJbnB1dFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJvdW5kIHRoZSBnaXZlbiBgdmFsdWVgIHdpdGggdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0byBrZWVwIGZvciB0aGUgcmF3IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gdmFsdWUgQW4gdW5mb3JtYXR0ZWQgbnVtZXJpYyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9yb3VuZFJhd1ZhbHVlKHZhbHVlLCBzZXR0aW5ncykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm91bmRWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MsIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNSYXdWYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUm91bmQgdGhlIGdpdmVuIGB2YWx1ZWAgd2l0aCB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRvIHNob3cgZm9yIHRoZSBlbGVtZW50IGlzIGZvY3VzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSB2YWx1ZSBBbiB1bmZvcm1hdHRlZCBudW1lcmljIHZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX3JvdW5kRm9ybWF0dGVkVmFsdWVTaG93bk9uRm9jdXModmFsdWUsIHNldHRpbmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3VuZFZhbHVlKHZhbHVlLCBzZXR0aW5ncywgTnVtYmVyKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3VuZCB0aGUgZ2l2ZW4gYHZhbHVlYCB3aXRoIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdG8gc2hvdyBmb3IgdGhlIGVsZW1lbnQgaXMgdW5mb2N1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gdmFsdWUgQW4gdW5mb3JtYXR0ZWQgbnVtZXJpYyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9yb3VuZEZvcm1hdHRlZFZhbHVlU2hvd25PbkJsdXIodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3VuZFZhbHVlKHZhbHVlLCBzZXR0aW5ncywgTnVtYmVyKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uQmx1cikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJvdW5kIHRoZSBpbnB1dCB2YWx1ZSB1c2luZyB0aGUgcm91bmRpbmcgbWV0aG9kIGRlZmluZWQgaW4gdGhlIHNldHRpbmdzLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBtdWx0aXBsZSByb3VuZGluZyBtZXRob2RzLiBTZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgZGV0YWlscyBhYm91dCB0aG9zZS5cbiAgICAgKlxuICAgICAqIE5vdGUgOiBUaGlzIGlzIGhhbmRsZWQgYXMgdGV4dCBzaW5jZSBKYXZhU2NyaXB0IG1hdGggZnVuY3Rpb25zIGNhbiByZXR1cm4gaW5hY2N1cmF0ZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBpbnB1dFZhbHVlIEFuIHVuZm9ybWF0dGVkIG51bWVyaWMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge2ludH0gZGVjaW1hbFBsYWNlc1RvUm91bmRUb1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHN0YXRpYyBfcm91bmRWYWx1ZShpbnB1dFZhbHVlLCBzZXR0aW5ncywgZGVjaW1hbFBsYWNlc1RvUm91bmRUbykge1xuICAgICAgICAvL1hYWCBOb3RlOyB0aGlzIGZ1bmN0aW9uIGlzIHN0YXRpYyBzaW5jZSB3ZSBuZWVkIHRvIHBhc3MgYSBgc2V0dGluZ3NgIG9iamVjdCB3aGVuIGNhbGxpbmcgdGhlIHN0YXRpYyBgQXV0b051bWVyaWMuZm9ybWF0KClgIG1ldGhvZFxuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKGlucHV0VmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IHJvdW5kaW5nIGEgYG51bGxgIHZhbHVlXG4gICAgICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vVE9ETyBEaXZpZGUgdGhpcyBmdW5jdGlvbiB0byBtYWtlIGl0IGVhc2llciB0byB1bmRlcnN0YW5kXG4gICAgICAgIGlucHV0VmFsdWUgPSAoaW5wdXRWYWx1ZSA9PT0gJycpID8gJzAnIDogaW5wdXRWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICBpZiAoc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QudG9OZWFyZXN0MDUgfHxcbiAgICAgICAgICAgIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLnJvdW5kaW5nTWV0aG9kLnRvTmVhcmVzdDA1QWx0IHx8XG4gICAgICAgICAgICBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC51cFRvTmV4dDA1IHx8XG4gICAgICAgICAgICBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC5kb3duVG9OZXh0MDUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb3VuZENsb3NlVG8wNShpbnB1dFZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBbbmVnYXRpdmVTaWduLCBwcmVwYXJlZFZhbHVlXSA9IEF1dG9OdW1lcmljLl9wcmVwYXJlVmFsdWVGb3JSb3VuZGluZyhpbnB1dFZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIGlucHV0VmFsdWUgPSBwcmVwYXJlZFZhbHVlO1xuXG4gICAgICAgIGNvbnN0IGRlY2ltYWxDaGFyYWN0ZXJQb3NpdGlvbiA9IGlucHV0VmFsdWUubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgICAgY29uc3QgaW5wdXRWYWx1ZUhhc05vRG90ID0gZGVjaW1hbENoYXJhY3RlclBvc2l0aW9uID09PSAtMTsgLy8gTm8gZG90IGNoYXJhY3RlciBpcyBmb3VuZCBpbiB0aGUgYGlucHV0VmFsdWVgXG4gICAgICAgIGNvbnN0IFssIGRlY2ltYWxQYXJ0XSA9IGlucHV0VmFsdWUuc3BsaXQoJy4nKTsgLy8gSGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYWx3YXlzIGEgcGVyaW9kICcuJ1xuICAgICAgICBjb25zdCBoYXNEZWNpbWFscyA9IGRlY2ltYWxQYXJ0ID4gMDtcblxuICAgICAgICAvLyBJZiBubyBkZWNpbWFscyBhcmUgZGV0ZWN0ZWRcbiAgICAgICAgaWYgKCFoYXNEZWNpbWFscyAmJlxuICAgICAgICAgICAgKHNldHRpbmdzLmFsbG93RGVjaW1hbFBhZGRpbmcgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZy5uZXZlciB8fFxuICAgICAgICAgICAgc2V0dGluZ3MuYWxsb3dEZWNpbWFsUGFkZGluZyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nLmZsb2F0cykpIHtcbiAgICAgICAgICAgIHJldHVybiAoTnVtYmVyKGlucHV0VmFsdWUpID09PSAwKSA/IGlucHV0VmFsdWUgOiBgJHtuZWdhdGl2ZVNpZ259JHtpbnB1dFZhbHVlfWA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbHNlIHRoZXJlIGFyZSBzb21lIGRlY2ltYWwgcGxhY2VzIHRoYXQgbWF5IG5lZWQgdG8gYmUgcm91bmRlZFxuICAgICAgICAvLyBTZXRzIHRoZSB0cnVuY2F0ZSB6ZXJvIG1ldGhvZFxuICAgICAgICBsZXQgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlO1xuICAgICAgICBpZiAoc2V0dGluZ3MuYWxsb3dEZWNpbWFsUGFkZGluZyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nLmFsd2F5cyB8fFxuICAgICAgICAgICAgc2V0dGluZ3MuYWxsb3dEZWNpbWFsUGFkZGluZyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nLmZsb2F0cykge1xuICAgICAgICAgICAgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlID0gZGVjaW1hbFBsYWNlc1RvUm91bmRUbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgdGhlIGRlY2ltYWwgcG9zaXRpb24gdG8gdXNlICh1c2UgdGhlIHZlcnkgbGFzdCBwb3NpdGlvbiBpZiB0aGVyZSBhcmUgbm8gZG90IGluIHRoZSBpbml0aWFsIGlucHV0VmFsdWUpXG4gICAgICAgIGNvbnN0IGRlY2ltYWxQb3NpdGlvblRvVXNlID0gaW5wdXRWYWx1ZUhhc05vRG90ID8gaW5wdXRWYWx1ZS5sZW5ndGggLSAxIDogZGVjaW1hbENoYXJhY3RlclBvc2l0aW9uO1xuICAgICAgICAvLyBDaGVja3MgZGVjaW1hbCBwbGFjZXMgdG8gZGV0ZXJtaW5lIGlmIHJvdW5kaW5nIGlzIHJlcXVpcmVkXG4gICAgICAgIGxldCBjaGVja0RlY2ltYWxQbGFjZXMgPSAoaW5wdXRWYWx1ZS5sZW5ndGggLSAxKSAtIGRlY2ltYWxQb3NpdGlvblRvVXNlO1xuICAgICAgICBsZXQgaW5wdXRWYWx1ZVJvdW5kZWQgPSAnJztcblxuICAgICAgICAvLyBDaGVjayBpZiBubyByb3VuZGluZyBpcyByZXF1aXJlZFxuICAgICAgICBpZiAoY2hlY2tEZWNpbWFsUGxhY2VzIDw9IGRlY2ltYWxQbGFjZXNUb1JvdW5kVG8pIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gcGFkIHdpdGggemVyb3NcbiAgICAgICAgICAgIGlucHV0VmFsdWVSb3VuZGVkID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChjaGVja0RlY2ltYWxQbGFjZXMgPCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRWYWx1ZUhhc05vRG90KSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWVSb3VuZGVkID0gYCR7aW5wdXRWYWx1ZVJvdW5kZWR9JHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfWA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHplcm9zID0gJzAwMDAwMCc7IC8vVE9ETyBDaGFuZ2UgdGhhdCBzdHJpbmcgd2l0aCBhIGxvbmdlciBvbmUgdG8gcHJldmVudCBoYXZpbmcgdG8gbG9vcCBudW1lcm91cyB0aW1lcyBpbiB0aGUgbmV4dCBgd2hpbGVgIHN0YXRlbWVudD9cbiAgICAgICAgICAgICAgICB3aGlsZSAoY2hlY2tEZWNpbWFsUGxhY2VzIDwgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHplcm9zID0gemVyb3Muc3Vic3RyaW5nKDAsIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSAtIGNoZWNrRGVjaW1hbFBsYWNlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWVSb3VuZGVkICs9IHplcm9zO1xuICAgICAgICAgICAgICAgICAgICBjaGVja0RlY2ltYWxQbGFjZXMgKz0gemVyb3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hlY2tEZWNpbWFsUGxhY2VzID4gdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZVJvdW5kZWQgPSB0aGlzLl90cnVuY2F0ZVplcm9zKGlucHV0VmFsdWVSb3VuZGVkLCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGVja0RlY2ltYWxQbGFjZXMgPT09IDAgJiYgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSB0cmFpbGluZyBkb3QsIGlmIGFueVxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWVSb3VuZGVkID0gaW5wdXRWYWx1ZVJvdW5kZWQucmVwbGFjZSgvXFwuJC8sICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIChOdW1iZXIoaW5wdXRWYWx1ZVJvdW5kZWQpID09PSAwKSA/IGlucHV0VmFsdWVSb3VuZGVkIDogYCR7bmVnYXRpdmVTaWdufSR7aW5wdXRWYWx1ZVJvdW5kZWR9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJvdW5kZWQgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgYWZ0ZXIgcm91bmRpbmdcbiAgICAgICAgbGV0IHJvdW5kZWRTdHJMZW5ndGg7XG4gICAgICAgIGlmIChpbnB1dFZhbHVlSGFzTm9Eb3QpIHtcbiAgICAgICAgICAgIHJvdW5kZWRTdHJMZW5ndGggPSBkZWNpbWFsUGxhY2VzVG9Sb3VuZFRvIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvdW5kZWRTdHJMZW5ndGggPSBOdW1iZXIoZGVjaW1hbFBsYWNlc1RvUm91bmRUbykgKyBOdW1iZXIoZGVjaW1hbENoYXJhY3RlclBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxhc3REaWdpdCA9IE51bWJlcihpbnB1dFZhbHVlLmNoYXJBdChyb3VuZGVkU3RyTGVuZ3RoICsgMSkpO1xuICAgICAgICBsZXQgaW5wdXRWYWx1ZUFycmF5ID0gaW5wdXRWYWx1ZS5zdWJzdHJpbmcoMCwgcm91bmRlZFN0ckxlbmd0aCArIDEpLnNwbGl0KCcnKTtcbiAgICAgICAgbGV0IG9kZDtcbiAgICAgICAgaWYgKGlucHV0VmFsdWUuY2hhckF0KHJvdW5kZWRTdHJMZW5ndGgpID09PSAnLicpIHtcbiAgICAgICAgICAgIG9kZCA9IGlucHV0VmFsdWUuY2hhckF0KHJvdW5kZWRTdHJMZW5ndGggLSAxKSAlIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZGQgPSBpbnB1dFZhbHVlLmNoYXJBdChyb3VuZGVkU3RyTGVuZ3RoKSAlIDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc2hvdWxkUm91bmRVcChsYXN0RGlnaXQsIHNldHRpbmdzLCBuZWdhdGl2ZVNpZ24sIG9kZCkpIHtcbiAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRoZSBsYXN0IGRpZ2l0IGlmIHJlcXVpcmVkLCBhbmQgY29udGludWUgdW50aWwgbm8gbW9yZSA5J3MgYXJlIGZvdW5kXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gKGlucHV0VmFsdWVBcnJheS5sZW5ndGggLSAxKTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRWYWx1ZUFycmF5W2ldICE9PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZUFycmF5W2ldID0gK2lucHV0VmFsdWVBcnJheVtpXSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFZhbHVlQXJyYXlbaV0gPCAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWVBcnJheVtpXSA9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBzdHJpbmcsIGNvbnZlcnRpbmcgYW55IDEwJ3MgdG8gMCdzXG4gICAgICAgIGlucHV0VmFsdWVBcnJheSA9IGlucHV0VmFsdWVBcnJheS5zbGljZSgwLCByb3VuZGVkU3RyTGVuZ3RoICsgMSk7XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSByb3VuZGVkIHZhbHVlXG4gICAgICAgIGlucHV0VmFsdWVSb3VuZGVkID0gdGhpcy5fdHJ1bmNhdGVaZXJvcyhpbnB1dFZhbHVlQXJyYXkuam9pbignJyksIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSk7XG5cbiAgICAgICAgcmV0dXJuIChOdW1iZXIoaW5wdXRWYWx1ZVJvdW5kZWQpID09PSAwKSA/IGlucHV0VmFsdWVSb3VuZGVkIDogYCR7bmVnYXRpdmVTaWdufSR7aW5wdXRWYWx1ZVJvdW5kZWR9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3VuZCB0aGUgYHZhbHVlYCB3aGVuIHRoZSByb3VuZGluZyBtZXRob2QgZGVhbHMgd2l0aCAnLjA1J1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBfcm91bmRDbG9zZVRvMDUodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3Mucm91bmRpbmdNZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC50b05lYXJlc3QwNTpcbiAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC50b05lYXJlc3QwNUFsdDpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IChNYXRoLnJvdW5kKHZhbHVlICogMjApIC8gMjApLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QudXBUb05leHQwNTpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IChNYXRoLmNlaWwodmFsdWUgKiAyMCkgLyAyMCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgIHZhbHVlID0gKE1hdGguZmxvb3IodmFsdWUgKiAyMCkgLyAyMCkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuY29udGFpbnModmFsdWUsICcuJykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlICsgJy4wMCc7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoIC0gdmFsdWUuaW5kZXhPZignLicpIDwgMykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUgKyAnMCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kaWZ5IHRoZSBnaXZlbiBgdmFsdWVgIGluIG9yZGVyIHRvIG1ha2UgaXQgdXNhYmxlIGZvciB0aGUgcmVzdCBvZiB0aGUgcm91bmRpbmcgZnVuY3Rpb24uXG4gICAgICogVGhpcyBjb252ZXJ0IHRoZSBgdmFsdWVgIHRvIGEgcG9zaXRpdmUgb25lLCB0cmltIGFueSBsZWFkaW5nIHplcm9zIGFuZCBtYWtlIHN1cmUgaXQgZG9lcyBub3Qgc3RhcnRzIHdpdGggYSBsZWFkaW5nIGRvdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtbc3RyaW5nLCBzdHJpbmddfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9wcmVwYXJlVmFsdWVGb3JSb3VuZGluZyh2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICAgICAgLy8gQ2hlY2tzIGlmIGBpbnB1dFZhbHVlYCBpcyBhIG5lZ2F0aXZlIHZhbHVlXG4gICAgICAgIGxldCBuZWdhdGl2ZVNpZ24gPSAnJztcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTmVnYXRpdmVTdHJpY3QodmFsdWUpKSB7XG4gICAgICAgICAgICBuZWdhdGl2ZVNpZ24gPSAnLSc7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZXMgdGhlIG5lZ2F0aXZlIHNpZ24gdGhhdCB3aWxsIGJlIGFkZGVkIGJhY2sgbGF0ZXIgaWYgcmVxdWlyZWRcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgnLScsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGVuZCBhIHplcm8gaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBub3QgYSBkaWdpdCAodGhlbiBpdCBpcyBsaWtlbHkgYSBkb3QpXG4gICAgICAgIGlmICghdmFsdWUubWF0Y2goL15cXGQvKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBgMCR7dmFsdWV9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZXMgaWYgdGhlIHZhbHVlIGlzIGVxdWFsIHRvIHplcm8uIElmIGl0IGlzLCByZW1vdmUgdGhlIG5lZ2F0aXZlIHNpZ25cbiAgICAgICAgaWYgKE51bWJlcih2YWx1ZSkgPT09IDApIHtcbiAgICAgICAgICAgIG5lZ2F0aXZlU2lnbiA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJpbXMgbGVhZGluZyB6ZXJvJ3MgYXMgbmVlZGVkXG4gICAgICAgIGlmICgoTnVtYmVyKHZhbHVlKSA+IDAgJiYgc2V0dGluZ3MubGVhZGluZ1plcm8gIT09IEF1dG9OdW1lcmljLm9wdGlvbnMubGVhZGluZ1plcm8ua2VlcCkgfHxcbiAgICAgICAgICAgICh2YWx1ZS5sZW5ndGggPiAwICYmIHNldHRpbmdzLmxlYWRpbmdaZXJvID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmxlYWRpbmdaZXJvLmFsbG93KSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eMCooXFxkKS8sICckMScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtuZWdhdGl2ZVNpZ24sIHZhbHVlXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIGEgcm91bmQgdXAgc2hvdWxkIGJlIGRvbmUgZ2l2ZW4gdGhlIGxhc3QgZGlnaXQsIHRoZSBzZXR0aW5ncyBhbmQgb3RoZXIgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHZhbHVlLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0RGlnaXRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmVnYXRpdmVTaWduXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9kZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9zaG91bGRSb3VuZFVwKGxhc3REaWdpdCwgc2V0dGluZ3MsIG5lZ2F0aXZlU2lnbiwgb2RkKSB7XG4gICAgICAgIHJldHVybiAobGFzdERpZ2l0ID4gNCAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC5oYWxmVXBTeW1tZXRyaWMpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgdXAgc3ltbWV0cmljXG4gICAgICAgICAgICAobGFzdERpZ2l0ID4gNCAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC5oYWxmVXBBc3ltbWV0cmljICYmIG5lZ2F0aXZlU2lnbiA9PT0gJycpICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgdXAgYXN5bW1ldHJpYyBwb3NpdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgIChsYXN0RGlnaXQgPiA1ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLnJvdW5kaW5nTWV0aG9kLmhhbGZVcEFzeW1tZXRyaWMgJiYgbmVnYXRpdmVTaWduID09PSAnLScpICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiB1cCBhc3ltbWV0cmljIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAgICAgICAgKGxhc3REaWdpdCA+IDUgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QuaGFsZkRvd25TeW1tZXRyaWMpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAvLyBSb3VuZCBoYWxmIGRvd24gc3ltbWV0cmljXG4gICAgICAgICAgICAobGFzdERpZ2l0ID4gNSAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5yb3VuZGluZ01ldGhvZC5oYWxmRG93bkFzeW1tZXRyaWMgJiYgbmVnYXRpdmVTaWduID09PSAnJykgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgZG93biBhc3ltbWV0cmljIHBvc2l0aXZlIHZhbHVlc1xuICAgICAgICAgICAgKGxhc3REaWdpdCA+IDQgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QuaGFsZkRvd25Bc3ltbWV0cmljICYmIG5lZ2F0aXZlU2lnbiA9PT0gJy0nKSAgICAgICAgICAgICB8fCAvLyBSb3VuZCBoYWxmIGRvd24gYXN5bW1ldHJpYyBuZWdhdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgIChsYXN0RGlnaXQgPiA1ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLnJvdW5kaW5nTWV0aG9kLmhhbGZFdmVuQmFua2Vyc1JvdW5kaW5nKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHxcbiAgICAgICAgICAgIChsYXN0RGlnaXQgPT09IDUgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QuaGFsZkV2ZW5CYW5rZXJzUm91bmRpbmcgJiYgb2RkID09PSAxKSAgICAgICAgICAgICAgICAgfHxcbiAgICAgICAgICAgIChsYXN0RGlnaXQgPiAwICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLnJvdW5kaW5nTWV0aG9kLnRvQ2VpbGluZ1Rvd2FyZFBvc2l0aXZlSW5maW5pdHkgJiYgbmVnYXRpdmVTaWduID09PSAnJykgfHxcbiAgICAgICAgICAgIChsYXN0RGlnaXQgPiAwICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLnJvdW5kaW5nTWV0aG9kLnRvRmxvb3JUb3dhcmROZWdhdGl2ZUluZmluaXR5ICYmIG5lZ2F0aXZlU2lnbiA9PT0gJy0nKSAgfHxcbiAgICAgICAgICAgIChsYXN0RGlnaXQgPiAwICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLnJvdW5kaW5nTWV0aG9kLnVwUm91bmRBd2F5RnJvbVplcm8pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm91bmQgdXAgYXdheSBmcm9tIHplcm9cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZXMgdGhlIGRlY2ltYWwgcGFydCBvZiBhIG51bWJlciB0byB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGBkZWNpbWFsUGxhY2VzVG9Sb3VuZFRvYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNQYXN0ZVxuICAgICAqIEBwYXJhbSB7aW50fSBkZWNpbWFsUGxhY2VzVG9Sb3VuZFRvXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc3RhdGljIF90cnVuY2F0ZURlY2ltYWxQbGFjZXModmFsdWUsIHNldHRpbmdzLCBpc1Bhc3RlLCBkZWNpbWFsUGxhY2VzVG9Sb3VuZFRvKSB7XG4gICAgICAgIGlmIChpc1Bhc3RlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3JvdW5kRm9ybWF0dGVkVmFsdWVTaG93bk9uRm9jdXModmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gdmFsdWUuc3BsaXQoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG5cbiAgICAgICAgLy8gVHJ1bmNhdGUgdGhlIGRlY2ltYWwgcGFydCB0byB0aGUgc2F0aXNmeWluZyBsZW5ndGggc2luY2Ugd2Ugd291bGQgcm91bmQgaXQgYW55d2F5XG4gICAgICAgIGlmIChkZWNpbWFsUGFydCAmJiBkZWNpbWFsUGFydC5sZW5ndGggPiBkZWNpbWFsUGxhY2VzVG9Sb3VuZFRvKSB7XG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBsYWNlc1RvUm91bmRUbyA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZERlY2ltYWxQYXJ0ID0gZGVjaW1hbFBhcnQuc3Vic3RyaW5nKDAsIGRlY2ltYWxQbGFjZXNUb1JvdW5kVG8pO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYCR7aW50ZWdlclBhcnR9JHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7bW9kaWZpZWREZWNpbWFsUGFydH1gO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGludGVnZXJQYXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgdGhlIG51bWJlciBzYXRpc2Z5IHRoZSBmb3JtYXQgY29uZGl0aW9uc1xuICAgICAqIGFuZCBsYXlzIGJldHdlZW4gc2V0dGluZ3MubWluaW11bVZhbHVlIGFuZCBzZXR0aW5ncy5tYXhpbXVtVmFsdWVcbiAgICAgKiBhbmQgdGhlIHN0cmluZyBsZW5ndGggZG9lcyBub3QgZXhjZWVkIHRoZSBkaWdpdHMgaW4gc2V0dGluZ3MubWluaW11bVZhbHVlIGFuZCBzZXR0aW5ncy5tYXhpbXVtVmFsdWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHN0YXRpYyBfY2hlY2tJZkluUmFuZ2VXaXRoT3ZlcnJpZGVPcHRpb24odmFsdWUsIHNldHRpbmdzKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCcsJywgJy4nKTtcbiAgICAgICAgY29uc3QgbWluUGFyc2UgPSBBdXRvTnVtZXJpY0hlbHBlci5wYXJzZVN0cihzZXR0aW5ncy5taW5pbXVtVmFsdWUpO1xuICAgICAgICBjb25zdCBtYXhQYXJzZSA9IEF1dG9OdW1lcmljSGVscGVyLnBhcnNlU3RyKHNldHRpbmdzLm1heGltdW1WYWx1ZSk7XG4gICAgICAgIGNvbnN0IHZhbFBhcnNlID0gQXV0b051bWVyaWNIZWxwZXIucGFyc2VTdHIodmFsdWUpO1xuXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3Mub3ZlcnJpZGVNaW5NYXhMaW1pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5vdmVycmlkZU1pbk1heExpbWl0cy5mbG9vcjpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbQXV0b051bWVyaWNIZWxwZXIudGVzdE1pbk1heChtaW5QYXJzZSwgdmFsUGFyc2UpID4gLTEsIHRydWVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm92ZXJyaWRlTWluTWF4TGltaXRzLmNlaWxpbmc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3RydWUsIEF1dG9OdW1lcmljSGVscGVyLnRlc3RNaW5NYXgobWF4UGFyc2UsIHZhbFBhcnNlKSA8IDFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm92ZXJyaWRlTWluTWF4TGltaXRzLmlnbm9yZTpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdHJ1ZSwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtBdXRvTnVtZXJpY0hlbHBlci50ZXN0TWluTWF4KG1pblBhcnNlLCB2YWxQYXJzZSkgPiAtMSwgQXV0b051bWVyaWNIZWxwZXIudGVzdE1pbk1heChtYXhQYXJzZSwgdmFsUGFyc2UpIDwgMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiB0aGUgYGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXNgIGFuZCBgc2hvd09ubHlOdW1iZXJzT25Gb2N1c2Agb3B0aW9ucyBhcmUgdXNlZC5cbiAgICAgKiBUaG9zZSBvcmlnaW5hbCBzZXR0aW5ncyBhcmUgdXNlZCBleGNsdXNpdmVseSBpbiB0aGUgYGZvY3VzaW5gIGFuZCBgZm9jdXNvdXRgIGV2ZW50IGhhbmRsZXJzLlxuICAgICAqL1xuICAgIF9rZWVwQW5PcmlnaW5hbFNldHRpbmdzQ29weSgpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbERpZ2l0R3JvdXBTZXBhcmF0b3IgPSB0aGlzLnNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3I7XG4gICAgICAgIHRoaXMub3JpZ2luYWxDdXJyZW5jeVN5bWJvbCAgICAgID0gdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFN1ZmZpeFRleHQgICAgICAgICAgPSB0aGlzLnNldHRpbmdzLnN1ZmZpeFRleHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzYCAmIGBzaG93T25seU51bWJlcnNPbkZvY3VzYCBvcHRpb25zIGFyZSBiZWluZyB1c2VkLlxuICAgICAqIFRoaXMgaXMgdGFrZW4gZnJvbSBRdWlya3Ntb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzdGF0aWMgX3JlYWRDb29raWUobmFtZSkge1xuICAgICAgICBjb25zdCBuYW1lRVEgPSBuYW1lICsgJz0nO1xuICAgICAgICBjb25zdCBjYSA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpO1xuICAgICAgICBsZXQgYyA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjID0gY2FbaV07XG4gICAgICAgICAgICB3aGlsZSAoYy5jaGFyQXQoMCkgPT09ICcgJykge1xuICAgICAgICAgICAgICAgIGMgPSBjLnN1YnN0cmluZygxLCBjLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYy5pbmRleE9mKG5hbWVFUSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYy5zdWJzdHJpbmcobmFtZUVRLmxlbmd0aCwgYy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBzZXNzaW9uU3RvcmFnZSBpcyBzdXBwb3J0ZWQuXG4gICAgICogVGhpcyBpcyB0YWtlbiBmcm9tIE1vZGVybml6ci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBfc3RvcmFnZVRlc3QoKSB7XG4gICAgICAgIGNvbnN0IG1vZCA9ICdtb2Rlcm5penInO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShtb2QsIG1vZCk7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKG1vZCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbnkgemVyb3MgaW4gZXhjZXNzIGluIHRoZSBmcm9udCBhbmQgYmFjayBvZiB0aGUgZ2l2ZW4gYHZhbHVlYCwgYWNjb3JkaW5nIHRvIHRoZSBgc2V0dGluZ3NgLlxuICAgICAqIFRoaXMgYWxzbyBtYW5hZ2VzIHRoZSBjYXNlcyB3aGVyZSB0aGUgZGVjaW1hbCBwb2ludCBpcyBvbiB0aGUgZmFyIGxlZnQgb3IgZmFyIHJpZ2h0IG9mIHRoZSBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIF90cmltTGVhZGluZ0FuZFRyYWlsaW5nWmVyb3ModmFsdWUpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcgaXMgdGhlIHZhbHVlIGlzIGFscmVhZHkgZW1wdHkuIFRoaXMgcHJldmVudCBjb252ZXJ0aW5nIHRoYXQgdmFsdWUgdG8gJzAnLlxuICAgICAgICBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5sZWFkaW5nWmVybyAhPT0gQXV0b051bWVyaWMub3B0aW9ucy5sZWFkaW5nWmVyby5rZWVwKSB7XG4gICAgICAgICAgICBpZiAoTnVtYmVyKHZhbHVlKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFJldHVybiAnMCcgaWYgdGhlIHZhbHVlIGlzIHplcm9cbiAgICAgICAgICAgICAgICByZXR1cm4gJzAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUcmltIHRoZSBsZWFkaW5nIHplcm9zLCB3aGlsZSBsZWF2aW5nIG9uZSB6ZXJvIHRvIHRoZSBsZWZ0IG9mIHRoZSBkZWNpbWFsIHBvaW50IGlmIG5lZWRlZFxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eKC0pPzArKD89XFxkKS9nLCckMScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9UT0RPIHJlbW92ZSB0aGlzIGZyb20gdGhhdCBmdW5jdGlvbiBhbmQgdXNlIGB0cmltUGFkZGVkWmVyb3NGcm9tRGVjaW1hbFBsYWNlcygpYCBpbnN0ZWFkXG4gICAgICAgIC8vIFRyaW0gdGhlIHRyYWlsaW5nIHplcm9zIGFmdGVyIHRoZSBsYXN0IGRlY2ltYWwgcGxhY2Ugbm90IGJlaW5nIGEgemVybyAoaWUuIDEuMjMwMCAtPiAxLjIzKVxuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuY29udGFpbnModmFsdWUsICcuJykpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvKFxcLlswLTldKj8pMCskLywgJyQxJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgYW55IHRyYWlsaW5nIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXC4kLywgJycpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgbmFtZSBmb3IgdGhlIHBlcnNpc3RlbnQgc3RvcmVkIGRhdGEgdmFyaWFibGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRQZXJzaXN0ZW50U3RvcmFnZU5hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbUVsZW1lbnQubmFtZSAhPT0gJycgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkKHRoaXMuZG9tRWxlbWVudC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmF3VmFsdWVTdG9yYWdlTmFtZSA9IGAke3RoaXMuc3RvcmFnZU5hbWVQcmVmaXh9JHtkZWNvZGVVUklDb21wb25lbnQodGhpcy5kb21FbGVtZW50Lm5hbWUpfWA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmF3VmFsdWVTdG9yYWdlTmFtZSA9IGAke3RoaXMuc3RvcmFnZU5hbWVQcmVmaXh9JHt0aGlzLmRvbUVsZW1lbnQuaWR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhdmUgdGhlIHJhdyBWYWx1ZSBpbnRvIHNlc3Npb25TdG9yYWdlIG9yIGEgY29va2llIGRlcGVuZGluZyBvbiB3aGF0IHRoZSBicm93c2VyIGlzIHN1cHBvcnRpbmcuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Vzc2lvblN0b3JhZ2VBdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHRoaXMucmF3VmFsdWVTdG9yYWdlTmFtZSwgdGhpcy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBjb29raWVzIGZvciBvYnNvbGV0ZSBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IHNlc3Npb25TdG9yYWdlIChpZS4gSUUgNiAmIDcpXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gYCR7dGhpcy5yYXdWYWx1ZVN0b3JhZ2VOYW1lfT0ke3RoaXMucmF3VmFsdWV9OyBleHBpcmVzPSA7IHBhdGg9L2A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgcmF3IHZhbHVlIGZyb20gc2Vzc2lvblN0b3JhZ2Ugb3IgdGhlIGNvb2tpZSBkZXBlbmRpbmcgb24gd2hhdCB0aGUgYnJvd3NlciBpcyBzdXBwb3J0aW5nLlxuICAgICAqXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0VmFsdWVGcm9tUGVyc2lzdGVudFN0b3JhZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXNzaW9uU3RvcmFnZUF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0odGhpcy5yYXdWYWx1ZVN0b3JhZ2VOYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fcmVhZENvb2tpZSh0aGlzLnJhd1ZhbHVlU3RvcmFnZU5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgQXV0b051bWVyaWNIZWxwZXIud2FybmluZygnYF9nZXRWYWx1ZUZyb21QZXJzaXN0ZW50U3RvcmFnZSgpYCBpcyBjYWxsZWQgYnV0IGBzZXR0aW5ncy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlYCBpcyBmYWxzZS4gVGhlcmUgbXVzdCBiZSBhbiBlcnJvciB0aGF0IG5lZWRzIGZpeGluZy4nLCB0aGlzLnNldHRpbmdzLnNob3dXYXJuaW5ncyk7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSByYXcgdmFsdWUgZGF0YSBmcm9tIHNlc3Npb25TdG9yYWdlIG9yIHRoZSBjb29raWUgZGVwZW5kaW5nIG9uIHdoYXQgdGhlIGJyb3dzZXIgaXMgc3VwcG9ydGluZy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmVWYWx1ZUZyb21QZXJzaXN0ZW50U3RvcmFnZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Vzc2lvblN0b3JhZ2VBdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMucmF3VmFsdWVTdG9yYWdlTmFtZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSAtIDg2NDAwMDAwKTsgLy8gLTg2NDAwMDAwID09PSAtMSAqIDI0ICogNjAgKiA2MCAqIDEwMDBcbiAgICAgICAgICAgICAgICBjb25zdCBleHBpcmVzID0gYDsgZXhwaXJlcz0ke2RhdGUudG9VVENTdHJpbmcoKX1gO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke3RoaXMucmF3VmFsdWVTdG9yYWdlTmFtZX09JycgOyR7ZXhwaXJlc307IHBhdGg9L2A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAnZm9jdXNpbicgYW5kICdtb3VzZWVudGVyJyBldmVudHNcbiAgICAgKiBPbiBmb2N1c2luLCBtdWx0aXBsZSB0aGluZ3MgaGFwcGVucyA6XG4gICAgICogLSBJZiBgQWx0YCBpcyBwcmVzc2VkLCB1bmZvcm1hdFxuICAgICAqIC0gUmVtb3ZlIHRoZSBzZXBhcmF0b3JzIGlmIGBzaG93T25seU51bWJlcnNPbkZvY3VzYCBpcyBzZXRcbiAgICAgKiAtIERlcGVuZGluZyBvbiBgZW1wdHlJbnB1dEJlaGF2aW9yYCwgcmVmb3JtYXQgdGhlIGVtcHR5IGZvcm1hdHRlZCB2YWx1ZVxuICAgICAqIC0gRGlzcGxheSB0aGUgY29ycmVjdCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgKG9uIGZvY3VzL2JsdXIpXG4gICAgICogLSBQbGFjZSB0aGUgY2FyZXQgY29ycmVjdGx5IGlmIHRoZSBlbGVtZW50IGlzIGVtcHR5XG4gICAgICpcbiAgICAgKiBOb3RlOiBPbiBmb2N1c2luLCB0aGUgYHJhd1ZhbHVlYCBpcyBuZXZlciBjaGFuZ2VkLiBPbmx5IHRoZSBmb3JtYXR0ZWQgdmFsdWUgY2FuIGJlIG1vZGlmaWVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uRm9jdXNJbkFuZE1vdXNlRW50ZXIoZSkge1xuICAgICAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlOyAvLyBKdXN0IGluIGNhc2Ugbm8gYGtleVVwYCBldmVudCBoYXZlIGJlZW4gc2VudCAoaWYgdGhlIHVzZXIgbG9zdCB0aGUgZm9jdXMgdG8gdGhlIHdpbmRvdyB3aGlsZSB0eXBpbmcpXG5cbiAgICAgICAgLy9UT0RPIGBBdXRvTnVtZXJpY0hlbHBlci5zZXRFbGVtZW50VmFsdWVgIGlzIGNhbGxlZCAzIHRpbWVzIHNlcXVlbnRpYWxseSBoZXJlLCBmaXggdGhhdFxuICAgICAgICAvL1RPRE8gQ3JlYXRlIHNlcGFyYXRlIGhhbmRsZXJzIGZvciB0aGUgZm9jdXMgYW5kIG1vdXNlZW50ZXIgZXZlbnRzXG4gICAgICAgIGNvbnN0IGluaXRpYWxFbGVtZW50VmFsdWUgPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnVuZm9ybWF0T25Ib3ZlciAmJiBlLnR5cGUgPT09ICdtb3VzZWVudGVyJyAmJiBlLmFsdEtleSkge1xuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fdW5mb3JtYXRBbHRIb3ZlcmVkKHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS50eXBlID09PSAnZm9jdXMnKSB7IC8vVE9ETyBNb3ZlIHRoYXQgYmFjayB0byB0aGUgJ2ZvY3VzJyBldmVudCBoYW5kbGVyIHdoZW4gdGhlIHNlcGFyYXRpb24gYmV0d2VlbiB0aGUgJ2ZvY3VzJyBhbmQgJ21vdXNlZW50ZXInIGhhbmRsZXIgd2lsbCBiZSBkb25lXG4gICAgICAgICAgICAvLyBXZSBrZWVwIHRyYWNrIGlmIHRoZSBlbGVtZW50IGlzIGN1cnJlbnRseSBmb2N1c2VkXG4gICAgICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS50eXBlID09PSAnZm9jdXMnICYmIHRoaXMuc2V0dGluZ3MudW5mb3JtYXRPbkhvdmVyICYmIHRoaXMuaG92ZXJlZFdpdGhBbHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuX3JlZm9ybWF0QWx0SG92ZXJlZCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLnR5cGUgPT09ICdmb2N1cycgfHwgZS50eXBlID09PSAnbW91c2VlbnRlcicgJiYgIXRoaXMuaXNGb2N1c2VkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuZW1wdHlJbnB1dEJlaGF2aW9yLmZvY3VzICYmXG4gICAgICAgICAgICAgICAgdGhpcy5yYXdWYWx1ZSA8IDAgJiYgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAhPT0gbnVsbCAmJiB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJycpIHsgLy9GSVhNRSB0aGlzIGlzIGNhbGxlZCBhIHNlY29uZCB0aW1lIGluIF9hZGRHcm91cFNlcGFyYXRvcnMgdG9vLiBQcmV2ZW50IHRoaXMsIGlmIHBvc3NpYmxlLlxuICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVtb3ZlIHRoZSBicmFja2V0cyBpZiB0aGUgdmFsdWUgaXMgbmVnYXRpdmVcbiAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5zZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLl9yZW1vdmVCcmFja2V0cyhBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KSwgdGhpcy5zZXR0aW5ncykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgdGhlIHJhd1ZhbHVlLCBtdWx0aXBsaWVkIGJ5IGByYXdWYWx1ZURpdmlzb3JgIGlmIGRlZmluZWRcbiAgICAgICAgICAgIGNvbnN0IHJhd1ZhbHVlVG9Gb3JtYXQgPSB0aGlzLl9nZXRSYXdWYWx1ZVRvRm9ybWF0KHRoaXMucmF3VmFsdWUpO1xuXG4gICAgICAgICAgICAvLyBNb2RpZnkgdGhlIGVsZW1lbnQgdmFsdWUgYWNjb3JkaW5nIHRvIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdG8gc2hvdyBvbiBmb2N1cyBvciB0aGUgYHNob3dPbmx5TnVtYmVyc09uRm9jdXNgIG9wdGlvblxuICAgICAgICAgICAgaWYgKHJhd1ZhbHVlVG9Gb3JtYXQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgLy8gUm91bmQgdGhlIGdpdmVuIHZhbHVlIGFjY29yZGluZyB0byB0aGUgb2JqZWN0IHN0YXRlIChmb2N1cy91bmZvY3VzZWQpXG4gICAgICAgICAgICAgICAgbGV0IHJvdW5kZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcm91bmRlZFZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rvci5fcm91bmRGb3JtYXR0ZWRWYWx1ZVNob3duT25Gb2N1cyhyYXdWYWx1ZVRvRm9ybWF0LCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb3VuZGVkVmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLl9yb3VuZEZvcm1hdHRlZFZhbHVlU2hvd25PbkJsdXIocmF3VmFsdWVUb0Zvcm1hdCwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2hvd09ubHlOdW1iZXJzT25Gb2N1cyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5zaG93T25seU51bWJlcnNPbkZvY3VzLm9ubHlOdW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBVc2UgYSBgdGhpcy5zZXR0aW5nc092ZXJyaWRlYCBvYmplY3QgaW5zdGVhZCBvZiBtb2RpZnlpbmcgdGhlIGB0aGlzLnNldHRpbmdzYCBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgICAgICA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnN1ZmZpeFRleHQgICAgICAgICAgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuc2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCwgcm91bmRlZFZhbHVlLnJlcGxhY2UoJy4nLCB0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bGwocm91bmRlZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rvci5fYWRkR3JvdXBTZXBhcmF0b3JzKHJvdW5kZWRWYWx1ZS5yZXBsYWNlKCcuJywgdGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSwgdGhpcy5zZXR0aW5ncywgdGhpcy5pc0ZvY3VzZWQsIHJhd1ZhbHVlVG9Gb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRWYWx1ZSh0aGlzLmRvbUVsZW1lbnQsIGZvcm1hdHRlZFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIHNlbmQgYSAnbmF0aXZlJyBjaGFuZ2UgZXZlbnQgd2hlbiBibHVycmluZyB0aGUgaW5wdXQsIHdlIG5lZWQgdG8gZmlyc3Qgc3RvcmUgdGhlIGluaXRpYWwgaW5wdXQgdmFsdWUgb24gZm9jdXMuXG4gICAgICAgICAgICB0aGlzLnZhbHVlT25Gb2N1cyA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZShlLnRhcmdldCk7XG4gICAgICAgICAgICB0aGlzLmxhc3RWYWwgPSB0aGlzLnZhbHVlT25Gb2N1cztcbiAgICAgICAgICAgIGNvbnN0IGlzRW1wdHlWYWx1ZSA9IHRoaXMuY29uc3RydWN0b3IuX2lzRWxlbWVudFZhbHVlRW1wdHlPck9ubHlUaGVOZWdhdGl2ZVNpZ24odGhpcy52YWx1ZU9uRm9jdXMsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICAgICAgY29uc3Qgb3JkZXJlZFZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rvci5fb3JkZXJWYWx1ZUN1cnJlbmN5U3ltYm9sQW5kU3VmZml4VGV4dCh0aGlzLnZhbHVlT25Gb2N1cywgdGhpcy5zZXR0aW5ncywgdHJ1ZSk7IC8vIFRoaXMgZGlzcGxheXMgdGhlIGN1cnJlbmN5IHNpZ24gb24gaG92ZXIgZXZlbiBpZiB0aGUgcmF3VmFsdWUgaXMgZW1wdHlcbiAgICAgICAgICAgIGlmICgoaXNFbXB0eVZhbHVlICYmIG9yZGVyZWRWYWx1ZSAhPT0gJycpICYmIHRoaXMuc2V0dGluZ3MuZW1wdHlJbnB1dEJlaGF2aW9yID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvci5mb2N1cykge1xuICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRWYWx1ZSh0aGlzLmRvbUVsZW1lbnQsIG9yZGVyZWRWYWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIGN1cnJlbmN5IHN5bWJvbCBhbmQgaXRzIG9uIHRoZSByaWdodCBoYW5kIHNpZGUsIHRoZW4gd2UgcGxhY2UgdGhlIGNhcmV0IGFjY29yZGluZ2x5IG9uIHRoZSBmYXIgbGVmdCBzaWRlXG4gICAgICAgICAgICAgICAgaWYgKG9yZGVyZWRWYWx1ZSA9PT0gdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCAmJiB0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnN1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5zZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCkgIT09IGluaXRpYWxFbGVtZW50VmFsdWUpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRyaWdnZXJFdmVudChBdXRvTnVtZXJpYy5ldmVudHMuZm9ybWF0dGVkLCB0aGlzLmRvbUVsZW1lbnQsIHsgb2xkVmFsdWU6IGluaXRpYWxFbGVtZW50VmFsdWUsIG5ld1ZhbHVlOiBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yIHRoZSAnZm9jdXMnIGV2ZW50LlxuICAgICAqIFdlIHVwZGF0ZSB0aGUgaW5mbyBvZiB0aGUgZm9jdXNlZCBzdGF0ZSBpbiB0aGUgYHRoaXMuaXNGb2N1c2VkYCB2YXJpYWJsZSB3aGVuIHRoZSBlbGVtZW50IGdldHMgZm9jdXNlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbkZvY3VzKCkge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5pc0NhbmNlbGxhYmxlKSB7XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IHVuZm9ybWF0dGVkIHZhbHVlIGZvciBsYXRlciB1c2UgYnkgdGhlICdjYW5jZWxsYWJsZScgZmVhdHVyZVxuICAgICAgICAgICAgdGhpcy5fc2F2ZUNhbmNlbGxhYmxlVmFsdWUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yIHRoZSAnZm9jdXNpbicgZXZlbnQuXG4gICAgICogVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHRoZSAnZm9jdXMnIGV2ZW50LCBhbmQgaXMgbmVjZXNzYXJ5IHRvIGNoYW5nZSB0aGUgc2VsZWN0aW9uIG9uIGZvY3VzIHVuZGVyIEZpcmVmb3ggZm9yIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uRm9jdXNJbihlKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNlbGVjdE9uRm9jdXMpIHtcbiAgICAgICAgICAgIC8vIFRoZSB3aG9sZSBpbnB1dCBjb250ZW50IGlzIHNlbGVjdGVkIG9uIGZvY3VzIChmb2xsb3dpbmcgdGhlIGBzZWxlY3RPbkZvY3VzYCBhbmQgYHNlbGVjdE51bWJlck9ubHlgIG9wdGlvbnMpXG4gICAgICAgICAgICAvL1hYWCBGaXJlZm94IDw0NyBkb2VzIG5vdCByZXNwZWN0IHRoaXMgc2VsZWN0aW9uLi4uT2ggd2VsbC5cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPciB3ZSBkZWNpZGUgd2hlcmUgdG8gcHV0IHRoZSBjYXJldCB1c2luZyB0aGUgYGNhcmV0UG9zaXRpb25PbkZvY3VzYCBvcHRpb25cbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIHRoaXMuX2luaXRpYWxDYXJldFBvc2l0aW9uKEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZSh0aGlzLmRvbUVsZW1lbnQpKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAna2V5ZG93bicgZXZlbnRzLlxuICAgICAqIFRoZSB1c2VyIGp1c3Qgc3RhcnRlZCBwdXNoaW5nIGFueSBrZXksIGhlbmNlIG9uZSBldmVudCBpcyBzZW50LlxuICAgICAqXG4gICAgICogTm90ZSA6XG4gICAgICogQnkgZGVmYXVsdCBhICdub3JtYWwnIGlucHV0IG91dHB1dCB0aG9zZSBldmVudHMgaW4gdGhlIHJpZ2h0IG9yZGVyIHdoZW4gaW5wdXR0aW5nIGEgY2hhcmFjdGVyIGtleSAoaWUuICdhJykgOlxuICAgICAqIC0ga2V5ZG93blxuICAgICAqIC0ga2V5cHJlc3NcbiAgICAgKiAtIGlucHV0XG4gICAgICogLSBrZXl1cFxuICAgICAqXG4gICAgICogLi4ud2hlbiBpbnB1dHRpbmcgYSBtb2RpZmllciBrZXkgKGllLiAnY3RybCcpIDpcbiAgICAgKiAtIGtleWRvd25cbiAgICAgKiAtIGtleXVwXG4gICAgICpcbiAgICAgKiBJZiAnZGVsZXRlJyBvciAnYmFja3NwYWNlJyBpcyBlbnRlcmVkLCB0aGUgZm9sbG93aW5nIGV2ZW50cyBhcmUgc2VudCA6XG4gICAgICogLSBrZXlkb3duXG4gICAgICogLSBpbnB1dFxuICAgICAqIC0ga2V5dXBcbiAgICAgKlxuICAgICAqIElmICdlbnRlcicgaXMgZW50ZXJlZCBhbmQgdGhlIHZhbHVlIGhhcyBub3QgY2hhbmdlZCwgdGhlIGZvbGxvd2luZyBldmVudHMgYXJlIHNlbnQgOlxuICAgICAqIC0ga2V5ZG93blxuICAgICAqIC0ga2V5cHJlc3NcbiAgICAgKiAtIGtleXVwXG4gICAgICpcbiAgICAgKiBJZiAnZW50ZXInIGlzIGVudGVyZWQgYW5kIHRoZSB2YWx1ZSBoYXMgYmVlbiBjaGFuZ2VkLCB0aGUgZm9sbG93aW5nIGV2ZW50cyBhcmUgc2VudCA6XG4gICAgICogLSBrZXlkb3duXG4gICAgICogLSBrZXlwcmVzc1xuICAgICAqIC0gY2hhbmdlXG4gICAgICogLSBrZXl1cFxuICAgICAqXG4gICAgICogV2hlbiBhIHBhc3RlIGlzIGRvbmUsIHRoZSBmb2xsb3dpbmcgZXZlbnRzIGFyZSBzZW50IDpcbiAgICAgKiAtIGlucHV0IChpZiBwYXN0ZSBpcyBkb25lIHdpdGggdGhlIG1vdXNlKVxuICAgICAqXG4gICAgICogLSBrZXlkb3duIChpZiBwYXN0ZSBpcyBkb25lIHdpdGggY3RybCt2KVxuICAgICAqIC0ga2V5ZG93blxuICAgICAqIC0gaW5wdXRcbiAgICAgKiAtIGtleXVwXG4gICAgICogLSBrZXl1cFxuICAgICAqXG4gICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlXG4gICAgICovXG4gICAgX29uS2V5ZG93bihlKSB7XG4gICAgICAgIHRoaXMuaXNFZGl0aW5nID0gdHJ1ZTsgLy8gS2VlcCB0cmFjayBpZiB0aGUgdXNlciBpcyBjdXJyZW50bHkgZWRpdGluZyB0aGUgZWxlbWVudCBtYW51YWxseVxuXG4gICAgICAgIGlmICghdGhpcy5pc0ZvY3VzZWQgJiYgdGhpcy5zZXR0aW5ncy51bmZvcm1hdE9uSG92ZXIgJiYgZS5hbHRLZXkgJiYgdGhpcy5kb21FbGVtZW50ID09PSBBdXRvTnVtZXJpY0hlbHBlci5nZXRIb3ZlcmVkRWxlbWVudCgpKSB7XG4gICAgICAgICAgICAvLyBIZXJlIEkgcHJldmVudCBjYWxsaW5nIF91bmZvcm1hdEFsdEhvdmVyZWQgaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBmb2N1c2VkLCBzaW5jZSB0aGUgZ2xvYmFsICdrZXlkb3duJyBsaXN0ZW5lciB3aWxsIHBpY2sgaXQgdXAgYXMgd2VsbFxuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fdW5mb3JtYXRBbHRIb3ZlcmVkKHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVFdmVudEtleUluZm8oZSk7XG4gICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlT25LZXlkb3duID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKGUudGFyZ2V0KTsgLy8gVGhpcyBpcyBuZWVkZWQgaW4gYG9uS2V5dXAoKWAgdG8gY2hlY2sgaWYgdGhlIHZhbHVlIGFzIGNoYW5nZWQgZHVyaW5nIHRoZSBrZXkgcHJlc3NcblxuICAgICAgICBpZiAodGhpcy5kb21FbGVtZW50LnJlYWRPbmx5KSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5Fc2MpIHtcbiAgICAgICAgICAgIC8vWFhYIFRoZSBkZWZhdWx0ICdFc2NhcGUnIGtleSBiZWhhdmlvciBkaWZmZXJzIGJldHdlZW4gRmlyZWZveCBhbmQgQ2hyb21lLCBGaXJlZm94IGFscmVhZHkgaGF2aW5nIGEgYnVpbHQtaW4gJ2NhbmNlbGxhYmxlLWxpa2UnIGZlYXR1cmUuIFRoaXMgaXMgd2h5IHdlIGNhbGwgYGUucHJldmVudERlZmF1bHQoKWAgaGVyZSBpbnN0ZWFkIG9mIGp1c3Qgd2hlbiBgaXNDYW5jZWxsYWJsZWAgaXMgc2V0IHRvIGB0cnVlYC4gVGhpcyBhbGxvdyB1cyB0byBrZWVwIHRoZSBzYW1lIGJlaGF2aW9yIGFjcm9zcyBicm93c2Vycy5cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuaXNDYW5jZWxsYWJsZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIHdhbnRzIHRvIGNhbmNlbCBpdHMgbW9kaWZpY2F0aW9ucyA6XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2V0IGJhY2sgdGhlIHNhdmVkIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmF3VmFsdWUgIT09IHRoaXMuc2F2ZWRDYW5jZWxsYWJsZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCBzZXQgdGhlIHZhbHVlIGFnYWluIGlmIGl0IGhhcyBub3QgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldCh0aGlzLnNhdmVkQ2FuY2VsbGFibGVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFuZCB3ZSBuZWVkIHRvIHNlbmQgYW4gJ2lucHV0JyBldmVudCB3aGVuIHNldHRpbmcgYmFjayB0aGUgaW5pdGlhbCB2YWx1ZSBpbiBvcmRlciB0byBtYWtlIG90aGVyIHNjcmlwdHMgYXdhcmUgb2YgdGhlIHZhbHVlIGNoYW5nZS4uLlxuICAgICAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50cmlnZ2VyRXZlbnQoQXV0b051bWVyaWMuZXZlbnRzLm5hdGl2ZS5pbnB1dCwgZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gLi5hbmQgbGFzdGx5IHdlIHVwZGF0ZSB0aGUgY2FyZXQgc2VsZWN0aW9uLCBldmVuIGlmIHRoZSBvcHRpb24gYGlzQ2FuY2VsbGFibGVgIGlzIGZhbHNlXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCgpO1xuICAgICAgICAgICAgLy9UT0RPIEFkZCBhbiBvcHRpb24gdG8gc2VsZWN0IGVpdGhlciB0aGUgaW50ZWdlciBvciBkZWNpbWFsIHBhcnQgd2l0aCBgRXNjYFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIFwiZW50ZXJcIiBrZXkgdGhyb3dzIGEgYGNoYW5nZWAgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBgZm9jdXNgIGV2ZW50XG4gICAgICAgIGxldCB0YXJnZXRWYWx1ZSA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZShlLnRhcmdldCk7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5FbnRlciAmJiB0aGlzLnZhbHVlT25Gb2N1cyAhPT0gdGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRyaWdnZXJFdmVudChBdXRvTnVtZXJpYy5ldmVudHMubmF0aXZlLmNoYW5nZSwgZS50YXJnZXQpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZU9uRm9jdXMgPSB0YXJnZXRWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuaXNDYW5jZWxsYWJsZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGFjdGl2YXRlZCB0aGUgJ2NhbmNlbGxhYmxlJyBmZWF0dXJlLCB3ZSBzYXZlIHRoZSB2YWxpZGF0ZWQgdmFsdWUgd2hlbiAnRW50ZXInIGlzIGhpdFxuICAgICAgICAgICAgICAgIHRoaXMuX3NhdmVDYW5jZWxsYWJsZVZhbHVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVJbnRlcm5hbFByb3BlcnRpZXMoZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Byb2Nlc3NOb25QcmludGFibGVLZXlzQW5kU2hvcnRjdXRzKGUpKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBrZXkgaXMgYSBkZWxldGUvYmFja3NwYWNlIGtleVxuICAgICAgICBpZiAodGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuQmFja3NwYWNlIHx8IHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkRlbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0NoYXJhY3RlckRlbGV0aW9uKCk7IC8vIEJlY2F1c2UgYmFja3NwYWNlIGFuZCBkZWxldGUgb25seSB0cmlnZ2VycyBrZXlkb3duIGFuZCBrZXl1cCBldmVudHMsIG5vdCBrZXlwcmVzc1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZm9ybWF0VmFsdWUoZSk7XG5cbiAgICAgICAgICAgIC8vIElmIGFuZCBvbmx5IGlmIHRoZSByZXN1bHRpbmcgdmFsdWUgaGFzIGNoYW5nZWQgYWZ0ZXIgdGhhdCBiYWNrc3BhY2UvZGVsZXRlLCB0aGVuIHdlIGhhdmUgdG8gc2VuZCBhbiAnaW5wdXQnIGV2ZW50IGxpa2UgYnJvd3NlcnMgbm9ybWFsbHkgZG8uXG4gICAgICAgICAgICB0YXJnZXRWYWx1ZSA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZShlLnRhcmdldCk7IC8vIFVwZGF0ZSB0aGUgdmFsdWUgc2luY2UgaXQgY291bGQgaGF2ZSBiZWVuIGNoYW5nZWQgZHVyaW5nIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgaWYgKCh0YXJnZXRWYWx1ZSAhPT0gdGhpcy5sYXN0VmFsKSAmJiB0aGlzLnRocm93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaHJvdyBhbiBpbnB1dCBldmVudCB3aGVuIGEgY2hhcmFjdGVyIGRlbGV0aW9uIGlzIGRldGVjdGVkXG4gICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudHJpZ2dlckV2ZW50KEF1dG9OdW1lcmljLmV2ZW50cy5uYXRpdmUuaW5wdXQsIGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIC4uLmFuZCBpbW1lZGlhdGVseSBwcmV2ZW50IHRoZSBicm93c2VyIHRvIGRlbGV0ZSBhIHNlY29uZCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sYXN0VmFsID0gdGFyZ2V0VmFsdWU7XG4gICAgICAgICAgICB0aGlzLnRocm93SW5wdXQgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IGZhbHNlOyAvL1RPRE8gSXMgdGhpcyBsaW5lIG5lZWRlZD8gKEkgbWVhbiwgX2Zvcm1hdFZhbHVlIGFsd2F5cyBzZXQgaXQgdG8gYHRydWVgLCBhbmQgdGhpcyBvdmVyd3JpdGUgdGhhdCBpbmZvKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdrZXlwcmVzcycgZXZlbnRzLlxuICAgICAqIFRoZSB1c2VyIGlzIHN0aWxsIHByZXNzaW5nIHRoZSBrZXksIHdoaWNoIHdpbGwgb3V0cHV0IGEgY2hhcmFjdGVyIChpZS4gJzInKSBjb250aW51b3VzbHkgdW50aWwgaXQgcmVsZWFzZXMgdGhlIGtleS5cbiAgICAgKiBOb3RlOiAna2V5cHJlc3MnIGV2ZW50cyBhcmUgbm90IHNlbnQgZm9yIGRlbGV0ZSBrZXlzIGxpa2UgQmFja3NwYWNlL0RlbGV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZVxuICAgICAqL1xuICAgIF9vbktleXByZXNzKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkluc2VydCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gdGhpcy5wcm9jZXNzZWQ7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUludGVybmFsUHJvcGVydGllcyhlKTtcblxuICAgICAgICBpZiAodGhpcy5fcHJvY2Vzc05vblByaW50YWJsZUtleXNBbmRTaG9ydGN1dHMoZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNDaGFyYWN0ZXJJbnNlcnRpb25BbGxvd2VkID0gdGhpcy5fcHJvY2Vzc0NoYXJhY3Rlckluc2VydGlvbigpO1xuICAgICAgICBpZiAoaXNDaGFyYWN0ZXJJbnNlcnRpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JtYXRWYWx1ZShlKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICgodGFyZ2V0VmFsdWUgIT09IHRoaXMubGFzdFZhbCkgJiYgdGhpcy50aHJvd0lucHV0KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhyb3dzIGlucHV0IGV2ZW50IG9uIGFkZGluZyBhIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRyaWdnZXJFdmVudChBdXRvTnVtZXJpYy5ldmVudHMubmF0aXZlLmlucHV0LCBlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyAuLi5hbmQgaW1tZWRpYXRlbHkgcHJldmVudCB0aGUgYnJvd3NlciB0byBhZGQgYSBzZWNvbmQgY2hhcmFjdGVyXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgodGhpcy5ldmVudEtleSA9PT0gdGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyIHx8IHRoaXMuZXZlbnRLZXkgPT09IHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSAmJlxuICAgICAgICAgICAgICAgICAgICAoQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCkuc3RhcnQgPT09IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQpLmVuZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCkuc3RhcnQgPT09IHRhcmdldFZhbHVlLmluZGV4T2YodGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQpLnN0YXJ0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sYXN0VmFsID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMudGhyb3dJbnB1dCA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IGZhbHNlOyAvL1RPRE8gSXMgdGhpcyBsaW5lIG5lZWRlZD8gKEkgbWVhbiwgX2Zvcm1hdFZhbHVlIGFsd2F5cyBzZXQgaXQgdG8gYHRydWVgLCBhbmQgdGhpcyBvdmVyd3JpdGUgdGhhdCBpbmZvKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdpbnB1dCcgZXZlbnRzLlxuICAgICAqIEhhbmRsaW5nIHRoaXMgZXZlbnQgaW5zdGVhZCBvZiBga2V5cHJlc3NgIGlzIG5lZWRlZCBpbiBvcmRlciB0byBzdXBwb3J0IGFuZHJvaWQgZGV2aWNlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKi9cbiAgICBfb25JbnB1dChlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCk7XG5cbiAgICAgICAgLy8gRml4IHRoZSBjYXJldCBwb3NpdGlvbiBvbiBrZXl1cCBpbiB0aGUgYF9mb3JtYXRWYWx1ZSgpYCBmdW5jdGlvblxuICAgICAgICB0aGlzLmFuZHJvaWRTZWxlY3Rpb25TdGFydCA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkFuZHJvaWREZWZhdWx0KSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICAgICAgLy8gVGhlIGtleUNvZGUgaXMgZXF1YWwgdG8gdGhlIGRlZmF1bHQgQW5kcm9pZCBDaHJvbWUgb25lICh3aGljaCBpcyBhbHdheXMgZXF1YWwgdG8gYGtleUNvZGUuQW5kcm9pZERlZmF1bHRgKVxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IHRoaXMubGFzdFZhbC5sZW5ndGggfHwgdmFsdWUubGVuZ3RoID49IHRoaXMubGFzdFZhbC5sZW5ndGggLSBzZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBrZXljb2RlIG9mIHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgZW50ZXJlZCwgYW5kIG92ZXJ3cml0ZSB0aGUgZmF1bHR5IGBldmVudEtleUNvZGVgIGluZm8gd2l0aCBpdFxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRLZXkgPSB2YWx1ZS5jaGFyQ29kZUF0KHNlbGVjdGlvbi5zdGFydCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBhY3R1YWwgY2hhcmFjdGVyIGVudGVyZWQsIGFuZCB1cGRhdGUgdGhlIGBldmVudEtleWAgd2l0aCBpdCAoaW5zdGVhZCBvZiB0aGUgQW5kcm9pZCBkZWZhdWx0IG9uZSlcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50S2V5ID0gdmFsdWUuY2hhckF0KHNlbGVjdGlvbi5zdGFydCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZ2l2ZW4gY2hhcmFjdGVyIHNob3VsZCBiZSBpbnNlcnRlZCwgYW5kIGlmIHNvLCBkbyBpbnNlcnQgaXQgaW50byB0aGUgY3VycmVudCBlbGVtZW50IHZhbHVlXG4gICAgICAgICAgICAgICAgY29uc3QgaXNDaGFyYWN0ZXJJbnNlcnRpb25BbGxvd2VkID0gdGhpcy5fcHJvY2Vzc0NoYXJhY3Rlckluc2VydGlvbigpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzQ2hhcmFjdGVySW5zZXJ0aW9uQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbGxvd2VkIGNoYXJhY3RlciBlbnRlcmVkIChudW1iZXIsIGRlY2ltYWwgb3IgcGx1cy9taW51cyBzaWduKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb3JtYXRWYWx1ZShlKTtcblxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMuZG9tRWxlbWVudCk7IC8vVE9ETyBpcyB0aGlzIG5lZWRlZCBhIHNlY29uZCB0aW1lP1xuICAgICAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBuZXcgY2FyZXQgcG9zaXRpb24uIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBvbiBrZXl1cCwgYF91cGRhdGVBdXRvTnVtZXJpY0hvbGRlckV2ZW50S2V5Y29kZSgpYCBjYXB0dXJlcyB0aGUgb2xkIGNhcmV0IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBDaGVjayBpZiB0aGlzIGlzIGFuIEFuZHJvaWQgYnVnIG9yIGFuIGF1dG9OdW1lcmljIG9uZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuZHJvaWRTZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvbi5zdGFydDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSBjYXJldCB0byB0aGUgcmlnaHQgaWYgdGhlIGBhbmRyb2lkQ2hhckVudGVyZWRgIGlzIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBvciBpZiBpdCdzIG9uIHRoZSBsZWZ0IG9mIHRoZSBjYXJldCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNpbWFsQ2hhcmFjdGVyUG9zaXRpb24gPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KS5pbmRleE9mKHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc0RlY2ltYWxDaGFyYWN0ZXIgPSBkZWNpbWFsQ2hhcmFjdGVyUG9zaXRpb24gIT09IC0xO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleSA9PT0gdGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNEZWNpbWFsQ2hhcmFjdGVyICYmIGRlY2ltYWxDaGFyYWN0ZXJQb3NpdGlvbiA8IHRoaXMuYW5kcm9pZFNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFuZHJvaWRTZWxlY3Rpb25TdGFydCArPSB0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQucHJlZml4ICYmIHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFuZHJvaWRTZWxlY3Rpb25TdGFydCArPSB0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24ubGVuZ3RoID4gdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbiB0aGUgY2FyZXQgcmlnaHQgbm93IGJlZm9yZSB0aGUgJ2tleXVwJyBldmVudCBpbiBvcmRlciB0byBwcmV2ZW50IHRoZSBjYXJldCBmcm9tIGp1bXBpbmcgYXJvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDYXJldFBvc2l0aW9uKHRoaXMuYW5kcm9pZFNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdFZhbCA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZSh0aGlzLmRvbUVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZW50ZXJlZCBjaGFyYWN0ZXIgaXMgbm90IGFsbG93ZWQgOyBvdmVyd3JpdGUgdGhlIG5ldyBpbnZhbGlkIHZhbHVlIHdpdGggdGhlIHByZXZpb3VzIHZhbGlkIG9uZSwgYW5kIHNldCBiYWNrIHRoZSBjYXJldC9zZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuc2V0RWxlbWVudFZhbHVlKHRoaXMubGFzdFZhbCk7IC8vVE9ETyBVcGRhdGUgdGhlIHJhd1ZhbHVlIGhlcmUgdG9vIHZpYSBfc2V0VmFsdWUoKT9cbiAgICAgICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLmRvbUVsZW1lbnQsIHNlbGVjdGlvbi5zdGFydCwgc2VsZWN0aW9uLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5kcm9pZFNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uLnN0YXJ0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy9UT0RPIENoZWNrIGhvdyB0aGF0IGlzIGFmZmVjdGluZyB0aGUgbm9ybWFsIHRyaWdnZXIgb2YgdGhlIGlucHV0IGV2ZW50XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDaGFyYWN0ZXIgZGVsZXRlZFxuICAgICAgICAgICAgICAgIC8vWFhYIFRoZSBjaGFuZ2UgaW4gbGVuZ3RoIGNvdWxkIGFsc28gYmUgdGhlIHJlc3VsdCBvZiB0aGUgYERlbGV0ZWAga2V5LCBidXQgdGhlcmUgdXN1YWxseSBhcmUgbm8gc3VjaCBrZXkgaW4gdGhlIEFuZHJvaWQgdmlydHVhbCBrZXlib2FyZHNcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50S2V5ID0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuQmFja3NwYWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgJ2tleXVwJyBldmVudHMuXG4gICAgICogVGhlIHVzZXIganVzdCByZWxlYXNlZCBhbnkga2V5LCBoZW5jZSBvbmUgZXZlbnQgaXMgc2VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZVxuICAgICAqL1xuICAgIF9vbktleXVwKGUpIHtcbiAgICAgICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5pc0NhbmNlbGxhYmxlICYmIHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkVzYykge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgd2FudHMgdG8gY2FuY2VsIGl0cyBtb2RpZmljYXRpb25zLCB3ZSBkcm9wIHRoZSAna2V5dXAnIGV2ZW50IGZvciB0aGUgRXNjIGtleVxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYW5hZ2UgdGhlIHVuZG8vcmVkbyBldmVudHNcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLlogfHwgdGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUueikge1xuICAgICAgICAgICAgaWYgKGUuY3RybEtleSAmJiBlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gUmVkb1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaXN0b3J5VGFibGVSZWRvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkdvaW5nUmVkbyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUuY3RybEtleSAmJiAhZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uR29pbmdSZWRvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgYW4gJ3VuZG8nIHRvIGJlIGxhdW5jaCB3aGVuIHJlbGVhc2luZyB0aGUgc2hpZnQga2V5IGJlZm9yZSB0aGUgY3RybCBrZXkgYWZ0ZXIgYSAncmVkbycgc2hvcnRjdXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkdvaW5nUmVkbyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5kb1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaXN0b3J5VGFibGVVbmRvKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9uR29pbmdSZWRvICYmIChlLmN0cmxLZXkgfHwgZS5zaGlmdEtleSkpIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSB3aGVyZSBpZiB0aGUgdXNlciBoYXMgZW50ZXJlZCBgQ29udHJvbCtTaGlmdCt6YCwgdGhlbiByZWxlYXNlIGB6YCwga2VlcGluZyBgQ29udHJvbGAgb3IgYFNoaWZ0YCBwcmVzc2VkLCB0aGVuIGB0aGlzLm9uR29pbmdSZWRvYCBpcyBuZXZlciBjaGFuZ2VkIGJhY2sgdG8gYGZhbHNlYCB3aGVuIHRoZSB1c2VyIHJlbGVhc2UgYENvbnRyb2xgIG9yIGBTaGlmdGBcbiAgICAgICAgICAgIHRoaXMub25Hb2luZ1JlZG8gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1hbmFnZSB0aGUgcmVmb3JtYXQgd2hlbiBob3ZlcmVkIHdpdGggdGhlIEFsdCBrZXkgcHJlc3NlZFxuICAgICAgICBpZiAodGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuQWx0ICYmIHRoaXMuaG92ZXJlZFdpdGhBbHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuX3JlZm9ybWF0QWx0SG92ZXJlZCh0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlSW50ZXJuYWxQcm9wZXJ0aWVzKGUpO1xuXG4gICAgICAgIGNvbnN0IHNraXAgPSB0aGlzLl9wcm9jZXNzTm9uUHJpbnRhYmxlS2V5c0FuZFNob3J0Y3V0cyhlKTtcbiAgICAgICAgZGVsZXRlIHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlO1xuICAgICAgICBjb25zdCBpc09uQW5kcm9pZCA9IHRoaXMuYW5kcm9pZFNlbGVjdGlvblN0YXJ0ICE9PSBudWxsO1xuICAgICAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZShlLnRhcmdldCk7XG4gICAgICAgIGlmIChza2lwICYmICFpc09uQW5kcm9pZCB8fCB0YXJnZXRWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZGVkIHRvIHByb3Blcmx5IHBsYWNlIHRoZSBjYXJldCB3aGVuIG9ubHkgdGhlIGN1cnJlbmN5IHNpZ24gaXMgcHJlc2VudFxuICAgICAgICBpZiAodGFyZ2V0VmFsdWUgPT09IHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnN1ZmZpeCkge1xuICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5zZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCB0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuVGFiKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5zZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCAwLCB0YXJnZXRWYWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCh0YXJnZXRWYWx1ZSA9PT0gdGhpcy5zZXR0aW5ncy5zdWZmaXhUZXh0KSB8fFxuICAgICAgICAgICAgKHRoaXMucmF3VmFsdWUgPT09ICcnICYmIHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgIT09ICcnICYmIHRoaXMuc2V0dGluZ3Muc3VmZml4VGV4dCAhPT0gJycpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5zZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNhdmVzIHRoZSBleHRlbmRlZCBkZWNpbWFsIHRvIHByZXNlcnZlIHRoZSBkYXRhIHdoZW4gbmF2aWdhdGluZyBhd2F5IGZyb20gdGhlIHBhZ2VcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmZvcm1hdHRlZCkgeyAgLy9UT0RPIElzIHRoaXMgbGluZSBuZWVkZWQ/IENvbnNpZGVyaW5nIHRoYXQgb25LZXlkb3duIGFuZCBvbktleXByZXNzIGJvdGggZmluaXNoIGJ5IHNldHRpbmcgaXQgdG8gZmFsc2UuLi5cbiAgICAgICAgICAgIHRoaXMuX2Zvcm1hdFZhbHVlKGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGlucHV0IHZhbHVlIGhhcyBjaGFuZ2VkIGR1cmluZyB0aGUga2V5IHByZXNzIGV2ZW50IGNoYWluLCBhbiBldmVudCBpcyBzZW50IHRvIGFsZXJ0IHRoYXQgYSBmb3JtYXR0aW5nIGhhcyBiZWVuIGRvbmUgKGNmLiBJc3N1ZSAjMTg3KVxuICAgICAgICBpZiAodGFyZ2V0VmFsdWUgIT09IHRoaXMuaW5pdGlhbFZhbHVlT25LZXlkb3duKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50cmlnZ2VyRXZlbnQoQXV0b051bWVyaWMuZXZlbnRzLmZvcm1hdHRlZCwgZS50YXJnZXQsIHsgb2xkVmFsdWU6IHRoaXMuaW5pdGlhbFZhbHVlT25LZXlkb3duLCBuZXdWYWx1ZTogdGFyZ2V0VmFsdWUgfSk7IC8vVE9ETyBEbyBJIG5lZWQgdG8gcmVtb3ZlIHRoaXMgc2luY2Ugd2Ugbm93IHNlbmQgdGhpcyBldmVudCBvbiBgc2V0KClgP1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWxlY3Rpb24gb2YgdGhlIGN1cnJlbnQgZWxlbWVudCBvZiB0aGUgaGlzdG9yeSB0YWJsZVxuICAgICAgICBpZiAodGhpcy5oaXN0b3J5VGFibGUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvbi5zdGFydDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gc2VsZWN0aW9uLmVuZDtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeVRhYmxlW3RoaXMuaGlzdG9yeVRhYmxlSW5kZXhdLnN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeVRhYmxlW3RoaXMuaGlzdG9yeVRhYmxlSW5kZXhdLmVuZCA9IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgJ2ZvY3Vzb3V0JyBldmVudHNcbiAgICAgKiBPbiBmb2N1c291dCwgbXVsdGlwbGUgdGhpbmdzIGhhcHBlbnMgOlxuICAgICAqIC0gVGhlIGVsZW1lbnQgdmFsdWUgaXMgZm9ybWF0dGVkIGJhY2sgaWYgdGhlIGBBbHRgIGtleSB3YXMgcHJlc3NlZCxcbiAgICAgKiAtIFRoZSBlbGVtZW50IHZhbHVlIGlzIGZvcm1hdHRlZCBiYWNrIGlmIGBzaG93T25seU51bWJlcnNPbkZvY3VzYCB3YXMgc2V0IHRvIG9ubHkgc2hvdyBudW1iZXJzLFxuICAgICAqIC0gVGhlIGVsZW1lbnQgdmFsdWUgaXMgbXVsdGlwbGllZCBieSBgcmF3VmFsdWVEaXZpc29yYCBvbiBgYmx1cmBcbiAgICAgKlxuICAgICAqIE5vdGU6IE9uIGZvY3Vzb3V0LCB0aGUgYHJhd1ZhbHVlYCBpcyBuZXZlciBjaGFuZ2VkLiBPbmx5IHRoZSBmb3JtYXR0ZWQgdmFsdWUgY2FuIGJlIG1vZGlmaWVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIF9vbkZvY3VzT3V0QW5kTW91c2VMZWF2ZShlKSB7XG4gICAgICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7IC8vIEp1c3QgaW4gY2FzZSBubyBga2V5VXBgIGV2ZW50IGhhdmUgYmVlbiBzZW50IChpZiB0aGUgdXNlciBsb3N0IHRoZSBmb2N1cyB0byB0aGUgd2luZG93IHdoaWxlIHR5cGluZylcblxuICAgICAgICAvL1RPRE8gQ3JlYXRlIHNlcGFyYXRlIGhhbmRsZXJzIGZvciBibHVyIGFuZCBtb3VzZWxlYXZlXG4gICAgICAgIC8vRklYTUUgRG8gbm90IGNhbGwgYHNldCgpYCBpZiB0aGUgY3VycmVudCByYXcgdmFsdWUgaXMgdGhlIHNhbWUgYXMgdGhlIG9uZSB3ZSBhcmUgdHJ5aW5nIHRvIHNldCAoY3VycmVudGx5LCBvbiBmb2N1cyBvdXQsIGBzZXQoKWAgaXMgYWx3YXlzIGNhbGxlZCwgZXZlbiBpZiB0aGUgdmFsdWUgaGFzIG5vdCBjaGFuZ2VkXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnVuZm9ybWF0T25Ib3ZlciAmJiBlLnR5cGUgPT09ICdtb3VzZWxlYXZlJyAmJiB0aGlzLmhvdmVyZWRXaXRoQWx0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLl9yZWZvcm1hdEFsdEhvdmVyZWQodGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoZS50eXBlID09PSAnbW91c2VsZWF2ZScgJiYgIXRoaXMuaXNGb2N1c2VkKSB8fCBlLnR5cGUgPT09ICdibHVyJykge1xuICAgICAgICAgICAgdGhpcy5fc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2hvd09ubHlOdW1iZXJzT25Gb2N1cyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5zaG93T25seU51bWJlcnNPbkZvY3VzLm9ubHlOdW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yID0gdGhpcy5vcmlnaW5hbERpZ2l0R3JvdXBTZXBhcmF0b3I7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCA9IHRoaXMub3JpZ2luYWxDdXJyZW5jeVN5bWJvbDtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnN1ZmZpeFRleHQgPSB0aGlzLm9yaWdpbmFsU3VmZml4VGV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIHRoZSByYXdWYWx1ZSwgbXVsdGlwbGllZCBieSBgcmF3VmFsdWVEaXZpc29yYCBpZiBkZWZpbmVkXG4gICAgICAgICAgICBjb25zdCByYXdWYWx1ZVRvRm9ybWF0ID0gdGhpcy5fZ2V0UmF3VmFsdWVUb0Zvcm1hdCh0aGlzLnJhd1ZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IGlzUmF3VmFsdWVOdWxsID0gQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKHJhd1ZhbHVlVG9Gb3JtYXQpO1xuICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gdGhpcy5jb25zdHJ1Y3Rvci5fY2hlY2tJZkluUmFuZ2VXaXRoT3ZlcnJpZGVPcHRpb24ocmF3VmFsdWVUb0Zvcm1hdCwgdGhpcy5zZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIC8vIERpcmVjdGx5IHNldCB0aGUgZm9ybWF0dGVkIHZhbHVlIGlmIHRoZSBgcmF3VmFsdWVgIGlzIGZvdW5kIGluIGB2YWx1ZXNUb1N0cmluZ3NgXG4gICAgICAgICAgICBsZXQgZWxlbWVudFZhbHVlSXNBbHJlYWR5U2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAocmF3VmFsdWVUb0Zvcm1hdCAhPT0gJycgJiYgIWlzUmF3VmFsdWVOdWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtaW5UZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRyaWdnZXJFdmVudChBdXRvTnVtZXJpYy5ldmVudHMubWluUmFuZ2VFeGNlZWRlZCwgdGhpcy5kb21FbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudHJpZ2dlckV2ZW50KEF1dG9OdW1lcmljLmV2ZW50cy5tYXhSYW5nZUV4Y2VlZGVkLCB0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZhbHVlc1RvU3RyaW5ncyAmJiB0aGlzLl9jaGVja1ZhbHVlc1RvU3RyaW5ncyhyYXdWYWx1ZVRvRm9ybWF0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGZvcm1hdHRlZCB2YWx1ZSB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRFbGVtZW50VmFsdWUodGhpcy5zZXR0aW5ncy52YWx1ZXNUb1N0cmluZ3NbcmF3VmFsdWVUb0Zvcm1hdF0pO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50VmFsdWVJc0FscmVhZHlTZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT25seSBnZW5lcmF0ZSB0aGUgZm9ybWF0dGVkIHZhbHVlIGlmIG5vIGB2YWx1ZXNUb1N0cmluZ3NgIGhhdmUgYmVlbiBmb3VuZFxuICAgICAgICAgICAgaWYgKCFlbGVtZW50VmFsdWVJc0FscmVhZHlTZXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmF3VmFsdWVOdWxsIHx8IHJhd1ZhbHVlVG9Gb3JtYXQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmF3VmFsdWVUb0Zvcm1hdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFN0cmluZyhyYXdWYWx1ZVRvRm9ybWF0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmF3VmFsdWVUb0Zvcm1hdCAhPT0gJycgJiYgIWlzUmF3VmFsdWVOdWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5UZXN0ICYmIG1heFRlc3QgJiYgIXRoaXMuY29uc3RydWN0b3IuX2lzRWxlbWVudFZhbHVlRW1wdHlPck9ubHlUaGVOZWdhdGl2ZVNpZ24ocmF3VmFsdWVUb0Zvcm1hdCwgdGhpcy5zZXR0aW5ncykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fbW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvclJhd1ZhbHVlKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZGl2aXNvcldoZW5VbmZvY3VzZWQgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gdGhpcy5zZXR0aW5ncy5kaXZpc29yV2hlblVuZm9jdXNlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rvci5fcm91bmRGb3JtYXR0ZWRWYWx1ZVNob3duT25CbHVyKHZhbHVlLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rvci5fbW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvckZvcm1hdHRlZFZhbHVlKHZhbHVlLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWluVGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRyaWdnZXJFdmVudChBdXRvTnVtZXJpYy5ldmVudHMubWluUmFuZ2VFeGNlZWRlZCwgdGhpcy5kb21FbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudHJpZ2dlckV2ZW50KEF1dG9OdW1lcmljLmV2ZW50cy5tYXhSYW5nZUV4Y2VlZGVkLCB0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyYXdWYWx1ZVRvRm9ybWF0ID09PSAnJyAmJiB0aGlzLnNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3IuemVybykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRSYXdWYWx1ZSgnMCcpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuY29uc3RydWN0b3IuX3JvdW5kVmFsdWUoJzAnLCB0aGlzLnNldHRpbmdzLCAwKTtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIGxldCBncm91cGVkVmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLl9vcmRlclZhbHVlQ3VycmVuY3lTeW1ib2xBbmRTdWZmaXhUZXh0KHZhbHVlLCB0aGlzLnNldHRpbmdzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKCEodGhpcy5jb25zdHJ1Y3Rvci5faXNFbGVtZW50VmFsdWVFbXB0eU9yT25seVRoZU5lZ2F0aXZlU2lnbih2YWx1ZSwgdGhpcy5zZXR0aW5ncykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChpc1Jhd1ZhbHVlTnVsbCAmJiB0aGlzLnNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3IubnVsbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwZWRWYWx1ZSA9IHRoaXMuY29uc3RydWN0b3IuX2FkZEdyb3VwU2VwYXJhdG9ycyh2YWx1ZSwgdGhpcy5zZXR0aW5ncywgZmFsc2UsIHJhd1ZhbHVlVG9Gb3JtYXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRlc3RpbmcgZm9yIGBhbGxvd0RlY2ltYWxQYWRkaW5nLm5ldmVyYCBvciBgYWxsb3dEZWNpbWFsUGFkZGluZy5mbG9hdHNgIGlzIG5lZWRlZCB0byBtYWtlIHN1cmUgd2UgZG8gbm90IGtlZXAgYSB0cmFpbGluZyBkZWNpbWFsQ2hhcmFjdGVyIChsaWtlICc1MDAuJykgaW4gdGhlIGVsZW1lbnQsIHNpbmNlIHRoZSByYXcgdmFsdWUgd291bGQgc3RpbGwgYmUgYSBjb3JyZWN0bHkgZm9ybWF0dGVkIGludGVnZXIgKCc1MDAnKVxuICAgICAgICAgICAgICAgIGlmIChncm91cGVkVmFsdWUgIT09IHJhd1ZhbHVlVG9Gb3JtYXQgfHxcbiAgICAgICAgICAgICAgICAgICAgcmF3VmFsdWVUb0Zvcm1hdCA9PT0gJycgfHwgLy8gVGhpcyBtYWtlIHN1cmUgd2UgZ2V0IHJpZCBvbiBhbnkgY3VycmVuY3kgc3ltYm9sIG9yIHN1ZmZpeCB0aGF0IG1pZ2h0IGhhdmUgYmVlbiBhZGRlZCBvbiBmb2N1c1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmFsbG93RGVjaW1hbFBhZGRpbmcgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZy5uZXZlciB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmFsbG93RGVjaW1hbFBhZGRpbmcgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZy5mbG9hdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3ltYm9sV2hlblVuZm9jdXNlZCAmJiByYXdWYWx1ZVRvRm9ybWF0ICE9PSAnJyAmJiByYXdWYWx1ZVRvRm9ybWF0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cGVkVmFsdWUgPSBgJHtncm91cGVkVmFsdWV9JHt0aGlzLnNldHRpbmdzLnN5bWJvbFdoZW5VbmZvY3VzZWR9YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZShncm91cGVkVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChncm91cGVkVmFsdWUgIT09IHRoaXMudmFsdWVPbkZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRyaWdnZXJFdmVudChBdXRvTnVtZXJpYy5ldmVudHMubmF0aXZlLmNoYW5nZSwgdGhpcy5kb21FbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudmFsdWVPbkZvY3VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fb25CbHVyKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgJ3Bhc3RlJyBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudHxDbGlwYm9hcmRFdmVudH0gZVxuICAgICAqL1xuICAgIF9vblBhc3RlKGUpIHtcbiAgICAgICAgLy9UT0RPIFVzaW5nIGN0cmwreiBhZnRlciBhIHBhc3RlIHNob3VsZCBjYW5jZWwgaXQgLT4gSG93IHdvdWxkIHRoYXQgYWZmZWN0IG90aGVyIGZyYW1ld29ya3MvY29tcG9uZW50IGJ1aWx0IHdpdGggdGhhdCBmZWF0dXJlIGluIG1pbmQgdGhvdWdoP1xuICAgICAgICAvL0ZJWE1FIFdoZW4gcGFzdGluZyAnMDAwJyBvbiBhIHRob3VzYW5kIGdyb3VwIHNlbGVjdGlvbiwgdGhlIHdob2xlIHNlbGVjdGlvbiBnZXRzIGRlbGV0ZWQsIGFuZCBvbmx5IG9uZSAnMCcgaXMgcGFzdGVkIChjZi4gaXNzdWUgIzMwMilcbiAgICAgICAgLy8gVGhlIGV2ZW50IGlzIHByZXZlbnRlZCBieSBkZWZhdWx0LCBzaW5jZSBvdGhlcndpc2UgdGhlIHVzZXIgd291bGQgYmUgYWJsZSB0byBwYXN0ZSBpbnZhbGlkIGNoYXJhY3RlcnMgaW50byB0aGUgaW5wdXRcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGxldCByYXdQYXN0ZWRUZXh0O1xuICAgICAgICBpZiAod2luZG93LmNsaXBib2FyZERhdGEgJiYgd2luZG93LmNsaXBib2FyZERhdGEuZ2V0RGF0YSkge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciB0aGUgb2Jzb2xldGUgYW5kIG5vbi1zdGFuZGFyZCBJRSBicm93c2VycyAxMCBhbmQgMTFcbiAgICAgICAgICAgIHJhd1Bhc3RlZFRleHQgPSB3aW5kb3cuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCdUZXh0Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5jbGlwYm9hcmREYXRhICYmIGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKSB7XG4gICAgICAgICAgICAvLyBOb3JtYWwgY2FzZSB3aXRoIG1vZGVybiBicm93c2Vyc1xuICAgICAgICAgICAgcmF3UGFzdGVkVGV4dCA9IGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKCdVbmFibGUgdG8gcmV0cmlldmUgdGhlIHBhc3RlZCB2YWx1ZS4gUGxlYXNlIHVzZSBhIG1vZGVybiBicm93c2VyIChpZS4gRmlyZWZveCBvciBDaHJvbWl1bSkuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAwLiBTcGVjaWFsIGNhc2UgaWYgdGhlIHVzZXIgaGFzIHNlbGVjdGVkIGFsbCB0aGUgaW5wdXQgdGV4dCBiZWZvcmUgcGFzdGluZ1xuICAgICAgICBjb25zdCBpbml0aWFsRm9ybWF0dGVkVmFsdWUgPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUoZS50YXJnZXQpO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25TdGFydCA9IGUudGFyZ2V0LnNlbGVjdGlvblN0YXJ0IHx8IDA7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbkVuZCA9IGUudGFyZ2V0LnNlbGVjdGlvbkVuZCB8fCAwO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25TaXplID0gc2VsZWN0aW9uRW5kIC0gc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIGxldCBpc0FsbElucHV0VGV4dFNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvblNpemUgPT09IGluaXRpYWxGb3JtYXR0ZWRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlzQWxsSW5wdXRUZXh0U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMS4gQ2hlY2sgaWYgdGhlIHBhc3RlIGhhcyBhIG5lZ2F0aXZlIHNpZ24gKG9ubHkgaWYgaXQncyB0aGUgZmlyc3QgY2hhcmFjdGVyKSwgYW5kIHN0b3JlIHRoYXQgaW5mb3JtYXRpb24gZm9yIGxhdGVyIHVzZVxuICAgICAgICBjb25zdCBpc1Bhc3RlTmVnYXRpdmUgPSBBdXRvTnVtZXJpY0hlbHBlci5pc05lZ2F0aXZlU3RyaWN0KHJhd1Bhc3RlZFRleHQpO1xuICAgICAgICBpZiAoaXNQYXN0ZU5lZ2F0aXZlKSB7XG4gICAgICAgICAgICAvLyAxYS4gUmVtb3ZlIHRoZSBuZWdhdGl2ZSBzaWduIGZyb20gdGhlIHBhc3RlZCB0ZXh0XG4gICAgICAgICAgICByYXdQYXN0ZWRUZXh0ID0gcmF3UGFzdGVkVGV4dC5zbGljZSgxLCByYXdQYXN0ZWRUZXh0Lmxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLiBTdHJpcCBhbGwgdGhvdXNhbmQgc2VwYXJhdG9ycywgYnJhY2tldHMgYW5kIGN1cnJlbmN5IHNpZ24sIGFuZCBjb252ZXJ0IHRoZSBkZWNpbWFsIGNoYXJhY3RlciB0byBhIGRvdFxuICAgICAgICBjb25zdCB1bnRyYW5zbGF0ZWRQYXN0ZWRUZXh0ID0gdGhpcy5fcHJlcGFyZVBhc3RlZFRleHQocmF3UGFzdGVkVGV4dCk7XG5cbiAgICAgICAgbGV0IHBhc3RlZFRleHQ7XG4gICAgICAgIGlmICh1bnRyYW5zbGF0ZWRQYXN0ZWRUZXh0ID09PSAnLicpIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSA6IElmIHRoZSB1c2VyIHRyaWVzIHRvIHBhc3RlIGEgc2luZ2xlIGRlY2ltYWwgY2hhcmFjdGVyICh0aGF0IGhhcyBiZWVuIHRyYW5zbGF0ZWQgdG8gJy4nIGFscmVhZHkpXG4gICAgICAgICAgICBwYXN0ZWRUZXh0ID0gJy4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm9ybWFsIGNhc2VcbiAgICAgICAgICAgIC8vIEFsbG93IHBhc3RpbmcgYXJhYmljIG51bWJlcnNcbiAgICAgICAgICAgIHBhc3RlZFRleHQgPSBBdXRvTnVtZXJpY0hlbHBlci5hcmFiaWNUb0xhdGluTnVtYmVycyh1bnRyYW5zbGF0ZWRQYXN0ZWRUZXh0LCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIFRlc3QgaWYgdGhlIHBhc3RlIGlzIHZhbGlkIChvbmx5IGhhcyBudW1iZXJzIGFuZCBldmVudHVhbGx5IGEgZGVjaW1hbCBjaGFyYWN0ZXIpLiBJZiBpdCdzIG5vdCB2YWxpZCwgc3RvcCBoZXJlLlxuICAgICAgICBpZiAocGFzdGVkVGV4dCAhPT0gJy4nICYmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdW1iZXIocGFzdGVkVGV4dCkgfHwgcGFzdGVkVGV4dCA9PT0gJycpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5vbkludmFsaWRQYXN0ZSA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5vbkludmFsaWRQYXN0ZS5lcnJvcikge1xuICAgICAgICAgICAgICAgIC8vVE9ETyBTaG91bGQgd2Ugc2VuZCBhIHdhcm5pbmcgaW5zdGVhZCBvZiB0aHJvd2luZyBhbiBlcnJvcj9cbiAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgcGFzdGVkIHZhbHVlICcke3Jhd1Bhc3RlZFRleHR9JyBpcyBub3QgYSB2YWxpZCBwYXN0ZSBjb250ZW50LmApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyA0LiBDYWxjdWxhdGUgdGhlIHBhc3RlIHJlc3VsdFxuICAgICAgICBsZXQgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3Rpbmc7XG4gICAgICAgIGxldCBpbml0aWFsVW5mb3JtYXR0ZWROdW1iZXIgPSB0aGlzLmdldE51bWVyaWNTdHJpbmcoKTtcbiAgICAgICAgbGV0IGlzSW5pdGlhbFZhbHVlTmVnYXRpdmUgPSBBdXRvTnVtZXJpY0hlbHBlci5pc05lZ2F0aXZlU3RyaWN0KGluaXRpYWxVbmZvcm1hdHRlZE51bWJlcik7XG4gICAgICAgIGxldCBpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlO1xuICAgICAgICBsZXQgcmVzdWx0O1xuXG4gICAgICAgIC8vIElmIHRoZSBwYXN0ZWQgY29udGVudCBpcyBuZWdhdGl2ZSwgdGhlbiB0aGUgcmVzdWx0IHdpbGwgYmUgbmVnYXRpdmUgdG9vXG4gICAgICAgIGlmIChpc1Bhc3RlTmVnYXRpdmUgJiYgIWlzSW5pdGlhbFZhbHVlTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIGluaXRpYWxVbmZvcm1hdHRlZE51bWJlciA9IGAtJHtpbml0aWFsVW5mb3JtYXR0ZWROdW1iZXJ9YDtcbiAgICAgICAgICAgIGlzSW5pdGlhbFZhbHVlTmVnYXRpdmUgPSB0cnVlO1xuICAgICAgICAgICAgaXNQYXN0ZU5lZ2F0aXZlQW5kSW5pdGlhbFZhbHVlSXNQb3NpdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGVmdFBhcnRDb250YWluZWRBRG90ID0gZmFsc2U7XG4gICAgICAgIGxldCBsZWZ0UGFydDtcbiAgICAgICAgbGV0IHJpZ2h0UGFydDtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlKSB7XG4gICAgICAgICAgICAvKiA0YS4gVHJ1bmNhdGUgcGFzdGUgYmVoYXZpb3I6XG4gICAgICAgICAgICAgKiBJbnNlcnQgYXMgbWFueSBudW1iZXJzIGFzIHBvc3NpYmxlIG9uIHRoZSByaWdodCBoYW5kIHNpZGUgb2YgdGhlIGNhcmV0IGZyb20gdGhlIHBhc3RlZCB0ZXh0IGNvbnRlbnQsIHVudGlsIHRoZSBpbnB1dCByZWFjaCBpdHMgcmFuZ2UgbGltaXQuXG4gICAgICAgICAgICAgKiBJZiB0aGVyZSBpcyBtb3JlIGNoYXJhY3RlcnMgaW4gdGhlIGNsaXBib2FyZCBvbmNlIGEgbGltaXQgaXMgcmVhY2hlZCwgZHJvcCB0aGUgZXh0cmFuZW91cyBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICogT3RoZXJ3aXNlIHBhc3RlIGFsbCB0aGUgbnVtYmVycyBpbiB0aGUgY2xpcGJvYXJkLlxuICAgICAgICAgICAgICogV2hpbGUgZG9pbmcgc28sIHdlIGNoZWNrIGlmIHRoZSByZXN1bHQgaXMgd2l0aGluIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlcyBhbGxvd2VkLCBhbmQgc3RvcCBhcyBzb29uIGFzIHdlIGVuY291bnRlciBvbmUgb2YgdGhvc2UuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogNGIuIFJlcGxhY2UgcGFzdGUgYmVoYXZpb3I6XG4gICAgICAgICAgICAgKiBJZGVtIHRoYW4gdGhlICd0cnVuY2F0ZScgcGFzdGUgYmVoYXZpb3IsIGV4Y2VwdCB0aGF0IHdoZW4gYSByYW5nZSBsaW1pdCBpcyBoaXQsIHdlIHRyeSB0byByZXBsYWNlIHRoZSBzdWJzZXF1ZW50IGluaXRpYWwgbnVtYmVycyB3aXRoIHRoZSBwYXN0ZWQgb25lcywgdW50aWwgd2UgaGl0IHRoZSByYW5nZSBsaW1pdCBhIHNlY29uZCAoYW5kIGxhc3QpIHRpbWUsIG9yIHdlIHJ1biBvdXQgb2YgbnVtYmVycyB0byBwYXN0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKiBlc2xpbnQgbm8tY2FzZS1kZWNsYXJhdGlvbnM6IDAgKi9cbiAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5vbkludmFsaWRQYXN0ZS50cnVuY2F0ZTpcbiAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5vbkludmFsaWRQYXN0ZS5yZXBsYWNlOlxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRGb3JtYXR0ZWRQYXJ0ID0gaW5pdGlhbEZvcm1hdHRlZFZhbHVlLnNsaWNlKDAsIHNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodEZvcm1hdHRlZFBhcnQgPSBpbml0aWFsRm9ybWF0dGVkVmFsdWUuc2xpY2Uoc2VsZWN0aW9uRW5kLCBpbml0aWFsRm9ybWF0dGVkVmFsdWUubGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCAhPT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEuIElmIHRoZXJlIGlzIGEgc2VsZWN0aW9uLCByZW1vdmUgdGhlIHNlbGVjdGVkIHBhcnQsIGFuZCByZXR1cm4gdGhlIGxlZnQgYW5kIHJpZ2h0IHBhcnRcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fcHJlcGFyZVBhc3RlZFRleHQobGVmdEZvcm1hdHRlZFBhcnQgKyByaWdodEZvcm1hdHRlZFBhcnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGIuIEVsc2UgaWYgdGhpcyBpcyBvbmx5IG9uZSBjYXJldCAoYW5kIHRoZXJlZm9yZSBubyBzZWxlY3Rpb24pLCB0aGVuIHJldHVybiB0aGUgbGVmdCBhbmQgcmlnaHQgcGFydFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9wcmVwYXJlUGFzdGVkVGV4dChpbml0aWFsRm9ybWF0dGVkVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBiYWNrIHRoZSBuZWdhdGl2ZSBzaWduIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmIChpc0luaXRpYWxWYWx1ZU5lZ2F0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljSGVscGVyLnNldFJhd05lZ2F0aXZlU2lnbihyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSB1bmZvcm1hdHRlZCByZXN1bHQgc3RyaW5nXG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcgPSBBdXRvTnVtZXJpY0hlbHBlci5jb252ZXJ0Q2hhcmFjdGVyQ291bnRUb0luZGV4UG9zaXRpb24oQXV0b051bWVyaWNIZWxwZXIuY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlKGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcikpO1xuICAgICAgICAgICAgICAgIGlmIChpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpbml0aWFsIHBhc3RlIGlzIG5lZ2F0aXZlIGFuZCB0aGUgaW5pdGlhbCB2YWx1ZSBpcyBub3QsIHRoZW4gSSBtdXN0IG9mZnNldCB0aGUgY2FyZXQgcG9zaXRpb24gYnkgb25lIHBsYWNlIHRvIHRoZSByaWdodCB0byB0YWtlIHRoZSBhZGRpdGlvbmFsIGh5cGhlbiBpbnRvIGFjY291bnRcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcrKztcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIFF1aWQgaWYgdGhlIG5lZ2F0aXZlIHNpZ24gaXMgbm90IG9uIHRoZSBsZWZ0IChuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCBhbmQgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQpP1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxlZnRQYXJ0ID0gcmVzdWx0LnNsaWNlKDAsIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nKTtcbiAgICAgICAgICAgICAgICByaWdodFBhcnQgPSByZXN1bHQuc2xpY2UoY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcsIHJlc3VsdC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChwYXN0ZWRUZXh0ID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmNvbnRhaW5zKGxlZnRQYXJ0LCAnLicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBJIHJlbW92ZSBhIGRvdCBoZXJlLCB0aGVuIEkgbmVlZCB0byB1cGRhdGUgdGhlIGNhcmV0IHBvc2l0aW9uIChkZWNyZW1lbnQgaXQgYnkgMSkgd2hlbiBwb3NpdGlvbmluZyBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG8gZG8gc28sIHdlIGtlZXAgdGhhdCBpbmZvIGluIG9yZGVyIHRvIG1vZGlmeSB0aGUgY2FyZXQgcG9zaXRpb24gbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRQYXJ0Q29udGFpbmVkQURvdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0UGFydCA9IGxlZnRQYXJ0LnJlcGxhY2UoJy4nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGFydCA9IHJpZ2h0UGFydC5yZXBsYWNlKCcuJywgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAtLSBIZXJlLCB3ZSBhcmUgZ29vZCB0byBnbyB0byBjb250aW51ZSBvbiB0aGUgc2FtZSBiYXNpc1xuXG4gICAgICAgICAgICAgICAgLy8gYy4gQWRkIG51bWJlcnMgb25lIGJ5IG9uZSBhdCB0aGUgY2FyZXQgcG9zaXRpb24sIHdoaWxlIHRlc3RpbmcgaWYgdGhlIHJlc3VsdCBpcyB2YWxpZCBhbmQgd2l0aGluIHRoZSByYW5nZSBvZiB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vICAgIENvbnRpbnVlIHVudGlsIHlvdSBlaXRoZXIgcnVuIG91dCBvZiBudW1iZXJzIHRvIHBhc3RlLCBvciB0aGF0IHlvdSBnZXQgb3V0IG9mIHRoZSByYW5nZSBsaW1pdHNcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5QYXJzZSA9IEF1dG9OdW1lcmljSGVscGVyLnBhcnNlU3RyKHRoaXMuc2V0dGluZ3MubWluaW11bVZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhQYXJzZSA9IEF1dG9OdW1lcmljSGVscGVyLnBhcnNlU3RyKHRoaXMuc2V0dGluZ3MubWF4aW11bVZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdEdvb2RLbm93blJlc3VsdCA9IHJlc3VsdDsgLy8gVGhpcyBpcyBzZXQgYXMgdGhlIGRlZmF1bHQsIGluIGNhc2Ugd2UgZG8gbm90IGFkZCBldmVuIG9uZSBudW1iZXJcbiAgICAgICAgICAgICAgICBsZXQgcGFzdGVkVGV4dEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgbW9kaWZpZWRMZWZ0UGFydCA9IGxlZnRQYXJ0O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhc3RlZFRleHRJbmRleCA8IHBhc3RlZFRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vZGlmeSB0aGUgcmVzdWx0IHdpdGggYW5vdGhlciBwYXN0ZWQgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkTGVmdFBhcnQgKz0gcGFzdGVkVGV4dFtwYXN0ZWRUZXh0SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBtb2RpZmllZExlZnRQYXJ0ICsgcmlnaHRQYXJ0O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSByYW5nZSBsaW1pdHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLl9jaGVja0lmSW5SYW5nZShyZXN1bHQsIG1pblBhcnNlLCBtYXhQYXJzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXN1bHQgaXMgb3V0IG9mIHRoZSByYW5nZSBsaW1pdHMsIHN0b3AgdGhlIGxvb3AgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBsYXN0IGdvb2Qga25vd24gcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIGxhc3RHb29kS25vd25SZXN1bHQgPSByZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsb2NhbCB2YXJpYWJsZXMgZm9yIHRoZSBuZXh0IGxvb3BcbiAgICAgICAgICAgICAgICAgICAgcGFzdGVkVGV4dEluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsYXN0IGNhcmV0IHBvc2l0aW9uIHdoZXJlIHRvIGluc2VydCBhIG5ldyBudW1iZXJcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyArPSBwYXN0ZWRUZXh0SW5kZXg7XG5cbiAgICAgICAgICAgICAgICAvL1hYWCBIZXJlIHdlIGhhdmUgdGhlIHJlc3VsdCBmb3IgdGhlIGB0cnVuY2F0ZWAgb3B0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Mub25JbnZhbGlkUGFzdGUgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMub25JbnZhbGlkUGFzdGUudHJ1bmNhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIElmIHRoZSB1c2VyIGFzIGRlZmluZWQgYSB0cnVuY2F0ZSBjYWxsYmFjayBhbmQgdGhlcmUgYXJlIHN0aWxsIHNvbWUgbnVtYmVycyAodGhhdCB3aWxsIGJlIGRyb3BwZWQpLCB0aGVuIGNhbGwgdGhpcyBjYWxsYmFjayB3aXRoIHRoZSBpbml0aWFsIHBhc3RlIGFzIHdlbGwgYXMgdGhlIHJlbWFpbmluZyBudW1iZXJzXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxhc3RHb29kS25vd25SZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRQYXJ0Q29udGFpbmVkQURvdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBkb3QgaGFzIGJlZW4gcmVtb3ZlZCBmb3IgdGhlIHBhcnQgb24gdGhlIGxlZnQgb2YgdGhlIGNhcmV0LCB3ZSBkZWNyZW1lbnQgdGhlIGNhcmV0IGluZGV4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZy0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL1hYWCAuLi5lbHNlIHdlIG5lZWQgdG8gY29udGludWUgbW9kaWZ5aW5nIHRoZSByZXN1bHQgZm9yIHRoZSAncmVwbGFjZScgb3B0aW9uXG5cbiAgICAgICAgICAgICAgICAvLyBkLiBVbnRpbCB0aGVyZSBhcmUgbnVtYmVycyB0byBwYXN0ZSwgcmVwbGFjZSB0aGUgaW5pdGlhbCBudW1iZXJzIG9uZSBieSBvbmUsIGFuZCBzdGlsbCBkbyB0aGUgcmFuZ2UgdGVzdC5cbiAgICAgICAgICAgICAgICAvLyAgICBTdG9wIHdoZW4geW91IGhhdmUgbm8gbW9yZSBudW1iZXJzIHRvIHBhc3RlLCBvciBpZiB5b3UgYXJlIG91dCBvZiB0aGUgcmFuZ2UgbGltaXRzLlxuICAgICAgICAgICAgICAgIC8vICAgIElmIHlvdSBkbyBnZXQgdG8gdGhlIHJhbmdlIGxpbWl0cywgdXNlIHRoZSBwcmV2aW91cyBrbm93biBnb29kIHZhbHVlIHdpdGhpbiB0aG9zZSBsaW1pdHMuXG4gICAgICAgICAgICAgICAgLy8gICAgTm90ZTogVGhlIG51bWJlcnMgYXJlIHJlcGxhY2VkIG9uZSBieSBvbmUsIGluIHRoZSBpbnRlZ2VyIHRoZW4gZGVjaW1hbCBwYXJ0LCB3aGlsZSBpZ25vcmluZyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAvL1RPRE8gV2hhdCBzaG91bGQgaGFwcGVuIGlmIHRoZSB1c2VyIHRyeSB0byBwYXN0ZSBhIGRlY2ltYWwgbnVtYmVyPyBTaG91bGQgd2Ugb3ZlcnJpZGUgdGhlIGN1cnJlbnQgaW5pdGlhbCBkZWNpbWFsIGNoYXJhY3RlciBpbiBmYXZvciBvZiB0aGlzIG5ldyBvbmU/IElmIHdlIGRvLCB0aGVuIHdlIGhhdmUgdG8gcmVjYWxjdWxhdGUgdGhlIHZNaW4vdk1heCBmcm9tIHRoZSBzdGFydCBpbiBvcmRlciB0byB0YWtlIGludG8gYWNjb3VudCB0aGlzIG5ldyBkZWNpbWFsIGNoYXJhY3RlciBwb3NpdGlvbi4uXG4gICAgICAgICAgICAgICAgbGV0IGxhc3RHb29kS25vd25SZXN1bHRJbmRleCA9IGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RHb29kS25vd25SZXN1bHRTaXplID0gbGFzdEdvb2RLbm93blJlc3VsdC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocGFzdGVkVGV4dEluZGV4IDwgcGFzdGVkVGV4dC5sZW5ndGggJiYgbGFzdEdvb2RLbm93blJlc3VsdEluZGV4IDwgbGFzdEdvb2RLbm93blJlc3VsdFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RHb29kS25vd25SZXN1bHRbbGFzdEdvb2RLbm93blJlc3VsdEluZGV4XSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBza2lwIHRoZSBkZWNpbWFsIGNoYXJhY3RlciAncmVwbGFjZW1lbnQnLiBUaGF0IHdheSwgd2UgZG8gbm90IGNoYW5nZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgcG9zaXRpb24gcmVnYXJkaW5nIHRoZSByZW1haW5pbmcgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHb29kS25vd25SZXN1bHRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHJlcGxhY2Ugb25lIGNoYXJhY3RlciBhdCBhIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNIZWxwZXIucmVwbGFjZUNoYXJBdChsYXN0R29vZEtub3duUmVzdWx0LCBsYXN0R29vZEtub3duUmVzdWx0SW5kZXgsIHBhc3RlZFRleHRbcGFzdGVkVGV4dEluZGV4XSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHJhbmdlIGxpbWl0c1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuX2NoZWNrSWZJblJhbmdlKHJlc3VsdCwgbWluUGFyc2UsIG1heFBhcnNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlc3VsdCBpcyBvdXQgb2YgdGhlIHJhbmdlIGxpbWl0cywgc3RvcCB0aGUgbG9vcCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGxhc3QgZ29vZCBrbm93biByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgbGFzdEdvb2RLbm93blJlc3VsdCA9IHJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxvY2FsIHZhcmlhYmxlcyBmb3IgdGhlIG5leHQgbG9vcFxuICAgICAgICAgICAgICAgICAgICBwYXN0ZWRUZXh0SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgbGFzdEdvb2RLbm93blJlc3VsdEluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsYXN0IGNhcmV0IHBvc2l0aW9uIHdoZXJlIHRvIGluc2VydCBhIG5ldyBudW1iZXJcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IGxhc3RHb29kS25vd25SZXN1bHRJbmRleDtcblxuICAgICAgICAgICAgICAgIGlmIChsZWZ0UGFydENvbnRhaW5lZEFEb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBkb3QgaGFzIGJlZW4gcmVtb3ZlZCBmb3IgdGhlIHBhcnQgb24gdGhlIGxlZnQgb2YgdGhlIGNhcmV0LCB3ZSBkZWNyZW1lbnQgdGhlIGNhcmV0IGluZGV4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGFzdEdvb2RLbm93blJlc3VsdDtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogNGMuIE5vcm1hbCBwYXN0ZSBiZWhhdmlvcjpcbiAgICAgICAgICAgICAqIEluc2VydCB0aGUgcGFzdGVkIG51bWJlciBpbnNpZGUgdGhlIGN1cnJlbnQgdW5mb3JtYXR0ZWQgdGV4dCwgYXQgdGhlIHJpZ2h0IGNhcmV0IHBvc2l0aW9uIG9yIHNlbGVjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMub25JbnZhbGlkUGFzdGUuZXJyb3I6XG4gICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMub25JbnZhbGlkUGFzdGUuaWdub3JlOlxuICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm9uSW52YWxpZFBhc3RlLmNsYW1wOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyAxLiBHZW5lcmF0ZSB0aGUgdW5mb3JtYXR0ZWQgcmVzdWx0XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdEZvcm1hdHRlZFBhcnQyID0gaW5pdGlhbEZvcm1hdHRlZFZhbHVlLnNsaWNlKDAsIHNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodEZvcm1hdHRlZFBhcnQyID0gaW5pdGlhbEZvcm1hdHRlZFZhbHVlLnNsaWNlKHNlbGVjdGlvbkVuZCwgaW5pdGlhbEZvcm1hdHRlZFZhbHVlLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgIT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhLiBJZiB0aGVyZSBpcyBhIHNlbGVjdGlvbiwgcmVtb3ZlIHRoZSBzZWxlY3RlZCBwYXJ0LCBhbmQgcmV0dXJuIHRoZSBsZWZ0IGFuZCByaWdodCBwYXJ0XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX3ByZXBhcmVQYXN0ZWRUZXh0KGxlZnRGb3JtYXR0ZWRQYXJ0MiArIHJpZ2h0Rm9ybWF0dGVkUGFydDIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGIuIEVsc2UgaWYgdGhpcyBpcyBvbmx5IG9uZSBjYXJldCAoYW5kIHRoZXJlZm9yZSBubyBzZWxlY3Rpb24pLCB0aGVuIHJldHVybiB0aGUgbGVmdCBhbmQgcmlnaHQgcGFydFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9wcmVwYXJlUGFzdGVkVGV4dChpbml0aWFsRm9ybWF0dGVkVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBiYWNrIHRoZSBuZWdhdGl2ZSBzaWduIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmIChpc0luaXRpYWxWYWx1ZU5lZ2F0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljSGVscGVyLnNldFJhd05lZ2F0aXZlU2lnbihyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSB1bmZvcm1hdHRlZCByZXN1bHQgc3RyaW5nXG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcgPSBBdXRvTnVtZXJpY0hlbHBlci5jb252ZXJ0Q2hhcmFjdGVyQ291bnRUb0luZGV4UG9zaXRpb24oQXV0b051bWVyaWNIZWxwZXIuY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlKGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcikpO1xuICAgICAgICAgICAgICAgIGlmIChpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpbml0aWFsIHBhc3RlIGlzIG5lZ2F0aXZlIGFuZCB0aGUgaW5pdGlhbCB2YWx1ZSBpcyBub3QsIHRoZW4gSSBtdXN0IG9mZnNldCB0aGUgY2FyZXQgcG9zaXRpb24gYnkgb25lIHBsYWNlIHRvIHRoZSByaWdodCB0byB0YWtlIHRoZSBhZGRpdGlvbmFsIGh5cGhlbiBpbnRvIGFjY291bnRcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcrKztcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIFF1aWQgaWYgdGhlIG5lZ2F0aXZlIHNpZ24gaXMgbm90IG9uIHRoZSBsZWZ0IChuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCBhbmQgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQpP1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxlZnRQYXJ0ID0gcmVzdWx0LnNsaWNlKDAsIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nKTtcbiAgICAgICAgICAgICAgICByaWdodFBhcnQgPSByZXN1bHQuc2xpY2UoY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcsIHJlc3VsdC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChwYXN0ZWRUZXh0ID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgb25seSBwYXN0ZSBhIHNpbmdsZSBkZWNpbWFsIGNoYXJhY3RlciwgdGhlbiB3ZSByZW1vdmUgdGhlIHByZXZpb3VzbHkgZXhpc3Rpbmcgb25lIChpZiBhbnkpXG4gICAgICAgICAgICAgICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5jb250YWlucyhsZWZ0UGFydCwgJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgSSByZW1vdmUgYSBkb3QgaGVyZSwgdGhlbiBJIG5lZWQgdG8gdXBkYXRlIHRoZSBjYXJldCBwb3NpdGlvbiAoZGVjcmVtZW50IGl0IGJ5IDEpIHdoZW4gcG9zaXRpb25pbmcgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvIGRvIHNvLCB3ZSBrZWVwIHRoYXQgaW5mbyBpbiBvcmRlciB0byBtb2RpZnkgdGhlIGNhcmV0IHBvc2l0aW9uIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0UGFydENvbnRhaW5lZEFEb3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFBhcnQgPSBsZWZ0UGFydC5yZXBsYWNlKCcuJywgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UGFydCA9IHJpZ2h0UGFydC5yZXBsYWNlKCcuJywgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAtLSBIZXJlLCB3ZSBhcmUgZ29vZCB0byBnbyB0byBjb250aW51ZSBvbiB0aGUgc2FtZSBiYXNpc1xuXG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgdGhlIHVuZm9ybWF0dGVkIHJlc3VsdFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGAke2xlZnRQYXJ0fSR7cGFzdGVkVGV4dH0ke3JpZ2h0UGFydH1gO1xuXG4gICAgICAgICAgICAgICAgLy8gMi4gQ2FsY3VsYXRlIHRoZSBjYXJldCBwb3NpdGlvbiBpbiB0aGUgdW5mb3JtYXR0ZWQgdmFsdWUsIGZvciBsYXRlciB1c2VcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBzZWxlY3Rpb24sIHRoZW4gdGhlIGNhcmV0IHBvc2l0aW9uIGlzIHNldCBhZnRlciB0aGUgcGFzdGVkIHRleHRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXhXaGVyZVBhc3RlZFRleHRIYXNCZWVuSW5zZXJ0ZWQgPSBBdXRvTnVtZXJpY0hlbHBlci5jb252ZXJ0Q2hhcmFjdGVyQ291bnRUb0luZGV4UG9zaXRpb24oQXV0b051bWVyaWNIZWxwZXIuY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlKGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcikpO1xuICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IGluZGV4V2hlcmVQYXN0ZWRUZXh0SGFzQmVlbkluc2VydGVkICsgcGFzdGVkVGV4dC5sZW5ndGg7IC8vIEkgbXVzdCBub3QgY291bnQgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXN0ZWQgdGV4dCAoaWUuICcuJylcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBbGxJbnB1dFRleHRTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHdoZW4gYWxsIHRoZSBpbnB1dCB0ZXh0IGlzIHNlbGVjdGVkIGJlZm9yZSBwYXN0aW5nLCB3aGljaCBtZWFucyB3ZSdsbCBjb21wbGV0ZWx5IGVyYXNlIGl0cyBjb250ZW50IGFuZCBwYXN0ZSBvbmx5IHRoZSBjbGlwYm9hcmQgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0UGFydCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIHNlbGVjdGVkIGZyb20gdGhlIGNhcmV0IHBvc2l0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGlucHV0IChvbiB0aGUgZmFyIHJpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcgPSBBdXRvTnVtZXJpY0hlbHBlci5jb252ZXJ0Q2hhcmFjdGVyQ291bnRUb0luZGV4UG9zaXRpb24oQXV0b051bWVyaWNIZWxwZXIuY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlKGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcikpICsgcGFzdGVkVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWwgY2FzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXhTZWxlY3Rpb25FbmRJblJhd1ZhbHVlID0gQXV0b051bWVyaWNIZWxwZXIuY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uKEF1dG9OdW1lcmljSGVscGVyLmNvdW50TnVtYmVyQ2hhcmFjdGVyc09uVGhlQ2FyZXRMZWZ0U2lkZShpbml0aWFsRm9ybWF0dGVkVmFsdWUsIHNlbGVjdGlvbkVuZCwgdGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhlcmUgSSBtdXN0IG5vdCBjb3VudCB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhc3RlZCB0ZXh0IChpZS4gJy4nKSwgb3IgdGhlIHRob3VzYW5kIHNlcGFyYXRvcnMgaW4gdGhlIGluaXRpYWwgc2VsZWN0ZWQgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKGUudGFyZ2V0KS5zbGljZShzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gaW5kZXhTZWxlY3Rpb25FbmRJblJhd1ZhbHVlIC0gc2VsZWN0aW9uU2l6ZSArIEF1dG9OdW1lcmljSGVscGVyLmNvdW50Q2hhckluVGV4dCh0aGlzLnNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IsIHNlbGVjdGVkVGV4dCkgKyBwYXN0ZWRUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1vZGlmeSB0aGUgY2FyZXQgcG9zaXRpb24gZm9yIHNwZWNpYWwgY2FzZXMsIG9ubHkgaWYgdGhlIHdob2xlIGlucHV0IGhhcyBub3QgYmVlbiBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGlmICghaXNBbGxJbnB1dFRleHRTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQYXN0ZU5lZ2F0aXZlQW5kSW5pdGlhbFZhbHVlSXNQb3NpdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHBhc3RlZCB2YWx1ZSBoYXMgYSAnLScgc2lnbiwgYnV0IHRoZSBpbml0aWFsIHZhbHVlIGRvZXMgbm90LCBvZmZzZXQgdGhlIGluZGV4IGJ5IG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0UGFydENvbnRhaW5lZEFEb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGEgZG90IGhhcyBiZWVuIHJlbW92ZWQgZm9yIHRoZSBwYXJ0IG9uIHRoZSBsZWZ0IG9mIHRoZSBjYXJldCwgd2UgZGVjcmVtZW50IHRoZSBjYXJldCBpbmRleCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmctLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDUuIENoZWNrIGlmIHRoZSByZXN1bHQgaXMgYSB2YWxpZCBudW1iZXIsIGlmIG5vdCwgZHJvcCB0aGUgcGFzdGUgYW5kIGRvIG5vdGhpbmcuXG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdW1iZXIocmVzdWx0KSB8fCByZXN1bHQgPT09ICcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5vbkludmFsaWRQYXN0ZSA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5vbkludmFsaWRQYXN0ZS5lcnJvcikge1xuICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBwYXN0ZWQgdmFsdWUgJyR7cmF3UGFzdGVkVGV4dH0nIHdvdWxkIHJlc3VsdCBpbnRvIGFuIGludmFsaWQgY29udGVudCAnJHtyZXN1bHR9Jy5gKTsgLy9UT0RPIFNob3VsZCB3ZSBzZW5kIGEgd2FybmluZyBpbnN0ZWFkIG9mIHRocm93aW5nIGFuIGVycm9yP1xuICAgICAgICAgICAgICAgIC8vVE9ETyBUaGlzIGlzIG5vdCBEUlkgOyByZWZhY3RvciB3aXRoIGFib3ZlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyA2LiBJZiBpdCdzIGEgdmFsaWQgbnVtYmVyLCBjaGVjayBpZiBpdCBmYWxscyBpbnNpZGUgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWUuIElmIHRoaXMgZmFpbHMsIG1vZGlmeSB0aGUgdmFsdWUgZm9sbG93aW5nIHRoaXMgcHJvY2VkdXJlIDpcbiAgICAgICAgLypcbiAgICAgICAgICogSWYgJ2Vycm9yJyAodGhpcyBpcyB0aGUgZGVmYXVsdCkgOlxuICAgICAgICAgKiAgICAgIC0gTm9ybWFsIHBhc3RlIGJlaGF2aW9yLlxuICAgICAgICAgKiAgICAgIC0gVHJ5IHRvIHNldCB0aGUgbmV3IHZhbHVlLCBpZiBpdCBmYWlscywgdGhlbiB0aHJvdyBhbiBlcnJvciBpbiB0aGUgY29uc29sZS5cbiAgICAgICAgICogICAgICAtIERvIG5vdCBjaGFuZ2UgdGhlIGlucHV0IHZhbHVlLCBkbyBub3QgY2hhbmdlIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgICAgICogSWYgJ2lnbm9yZScgOlxuICAgICAgICAgKiAgICAgIC0gTm9ybWFsIHBhc3RlIGJlaGF2aW9yLlxuICAgICAgICAgKiAgICAgIC0gVHJ5IHRvIHNldCB0aGUgbmV3IHZhbHVlLCBpZiBpdCBmYWlscywgZG8gbm90aGluZyBtb3JlLlxuICAgICAgICAgKiAgICAgIC0gRG8gbm90IGNoYW5nZSB0aGUgaW5wdXQgdmFsdWUsIGRvIG5vdCBjaGFuZ2UgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICAgKiBJZiAnY2xhbXAnIDpcbiAgICAgICAgICogICAgICAtIE5vcm1hbCBwYXN0ZSBiZWhhdmlvci5cbiAgICAgICAgICogICAgICAtIFRyeSB0byBzZXQgdGhlIG5ldyB2YWx1ZSwgaWYgaXQgZmFpbHMsIHNldCB0aGUgdmFsdWUgdG8gdGhlIG1pbmltdW0gb3IgbWF4aW11bSBsaW1pdCwgd2hpY2hldmVyIGlzIGNsb3Nlc3QgdG8gdGhlXG4gICAgICAgICAqICAgICAgICBwYXN0ZSByZXN1bHQuXG4gICAgICAgICAqICAgICAgLSBDaGFuZ2UgdGhlIGNhcmV0IHBvc2l0aW9uIHRvIGJlIHBvc2l0aW9uZWQgb24gdGhlIGxlZnQgaGFuZCBzaWRlIG9mIHRoZSBkZWNpbWFsIGNoYXJhY3Rlci5cbiAgICAgICAgICogSWYgJ3RydW5jYXRlJyA6XG4gICAgICAgICAqICAgICAgLSBUcnVuY2F0ZSBwYXN0ZSBiZWhhdmlvci5cbiAgICAgICAgICogICAgICAtIFRyeSB0byBzZXQgdGhlIG5ldyB2YWx1ZSwgdW50aWwgaXQgZmFpbHMgKGlmIHRoZSByZXN1bHQgaXMgb3V0IG9mIHRoZSBtaW4gYW5kIG1heCB2YWx1ZSBsaW1pdHMpLlxuICAgICAgICAgKiAgICAgIC0gRHJvcCB0aGUgcmVtYWluaW5nIG5vbi1wYXN0ZWQgbnVtYmVycywgYW5kIGtlZXAgdGhlIGxhc3Qga25vd24gbm9uLWZhaWxpbmcgcmVzdWx0LlxuICAgICAgICAgKiAgICAgIC0gQ2hhbmdlIHRoZSBjYXJldCBwb3NpdGlvbiB0byBiZSBwb3NpdGlvbmVkIGFmdGVyIHRoZSBsYXN0IHBhc3RlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAqIElmICdyZXBsYWNlJyA6XG4gICAgICAgICAqICAgICAgLSBSZXBsYWNlIHBhc3RlIGJlaGF2aW9yLlxuICAgICAgICAgKiAgICAgIC0gVHJ5IHRvIHNldCB0aGUgbmV3IHZhbHVlLCB1bnRpbCBpdCBmYWlscyAoaWYgdGhlIHJlc3VsdCBpcyBvdXQgb2YgdGhlIG1pbiBhbmQgbWF4IHZhbHVlIGxpbWl0cykuXG4gICAgICAgICAqICAgICAtIFRoZW4gdHJ5IHRvIHJlcGxhY2UgYXMgbWFueSBudW1iZXJzIGFzIHBvc3NpYmxlIHdpdGggdGhlIHBhc3RlZCBvbmVzLiBPbmNlIGl0IGZhaWxzLCBrZWVwIHRoZSBsYXN0IGtub3duIG5vbi1mYWlsaW5nIHJlc3VsdC5cbiAgICAgICAgICogICAgICAtIENoYW5nZSB0aGUgY2FyZXQgcG9zaXRpb24gdG8gYmUgcG9zaXRpb25lZCBhZnRlciB0aGUgbGFzdCBwYXN0ZWQgY2hhcmFjdGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IHZhbHVlSGFzQmVlblNldCA9IGZhbHNlO1xuICAgICAgICBsZXQgdmFsdWVIYXNCZWVuQ2xhbXBlZCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zZXQocmVzdWx0KTtcbiAgICAgICAgICAgIHZhbHVlSGFzQmVlblNldCA9IHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsZXQgY2xhbXBlZFZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm9uSW52YWxpZFBhc3RlLmNsYW1wOlxuICAgICAgICAgICAgICAgICAgICBjbGFtcGVkVmFsdWUgPSBBdXRvTnVtZXJpY0hlbHBlci5jbGFtcFRvUmFuZ2VMaW1pdHMocmVzdWx0LCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGNsYW1wZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBGYXRhbCBlcnJvcjogVW5hYmxlIHRvIHNldCB0aGUgY2xhbXBlZCB2YWx1ZSAnJHtjbGFtcGVkVmFsdWV9Jy5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlSGFzQmVlbkNsYW1wZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUhhc0JlZW5TZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjbGFtcGVkVmFsdWU7IC8vIFRoaXMgaXMgdXNlZCBvbmx5IGZvciBzZXR0aW5nIHRoZSBjYXJldCBwb3NpdGlvbiBsYXRlclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMub25JbnZhbGlkUGFzdGUuZXJyb3I6XG4gICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm9uSW52YWxpZFBhc3RlLnRydW5jYXRlOlxuICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5vbkludmFsaWRQYXN0ZS5yZXBsYWNlOlxuICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBhbiBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBwYXN0ZWQgdmFsdWUgJyR7cmF3UGFzdGVkVGV4dH0nIHJlc3VsdHMgaW4gYSB2YWx1ZSAnJHtyZXN1bHR9JyB0aGF0IGlzIG91dHNpZGUgb2YgdGhlIG1pbmltdW0gWyR7dGhpcy5zZXR0aW5ncy5taW5pbXVtVmFsdWV9XSBhbmQgbWF4aW11bSBbJHt0aGlzLnNldHRpbmdzLm1heGltdW1WYWx1ZX1dIHZhbHVlIHJhbmdlLmApO1xuICAgICAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMub25JbnZhbGlkUGFzdGUuaWdub3JlOlxuICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gLi4uYW5kIG5vdGhpbmcgZWxzZSBzaG91bGQgYmUgY2hhbmdlZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNy4gVGhlbiBsYXN0bHksIHNldCB0aGUgY2FyZXQgcG9zaXRpb24gYXQgdGhlIHJpZ2h0IGxvZ2ljYWwgcGxhY2VcbiAgICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUoZS50YXJnZXQpO1xuICAgICAgICBsZXQgY2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyO1xuICAgICAgICBpZiAodmFsdWVIYXNCZWVuU2V0KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3Mub25JbnZhbGlkUGFzdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMub25JbnZhbGlkUGFzdGUuY2xhbXA6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUhhc0JlZW5DbGFtcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5zdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5zZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCB0YXJnZXRWYWx1ZS5sZW5ndGggLSB0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCk7IC8vIFRoaXMgcHV0cyB0aGUgY2FyZXQgb24gdGhlIHJpZ2h0IG9mIHRoZSBsYXN0IGRlY2ltYWwgcGxhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgdGFyZ2V0VmFsdWUubGVuZ3RoKTsgLy8gLi5hbmQgdGhpcyBvbiB0aGUgZmFyIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IC8vIGVsc2UgaWYgdGhlIHZhbHVlIGhhcyBub3QgYmVlbiBjbGFtcGVkLCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyB1c2VkLi4uXG4gICAgICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5vbkludmFsaWRQYXN0ZS5lcnJvcjpcbiAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMub25JbnZhbGlkUGFzdGUuaWdub3JlOlxuICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5vbkludmFsaWRQYXN0ZS50cnVuY2F0ZTpcbiAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMub25JbnZhbGlkUGFzdGUucmVwbGFjZTpcbiAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbmV2ZXIgb25lIG9yIG11bHRpcGxlIGNoYXJhY3RlcnMgYXJlIHBhc3RlZCwgdGhpcyBtZWFucyB3ZSBoYXZlIHRvIG1hbmFnZSB0aGUgcG90ZW50aWFsIHRob3VzYW5kIHNlcGFyYXRvcnMgdGhhdCBjb3VsZCBiZSBhZGRlZCBieSB0aGUgZm9ybWF0dGluZ1xuICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIgPSBBdXRvTnVtZXJpY0hlbHBlci5maW5kQ2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyKHJlc3VsdCwgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcsIHRhcmdldFZhbHVlLCB0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5zZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCBjYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gOC4gV2UgbWFrZSBzdXJlIHdlIHNlbmQgYW4gaW5wdXQgZXZlbnQgb25seSBpZiB0aGUgcmVzdWx0IGlzIGRpZmZlcmVudCB0aGFuIHRoZSBpbml0aWFsIHZhbHVlIGJlZm9yZSB0aGUgcGFzdGVcbiAgICAgICAgaWYgKHZhbHVlSGFzQmVlblNldCAmJiBpbml0aWFsRm9ybWF0dGVkVmFsdWUgIT09IHRhcmdldFZhbHVlKSB7XG4gICAgICAgICAgICAvLyBPbiBhICdub3JtYWwnIG5vbi1hdXRvTnVtZXJpYyBpbnB1dCwgYW4gYGlucHV0YCBldmVudCBpcyBzZW50IHdoZW4gYSBwYXN0ZSBpcyBkb25lLiBXZSBtaW1pYyB0aGF0LlxuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudHJpZ2dlckV2ZW50KEF1dG9OdW1lcmljLmV2ZW50cy5uYXRpdmUuaW5wdXQsIGUudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gZm9jdXNpbmcgb3V0IG9mIHRoZSBpbnB1dCwgd2UgY2hlY2sgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLCBhbmQgaWYgaXQgaGFzLCB0aGVuIHdlIHNlbmQgYSBgY2hhbmdlYCBldmVudCAoc2luY2UgdGhlIG5hdGl2ZSBvbmUgd291bGQgaGF2ZSBiZWVuIHByZXZlbnRlZCBieSBgZS5wcmV2ZW50RGVmYXVsdCgpYCBjYWxsZWQgaW4gdGhlIG90aGVyIGV2ZW50IGxpc3RlbmVycykuXG4gICAgICogV2UgYWxzbyB1cGRhdGUgdGhlIGluZm8gb2YgdGhlIGZvY3VzZWQgc3RhdGUgaW4gdGhlIGB0aGlzLmlzRm9jdXNlZGAgdmFyaWFibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICovXG4gICAgX29uQmx1cihlKSB7XG4gICAgICAgIC8vIEtlZXAgdHJhY2sgaWYgdGhlIGVsZW1lbnQgaXMgY3VycmVudGx5IGZvY3VzZWRcbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gS2VlcCB0cmFjayBpZiB0aGUgdXNlciBpcyBjdXJyZW50bHkgZWRpdGluZyB0aGUgZWxlbWVudFxuICAgICAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUoZS50YXJnZXQpICE9PSB0aGlzLnZhbHVlT25Gb2N1cykge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudHJpZ2dlckV2ZW50KEF1dG9OdW1lcmljLmV2ZW50cy5uYXRpdmUuY2hhbmdlLCBlLnRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAnd2hlZWwnIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1doZWVsRXZlbnR9IGVcbiAgICAgKi9cbiAgICBfb25XaGVlbChlKSB7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGlzIHVzaW5nIHRoZSAnU2hpZnQnIGtleSBtb2RpZmllciwgdGhlbiB3ZSBpZ25vcmUgdGhlIHdoZWVsIGV2ZW50XG4gICAgICAgIC8vIFRoaXMgc3BlY2lhbCBiZWhhdmlvciBpcyBhcHBsaWVkIGluIG9yZGVyIHRvIGF2b2lkIHByZXZlbnRpbmcgdGhlIHVzZXIgdG8gc2Nyb2xsIHRoZSBwYWdlIGlmIHRoZSBpbnB1dHMgYXJlIGNvdmVyaW5nIHRoZSB3aG9sZSBhdmFpbGFibGUgc3BhY2UuXG4gICAgICAgIC8vIElmIHRoYXQncyB0aGUgY2FzZSwgdGhlbiBoZSBjYW4gdXNlIHRoZSAnU2hpZnQnIG1vZGlmaWVyIGtleSB3aGlsZSB1c2luZyB0aGUgbW91c2Ugd2hlZWwgaW4gb3JkZXIgdG8gYnlwYXNzIHRoZSBpbmNyZW1lbnQvZGVjcmVtZW50IGZlYXR1cmVcbiAgICAgICAgLy8gVGhpcyBpcyB1c2VmdWwgb24gc21hbGwgc2NyZWVuIHdoZXJlIHNvbWUgYmFkbHkgY29uZmlndXJlZCBpbnB1dHMgY291bGQgdXNlIGFsbCB0aGUgYXZhaWxhYmxlIHNwYWNlLlxuICAgICAgICBpZiAoIWUuc2hpZnRLZXkgJiYgdGhpcy5zZXR0aW5ncy5tb2RpZnlWYWx1ZU9uV2hlZWwpIHtcbiAgICAgICAgICAgIHRoaXMuaXNXaGVlbEV2ZW50ID0gdHJ1ZTsgLy8gS2VlcCB0aGUgaW5mbyB0aGF0IHdlIGFyZSBjdXJyZW50bHkgbWFuYWdpbmcgYSBtb3VzZSB3aGVlbCBldmVudFxuXG4gICAgICAgICAgICAvLyAwKSBGaXJzdCwgc2F2ZSB0aGUgY2FyZXQgcG9zaXRpb24gc28gd2UgY2FuIHNldCBpdCBiYWNrIG9uY2UgdGhlIHZhbHVlIGhhcyBiZWVuIGNoYW5nZWRcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0ID0gZS50YXJnZXQuc2VsZWN0aW9uU3RhcnQgfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbkVuZCA9IGUudGFyZ2V0LnNlbGVjdGlvbkVuZCB8fCAwO1xuXG4gICAgICAgICAgICAvLyAxKSBHZXQgdGhlIHVuZm9ybWF0dGVkIHZhbHVlXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VW5mb3JtYXR0ZWRWYWx1ZSA9IHRoaXMucmF3VmFsdWU7XG5cbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWRPck51bGxPckVtcHR5KGN1cnJlbnRVbmZvcm1hdHRlZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGJ5IGRlZmF1bHQgdGhlIGlucHV0IGlzIGVtcHR5LCBzdGFydCBhdCAnMCdcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5taW5pbXVtVmFsdWUgPiAwIHx8IHRoaXMuc2V0dGluZ3MubWF4aW11bVZhbHVlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvciBpZiAnMCcgaXMgbm90IGJldHdlZW4gbWluIGFuZCBtYXggdmFsdWUsICdtaW5pbXVtVmFsdWUnIGlmIHRoZSB1c2VyIGRvZXMgYSB3aGVlbHVwLCAnbWF4aW11bVZhbHVlJyBpZiB0aGUgdXNlciBkb2VzIGEgd2hlZWxkb3duXG4gICAgICAgICAgICAgICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc1doZWVsVXBFdmVudChlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5zZXR0aW5ncy5taW5pbXVtVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNXaGVlbERvd25FdmVudChlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5zZXR0aW5ncy5tYXhpbXVtVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgZXZlbnQgaXMgbm90IGEgJ3doZWVsJyBldmVudC5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjdXJyZW50VW5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gK3Jlc3VsdDsgLy8gVHlwZWNhc3QgdG8gYSBudW1iZXIgbmVlZGVkIGZvciB0aGUgZm9sbG93aW5nIGFkZGl0aW9uL3N1YnRyYWN0aW9uXG5cbiAgICAgICAgICAgIC8vIDIpIEluY3JlbWVudC9EZWNyZW1lbnQgdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBCdXQgZmlyc3QsIGNob29zZSB0aGUgaW5jcmVtZW50L2RlY3JlbWVudCBtZXRob2QgOyBmaXhlZCBvciBwcm9ncmVzc2l2ZVxuICAgICAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVtYmVyKHRoaXMuc2V0dGluZ3Mud2hlZWxTdGVwKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSArdGhpcy5zZXR0aW5ncy53aGVlbFN0ZXA7IC8vIFR5cGVjYXN0IHRvIGEgbnVtYmVyIG5lZWRlZCBmb3IgdGhlIGZvbGxvd2luZyBhZGRpdGlvbi9zdWJ0cmFjdGlvblxuICAgICAgICAgICAgICAgIC8vIEZpeGVkIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHNpbXBsZXN0IG1ldGhvZCwgd2hlcmUgYSBmaXhlZCBvZmZzZXQgaW4gYWRkZWQvc3VidHJhY3RlZCBmcm9tIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzV2hlZWxVcEV2ZW50KGUpKSB7IC8vIEluY3JlbWVudFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RlcDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzV2hlZWxEb3duRXZlbnQoZSkpIHsgLy8gRGVjcmVtZW50XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCAtPSBzdGVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUHJvZ3Jlc3NpdmUgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gRm9yIHRoaXMgbWV0aG9kLCB3ZSBjYWxjdWxhdGUgYW4gb2Zmc2V0IHRoYXQgaXMgaW4gcmVsYXRpb24gdG8gdGhlIHNpemUgb2YgdGhlIGN1cnJlbnQgbnVtYmVyICh1c2luZyBvbmx5IHRoZSBpbnRlZ2VyIHBhcnQgc2l6ZSkuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGJpZ2dlciB0aGUgbnVtYmVyLCB0aGUgYmlnZ2VyIHRoZSBvZmZzZXQgKHVzdWFsbHkgdGhlIG51bWJlciBjb3VudCBpbiB0aGUgaW50ZWdlciBwYXJ0IG1pbnVzIDMsIGV4Y2VwdCBmb3Igc21hbGwgbnVtYmVycyB3aGVyZSBhIGRpZmZlcmVudCBiZWhhdmlvciBpcyBiZXR0ZXIgZm9yIHRoZSB1c2VyIGV4cGVyaWVuY2UpLlxuICAgICAgICAgICAgICAgIC8vVE9ETyBLbm93biBsaW1pdGF0aW9uIDogVGhlIHByb2dyZXNzaXZlIG1ldGhvZCBkb2VzIG5vdCBwbGF5IHdlbGwgd2l0aCBudW1iZXJzIGJldHdlZW4gMCBhbmQgMSB3aGVyZSB0byBtb2RpZnkgdGhlIGRlY2ltYWwgcGxhY2VzIHRoZSByYXdWYWx1ZSBmaXJzdCBoYXMgdG8gZ28gZnJvbSAnMScgdG8gJzAnXG4gICAgICAgICAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzV2hlZWxVcEV2ZW50KGUpKSB7IC8vIEluY3JlbWVudFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBBdXRvTnVtZXJpY0hlbHBlci5hZGRBbmRSb3VuZFRvTmVhcmVzdEF1dG8ocmVzdWx0LCB0aGlzLnNldHRpbmdzLmRlY2ltYWxQbGFjZXNSYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc1doZWVsRG93bkV2ZW50KGUpKSB7IC8vIERlY3JlbWVudFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBBdXRvTnVtZXJpY0hlbHBlci5zdWJ0cmFjdEFuZFJvdW5kVG9OZWFyZXN0QXV0byhyZXN1bHQsIHRoaXMuc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDMpIFNldCB0aGUgbmV3IHZhbHVlIHNvIGl0IGdldHMgZm9ybWF0dGVkXG4gICAgICAgICAgICAvLyBGaXJzdCBjbGFtcCB0aGUgcmVzdWx0IGlmIG5lZWRlZFxuICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNIZWxwZXIuY2xhbXBUb1JhbmdlTGltaXRzKHJlc3VsdCwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSArY3VycmVudFVuZm9ybWF0dGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5ICdzZXQnIHRoZSB2YWx1ZSBpZiBpdCBoYXMgY2hhbmdlZC4gRm9yIGluc3RhbmNlICdzZXQnIHNob3VsZCBub3QgaGFwcGVuIGlmIHRoZSB1c2VyIGhpdHMgYSBsaW1pdCBhbmQgY29udGludWUgdG8gdHJ5IHRvIGdvIHBhc3QgaXQgc2luY2Ugd2UgY2xhbXAgdGhlIHZhbHVlLlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vWFhYIERvIG5vdCBwcmV2ZW50IGlmIHRoZSB2YWx1ZSBpcyBub3QgbW9kaWZpZWQ/IEZyb20gYSBVWCBwb2ludCBvZiB2aWV3LCBwcmV2ZW50aW5nIHRoZSB3aGVlbCBldmVudCB3aGVuIHRoZSB1c2VyIHVzZSBpdCBvbiB0b3Agb2YgYW4gYXV0b051bWVyaWMgZWxlbWVudCBzaG91bGQgYWx3YXlzIGJlIGRvbmUsIGV2ZW4gaWYgdGhlIHZhbHVlIGRvZXMgbm90IGNoYW5nZS4gUGVyaGFwcyB0aGF0IGNvdWxkIGFmZmVjdCBvdGhlciBzY3JpcHRzIHJlbHlpbmcgb24gdGhpcyBldmVudCB0byBiZSBzZW50IHRob3VnaC5cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gV2UgcHJldmVudCB0aGUgcGFnZSB0byBzY3JvbGwgd2hpbGUgd2UgaW5jcmVtZW50L2RlY3JlbWVudCB0aGUgdmFsdWVcblxuICAgICAgICAgICAgLy8gNCkgRmluYWxseSwgd2Ugc2V0IGJhY2sgdGhlIGNhcmV0IHBvc2l0aW9uL3NlbGVjdGlvblxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byB0YWtlIGludG8gYWNjb3VudCB0aGUgZmFjdCB0aGF0IHRoZSBudW1iZXIgY291bnQgY291bGQgYmUgZGlmZmVyZW50IGF0IHRoZSBlbmQgb2YgdGhlIHdoZWVsIGV2ZW50IDsgaXQgd291bGQgYmUgdG9vIGNvbXBsZXggYW5kIG1vc3Qgb2YgdGhlIHRpbWUgdW5yZWxpYWJsZVxuICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpO1xuXG4gICAgICAgICAgICB0aGlzLmlzV2hlZWxFdmVudCA9IGZhbHNlOyAvLyBTZXQgYmFjayB0aGUgbW91c2Ugd2hlZWwgaW5kaWNhdG9yIHRvIGl0cyBkZWZhdWx0XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAnZHJvcCcgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RHJhZ0V2ZW50fSBlXG4gICAgICovXG4gICAgX29uRHJvcChlKSB7XG4gICAgICAgIHRoaXMuaXNEcm9wRXZlbnQgPSB0cnVlO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IGRyb3BwZWRUZXh0ID0gZS5kYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuICAgICAgICBjb25zdCBjbGVhbmVkVmFsdWUgPSB0aGlzLnVuZm9ybWF0T3RoZXIoZHJvcHBlZFRleHQpO1xuICAgICAgICB0aGlzLnNldChjbGVhbmVkVmFsdWUpO1xuICAgICAgICB0aGlzLmlzRHJvcEV2ZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgJ3N1Ym1pdCcgZXZlbnRzIGhhcHBlbmluZyBvbiB0aGUgcGFyZW50IDxmb3JtPiBlbGVtZW50LlxuICAgICAqIElmIGB1bmZvcm1hdE9uU3VibWl0YCBpcyBzZXQgdG8gYHRydWVgLCB0aGUgZWxlbWVudCB2YWx1ZSBpcyBmaXJzdCB1bmZvcm1hdHRlZCBiZWZvcmUgdGhlIGZvcm0gaXMgc3VibWl0dGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgX29uRm9ybVN1Ym1pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudW5mb3JtYXRPblN1Ym1pdCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKHRoaXMucmF3VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdGVuIGZvciB0aGUgYGFsdGAga2V5IGtleWRvd24gZXZlbnQgZ2xvYmFsbHksIGFuZCBpZiB0aGUgZXZlbnQgaXMgY2F1Z2h0LCB1bmZvcm1hdCB0aGUgQXV0b051bWVyaWMgZWxlbWVudCB0aGF0IGlzIGhvdmVyZWQgYnkgdGhlIG1vdXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25LZXlkb3duR2xvYmFsKGUpIHtcbiAgICAgICAgLy9UT0RPIEZpbmQgYSB3YXkgdG8ga2VlcCB0aGUgY2FyZXQgcG9zaXRpb24gYmV0d2VlbiB0aGUgYWx0IGtleXVwL2tleWRvd24gc3RhdGVzXG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5jaGFyYWN0ZXIoZSkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkFsdCkge1xuICAgICAgICAgICAgY29uc3QgaG92ZXJlZEVsZW1lbnQgPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRIb3ZlcmVkRWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKEF1dG9OdW1lcmljLmlzTWFuYWdlZEJ5QXV0b051bWVyaWMoaG92ZXJlZEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5FbGVtZW50ID0gQXV0b051bWVyaWMuZ2V0QXV0b051bWVyaWNFbGVtZW50KGhvdmVyZWRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLl91bmZvcm1hdEFsdEhvdmVyZWQoYW5FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3RlbiBmb3IgdGhlIGBhbHRgIGtleSBrZXl1cCBldmVudCBnbG9iYWxseSwgYW5kIGlmIHRoZSBldmVudCBpcyBjYXVnaHQsIHJlZm9ybWF0IHRoZSBBdXRvTnVtZXJpYyBlbGVtZW50IHRoYXQgaXMgaG92ZXJlZCBieSB0aGUgbW91c2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbktleXVwR2xvYmFsKGUpIHtcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmNoYXJhY3RlcihlKSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuQWx0KSB7XG4gICAgICAgICAgICBjb25zdCBob3ZlcmVkRWxlbWVudCA9IEF1dG9OdW1lcmljSGVscGVyLmdldEhvdmVyZWRFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAoQXV0b051bWVyaWMuaXNNYW5hZ2VkQnlBdXRvTnVtZXJpYyhob3ZlcmVkRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbkVsZW1lbnQgPSBBdXRvTnVtZXJpYy5nZXRBdXRvTnVtZXJpY0VsZW1lbnQoaG92ZXJlZEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuX3JlZm9ybWF0QWx0SG92ZXJlZChhbkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgRE9NIGVsZW1lbnQgaXMgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljLlxuICAgICAqIEEgc3VwcG9ydGVkIGVsZW1lbnQgaXMgYW4gZWxlbWVudCB3aGl0ZWxpc3RlZCBpbiB0aGUgYGFsbG93ZWRUYWdMaXN0YC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzRWxlbWVudFRhZ1N1cHBvcnRlZCgpIHtcbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc0VsZW1lbnQodGhpcy5kb21FbGVtZW50KSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIERPTSBlbGVtZW50IGlzIG5vdCB2YWxpZCwgJHt0aGlzLmRvbUVsZW1lbnR9IGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEF1dG9OdW1lcmljSGVscGVyLmlzSW5BcnJheSh0aGlzLmRvbUVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpLCB0aGlzLmFsbG93ZWRUYWdMaXN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGluIHRoZSBET00gZWxlbWVudCBpcyBhbiA8aW5wdXQ+LlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNJbnB1dEVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvbUVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGlucHV0IHR5cGUgaXMgc3VwcG9ydGVkIGJ5IEF1dG9OdW1lcmljXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAdGhyb3dzXG4gICAgICovXG4gICAgX2lzSW5wdXRUeXBlU3VwcG9ydGVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZG9tRWxlbWVudC50eXBlID09PSAndGV4dCcgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnQudHlwZSA9PT0gJ2hpZGRlbicgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnQudHlwZSA9PT0gJ3RlbCcgfHxcbiAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkodGhpcy5kb21FbGVtZW50LnR5cGUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgRE9NIGVsZW1lbnQgaXMgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljLlxuICAgICAqIEEgc3VwcG9ydGVkIGVsZW1lbnQgaXMgZWl0aGVyIGFuIDxpbnB1dD4gZWxlbWVudCB3aXRoIHRoZSByaWdodCAndHlwZScgYXR0cmlidXRlLCBvciBhIHRhZyB3aGl0ZWxpc3RlZCBpbiB0aGUgYGFsbG93ZWRUYWdMaXN0YC5cbiAgICAgKiBJZiB0aGUgY2hlY2sgZmFpbHMsIHRoaXMgbWV0aG9kIHRocm93cy5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFsc28gc2V0IHRoZSBpbmZvIGB0aGlzLmlzSW5wdXRFbGVtZW50YCB3aGljaCBrZWVwIHRyYWNrcyBpZiB0aGUgRE9NIGVsZW1lbnQgaXMgYW4gPGlucHV0PiBvciBub3QsIGFuZCB0aGUgYHRoaXMuaXNDb250ZW50RWRpdGFibGVgIGlmIHRoZSBlbGVtZW50IGhhcyB0aGUgYGNvbnRlbnRlZGl0YWJsZWAgYXR0cmlidXRlIHNldCB0byBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hlY2tFbGVtZW50KCkge1xuICAgICAgICBjb25zdCBjdXJyZW50RWxlbWVudFRhZyA9IHRoaXMuZG9tRWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pc0VsZW1lbnRUYWdTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudGhyb3dFcnJvcihgVGhlIDwke2N1cnJlbnRFbGVtZW50VGFnfT4gdGFnIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pc0lucHV0RWxlbWVudCgpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzSW5wdXRUeXBlU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgaW5wdXQgdHlwZSBcIiR7dGhpcy5kb21FbGVtZW50LnR5cGV9XCIgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmlzSW5wdXRFbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNJbnB1dEVsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaXNDb250ZW50RWRpdGFibGUgPSB0aGlzLmRvbUVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSAmJiB0aGlzLmRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSA9PT0gJ3RydWUnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0cyB0aGUgZGVmYXVsdCB2YWx1ZSBvbiBwYWdlIGxvYWQuXG4gICAgICogVGhpcyBpcyBjYWxsZWQgb25seSBpZiB0aGUgYGZvcm1hdE9uUGFnZUxvYWRgIG9wdGlvbiBpcyBzZXQgdG8gYHRydWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfG51bGx9IGZvcmNlZEluaXRpYWxWYWx1ZSBUaGUgdmFsdWUgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgaW5pdGlhbGl6YXRpb24sIGluIHBsYWNlIG9uIHRoZSBldmVudHVhbCBodG1sIG9uZVxuICAgICAqL1xuICAgIF9mb3JtYXREZWZhdWx0VmFsdWVPblBhZ2VMb2FkKGZvcmNlZEluaXRpYWxWYWx1ZSA9IG51bGwpIHtcbiAgICAgICAgbGV0IHNldFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgbGV0IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwoZm9yY2VkSW5pdGlhbFZhbHVlKSkge1xuICAgICAgICAgICAgY3VycmVudFZhbHVlID0gZm9yY2VkSW5pdGlhbFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudFZhbHVlID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0lucHV0RWxlbWVudCB8fCB0aGlzLmlzQ29udGVudEVkaXRhYmxlKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogSWYgdGhlIGlucHV0IHZhbHVlIGhhcyBiZWVuIHNldCBieSB0aGUgZGV2LCBidXQgbm90IGRpcmVjdGx5IGFzIGFuIGF0dHJpYnV0ZSBpbiB0aGUgaHRtbCwgdGhlbiBpdCB0YWtlc1xuICAgICAgICAgICAgICogcHJlY2VkZW5jZSBhbmQgc2hvdWxkIGdldCBmb3JtYXR0ZWQgZHVyaW5nIHRoZSBpbml0aWFsaXphdGlvbiAoaWYgdGhpcyBpbnB1dCB2YWx1ZSBpcyBhIHZhbGlkIG51bWJlciBhbmQgdGhhdCB0aGVcbiAgICAgICAgICAgICAqIGRldmVsb3BlciB3YW50cyBpdCBmb3JtYXR0ZWQgb24gaW5pdCAoY2YuIHRoZSBgc2V0dGluZ3MuZm9ybWF0T25QYWdlTG9hZGAgb3B0aW9uKSkuXG4gICAgICAgICAgICAgKiBOb3RlOyB0aGlzIGlzIHRydWUgd2hhdGV2ZXIgdGhlIGRldmVsb3BlciBoYXMgc2V0IGZvciBgZGF0YS1kZWZhdWx0LXZhbHVlLW92ZXJyaWRlYCBpbiB0aGUgaHRtbCAoYXNwLm5ldCB1c2VycykuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSW4gb3RoZXIgd29yZHMgOiBpZiBgZGVmYXVsdFZhbHVlT3ZlcnJpZGVgIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgZGV2ZWxvcGVyIGlzIHRyeWluZyB0byBwcmV2ZW50IHBvc3RiYWNrIHByb2JsZW1zLlxuICAgICAgICAgICAgICogQnV0IGlmIGBpbnB1dC52YWx1ZWAgaXMgc2V0IHRvIGEgbnVtYmVyLCBhbmQgdGhlIGh0bWwgYHZhbHVlYCBhdHRyaWJ1dGUgaXMgbm90IHNldCwgdGhlbiBpdCBtZWFucyB0aGUgZGV2IGhhc1xuICAgICAgICAgICAgICogY2hhbmdlZCB0aGUgaW5wdXQgdmFsdWUsIGFuZCB0aGVuIGl0IG1lYW5zIHdlIHNob3VsZCBub3Qgb3ZlcndyaXRlIGhpcyBvd24gZGVjaXNpb24gdG8gZG8gc28uXG4gICAgICAgICAgICAgKiBIZW5jZSwgaWYgYGRlZmF1bHRWYWx1ZU92ZXJyaWRlYCBpcyBub3QgbnVsbCwgYnV0IGBpbnB1dC52YWx1ZWAgaXMgYSBudW1iZXIgYW5kIGB0aGlzLmRvbUVsZW1lbnQuaGFzQXR0cmlidXRlKCd2YWx1ZScpYFxuICAgICAgICAgICAgICogaXMgZmFsc2UsIHdlIHNob3VsZCBpZ25vcmUgYGRlZmF1bHRWYWx1ZU92ZXJyaWRlYCBhbHRvZ2V0aGVyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCB1bkxvY2FsaXplZEN1cnJlbnRWYWx1ZSA9IHRoaXMuY29uc3RydWN0b3IuX3RvTnVtZXJpY1ZhbHVlKGN1cnJlbnRWYWx1ZSwgdGhpcy5zZXR0aW5ncyk7IC8vIFRoaXMgYWxsb3dzIHRvIHVzZSBhIGxvY2FsaXplZCB2YWx1ZSBvbiBzdGFydHVwXG4gICAgICAgICAgICBpZiAoIXRoaXMuZG9tRWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgdGhpcy5kb21FbGVtZW50LmdldEF0dHJpYnV0ZSgndmFsdWUnKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgYHZhbHVlYCBpcyB2YWxpZCBvciBub3RcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKE51bWJlcih1bkxvY2FsaXplZEN1cnJlbnRWYWx1ZSkpICYmIEluZmluaXR5ICE9PSB1bkxvY2FsaXplZEN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldCh1bkxvY2FsaXplZEN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm90LCBpbmZvcm0gdGhlIGRldmVsb3BlciB0aGF0IG5vdGhpbmcgdXNhYmxlIGhhcyBiZWVuIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHtjdXJyZW50VmFsdWV9XSB1c2VkIGluIHRoZSBpbnB1dCBpcyBub3QgYSB2YWxpZCB2YWx1ZSBhdXRvTnVtZXJpYyBjYW4gd29yayB3aXRoLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogQ2hlY2tzIGZvciA6XG4gICAgICAgICAgICAgICAgICogLSBwYWdlIHJlbG9hZCBmcm9tIGJhY2sgYnV0dG9uLCBhbmRcbiAgICAgICAgICAgICAgICAgKiAtIEFTUC5uZXQgZm9ybSBwb3N0IGJhY2tcbiAgICAgICAgICAgICAgICAgKiAgICAgIFRoZSBmb2xsb3dpbmcgSFRNTCBkYXRhIGF0dHJpYnV0ZSBpcyBSRVFVSVJFRCAoZGF0YS1hbi1kZWZhdWx0PVwic2FtZSB2YWx1ZSBhcyB0aGUgdmFsdWUgYXR0cmlidXRlXCIpXG4gICAgICAgICAgICAgICAgICogICAgICBleGFtcGxlOiA8YXNwOlRleHRCb3ggcnVuYXQ9XCJzZXJ2ZXJcIiBpZD1cInNvbWVJRFwiIHRleHQ9XCIxMjM0LjU2XCIgZGF0YS1hbi1kZWZhdWx0PVwiMTIzNC41NlwiPlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICgodGhpcy5zZXR0aW5ncy5kZWZhdWx0VmFsdWVPdmVycmlkZSAhPT0gbnVsbCAmJiB0aGlzLnNldHRpbmdzLmRlZmF1bHRWYWx1ZU92ZXJyaWRlLnRvU3RyaW5nKCkgIT09IGN1cnJlbnRWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc2V0dGluZ3MuZGVmYXVsdFZhbHVlT3ZlcnJpZGUgPT09IG51bGwgJiYgY3VycmVudFZhbHVlICE9PSAnJyAmJiBjdXJyZW50VmFsdWUgIT09IHRoaXMuZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykpIHx8XG4gICAgICAgICAgICAgICAgICAgIChjdXJyZW50VmFsdWUgIT09ICcnICYmIHRoaXMuZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PT0gJ2hpZGRlbicgJiYgIUF1dG9OdW1lcmljSGVscGVyLmlzTnVtYmVyKHVuTG9jYWxpemVkQ3VycmVudFZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSAmJiAodGhpcy5zZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICE9PSBudWxsIHx8IHRoaXMuc2V0dGluZ3MuZGl2aXNvcldoZW5VbmZvY3VzZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRSYXdWYWx1ZSh0aGlzLl9nZXRWYWx1ZUZyb21QZXJzaXN0ZW50U3RvcmFnZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIHZhbHVlIHNob3VsZCBOT1QgYmUgc2F2ZWQgaW4gc2Vzc2lvblN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b1N0cmlwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAhPT0gbnVsbCAmJiB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmlwID0gdGhpcy5jb25zdHJ1Y3Rvci5fcmVtb3ZlQnJhY2tldHMoY3VycmVudFZhbHVlLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJpcCA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnN1ZmZpeCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnByZWZpeCAmJiB0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnN1ZmZpeCkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuaXNOZWdhdGl2ZShjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmF3VmFsdWUodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgKyB0aGlzLmNvbnN0cnVjdG9yLl9zdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnModG9TdHJpcCwgdGhpcy5zZXR0aW5ncywgdHJ1ZSwgdGhpcy5pc0ZvY3VzZWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmF3VmFsdWUodGhpcy5jb25zdHJ1Y3Rvci5fc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHRvU3RyaXAsIHRoaXMuc2V0dGluZ3MsIHRydWUsIHRoaXMuaXNGb2N1c2VkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3MuZW1wdHlJbnB1dEJlaGF2aW9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3IuZm9jdXM6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBXaGF0IGFib3V0IHRoZSBgQXV0b051bWVyaWMub3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3IucHJlc3NgIHZhbHVlP1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMuZW1wdHlJbnB1dEJlaGF2aW9yLmFsd2F5czpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZSh0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvci56ZXJvOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXRWYWx1ZSAmJiBjdXJyZW50VmFsdWUgPT09IHRoaXMuZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZGVmYXVsdFZhbHVlT3ZlcnJpZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5kZWZhdWx0VmFsdWVPdmVycmlkZSA9PT0gY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5oYW5jZSB0aGUgdXNlciBleHBlcmllbmNlIGJ5IG1vZGlmeWluZyB0aGUgZGVmYXVsdCBgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRgIG9wdGlvbiBkZXBlbmRpbmcgb24gYGN1cnJlbmN5U3ltYm9sYCBhbmQgYGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50YC5cbiAgICAgKlxuICAgICAqIElmIHRoZSB1c2VyIGhhcyBub3Qgc2V0IHRoZSBwbGFjZW1lbnQgb2YgdGhlIG5lZ2F0aXZlIHNpZ24gKGBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudGApLCBidXQgaGFzIHNldCBhIGN1cnJlbmN5IHN5bWJvbCAoYGN1cnJlbmN5U3ltYm9sYCksXG4gICAgICogdGhlbiB3ZSBtb2RpZnkgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50YCBpbiBvcmRlciB0byBrZWVwIHRoZSByZXN1bHRpbmcgb3V0cHV0IGxvZ2ljYWwgYnkgZGVmYXVsdCA6XG4gICAgICogLSBcIiQtMSwyMzQuNTZcIiBpbnN0ZWFkIG9mIFwiLSQxLDIzNC41NlwiICh7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJyXCJ9KVxuICAgICAqIC0gXCItMSwyMzQuNTYkXCIgaW5zdGVhZCBvZiBcIjEsMjM0LjU2LSRcIiAoe2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6IFwic1wiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJwXCJ9KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICovXG4gICAgc3RhdGljIF9jb3JyZWN0TmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRPcHRpb24oc2V0dGluZ3MpIHtcbiAgICAgICAgLy9YWFggTm90ZTsgdGhpcyBmdW5jdGlvbiBpcyBzdGF0aWMgc2luY2Ugd2UgbmVlZCB0byBwYXNzIGEgYHNldHRpbmdzYCBvYmplY3Qgd2hlbiBjYWxsaW5nIHRoZSBzdGF0aWMgYEF1dG9OdW1lcmljLmZvcm1hdCgpYCBtZXRob2RcbiAgICAgICAgLy8gSWYgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgaXMgYWxyZWFkeSBzZXQsIHdlIGRvIG5vdCBvdmVyd3JpdGUgaXRcbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bGwoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkKHNldHRpbmdzKSAmJlxuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSAmJlxuICAgICAgICAgICAgIUF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eShzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQuc3VmZml4OlxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucHJlZml4OyAvLyBEZWZhdWx0IC0xLDIzNC41NiDigqxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnByZWZpeDpcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LmxlZnQ7IC8vIERlZmF1bHQgLSQxLDIzNC41NlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2V0cyB0aGUgZGVmYXVsdCB2YWx1ZSBpZiBgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRgIGlzIGBudWxsYFxuICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LmxlZnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3JyZWN0IHRoZSBgY2FyZXRQb3NpdGlvbk9uRm9jdXNgIGFuZCBgc2VsZWN0T25Gb2N1c2Agb3B0aW9ucywgc2luY2Ugc2V0dGluZyBib3RoIGxlYWRzIHRvIGEgY29uZmxpY3QuXG4gICAgICogVGhpcyBtZXRob2QgZGlyZWN0bHkgbW9kaWZpZXMgdGhlIGBvcHRpb25zYCBvYmplY3QgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLCB0aGVuIHJldHVybnMgaXQuXG4gICAgICogSXQgcmV0dXJucyBgbnVsbGAgaWYgdGhlIGdpdmVuIG9wdGlvbiBpcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBwYXNzZWQgYXMgYW4gYXJndW1lbnQgYnkgdGhlIHVzZXJcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX2NvcnJlY3RDYXJldFBvc2l0aW9uT25Gb2N1c0FuZFNlbGVjdE9uRm9jdXNPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgdXNlciBoYXMgc2V0IHRoZSBgY2FyZXRQb3NpdGlvbk9uRm9jdXNgIG9wdGlvbiwgZG8gbm90IHNldCBgc2VsZWN0T25Gb2N1c2AgdG8gYHRydWVgIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkob3B0aW9ucy5jYXJldFBvc2l0aW9uT25Gb2N1cykgJiYgQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWRPck51bGxPckVtcHR5KG9wdGlvbnMuc2VsZWN0T25Gb2N1cykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2VsZWN0T25Gb2N1cyA9IEF1dG9OdW1lcmljLm9wdGlvbnMuc2VsZWN0T25Gb2N1cy5kb05vdFNlbGVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGhhcyBzZXQgdGhlIGBzZWxlY3RPbkZvY3VzYCBvcHRpb24gdG8gYHRydWVgLCBzZXQgYGNhcmV0UG9zaXRpb25PbkZvY3VzYCB0byBgZG9Ob0ZvcmNlQ2FyZXRQb3NpdGlvbmBcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eShvcHRpb25zLmNhcmV0UG9zaXRpb25PbkZvY3VzKSAmJiAhQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWRPck51bGxPckVtcHR5KG9wdGlvbnMuc2VsZWN0T25Gb2N1cykgJiYgb3B0aW9ucy5zZWxlY3RPbkZvY3VzID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLnNlbGVjdE9uRm9jdXMuc2VsZWN0KSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhcmV0UG9zaXRpb25PbkZvY3VzID0gQXV0b051bWVyaWMub3B0aW9ucy5jYXJldFBvc2l0aW9uT25Gb2N1cy5kb05vRm9yY2VDYXJldFBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBudW1iZXIgZGUgZGVjaW1hbCBwbGFjZXMgdG8gYmUgdXNlZCBieSB0aGUgQXV0b051bWVyaWMgb2JqZWN0LCBmb3IgZWFjaCBvZiBpdHMgc3RhdGUsIGFuZCBmb3IgaXRzIGZvcm1hdHRlZCBhbmQgcmF3IHZhbHVlLlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBgcmF3VmFsdWVgIHByZWNpc2lvbiBpcyB0aGUgc2FtZSBhcyB0aGUgZm9ybWF0dGVkIHZhbHVlIG9uZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBkdXJpbmcgdGhlIEF1dG9OdW1lcmljIG9iamVjdCBpbml0aWFsaXphdGlvbi4gVGhpcyBhc3N1bWVzIHNvbWUgaW50ZXJuYWwgdmFyaWFibGUgc3RhdGUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZHMgc2V0IHRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhY2NvcmRpbmdseSB0byB0aGVpciBvd24gdmFsdWUgYW5kIHRoZSBtYW5kYXRvcnkgYGRlY2ltYWxQbGFjZXNgIG9wdGlvbjpcbiAgICAgKiAtIGRlY2ltYWxQbGFjZXNSYXdWYWx1ZSAgICAgKG51bGxhYmxlKVxuICAgICAqIC0gZGVjaW1hbFBsYWNlc1Nob3duT25CbHVyICAobnVsbGFibGUpXG4gICAgICogLSBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIChudWxsYWJsZSlcbiAgICAgKlxuICAgICAqIE5vdGU6IHRoZSBgZGVjaW1hbFBsYWNlc2Agb3B0aW9uIGlzIG9ubHkgdXNlZCBoZXJlIGFuZCBvbmx5IHNlcnZlIHRvIGRlZmluZSB0aG9zZSB0aHJlZSBwcmV2aW91cyBvcHRpb25zIHZhbHVlLlxuICAgICAqIEF1dG9OdW1lcmljIHdpbGwgdGhlbiAqb25seSogdXNlIGBkZWNpbWFsUGxhY2VzUmF3VmFsdWVgLCBgZGVjaW1hbFBsYWNlc1Nob3duT25CbHVyYCBhbmQgYGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXNgIGZyb20gdGhlcmUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZHMgZGlyZWN0bHkgbW9kaWZpZXMgdGhlIGBzZXR0aW5nc2Agb2JqZWN0IHBhc3NlZCBhcyBhIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBUaGlzIGlzIGFuIG9iamVjdCB3aXRoIHRoZSBuZXcgc2V0dGluZ3MgdG8gdXNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9jYWxjdWxhdGVEZWNpbWFsUGxhY2VzT25Jbml0KHNldHRpbmdzKSB7XG4gICAgICAgIC8vIENoZWNrIHRoZSBgZGVjaW1hbFBsYWNlcypgIG9wdGlvbnMgYW5kIG91dHB1dCBhbnkgd2FybmluZ3MgYXMgbmVlZGVkLCBiZWZvcmUgbW9kaWZ5aW5nIHRob3NlIG9wdGlvbnNcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVEZWNpbWFsUGxhY2VzUmF3VmFsdWUoc2V0dGluZ3MpO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemF0aW9uIHBoYXNlXG4gICAgICAgIC8vWFhYIFRoaXMgYXNzdW1lcyBhdCB0aGlzIHN0YWdlLCBgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc2AgYXMgYmVlbiBzZXQgZnJvbSB0aGUgZGVmYXVsdCBvcHRpb25zXG5cbiAgICAgICAgLy8gT3ZlcndyaXRlIHRoZSBgZGVjaW1hbFBsYWNlcypgIHZhbHVlcyBpZiB0aGUgYGRlY2ltYWxQbGFjZXMqYCBvcHRpb25zIGFyZSBub3Qgc2V0IGluIHRoZSBgc2V0dGluZ3NgXG4gICAgICAgIC8vIFNldHMgYGRlY2ltYWxQbGFjZXNTaG93bk9uQmx1cmAgKHByZXZpb3VzbHkga25vd24gYXMgYHNjYWxlRGVjaW1hbFBsYWNlc2ApXG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMudXNlRGVmYXVsdCkgIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uQmx1ciA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkJsdXIudXNlRGVmYXVsdCkgIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uQmx1ciA9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmRlY2ltYWxQbGFjZXNSYXdWYWx1ZS51c2VEZWZhdWx0KSAge1xuICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0aGUgYWRkaXRpb25hbCBkZWNpbWFsIHBsYWNlcyB0byB0aGUgcmF3IHZhbHVlXG4gICAgICAgIGxldCBhZGRpdGlvbmFsRGVjaW1hbFBsYWNlc1Jhd1ZhbHVlID0gMDtcbiAgICAgICAgaWYgKHNldHRpbmdzLnJhd1ZhbHVlRGl2aXNvciAmJiBzZXR0aW5ncy5yYXdWYWx1ZURpdmlzb3IgIT09IEF1dG9OdW1lcmljLm9wdGlvbnMucmF3VmFsdWVEaXZpc29yLm5vbmUpIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxEZWNpbWFsUGxhY2VzUmF3VmFsdWUgPSBTdHJpbmcoc2V0dGluZ3MucmF3VmFsdWVEaXZpc29yKS5sZW5ndGggLSAxOyAvLyBpZS4gRGl2aWRpbmcgYnkgJzEwMCcgYWRkcyAyIGRlY2ltYWwgcGxhY2VzIHRvIHRoZSBuZWVkZWQgcHJlY2lzaW9uXG4gICAgICAgICAgICBpZiAoYWRkaXRpb25hbERlY2ltYWxQbGFjZXNSYXdWYWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsRGVjaW1hbFBsYWNlc1Jhd1ZhbHVlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNSYXdWYWx1ZSA9IE1hdGgubWF4KFxuICAgICAgICAgICAgTWF0aC5tYXgoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25CbHVyLCBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSArIGFkZGl0aW9uYWxEZWNpbWFsUGxhY2VzUmF3VmFsdWUsXG4gICAgICAgICAgICBOdW1iZXIoc2V0dGluZ3Mub3JpZ2luYWxEZWNpbWFsUGxhY2VzUmF3VmFsdWUpICsgYWRkaXRpb25hbERlY2ltYWxQbGFjZXNSYXdWYWx1ZVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY2FsY3VsYXRlIHRoZSBudW1iZXIgZGUgZGVjaW1hbCBwbGFjZXMgdG8gYmUgdXNlZCBieSB0aGUgQXV0b051bWVyaWMgb2JqZWN0LCBmb3IgZWFjaCBvZiBpdHMgc3RhdGUsIGFuZCBmb3IgaXRzIGZvcm1hdHRlZCBhbmQgcmF3IHZhbHVlLlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBgcmF3VmFsdWVgIHByZWNpc2lvbiBpcyB0aGUgc2FtZSBhcyB0aGUgZm9ybWF0dGVkIHZhbHVlIG9uZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNsb3NlIHRvIHRoZSBvbmUgY2FsbGVkIGR1cmluZyBpbml0aWFsaXphdGlvbiwgYF9jYWxjdWxhdGVEZWNpbWFsUGxhY2VzT25Jbml0KClgLCBidXQgd2l0aCBzbGlnaHQgZGlmZmVyZW5jZSBzbyB0aGF0IHRoZSBgZGVjaW1hbFBsYWNlcypgIG9wdGlvbnMgYXJlIGNvcnJlY3RseSB1cGRhdGVkIGFzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kcyBzZXQgdGhlIGZvbGxvd2luZyBvcHRpb25zIGFjY29yZGluZ2x5IHRvIHRoZWlyIG93biB2YWx1ZSBhbmQgdGhlIG1hbmRhdG9yeSBgZGVjaW1hbFBsYWNlc2Agb3B0aW9uOlxuICAgICAqIC0gZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlICAgICAobnVsbGFibGUpXG4gICAgICogLSBkZWNpbWFsUGxhY2VzU2hvd25PbkJsdXIgIChudWxsYWJsZSlcbiAgICAgKiAtIGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgKG51bGxhYmxlKVxuICAgICAqXG4gICAgICogTm90ZTogdGhlIGBkZWNpbWFsUGxhY2VzYCBvcHRpb24gaXMgb25seSB1c2VkIGhlcmUgYW5kIG9ubHkgc2VydmUgdG8gZGVmaW5lIHRob3NlIHRocmVlIHByZXZpb3VzIG9wdGlvbnMgdmFsdWUuXG4gICAgICogQXV0b051bWVyaWMgd2lsbCB0aGVuICpvbmx5KiB1c2UgYGRlY2ltYWxQbGFjZXNSYXdWYWx1ZWAsIGBkZWNpbWFsUGxhY2VzU2hvd25PbkJsdXJgIGFuZCBgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c2AgZnJvbSB0aGVyZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kcyBkaXJlY3RseSBtb2RpZmllcyB0aGUgYHNldHRpbmdzYCBvYmplY3QgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIFRoaXMgaXMgYW4gb2JqZWN0IHdpdGggdGhlIG5ldyBzZXR0aW5ncyB0byB1c2UuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRTZXR0aW5ncyBUaGlzIGlzIHRoZSBjdXJyZW50IHNldHRpbmdzIChgdGhpcy5zZXR0aW5nc2ApIHVzZWQgYnkgdGhlIGVsZW1lbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgX2NhbGN1bGF0ZURlY2ltYWxQbGFjZXNPblVwZGF0ZShzZXR0aW5ncywgY3VycmVudFNldHRpbmdzID0gbnVsbCkge1xuICAgICAgICAvLyBDaGVjayB0aGUgYGRlY2ltYWxQbGFjZXMqYCBvcHRpb25zIGFuZCBvdXRwdXQgYW55IHdhcm5pbmdzIGFzIG5lZWRlZCwgYmVmb3JlIG1vZGlmeWluZyB0aG9zZSBvcHRpb25zXG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlRGVjaW1hbFBsYWNlc1Jhd1ZhbHVlKHNldHRpbmdzKTtcblxuICAgICAgICAvLyBVcGRhdGUgcGhhc2VcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChjdXJyZW50U2V0dGluZ3MpKSB7XG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBXaGVuIHVwZGF0aW5nIHRoZSBzZXR0aW5ncywgdGhlIHByZXZpb3VzIG9uZXMgc2hvdWxkIGJlIHBhc3NlZCBhcyBhbiBhcmd1bWVudC5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlY2ltYWxQbGFjZXNJbk9wdGlvbnMgPSAnZGVjaW1hbFBsYWNlcycgaW4gc2V0dGluZ3M7XG4gICAgICAgIGlmICghKGRlY2ltYWxQbGFjZXNJbk9wdGlvbnMgfHxcbiAgICAgICAgICAgICAgICAnZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlJyBpbiBzZXR0aW5ncyB8fFxuICAgICAgICAgICAgICAgICdkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzJyBpbiBzZXR0aW5ncyB8fFxuICAgICAgICAgICAgICAgICdkZWNpbWFsUGxhY2VzU2hvd25PbkJsdXInIGluIHNldHRpbmdzIHx8XG4gICAgICAgICAgICAgICAgJ3Jhd1ZhbHVlRGl2aXNvcicgaW4gc2V0dGluZ3MpKSB7XG4gICAgICAgICAgICAvLyBEbyBOb3RoaW5nIGlmIG5vIGRlY2ltYWwgcGxhY2VzLXJlbGF0ZWQgb3B0aW9ucyBhcmUgbW9kaWZpZWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE92ZXJ3cml0ZSB0aGUgYGRlY2ltYWxQbGFjZXMqYCB2YWx1ZXMgaWYgdGhlIGBkZWNpbWFsUGxhY2VzKmAgb3B0aW9ucyBhcmUgbm90IHNldCBpbiB0aGUgYHNldHRpbmdzYFxuICAgICAgICBpZiAoZGVjaW1hbFBsYWNlc0luT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCEoJ2RlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMnIGluIHNldHRpbmdzKSB8fFxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cy51c2VEZWZhdWx0KSAge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISgnZGVjaW1hbFBsYWNlc1Nob3duT25CbHVyJyBpbiBzZXR0aW5ncykgfHxcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkJsdXIgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25CbHVyLnVzZURlZmF1bHQpICB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25CbHVyID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEoJ2RlY2ltYWxQbGFjZXNSYXdWYWx1ZScgaW4gc2V0dGluZ3MpIHx8XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmRlY2ltYWxQbGFjZXNSYXdWYWx1ZS51c2VEZWZhdWx0KSAge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNSYXdWYWx1ZSA9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWQoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzID0gY3VycmVudFNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkJsdXIpKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25CbHVyID0gY3VycmVudFNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uQmx1cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0aGUgYWRkaXRpb25hbCBkZWNpbWFsIHBsYWNlcyB0byB0aGUgcmF3IHZhbHVlXG4gICAgICAgIGxldCBhZGRpdGlvbmFsRGVjaW1hbFBsYWNlc1Jhd1ZhbHVlID0gMDtcbiAgICAgICAgaWYgKHNldHRpbmdzLnJhd1ZhbHVlRGl2aXNvciAmJiBzZXR0aW5ncy5yYXdWYWx1ZURpdmlzb3IgIT09IEF1dG9OdW1lcmljLm9wdGlvbnMucmF3VmFsdWVEaXZpc29yLm5vbmUpIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxEZWNpbWFsUGxhY2VzUmF3VmFsdWUgPSBTdHJpbmcoc2V0dGluZ3MucmF3VmFsdWVEaXZpc29yKS5sZW5ndGggLSAxOyAvLyBpZS4gRGl2aWRpbmcgYnkgJzEwMCcgYWRkcyAyIGRlY2ltYWwgcGxhY2VzIHRvIHRoZSBuZWVkZWQgcHJlY2lzaW9uXG4gICAgICAgICAgICBpZiAoYWRkaXRpb25hbERlY2ltYWxQbGFjZXNSYXdWYWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsRGVjaW1hbFBsYWNlc1Jhd1ZhbHVlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2V0dGluZ3MuZGVjaW1hbFBsYWNlcyAmJiAhc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzUmF3VmFsdWUgPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICBNYXRoLm1heChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkJsdXIsIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpICsgYWRkaXRpb25hbERlY2ltYWxQbGFjZXNSYXdWYWx1ZSxcbiAgICAgICAgICAgICAgICBOdW1iZXIoY3VycmVudFNldHRpbmdzLm9yaWdpbmFsRGVjaW1hbFBsYWNlc1Jhd1ZhbHVlKSArIGFkZGl0aW9uYWxEZWNpbWFsUGxhY2VzUmF3VmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzUmF3VmFsdWUgPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICBNYXRoLm1heChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkJsdXIsIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpICsgYWRkaXRpb25hbERlY2ltYWxQbGFjZXNSYXdWYWx1ZSxcbiAgICAgICAgICAgICAgICBOdW1iZXIoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlKSArIGFkZGl0aW9uYWxEZWNpbWFsUGxhY2VzUmF3VmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmFseXplIGFuZCBzYXZlIHRoZSBtaW5pbXVtVmFsdWUgYW5kIG1heGltdW1WYWx1ZSBpbnRlZ2VyIHNpemUgZm9yIGxhdGVyIHVzZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVWTWluQW5kVk1heEludGVnZXJTaXplcygpIHtcbiAgICAgICAgbGV0IFttYXhpbXVtVmFsdWVJbnRlZ2VyUGFydF0gPSB0aGlzLnNldHRpbmdzLm1heGltdW1WYWx1ZS50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgIGxldCBbbWluaW11bVZhbHVlSW50ZWdlclBhcnRdID0gKCF0aGlzLnNldHRpbmdzLm1pbmltdW1WYWx1ZSAmJiB0aGlzLnNldHRpbmdzLm1pbmltdW1WYWx1ZSAhPT0gMCk/W106dGhpcy5zZXR0aW5ncy5taW5pbXVtVmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICBtYXhpbXVtVmFsdWVJbnRlZ2VyUGFydCA9IG1heGltdW1WYWx1ZUludGVnZXJQYXJ0LnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIG1pbmltdW1WYWx1ZUludGVnZXJQYXJ0ID0gbWluaW11bVZhbHVlSW50ZWdlclBhcnQucmVwbGFjZSgnLScsICcnKTtcblxuICAgICAgICB0aGlzLnNldHRpbmdzLm1JbnRQb3MgPSBNYXRoLm1heChtYXhpbXVtVmFsdWVJbnRlZ2VyUGFydC5sZW5ndGgsIDEpO1xuICAgICAgICB0aGlzLnNldHRpbmdzLm1JbnROZWcgPSBNYXRoLm1heChtaW5pbXVtVmFsdWVJbnRlZ2VyUGFydC5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBvbmNlIHdoYXQgYXJlIHRoZSBgdmFsdWVzVG9TdHJpbmdzYCBvcHRpb24ga2V5cy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVWYWx1ZXNUb1N0cmluZ3NLZXlzKCkge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52YWx1ZXNUb1N0cmluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzVG9TdHJpbmdzS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuc2V0dGluZ3MudmFsdWVzVG9TdHJpbmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzVG9TdHJpbmdzS2V5cyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWx0ZXJuYXRpdmUgZGVjaW1hbCBzZXBhcmF0b3Iga2V5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldEFsdGVybmF0aXZlRGVjaW1hbFNlcGFyYXRvckNoYXJhY3RlcigpIHtcbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzTnVsbCh0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSkgJiYgTnVtYmVyKHRoaXMuc2V0dGluZ3MuZGVjaW1hbFBsYWNlcykgPiAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyID09PSAnLicgJiYgdGhpcy5zZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yICE9PSAnLCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSA9ICcsJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyID09PSAnLCcgJiYgdGhpcy5zZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yICE9PSAnLicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSA9ICcuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhY2hlcyByZWd1bGFyIGV4cHJlc3Npb25zIGZvciBfc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVnZXhcbiAgICAgKi9cbiAgICBzdGF0aWMgX2NhY2hlc1VzdWFsUmVndWxhckV4cHJlc3Npb25zKHNldHRpbmdzLCByZWdleCkge1xuICAgICAgICBjb25zdCBhbGxOdW1iZXJzUmVnID0gJ1swLTldJztcbiAgICAgICAgY29uc3Qgbm9BbGxOdW1iZXJzUmVnID0gJ1teMC05XSc7XG5cbiAgICAgICAgLy8gVGVzdCBpZiB0aGVyZSBpcyBhIG5lZ2F0aXZlIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nXG4gICAgICAgIGNvbnN0IGFOZWdSZWcgPSBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI/YChbLVxcXFwke3NldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcn1dPylgOicoLT8pJztcbiAgICAgICAgcmVnZXguYU5lZ1JlZ0F1dG9TdHJpcCA9IGFOZWdSZWc7XG5cbiAgICAgICAgbGV0IG5lZ2F0aXZlU2lnblJlZ1BhcnQ7XG4gICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIG5lZ2F0aXZlU2lnblJlZ1BhcnQgPSBgXFxcXCR7c2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWdhdGl2ZVNpZ25SZWdQYXJ0ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0aW5ncy5za2lwRmlyc3RBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAke2FOZWdSZWd9W14tJHtuZWdhdGl2ZVNpZ25SZWdQYXJ0fVxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9JHthbGxOdW1iZXJzUmVnfV0uKj8oJHthbGxOdW1iZXJzUmVnfXxcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7YWxsTnVtYmVyc1JlZ30pYCk7XG4gICAgICAgIHNldHRpbmdzLnNraXBMYXN0QXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgKCR7YWxsTnVtYmVyc1JlZ31cXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfT8pW15cXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7YWxsTnVtYmVyc1JlZ31dJHtub0FsbE51bWJlcnNSZWd9KiRgKTtcblxuICAgICAgICBjb25zdCBhbGxvd2VkID0gYC0wMTIzNDU2Nzg5XFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn1gO1xuICAgICAgICBzZXR0aW5ncy5hbGxvd2VkQXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgW14ke2FsbG93ZWR9XWAsICdnJyk7XG4gICAgICAgIHNldHRpbmdzLm51bVJlZ0F1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYCR7YU5lZ1JlZ30oPzpcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfT8oJHthbGxOdW1iZXJzUmVnfStcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7YWxsTnVtYmVyc1JlZ30rKXwoJHthbGxOdW1iZXJzUmVnfSooPzpcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7YWxsTnVtYmVyc1JlZ30qKT8pKWApO1xuXG4gICAgICAgIC8vIFVzaW5nIHRoaXMgcmVnZXggdmVyc2lvbiBgXiR7cmVnZXguYU5lZ1JlZ0F1dG9TdHJpcH0wKihcXFxcZHwkKWAgZW50aXJlbHkgY2xlYXIgdGhlIGlucHV0IG9uIGJsdXJcbiAgICAgICAgc2V0dGluZ3Muc3RyaXBSZWcgPSBuZXcgUmVnRXhwKGBeJHtyZWdleC5hTmVnUmVnQXV0b1N0cmlwfTAqKCR7YWxsTnVtYmVyc1JlZ30pYCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kaWZ5IHRoZSB1c2VyIHNldHRpbmdzIHRvIG1ha2UgdGhlbSAnZXhwbG9pdGFibGUnIGxhdGVyLlxuICAgICAqL1xuICAgIF90cmFuc2Zvcm1PcHRpb25zVmFsdWVzVG9EZWZhdWx0VHlwZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc2V0dGluZ3Nba2V5XTtcblxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHN0cmluZ3MgJ3RydWUnIGFuZCAnZmFsc2UnIHRvIGJvb2xlYW5zXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAndHJ1ZScgfHwgdmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nc1trZXldID0gdmFsdWUgPT09ICd0cnVlJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IG51bWJlcnMgaW4gb3B0aW9ucyB0byBzdHJpbmdzXG4gICAgICAgICAgICAgICAgLy9UT0RPIE9ubHkgdHJhbnNmb3JtIHRoZSB2YWx1ZXMgb2YgdHlwZSAnTnVtYmVyJyB0byAnU3RyaW5nJyBpZiBpdCdzIGEgY3VycmVuY3kgbnVtYmVyIChzbyB0aGF0IHdlIGNhbiBoYXZlIGJpZyBudW1iZXJzKS4gRG8gbm90IGNvbnZlcnQgb3RoZXIgbnVtYmVycyAoaWUuIGBoaXN0b3J5U2l6ZWApXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nc1trZXldID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBvbGQgc2V0dGluZ3Mgb3B0aW9ucyBuYW1lIHRvIG5ldyBvbmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBzdGF0aWMgX2NvbnZlcnRPbGRPcHRpb25zVG9OZXdPbmVzKG9wdGlvbnMpIHtcbiAgICAgICAgLy9UT0RPIERlbGV0ZSB0aGlzIGZ1bmN0aW9uIG9uY2UgdGhlIG9sZCBvcHRpb25zIGFyZSBub3QgdXNlZCBhbnltb3JlXG4gICAgICAgIGNvbnN0IG9sZE9wdGlvbnNDb252ZXJ0ZXIgPSB7XG4gICAgICAgICAgICAvLyBPbGQgb3B0aW9uIG5hbWVzLCB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmcgbmV3IG5hbWVzXG4gICAgICAgICAgICBhU2VwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGlnaXRHcm91cFNlcGFyYXRvcicsXG4gICAgICAgICAgICBuU2VwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnc2hvd09ubHlOdW1iZXJzT25Gb2N1cycsXG4gICAgICAgICAgICBkR3JvdXAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGlnaXRhbEdyb3VwU3BhY2luZycsXG4gICAgICAgICAgICBhRGVjICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGVjaW1hbENoYXJhY3RlcicsXG4gICAgICAgICAgICBhbHREZWMgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlJyxcbiAgICAgICAgICAgIGFTaWduICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdjdXJyZW5jeVN5bWJvbCcsXG4gICAgICAgICAgICBwU2lnbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQnLFxuICAgICAgICAgICAgcE5lZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ25lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50JyxcbiAgICAgICAgICAgIGFTdWZmaXggICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdzdWZmaXhUZXh0JyxcbiAgICAgICAgICAgIG9MaW1pdHMgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdvdmVycmlkZU1pbk1heExpbWl0cycsXG4gICAgICAgICAgICB2TWF4ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnbWF4aW11bVZhbHVlJyxcbiAgICAgICAgICAgIHZNaW4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdtaW5pbXVtVmFsdWUnLFxuICAgICAgICAgICAgbURlYyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2RlY2ltYWxQbGFjZXNPdmVycmlkZScsXG4gICAgICAgICAgICBlRGVjICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cycsXG4gICAgICAgICAgICBzY2FsZURlY2ltYWwgICAgICAgICAgICAgICAgICAgICAgOiAnZGVjaW1hbFBsYWNlc1Nob3duT25CbHVyJyxcbiAgICAgICAgICAgIGFTdG9yICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlJyxcbiAgICAgICAgICAgIG1Sb3VuZCAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdyb3VuZGluZ01ldGhvZCcsXG4gICAgICAgICAgICBhUGFkICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnYWxsb3dEZWNpbWFsUGFkZGluZycsXG4gICAgICAgICAgICBuQnJhY2tldCAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnbmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXInLFxuICAgICAgICAgICAgd0VtcHR5ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2VtcHR5SW5wdXRCZWhhdmlvcicsXG4gICAgICAgICAgICBsWmVybyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnbGVhZGluZ1plcm8nLFxuICAgICAgICAgICAgYUZvcm0gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2Zvcm1hdE9uUGFnZUxvYWQnLFxuICAgICAgICAgICAgc051bWJlciAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ3NlbGVjdE51bWJlck9ubHknLFxuICAgICAgICAgICAgYW5EZWZhdWx0ICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2RlZmF1bHRWYWx1ZU92ZXJyaWRlJyxcbiAgICAgICAgICAgIHVuU2V0T25TdWJtaXQgICAgICAgICAgICAgICAgICAgICA6ICd1bmZvcm1hdE9uU3VibWl0JyxcbiAgICAgICAgICAgIG91dHB1dFR5cGUgICAgICAgICAgICAgICAgICAgICAgICA6ICdvdXRwdXRGb3JtYXQnLFxuICAgICAgICAgICAgZGVidWcgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ3Nob3dXYXJuaW5ncycsXG5cbiAgICAgICAgICAgIC8vIEN1cnJlbnQgb3B0aW9ucyA6XG4gICAgICAgICAgICBhbGxvd0RlY2ltYWxQYWRkaW5nICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uRm9jdXMgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0ZUxvY2FsTGlzdCAgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBjdXJyZW5jeVN5bWJvbCAgICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGRlY2ltYWxDaGFyYWN0ZXIgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZGVjaW1hbFBsYWNlcyAgICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGRlY2ltYWxQbGFjZXNSYXdWYWx1ZSAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBkZWNpbWFsUGxhY2VzU2hvd25PbkJsdXIgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZU92ZXJyaWRlICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBkaWdpdGFsR3JvdXBTcGFjaW5nICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGRpdmlzb3JXaGVuVW5mb2N1c2VkICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBlbXB0eUlucHV0QmVoYXZpb3IgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZmFpbE9uVW5rbm93bk9wdGlvbiAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGZvcm1hdE9uUGFnZUxvYWQgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBoaXN0b3J5U2l6ZSAgICAgICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgaXNDYW5jZWxsYWJsZSAgICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGxlYWRpbmdaZXJvICAgICAgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBtYXhpbXVtVmFsdWUgICAgICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbWluaW11bVZhbHVlICAgICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG1vZGlmeVZhbHVlT25XaGVlbCAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG5vRXZlbnRMaXN0ZW5lcnMgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBvbkludmFsaWRQYXN0ZSAgICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0ICAgICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG92ZXJyaWRlTWluTWF4TGltaXRzICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICByYXdWYWx1ZURpdmlzb3IgICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgcmVhZE9ubHkgICAgICAgICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHJvdW5kaW5nTWV0aG9kICAgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc2VsZWN0TnVtYmVyT25seSAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHNlbGVjdE9uRm9jdXMgICAgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzZXJpYWxpemVTcGFjZXMgICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc2hvd09ubHlOdW1iZXJzT25Gb2N1cyAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHNob3dQb3NpdGl2ZVNpZ24gICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzaG93V2FybmluZ3MgICAgICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc3R5bGVSdWxlcyAgICAgICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHN1ZmZpeFRleHQgICAgICAgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzeW1ib2xXaGVuVW5mb2N1c2VkICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgdW5mb3JtYXRPbkhvdmVyICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHVuZm9ybWF0T25TdWJtaXQgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZXNUb1N0cmluZ3MgICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgd2hlZWxTdGVwICAgICAgICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcblxuICAgICAgICAgICAgLy8gQWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0aGF0IGFyZSBhZGRlZCB0byB0aGUgYHNldHRpbmdzYCBvYmplY3QgOlxuICAgICAgICAgICAgLy9GSVhNRSBGaW5kIGEgd2F5IHRvIGV4Y2x1ZGUgdGhvc2UgaW50ZXJuYWwgZGF0YSBmcm9tIHRoZSBzZXR0aW5ncyBvYmplY3QgKGlkZWFsbHkgYnkgdXNpbmcgYW5vdGhlciBvYmplY3QsIG9yIGJldHRlciB5ZXQsIGNsYXNzIGF0dHJpYnV0ZXMpIC0tPlxuICAgICAgICAgICAgYWxsb3dlZEF1dG9TdHJpcCAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG1JbnROZWcgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBtSW50UG9zICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbmVnYXRpdmVTaWduQ2hhcmFjdGVyICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG51bVJlZ0F1dG9TdHJpcCAgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBvcmlnaW5hbERlY2ltYWxQbGFjZXMgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgb3JpZ2luYWxEZWNpbWFsUGxhY2VzUmF3VmFsdWUgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHBvc2l0aXZlU2lnbkNoYXJhY3RlciAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBza2lwRmlyc3RBdXRvU3RyaXAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc2tpcExhc3RBdXRvU3RyaXAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHN0cmlwUmVnICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChjb25zdCBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIGlmIChvbGRPcHRpb25zQ29udmVydGVyW29wdGlvbl0gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9wdGlvbiBpcyBhICduZXcnIG9wdGlvbiwgd2UgY29udGludWUgbG9vcGluZ1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob2xkT3B0aW9uc0NvbnZlcnRlci5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2Ugd2UgaGF2ZSBhbiAnb2xkJyBvcHRpb24gbmFtZVxuICAgICAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci53YXJuaW5nKGBZb3UgYXJlIHVzaW5nIHRoZSBkZXByZWNhdGVkIG9wdGlvbiBuYW1lICcke29wdGlvbn0nLiBQbGVhc2UgdXNlICcke29sZE9wdGlvbnNDb252ZXJ0ZXJbb3B0aW9uXX0nIGluc3RlYWQgZnJvbSBub3cgb24uIFRoZSBvbGQgb3B0aW9uIG5hbWUgd2lsbCBiZSBkcm9wcGVkIHZlcnkgc29vbuKEoi5gLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVuIHdlIG1vZGlmeSB0aGUgaW5pdGlhbCBvcHRpb24gb2JqZWN0IHRvIHVzZSB0aGUgbmV3IG9wdGlvbnMgaW5zdGVhZCBvZiB0aGUgb2xkIG9uZXNcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tvbGRPcHRpb25zQ29udmVydGVyW29wdGlvbl1dID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9uc1tvcHRpb25dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5mYWlsT25Vbmtub3duT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLm9yIHRoZSBvcHRpb24gbmFtZSBpcyB1bmtub3duLiBUaGlzIG1lYW5zIHRoZXJlIGlzIGEgcHJvYmxlbSB3aXRoIHRoZSBvcHRpb25zIG9iamVjdCwgdGhlcmVmb3JlIHdlIHRocm93IGFuIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBPcHRpb24gbmFtZSAnJHtvcHRpb259JyBpcyB1bmtub3duLiBQbGVhc2UgZml4IHRoZSBvcHRpb25zIHBhc3NlZCB0byBhdXRvTnVtZXJpY2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnbURlYycgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIud2FybmluZygnVGhlIG9sZCBgbURlY2Agb3B0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgbW9yZSBhY2N1cmF0ZSBvcHRpb25zIDsgYGRlY2ltYWxQbGFjZXNgLCBgZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlYCwgYGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXNgIGFuZCBgZGVjaW1hbFBsYWNlc1Nob3duT25CbHVyYC4nLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuYWx5c2UgdGhlIHNldHRpbmdzL29wdGlvbnMgcGFzc2VkIGJ5IHRoZSB1c2VyLCB2YWxpZGF0ZSBhbmQgY2xlYW4gdGhlbSwgdGhlbiBzZXQgdGhlbSBpbnRvIGB0aGlzLnNldHRpbmdzYC5cbiAgICAgKiBOb3RlOiBUaGlzIHNldHMgdGhlIHNldHRpbmdzIHRvIGBudWxsYCBpZiBzb21laG93IHRoZSBzZXR0aW5ncyBvYmpldCBpcyB1bmRlZmluZWQgb3IgZW1wdHlcbiAgICAgKiAgICAgICBJZiBvbmx5IGBkZWNpbWFsUGxhY2VzYCBpcyBkZWZpbmVkIGluIHRoZSBvcHRpb24sIG92ZXJ3cml0ZSB0aGUgb3RoZXIgZGVjaW1hbFBsYWNlcyogb3B0aW9ucywgb3RoZXJ3aXNlLCB1c2UgdGhvc2Ugb3B0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVwZGF0ZSAtIElmIHNldCB0byBgdHJ1ZWAsIHRoZW4gdGhlIHNldHRpbmdzIGFscmVhZHkgZXhpc3RzIGFuZCB0aGlzIGZ1bmN0aW9uIG9ubHkgdXBkYXRlcyB0aGVtIGluc3RlYWQgb2YgcmVjcmVhdGluZyB0aGVtIGZyb20gc2NyYXRjaFxuICAgICAqIEB0aHJvd3NcbiAgICAgKi9cbiAgICBfc2V0U2V0dGluZ3Mob3B0aW9ucywgdXBkYXRlID0gZmFsc2UpIHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgdXNlZCBvbGQgb3B0aW9ucywgd2UgY29udmVydCB0aGVtIHRvIG5ldyBvbmVzXG4gICAgICAgIGlmICh1cGRhdGUgfHwgIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChvcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fY29udmVydE9sZE9wdGlvbnNUb05ld09uZXMob3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAvLyBUaGUgc2V0dGluZ3MgYXJlIHVwZGF0ZWRcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgb3JpZ2luYWwgZGF0YSwgaWYgaXQgaGFzIGNoYW5nZWRcbiAgICAgICAgICAgIGNvbnN0IGRlY2ltYWxQbGFjZXNSYXdWYWx1ZUluT3B0aW9ucyA9ICdkZWNpbWFsUGxhY2VzUmF3VmFsdWUnIGluIG9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlSW5PcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5vcmlnaW5hbERlY2ltYWxQbGFjZXNSYXdWYWx1ZSA9IG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBkZWNpbWFsUGxhY2VzSW5PcHRpb25zID0gJ2RlY2ltYWxQbGFjZXMnIGluIG9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBsYWNlc0luT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Mub3JpZ2luYWxEZWNpbWFsUGxhY2VzID0gb3B0aW9ucy5kZWNpbWFsUGxhY2VzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGVuIHVwZGF0ZSBhbGwgdGhlIGBkZWNpbWFsUGxhY2VzKmAgb3B0aW9uc1xuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fY2FsY3VsYXRlRGVjaW1hbFBsYWNlc09uVXBkYXRlKG9wdGlvbnMsIHRoaXMuc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAvLyBGaW5hbGx5IGdlbmVyYXRlIHRoZSB1cGRhdGVkIHNldHRpbmdzIG9iamVjdCB0byB1c2VcbiAgICAgICAgICAgIHRoaXMuX21lcmdlU2V0dGluZ3Mob3B0aW9ucyk7IC8vVE9ETyBDaGVjayB0aGF0IHRoZSBgc3R5bGVSdWxlc2Agb3B0aW9uIGlzIGNvcnJlY3RseSBjbG9uZWQgKGR1ZSB0byBkZXB0aCBjbG9uaW5nIGxpbWl0YXRpb24pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgc2V0dGluZ3MgYXJlIGdlbmVyYXRlZCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkbid0IGdyYWIgYW55IHNldHRpbmdzLCBjcmVhdGUgdGhlbSBmcm9tIHRoZSBkZWZhdWx0IG9uZXMgYW5kIGNvbWJpbmUgdGhlbSB3aXRoIHRoZSBvcHRpb25zIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBhcyB3ZWxsIGFzIHdpdGggdGhlIEhUTUw1IGBkYXRhLSpgIGluZm8gKHZpYSBgdGhpcy5kb21FbGVtZW50LmRhdGFzZXRgKSwgaWYgYW55LlxuICAgICAgICAgICAgdGhpcy5fbWVyZ2VTZXR0aW5ncyh0aGlzLmNvbnN0cnVjdG9yLmdldERlZmF1bHRDb25maWcoKSwgdGhpcy5kb21FbGVtZW50LmRhdGFzZXQsIG9wdGlvbnMsIHsgcmF3VmFsdWUgOiB0aGlzLmRlZmF1bHRSYXdWYWx1ZSB9KTtcbiAgICAgICAgICAgIHRoaXMuY2FyZXRGaXggPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudGhyb3dJbnB1dCA9IHRydWU7IC8vIFRocm93IGlucHV0IGV2ZW50XG4gICAgICAgICAgICB0aGlzLmFsbG93ZWRUYWdMaXN0ID0gQXV0b051bWVyaWNFbnVtLmFsbG93ZWRUYWdMaXN0O1xuICAgICAgICAgICAgdGhpcy5ydW5PbmNlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmhvdmVyZWRXaXRoQWx0ID0gZmFsc2U7IC8vIEtlZXAgdHJhY2tzIGlmIHRoZSBjdXJyZW50IEF1dG9OdW1lcmljIGVsZW1lbnQgaXMgaG92ZXJlZCBieSB0aGUgbW91c2UgY3Vyc29yIHdoaWxlIGBBbHRgIGlzIHByZXNzZWRcbiAgICAgICAgICAgIHRoaXMuYW5kcm9pZFNlbGVjdGlvblN0YXJ0ID0gbnVsbDsgLy8gSWYgYG51bGxgLCB0aGVuIHdlIGFyZSBub3Qgb24gYW4gQW5kcm9pZCBkZXZpY2UgKHRoZSBrZXlDb2RlIGlzIG5vdCBhbHdheXMgZXF1YWwgdG8gMjI5KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTW9kaWZ5IHRoZSB1c2VyIHNldHRpbmdzIHRvIG1ha2UgdGhlbSAnZXhwbG9pdGFibGUnXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybU9wdGlvbnNWYWx1ZXNUb0RlZmF1bHRUeXBlcygpO1xuXG4gICAgICAgIC8vIEltbWVkaWF0ZWx5IHJ1biB0aGUgY2FsbGJhY2tzIHRoYXQgY291bGQgdXBkYXRlIHRoZSBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgdGhpcy5fcnVuQ2FsbGJhY2tzRm91bmRJblRoZVNldHRpbmdzT2JqZWN0KCk7XG5cbiAgICAgICAgLy8gSW1wcm92ZSB0aGUgYG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50YCBvcHRpb24gaWYgbmVlZGVkXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuX2NvcnJlY3ROZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudE9wdGlvbih0aGlzLnNldHRpbmdzKTtcblxuICAgICAgICAvLyBTZXQgdGhlIGBjYXJldFBvc2l0aW9uT25Gb2N1c2AgYW5kIGBzZWxlY3RPbkZvY3VzYCBvcHRpb25zIHNvIHRoYXQgdGhleSBkbyBub3QgY29uZmxpY3QsIGlmIG9uZSBvZiB0aG9zZSBoYXZlIGJlZW4gc2V0IG1hbnVhbGx5IGJ5IHRoZSB1c2VyLlxuICAgICAgICAvLyBJZiBvcmRlciB0byBjaGVjayB0aGF0LCB3ZSB0YWtlIGEgbG9vayBhdCB0aGUgb3JpZ2luYWwgb3B0aW9ucyB0aGUgdXNlciBwYXNzZWQgYXMgYW4gYXJndW1lbnQsIG5vdCBgdGhpcy5zZXR0aW5nc2AgdGhhdCBoYXZlIGJlZW4gbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHQgc2V0dGluZ3MuIC8vVE9ETyBDaGVjayB0aGUgdmFsaWRpdHkgb2YgdGhhdCBjb21tZW50XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuX2NvcnJlY3RDYXJldFBvc2l0aW9uT25Gb2N1c0FuZFNlbGVjdE9uRm9jdXNPcHRpb25zKHRoaXMuc2V0dGluZ3MpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgbmVnYXRpdmUgYW5kIHBvc2l0aXZlIHNpZ25zLCBhcyBuZWVkZWRcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgPSB0aGlzLnNldHRpbmdzLm1pbmltdW1WYWx1ZSA8IDAgPyAnLScgOiAnJztcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5wb3NpdGl2ZVNpZ25DaGFyYWN0ZXIgPSB0aGlzLnNldHRpbmdzLm1heGltdW1WYWx1ZSA+PSAwID8gJysnIDogJyc7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgKGR1cmluZyB0aGUgZWxlbWVudCBpbml0aWFsaXphdGlvbilcbiAgICAgICAgaWYgKCF1cGRhdGUpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgYG9yaWdpbmFsRGVjaW1hbFBsYWNlc2AgaW5mbyBpcyBzZXRcbiAgICAgICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bGwob3B0aW9ucykgfHwgIW9wdGlvbnMuZGVjaW1hbFBsYWNlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Mub3JpZ2luYWxEZWNpbWFsUGxhY2VzID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5vcmlnaW5hbERlY2ltYWxQbGFjZXMgPSBvcHRpb25zLmRlY2ltYWxQbGFjZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGBvcmlnaW5hbERlY2ltYWxQbGFjZXNSYXdWYWx1ZWAgaW5mb1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5vcmlnaW5hbERlY2ltYWxQbGFjZXNSYXdWYWx1ZSA9IHRoaXMuc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlO1xuXG4gICAgICAgICAgICAvLyBUaGVuIHVwZGF0ZSBhbGwgdGhlIGBkZWNpbWFsUGxhY2VzKmAgb3B0aW9uc1xuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fY2FsY3VsYXRlRGVjaW1hbFBsYWNlc09uSW5pdCh0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZGl0aW9uYWwgY2hhbmdlcyB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVZNaW5BbmRWTWF4SW50ZWdlclNpemVzKCk7XG4gICAgICAgIHRoaXMuX3NldEFsdGVybmF0aXZlRGVjaW1hbFNlcGFyYXRvckNoYXJhY3RlcigpO1xuICAgICAgICB0aGlzLl9zZXRUcmFpbGluZ05lZ2F0aXZlU2lnbkluZm8oKTtcbiAgICAgICAgdGhpcy5yZWdleCA9IHt9OyAvLyBDcmVhdGUgdGhlIG9iamVjdCB0aGF0IHdpbGwgc3RvcmUgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fY2FjaGVzVXN1YWxSZWd1bGFyRXhwcmVzc2lvbnModGhpcy5zZXR0aW5ncywgdGhpcy5yZWdleCk7XG4gICAgICAgIHRoaXMuX3NldEJyYWNrZXRzKCk7XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVZhbHVlc1RvU3RyaW5nc0tleXMoKTtcblxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgc2V0dGluZ3MuIEJvdGggdGVzdHMgdGhyb3dzIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzRW1wdHlPYmoodGhpcy5zZXR0aW5ncykpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoJ1VuYWJsZSB0byBzZXQgdGhlIHNldHRpbmdzLCB0aG9zZSBhcmUgaW52YWxpZCA7IGFuIGVtcHR5IG9iamVjdCB3YXMgZ2l2ZW4uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnZhbGlkYXRlKHRoaXMuc2V0dGluZ3MsIGZhbHNlLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBPcmlnaW5hbCBzZXR0aW5ncyBzYXZlZCBmb3IgdXNlIHdoZW4gZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cywgZGl2aXNvcldoZW5VbmZvY3VzZWQgJiBzaG93T25seU51bWJlcnNPbkZvY3VzIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWRcbiAgICAgICAgdGhpcy5fa2VlcEFuT3JpZ2luYWxTZXR0aW5nc0NvcHkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBgdmFsdWVgIHBhcmFtZXRlciB0aGF0IGNhbiBlaXRoZXIgYmUgOlxuICAgICAqIC0gYSByZWFsIG51bWJlcixcbiAgICAgKiAtIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIHJlYWwgbnVtYmVyLCBvclxuICAgICAqIC0gYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgbG9jYWxpemVkIG51bWJlciAod2l0aCBzcGVjaWZpYyBncm91cCBzZXBhcmF0b3JzIGFuZCBkZWNpbWFsIGNoYXJhY3RlciksXG4gICAgICogLi4udG8gYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgcmVhbCAnamF2YXNjcmlwdCcgbnVtYmVyIChpZS4gJzEyMzQnIG9yICcxMjM0LjU2NycpLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGBOYU5gIGlmIHN1Y2ggY29udmVyc2lvbiBmYWlscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aW50fGZsb2F0fHN0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfE5hTn1cbiAgICAgKi9cbiAgICBzdGF0aWMgX3RvTnVtZXJpY1ZhbHVlKHZhbHVlLCBzZXR0aW5ncykge1xuICAgICAgICAvL1hYWCBOb3RlOyB0aGlzIGZ1bmN0aW9uIGlzIHN0YXRpYyBzaW5jZSB3ZSBuZWVkIHRvIHBhc3MgYSBgc2V0dGluZ3NgIG9iamVjdCB3aGVuIGNhbGxpbmcgdGhlIHN0YXRpYyBgQXV0b051bWVyaWMuZm9ybWF0KClgIG1ldGhvZFxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNOdW1iZXIoTnVtYmVyKHZhbHVlKSkpIHtcbiAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBoYXMgZWl0aGVyIGFscmVhZHkgYmVlbiBzdHJpcHBlZCwgb3IgYSAncmVhbCcgamF2YXNjcmlwdCBudW1iZXIgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyXG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEVsc2UgaWYgaXQncyBhIHN0cmluZyB0aGF0IGBOdW1iZXIoKWAgY2Fubm90IHR5cGVjYXN0LCB0aGVuIHdlIHRyeSB0byBjb252ZXJ0IHRoZSBsb2NhbGl6ZWQgbnVtZXJpYyBzdHJpbmcgdG8gYSBudW1lcmljIG9uZVxuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgdmFsdWUgdG8gYSBudW1lcmljIHN0cmluZywgc3RyaXBwaW5nIHVubmVjZXNzYXJ5IGNoYXJhY3RlcnMgaW4gdGhlIHByb2Nlc3NcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2NvbnZlcnRUb051bWVyaWNTdHJpbmcodmFsdWUudG9TdHJpbmcoKSwgc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVzdWx0IGlzIHN0aWxsIG5vdCBhIG51bWVyaWMgc3RyaW5nLCB0aGVuIHdlIHRocm93IGEgd2FybmluZ1xuICAgICAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc051bWJlcihOdW1iZXIocmVzdWx0KSkpIHtcbiAgICAgICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci53YXJuaW5nKGBUaGUgdmFsdWUgXCIke3ZhbHVlfVwiIGJlaW5nICdzZXQnIGlzIG5vdCBudW1lcmljIGFuZCB0aGVyZWZvcmUgY2Fubm90IGJlIHVzZWQgYXBwcm9wcmlhdGVseS5gLCBzZXR0aW5ncy5zaG93V2FybmluZ3MpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwYXN0ZWQgdGV4dCB0aGF0IHdpbGwgYmUgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHJldHVybnMge3N0cmluZ3x2b2lkfFhNTHwqfVxuICAgICAqL1xuICAgIF9wcmVwYXJlUGFzdGVkVGV4dCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLl9zdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnModGV4dCwgdGhpcy5zZXR0aW5ncywgdHJ1ZSwgdGhpcy5pc0ZvY3VzZWQpLnJlcGxhY2UodGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyLCAnLicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBnaXZlbiB2YWx1ZSAoYSBudW1iZXIgYXMgYSBzdHJpbmcpIGlzIHdpdGhpbiB0aGUgcmFuZ2Ugc2V0IGluIHRoZSBzZXR0aW5ncyBgbWluaW11bVZhbHVlYCBhbmQgYG1heGltdW1WYWx1ZWAsIEZBTFNFIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJzZWRNaW5WYWx1ZSBQYXJzZWQgdmlhIHRoZSBgcGFyc2VTdHIoKWAgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyc2VkTWF4VmFsdWUgUGFyc2VkIHZpYSB0aGUgYHBhcnNlU3RyKClgIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIF9jaGVja0lmSW5SYW5nZSh2YWx1ZSwgcGFyc2VkTWluVmFsdWUsIHBhcnNlZE1heFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gQXV0b051bWVyaWNIZWxwZXIucGFyc2VTdHIodmFsdWUpO1xuICAgICAgICByZXR1cm4gQXV0b051bWVyaWNIZWxwZXIudGVzdE1pbk1heChwYXJzZWRNaW5WYWx1ZSwgcGFyc2VkVmFsdWUpID4gLTEgJiYgQXV0b051bWVyaWNIZWxwZXIudGVzdE1pbk1heChwYXJzZWRNYXhWYWx1ZSwgcGFyc2VkVmFsdWUpIDwgMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHNlbGVjdGlvbiB2YWx1ZXMgYXMgd2VsbCBhcyByZXNldHMgdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBjdXJyZW50IEF1dG9OdW1lcmljIG9iamVjdC5cbiAgICAgKiBUaGlzIGtlZXBzIHRyYWNrcyBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gYW5kIHJlc2V0cyB0aGUgJ3Byb2Nlc3NlZCcgYW5kICdmb3JtYXR0ZWQnIHN0YXRlLlxuICAgICAqXG4gICAgICogTm90ZSA6IFRob3NlIHR3byBjYW4gY2hhbmdlIGJldHdlZW4gdGhlIGtleWRvd24sIGtleXByZXNzIGFuZCBrZXl1cCBldmVudHMsIHRoYXQncyB3aHlcbiAgICAgKiAgICAgICAgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZWFjaCBldmVudCBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlSW50ZXJuYWxQcm9wZXJ0aWVzKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRTZWxlY3Rpb24odGhpcy5kb21FbGVtZW50KTtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGBldmVudC5rZXlgIGF0dHJpYnV0ZSB0aGF0IHRyaWdnZXJlZCB0aGUgZ2l2ZW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBgZXZlbnQua2V5YCBkZXNjcmliZXM6XG4gICAgICogLSB0aGUga2V5IG5hbWUgKGlmIGEgbm9uLXByaW50YWJsZSBjaGFyYWN0ZXIpLFxuICAgICAqIC0gb3IgZGlyZWN0bHkgdGhlIGNoYXJhY3RlciB0aGF0IHJlc3VsdCBmcm9tIHRoZSBrZXkgcHJlc3MgdXNlZCB0byB0cmlnZ2VyIHRoZSBldmVudC5cbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleVxuICAgICAqIFRoZSBrZXkgbGlzdCBpcyBkZXNjcmliZWQgaGVyZTpcbiAgICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXkvS2V5X1ZhbHVlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudHxLZXlib2FyZEV2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlRXZlbnRLZXlJbmZvKGUpIHtcbiAgICAgICAgdGhpcy5ldmVudEtleSA9IEF1dG9OdW1lcmljSGVscGVyLmNoYXJhY3RlcihlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYXZlIHRoZSB1bmZvcm1hdHRlZCBlbGVtZW50IHZhbHVlLlxuICAgICAqIFRoaXMgaXMgdXNlZCBpbiB0aGUgJ2NhbmNlbGxhYmxlJyBmZWF0dXJlIHdoZXJlIHRoZSBlbGVtZW50IHZhbHVlIGlzIHNhdmVkIG9uIGZvY3VzIGFuZCBpbnB1dCB2YWxpZGF0aW9uLCB0byBiZSB1c2VkIGlmIHRoZSB1c2VyIHdhbnRzIHRvIGNhbmNlbCBoaXMgbW9kaWZpY2F0aW9ucyBieSBoaXR0aW5nIHRoZSAnRXNjYXBlJyBrZXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zYXZlQ2FuY2VsbGFibGVWYWx1ZSgpIHtcbiAgICAgICAgdGhpcy5zYXZlZENhbmNlbGxhYmxlVmFsdWUgPSB0aGlzLnJhd1ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdGV4dCBzZWxlY3Rpb24gaW5zaWRlIHRoZSBpbnB1dCB3aXRoIHRoZSBnaXZlbiBzdGFydCBhbmQgZW5kIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0XG4gICAgICogQHBhcmFtIHtpbnR9IGVuZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNlbGVjdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICAgIC8vVE9ETyB1c2UgdGhpcyBmdW5jdGlvbiB0byByZXBsYWNlIHRoZSBkaXJlY3QgY2FsbHMgdG8gYHNldEVsZW1lbnRTZWxlY3Rpb24oKWAsIHdoZXJldmVyIHBvc3NpYmxlXG4gICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIDApO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbihlbmQsIEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZSh0aGlzLmRvbUVsZW1lbnQpLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0ge1xuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICBsZW5ndGg6IGVuZCAtIHN0YXJ0LFxuICAgICAgICB9O1xuXG4gICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRTZWxlY3Rpb24odGhpcy5kb21FbGVtZW50LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNhcmV0IHBvc2l0aW9uIGluc2lkZSB0aGUgaW5wdXQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbnR9IHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0Q2FyZXRQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICB0aGlzLl9zZXRTZWxlY3Rpb24ocG9zaXRpb24sIHBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgc3RyaW5nIHBhcnRzIGxvY2F0ZWQgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGUgb2YgdGhlIGNhcmV0IG9yIHNlbGVjdGlvbi5cbiAgICAgKiBUaG9zZSBwYXJ0cyBhcmUgbGVmdCAndW50b3VjaGVkJywgaWUuIGZvcm1hdHRlZCBieSBhdXRvTnVtZXJpYy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtbc3RyaW5nLCBzdHJpbmddfSBUaGUgcGFydHMgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IG9mIHRoZSBjYXJldCBvciBzZWxlY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZSh0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICBjb25zdCBsZWZ0ID0gdmFsdWUuc3Vic3RyaW5nKDAsIHRoaXMuc2VsZWN0aW9uLnN0YXJ0KTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSB2YWx1ZS5zdWJzdHJpbmcodGhpcy5zZWxlY3Rpb24uZW5kLCB2YWx1ZS5sZW5ndGgpO1xuXG4gICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBjb250YWluaW5nIHRoZSBzdHJpbmcgcGFydHMgbG9jYXRlZCBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZSBvZiB0aGUgY2FyZXQgb3Igc2VsZWN0aW9uLlxuICAgICAqIFRob3NlIHBhcnRzIGFyZSB1bmZvcm1hdHRlZCAoc3RyaXBwZWQpIG9mIGFueSBub24tbnVtYmVycyBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1tzdHJpbmcsIHN0cmluZ119IFRoZSBwYXJ0cyBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgdGhlIGNhcmV0IG9yIHNlbGVjdGlvbiwgdW5mb3JtYXR0ZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0VW5mb3JtYXR0ZWRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCkge1xuICAgICAgICBsZXQgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX2dldExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKGxlZnQgPT09ICcnICYmIHJpZ2h0ID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIFsnJywgJyddO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgY2hhbmdpbmcgdGhlIHNpZ24gYW5kIGBsZWZ0YCBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIHplcm8sIHByZXZlbnQgc3RyaXBwaW5nIHRoZSBsZWFkaW5nIHplcm8ocylcbiAgICAgICAgbGV0IHN0cmlwWmVyb3MgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuSHlwaGVuICYmIE51bWJlcihsZWZ0KSA9PT0gMCkge1xuICAgICAgICAgICAgc3RyaXBaZXJvcyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNUcmFpbGluZ05lZ2F0aXZlICYmXG4gICAgICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci5pc05lZ2F0aXZlKHJpZ2h0KSAmJlxuICAgICAgICAgICAgIUF1dG9OdW1lcmljSGVscGVyLmlzTmVnYXRpdmUobGVmdCkpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgc2V0IHRoZSBuZWdhdGl2ZSBzaWduIGlmIHRoZSB2YWx1ZSBpcyBuZWdhdGl2ZVxuICAgICAgICAgICAgbGVmdCA9ICctJyArIGxlZnQ7XG4gICAgICAgICAgICByaWdodCA9IHJpZ2h0LnJlcGxhY2UodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlZnQgPSBBdXRvTnVtZXJpYy5fc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKGxlZnQsIHRoaXMuc2V0dGluZ3MsIHN0cmlwWmVyb3MsIHRoaXMuaXNGb2N1c2VkKTtcbiAgICAgICAgcmlnaHQgPSBBdXRvTnVtZXJpYy5fc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHJpZ2h0LCB0aGlzLnNldHRpbmdzLCBmYWxzZSwgdGhpcy5pc0ZvY3VzZWQpO1xuXG4gICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0cmlwIHBhcnRzIGZyb20gZXhjZXNzIGNoYXJhY3RlcnMgYW5kIGxlYWRpbmcgemVyb3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGVmdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByaWdodFxuICAgICAqIEByZXR1cm5zIHtbKiwqLCpdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX25vcm1hbGl6ZVBhcnRzKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIC8vVE9ETyBSZWZhY3RvciB3aXRoIGBfZ2V0VW5mb3JtYXR0ZWRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uYCB3aGljaCBzaGFyZSBhIGxvdCBvZiBzaW1pbGFyIGNvZGVcbiAgICAgICAgLy8gSWYgY2hhbmdpbmcgdGhlIHNpZ24gYW5kIGxlZnQgaXMgZXF1YWwgdG8gdGhlIG51bWJlciB6ZXJvIC0gcHJldmVudHMgc3RyaXBwaW5nIHRoZSBsZWFkaW5nIHplcm9zXG4gICAgICAgIGxldCBzdHJpcFplcm9zID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkh5cGhlbiAmJiBOdW1iZXIobGVmdCkgPT09IDApIHtcbiAgICAgICAgICAgIHN0cmlwWmVyb3MgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzVHJhaWxpbmdOZWdhdGl2ZSAmJlxuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuaXNOZWdhdGl2ZShyaWdodCkgJiZcbiAgICAgICAgICAgICFBdXRvTnVtZXJpY0hlbHBlci5pc05lZ2F0aXZlKGxlZnQpKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHNldCB0aGUgbmVnYXRpdmUgc2lnbiBpZiB0aGUgdmFsdWUgaXMgbmVnYXRpdmVcbiAgICAgICAgICAgIGxlZnQgPSAnLScgKyBsZWZ0O1xuICAgICAgICAgICAgcmlnaHQgPSByaWdodC5yZXBsYWNlKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZWZ0ID0gQXV0b051bWVyaWMuX3N0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhsZWZ0LCB0aGlzLnNldHRpbmdzLCBzdHJpcFplcm9zLCB0aGlzLmlzRm9jdXNlZCk7XG4gICAgICAgIHJpZ2h0ID0gQXV0b051bWVyaWMuX3N0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhyaWdodCwgdGhpcy5zZXR0aW5ncywgZmFsc2UsIHRoaXMuaXNGb2N1c2VkKTtcblxuICAgICAgICAvLyBQcmV2ZW50cyBtdWx0aXBsZSBsZWFkaW5nIHplcm9zIGZyb20gYmVpbmcgZW50ZXJlZFxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5sZWFkaW5nWmVyby5kZW55ICYmXG4gICAgICAgICAgICAodGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUubnVtMCB8fCB0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5udW1wYWQwKSAmJlxuICAgICAgICAgICAgTnVtYmVyKGxlZnQpID09PSAwICYmXG4gICAgICAgICAgICAvLyBJZiBgcmlnaHRgIGlzIG5vdCBlbXB0eSBhbmQgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBub3QgYGRlY2ltYWxDaGFyYWN0ZXJgXG4gICAgICAgICAgICAhQXV0b051bWVyaWNIZWxwZXIuY29udGFpbnMobGVmdCwgdGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSAmJiByaWdodCAhPT0gJycpIHtcbiAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5zZXJ0IHplcm8gdGhlcmUgaXMgYSBsZWFkaW5nIGRvdFxuICAgICAgICBsZXQgbmV3VmFsdWUgPSBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBuZXdWYWx1ZS5tYXRjaChuZXcgUmVnRXhwKGBeJHt0aGlzLnJlZ2V4LmFOZWdSZWdBdXRvU3RyaXB9XFxcXCR7dGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfWApKTtcbiAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQucmVwbGFjZShtWzFdLCBtWzFdICsgJzAnKTtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGxlZnQgKyByaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHQsIG5ld1ZhbHVlXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZvcm1hdHRlZCBlbGVtZW50IHZhbHVlIGFzIHdlbGwgYXMgdGhlIGByYXdWYWx1ZWAuXG4gICAgICogVGhpcyByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZWxlbWVudCBhbmQgcmF3IHZhbHVlIGhhdmUgYmVlbiBtb2RpZmllZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICogVGhpcyBtZXRob2QgYWxzbyBhZGp1c3QgdGhlIGNhcmV0IHBvc2l0aW9uIGFjY29yZGluZyB0byB0aGUgYGxlYWRpbmdaZXJvYCBvcHRpb24gYW5kIHRoZSBub3JtYWxpemVkIHZhbHVlLiAvL1RPRE8gV2hhdCBhYm91dCB0aGUgY3Vyc29yICpzZWxlY3Rpb24qP1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxlZnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUGFzdGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0LCBpc1Bhc3RlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgW25vcm1hbGl6ZWRMZWZ0LCBub3JtYWxpemVkUmlnaHQsIG5vcm1hbGl6ZWROZXdWYWx1ZV0gPSB0aGlzLl9ub3JtYWxpemVQYXJ0cyhsZWZ0LCByaWdodCk7XG4gICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IEF1dG9OdW1lcmljLl9jaGVja0lmSW5SYW5nZVdpdGhPdmVycmlkZU9wdGlvbihub3JtYWxpemVkTmV3VmFsdWUsIHRoaXMuc2V0dGluZ3MpO1xuXG4gICAgICAgIGlmIChtaW5UZXN0ICYmIG1heFRlc3QpIHtcbiAgICAgICAgICAgIC8vIEZpcnN0LCBzZXQgdGhlIHJhdyB2YWx1ZVxuICAgICAgICAgICAgY29uc3Qgcm91bmRlZFJhd1ZhbHVlID0gQXV0b051bWVyaWMuX3RydW5jYXRlRGVjaW1hbFBsYWNlcyhub3JtYWxpemVkTmV3VmFsdWUsIHRoaXMuc2V0dGluZ3MsIGlzUGFzdGUsIHRoaXMuc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RWYWx1ZSA9IHJvdW5kZWRSYXdWYWx1ZS5yZXBsYWNlKHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgJy4nKTtcblxuICAgICAgICAgICAgaWYgKHRlc3RWYWx1ZSA9PT0gJycgfHwgdGVzdFZhbHVlID09PSB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZVRvU2V0T25FbXB0eTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3MuZW1wdHlJbnB1dEJlaGF2aW9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3IuemVybzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlVG9TZXRPbkVtcHR5ID0gJzAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3IubnVsbDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlVG9TZXRPbkVtcHR5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlVG9TZXRPbkVtcHR5ID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UmF3VmFsdWUodmFsdWVUb1NldE9uRW1wdHkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRSYXdWYWx1ZSh0aGlzLl90cmltTGVhZGluZ0FuZFRyYWlsaW5nWmVyb3ModGVzdFZhbHVlKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZW4gc2V0IHRoZSBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgICAgICAgIGNvbnN0IHJvdW5kZWRWYWx1ZVRvU2hvdyA9IEF1dG9OdW1lcmljLl90cnVuY2F0ZURlY2ltYWxQbGFjZXMobm9ybWFsaXplZE5ld1ZhbHVlLCB0aGlzLnNldHRpbmdzLCBpc1Bhc3RlLCB0aGlzLnNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpO1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gbm9ybWFsaXplZExlZnQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID4gcm91bmRlZFZhbHVlVG9TaG93Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gcm91bmRlZFZhbHVlVG9TaG93Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdoZW4gdGhlIHVzZXIgZW50ZXIgYSAnMCcgb24gdGhlIGZhciBsZWZ0IHdpdGggYSBsZWFkaW5nIHplcm8gb3B0aW9uIHNldCB0byAnZGVueScsIHRoYXQgdGhlIGNhcmV0IGRvZXMgbm90IG1vdmVzIHNpbmNlIHRoZSBpbnB1dCBpcyBkcm9wcGVkIChmaXggaXNzdWUgIzI4MylcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMSAmJiBub3JtYWxpemVkTGVmdCA9PT0gJzAnICYmIHRoaXMuc2V0dGluZ3MubGVhZGluZ1plcm8gPT09IEF1dG9OdW1lcmljLm9wdGlvbnMubGVhZGluZ1plcm8uZGVueSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGVudGVyIGAwYCwgdGhlbiB0aGUgY2FyZXQgaXMgcHV0IG9uIHRoZSByaWdodCBzaWRlIG9mIGl0IChGaXggaXNzdWUgIzI5OSlcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFJpZ2h0ID09PSAnJyB8fCBub3JtYWxpemVkTGVmdCA9PT0gJzAnICYmIG5vcm1hbGl6ZWRSaWdodCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRWYWx1ZSh0aGlzLmRvbUVsZW1lbnQsIHJvdW5kZWRWYWx1ZVRvU2hvdyk7XG4gICAgICAgICAgICB0aGlzLl9zZXRDYXJldFBvc2l0aW9uKHBvc2l0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1pblRlc3QpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRyaWdnZXJFdmVudChBdXRvTnVtZXJpYy5ldmVudHMubWluUmFuZ2VFeGNlZWRlZCwgdGhpcy5kb21FbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICghbWF4VGVzdCkge1xuICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIudHJpZ2dlckV2ZW50KEF1dG9OdW1lcmljLmV2ZW50cy5tYXhSYW5nZUV4Y2VlZGVkLCB0aGlzLmRvbUVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgYF9leHBhbmRTZWxlY3Rpb25PblNpZ24oKWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IGNvbnRhaW5pbmcgW3NpZ25Qb3NpdGlvbiwgY3VycmVuY3lTeW1ib2xQb3NpdGlvbl0gb2YgYSBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRTaWduUG9zaXRpb24oKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW5jeVN5bWJvbExlbiA9IHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnByZWZpeCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc05lZyA9IHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICYmIHZhbHVlICYmIHZhbHVlLmNoYXJBdCgwKSA9PT0gdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKGhhc05lZykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbMSwgY3VycmVuY3lTeW1ib2xMZW4gKyAxXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbMCwgY3VycmVuY3lTeW1ib2xMZW5dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVMZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3ZhbHVlTGVuIC0gY3VycmVuY3lTeW1ib2xMZW4sIHZhbHVlTGVuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFsxMDAwLCAtMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgc2VsZWN0aW9uIHRvIGNvdmVyIHdob2xlIHNpZ25cbiAgICAgKiBQcmV2ZW50cyBwYXJ0aWFsIGRlbGV0aW9uL2NvcHlpbmcvb3ZlcndyaXRpbmcgb2YgYSBzaWduXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZXhwYW5kU2VsZWN0aW9uT25TaWduKCkge1xuICAgICAgICBjb25zdCBbc2lnblBvc2l0aW9uLCBjdXJyZW5jeVN5bWJvbFBvc2l0aW9uXSA9IHRoaXMuX2dldFNpZ25Qb3NpdGlvbigpO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcblxuICAgICAgICAvLyBJZiBzZWxlY3Rpb24gY2F0Y2hlcyBzb21ldGhpbmcgZXhjZXB0IHNpZ24gYW5kIGNhdGNoZXMgb25seSBzcGFjZSBmcm9tIHNpZ25cbiAgICAgICAgaWYgKHNlbGVjdGlvbi5zdGFydCA8IGN1cnJlbmN5U3ltYm9sUG9zaXRpb24gJiYgc2VsZWN0aW9uLmVuZCA+IHNpZ25Qb3NpdGlvbikge1xuICAgICAgICAgICAgLy8gVGhlbiBzZWxlY3Qgd2l0aG91dCBlbXB0eSBzcGFjZVxuICAgICAgICAgICAgaWYgKChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb24gfHwgc2VsZWN0aW9uLmVuZCA+IGN1cnJlbmN5U3ltYm9sUG9zaXRpb24pICYmXG4gICAgICAgICAgICAgICAgQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCkuc3Vic3RyaW5nKE1hdGgubWF4KHNlbGVjdGlvbi5zdGFydCwgc2lnblBvc2l0aW9uKSwgTWF0aC5taW4oc2VsZWN0aW9uLmVuZCwgY3VycmVuY3lTeW1ib2xQb3NpdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIC5tYXRjaCgvXlxccyokLykpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnN0YXJ0IDwgc2lnblBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGlvbihzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKGN1cnJlbmN5U3ltYm9sUG9zaXRpb24sIHNlbGVjdGlvbi5lbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRWxzZSBzZWxlY3Qgd2l0aCB3aG9sZSBzaWduXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKE1hdGgubWluKHNlbGVjdGlvbi5zdGFydCwgc2lnblBvc2l0aW9uKSwgTWF0aC5tYXgoc2VsZWN0aW9uLmVuZCwgY3VycmVuY3lTeW1ib2xQb3NpdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ5IHRvIHN0cmlwIHBhc3RlZCB2YWx1ZSB0byBkaWdpdHNcbiAgICAgKi9cbiAgICBfY2hlY2tQYXN0ZSgpIHtcbiAgICAgICAgaWYgKCFBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZCh0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFBhcnRzID0gdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGU7XG4gICAgICAgICAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0TGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICAvLyBUcnkgdG8gc3RyaXAgdGhlIHBhc3RlZCB2YWx1ZSBmaXJzdFxuICAgICAgICAgICAgZGVsZXRlIHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlO1xuXG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZExlZnRQYXJ0ID0gbGVmdC5zdWJzdHIoMCwgb2xkUGFydHNbMF0ubGVuZ3RoKSArIEF1dG9OdW1lcmljLl9zdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMobGVmdC5zdWJzdHIob2xkUGFydHNbMF0ubGVuZ3RoKSwgdGhpcy5zZXR0aW5ncywgdHJ1ZSwgdGhpcy5pc0ZvY3VzZWQpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9zZXRWYWx1ZVBhcnRzKG1vZGlmaWVkTGVmdFBhcnQsIHJpZ2h0LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnNldEVsZW1lbnRWYWx1ZSh0aGlzLmRvbUVsZW1lbnQsIG9sZFBhcnRzLmpvaW4oJycpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDYXJldFBvc2l0aW9uKG9sZFBhcnRzWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBnaXZlbiBrZXkgc2hvdWxkIGJlIGlnbm9yZWQgb3Igbm90LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50S2V5TmFtZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIF9zaG91bGRTa2lwRXZlbnRLZXkoZXZlbnRLZXlOYW1lKSB7XG4gICAgICAgIGNvbnN0IGlzRm5LZXlzID0gQXV0b051bWVyaWNIZWxwZXIuaXNJbkFycmF5KGV2ZW50S2V5TmFtZSwgQXV0b051bWVyaWNFbnVtLmtleU5hbWUuX2FsbEZuS2V5cyk7XG4gICAgICAgIGNvbnN0IGlzT1NLZXlzID0gZXZlbnRLZXlOYW1lID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5PU0xlZnQgfHwgZXZlbnRLZXlOYW1lID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5PU1JpZ2h0O1xuICAgICAgICBjb25zdCBpc0NvbnRleHRNZW51ID0gZXZlbnRLZXlOYW1lID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5Db250ZXh0TWVudTtcbiAgICAgICAgY29uc3QgaXNTb21lTm9uUHJpbnRhYmxlS2V5cyA9IEF1dG9OdW1lcmljSGVscGVyLmlzSW5BcnJheShldmVudEtleU5hbWUsIEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLl9zb21lTm9uUHJpbnRhYmxlS2V5cyk7XG4gICAgICAgIGNvbnN0IGlzT3RoZXJOb25QcmludGFibGVLZXlzID0gZXZlbnRLZXlOYW1lID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5OdW1Mb2NrIHx8XG4gICAgICAgICAgICBldmVudEtleU5hbWUgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLlNjcm9sbExvY2sgfHxcbiAgICAgICAgICAgIGV2ZW50S2V5TmFtZSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuSW5zZXJ0IHx8XG4gICAgICAgICAgICBldmVudEtleU5hbWUgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkNvbW1hbmQ7XG4gICAgICAgIGNvbnN0IGlzVW5yZWNvZ25pemFibGVLZXlzID0gZXZlbnRLZXlOYW1lID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5VbmlkZW50aWZpZWQ7XG5cbiAgICAgICAgcmV0dXJuIGlzRm5LZXlzIHx8IGlzT1NLZXlzIHx8IGlzQ29udGV4dE1lbnUgfHwgaXNTb21lTm9uUHJpbnRhYmxlS2V5cyB8fCBpc1VucmVjb2duaXphYmxlS2V5cyB8fCBpc090aGVyTm9uUHJpbnRhYmxlS2V5cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGNvcHlpbmcsIGN1dHRpbmcgYW5kIHBhc3RpbmcsIGFzIHdlbGwgYXMgdW5kby9yZWRvaW5nIGFuZCBjdXJzb3IgbW92aW5nLlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgZnVydGhlciBwcm9jZXNzaW5nIHNob3VsZCBub3QgYmUgcGVyZm9ybWVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcHJvY2Vzc05vblByaW50YWJsZUtleXNBbmRTaG9ydGN1dHMoZSkge1xuICAgICAgICAvLyBDYXRjaCB0aGUgY3RybCB1cCBvbiBjdHJsLXZcbiAgICAgICAgaWYgKCgoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgJiYgZS50eXBlID09PSAna2V5dXAnICYmICFBdXRvTnVtZXJpY0hlbHBlci5pc1VuZGVmaW5lZCh0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSkpIHx8IChlLnNoaWZ0S2V5ICYmIHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkluc2VydCkpIHtcbiAgICAgICAgICAgIC8vVE9ETyBNb3ZlIHRoaXMgdGVzdCBpbnNpZGUgdGhlIGBvbktleXVwYCBoYW5kbGVyXG4gICAgICAgICAgICB0aGlzLl9jaGVja1Bhc3RlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNraXAgYWxsIGZ1bmN0aW9uIGtleXMgKEYxLUYxMiksIFdpbmRvd3Mga2V5cywgdGFiIGFuZCBvdGhlciBzcGVjaWFsIGtleXNcbiAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuX3Nob3VsZFNraXBFdmVudEtleSh0aGlzLmV2ZW50S2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhIFwiU2VsZWN0IGFsbFwiIGtleWJvYXJkIHNob3J0Y3V0IGlzIGRldGVjdGVkIChjdHJsICsgYSlcbiAgICAgICAgaWYgKChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSAmJiB0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5hKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zZWxlY3ROdW1iZXJPbmx5KSB7XG4gICAgICAgICAgICAgICAgLy8gYHByZXZlbnREZWZhdWx0KClgIGlzIHVzZWQgaGVyZSB0byBwcmV2ZW50IHRoZSBicm93c2VyIHRvIGZpcnN0IHNlbGVjdCBhbGwgdGhlIGlucHV0IHRleHQgKGluY2x1ZGluZyB0aGUgY3VycmVuY3kgc2lnbiksIG90aGVyd2lzZSB3ZSB3b3VsZCBzZWUgdGhhdCB3aG9sZSBzZWxlY3Rpb24gZmlyc3QgaW4gYSBmbGFzaCwgdGhlbiB0aGUgc2VsZWN0aW9uIHdpdGggb25seSB0aGUgbnVtYmVyIHBhcnQgd2l0aG91dCB0aGUgY3VycmVuY3kgc2lnbi5cbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgLy9UT0RPIHJlcGxhY2UgYHNlbGVjdE51bWJlcmAgYnkgYHNlbGVjdGA/XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3ROdW1iZXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhIFwiQ29weVwiLCBcIlBhc3RlXCIgb3IgXCJDdXRcIiBrZXlib2FyZCBzaG9ydGN1dCBpcyBkZXRlY3RlZCAocmVzcGVjdGl2ZWx5ICdjdHJsICsgYycsICdjdHJsICsgdicgb3IgJ2N0cmwgKyB4JylcbiAgICAgICAgaWYgKChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSAmJiAodGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuYyB8fCB0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS52IHx8IHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLngpKSB7XG4gICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9leHBhbmRTZWxlY3Rpb25PblNpZ24oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVHJ5IHRvIHByZXZlbnQgd3JvbmcgcGFzdGVcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS52IHx8IHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkluc2VydCkge1xuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUgPSB0aGlzLl9nZXRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Bhc3RlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZS50eXBlID09PSAna2V5ZG93bicgfHwgZS50eXBlID09PSAna2V5cHJlc3MnIHx8IHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLmM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLlogfHwgdGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUueikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBKdW1wIG92ZXIgdGhlIHRob3VzYW5kIHNlcGFyYXRvclxuICAgICAgICAvL1RPRE8gTW92ZSB0aGlzIHRlc3QgaW5zaWRlIHRoZSBgb25LZXlkb3duYCBoYW5kbGVyXG4gICAgICAgIGlmICh0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5MZWZ0QXJyb3cgfHwgdGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuUmlnaHRBcnJvdykge1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nICYmICFlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuTGVmdEFycm93ICYmXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQgLSAyKSA9PT0gdGhpcy5zZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCAtIDIpID09PSB0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENhcmV0UG9zaXRpb24odGhpcy5zZWxlY3Rpb24uc3RhcnQgLSAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLlJpZ2h0QXJyb3cgJiZcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCArIDEpID09PSB0aGlzLnNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0ICsgMSkgPT09IHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2FyZXRQb3NpdGlvbih0aGlzLnNlbGVjdGlvbi5zdGFydCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQXV0b051bWVyaWNIZWxwZXIuaXNJbkFycmF5KHRoaXMuZXZlbnRLZXksIEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLl9kaXJlY3Rpb25LZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGRlbGV0aW9uIG9mIGNoYXJhY3RlcnMgd2hlbiB0aGUgbWludXMgc2lnbiBpcyB0byB0aGUgcmlnaHQgb2YgdGhlIG51bWVyaWMgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZWZ0IFRoZSBwYXJ0IG9uIHRoZSBsZWZ0IG9mIHRoZSBjYXJldCBvciBzZWxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmlnaHQgVGhlIHBhcnQgb24gdGhlIHJpZ2h0IG9mIHRoZSBjYXJldCBvciBzZWxlY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7W3N0cmluZywgc3RyaW5nXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wcm9jZXNzQ2hhcmFjdGVyRGVsZXRpb25JZlRyYWlsaW5nTmVnYXRpdmVTaWduKFtsZWZ0LCByaWdodF0pIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KTtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5wcmVmaXggJiYgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5zdWZmaXgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5CYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhcmV0Rml4ID0gKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHZhbHVlLmluZGV4T2YodGhpcy5zZXR0aW5ncy5zdWZmaXhUZXh0KSAmJiB0aGlzLnNldHRpbmdzLnN1ZmZpeFRleHQgIT09ICcnKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0IC0gMSkgPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSB2YWx1ZS5sZW5ndGggLSB0aGlzLnNldHRpbmdzLnN1ZmZpeFRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXJldEZpeCA9ICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB2YWx1ZS5pbmRleE9mKHRoaXMuc2V0dGluZ3Muc3VmZml4VGV4dCkgJiYgdGhpcy5zZXR0aW5ncy5zdWZmaXhUZXh0ICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHZhbHVlLmluZGV4T2YodGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCkgKyB0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNOZWdhdGl2ZShsZWZ0KSAmJiB2YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQpID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnN1ZmZpeCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LmxlZnQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdmFsdWUuaW5kZXhPZih0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgKyB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuQmFja3NwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09ICh2YWx1ZS5pbmRleE9mKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSArIHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyLmxlbmd0aCkgJiYgQXV0b051bWVyaWNIZWxwZXIuY29udGFpbnModmFsdWUsIHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJy0nICYmICgodGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gdmFsdWUuaW5kZXhPZih0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHx8ICFBdXRvTnVtZXJpY0hlbHBlci5jb250YWlucyh2YWx1ZSwgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRbMF0gPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSB2YWx1ZS5pbmRleE9mKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSAmJiBBdXRvTnVtZXJpY0hlbHBlci5jb250YWlucyh2YWx1ZSwgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5yaWdodDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXJldEZpeCA9ICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB2YWx1ZS5pbmRleE9mKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSArIHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5CYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gKHZhbHVlLmluZGV4T2YodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICsgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJy0nICYmIHRoaXMuc2VsZWN0aW9uLnN0YXJ0IDw9ICh2YWx1ZS5pbmRleE9mKHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSAtIHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnJyAmJiAhQXV0b051bWVyaWNIZWxwZXIuY29udGFpbnModmFsdWUsIHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXJldEZpeCA9ICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB2YWx1ZS5pbmRleE9mKHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wpICYmIHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgIT09ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gdmFsdWUuaW5kZXhPZih0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgZGVsZXRpb24gb2YgY2hhcmFjdGVycy5cbiAgICAgKi9cbiAgICBfcHJvY2Vzc0NoYXJhY3RlckRlbGV0aW9uKCkge1xuICAgICAgICBsZXQgbGVmdDtcbiAgICAgICAgbGV0IHJpZ2h0O1xuXG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0VW5mb3JtYXR0ZWRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgcmlnaHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aHJvd0lucHV0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzVHJhaWxpbmdOZWdhdGl2ZSAmJiBBdXRvTnVtZXJpY0hlbHBlci5pc05lZ2F0aXZlKEF1dG9OdW1lcmljSGVscGVyLmdldEVsZW1lbnRWYWx1ZSh0aGlzLmRvbUVsZW1lbnQpKSkge1xuICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLl9wcm9jZXNzQ2hhcmFjdGVyRGVsZXRpb25JZlRyYWlsaW5nTmVnYXRpdmVTaWduKFtsZWZ0LCByaWdodF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuQmFja3NwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZXhwYW5kU2VsZWN0aW9uT25TaWduKCk7XG4gICAgICAgICAgICBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0VW5mb3JtYXR0ZWRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIGEgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYWxsb3dlZCB0byBiZSB0eXBlZC5cbiAgICAgKiBJZiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHNob3duIG9uIGZvY3VzIGlzIHplcm8sIHRoZW4gdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIG5vdCBhbGxvd2VkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNEZWNpbWFsQ2hhcmFjdGVySW5zZXJ0aW9uQWxsb3dlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyAhPT0gQXV0b051bWVyaWMub3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzLm5vbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUga2V5IGlzIGFsbG93ZWQuXG4gICAgICogVGhpcyBmdW5jdGlvbiBkZWNpZGVzIGlmIHRoZSBrZXkgcHJlc3NlZCBzaG91bGQgYmUgZHJvcHBlZCBvciBhY2NlcHRlZCwgYW5kIG1vZGlmeSB0aGUgdmFsdWUgJ29uLXRoZS1mbHknIGFjY29yZGluZ2x5LlxuICAgICAqIC8vVE9ETyBUaGlzIHNob3VsZCB1c2UgYW5vdGhlciBmdW5jdGlvbiBpbiBvcmRlciB0byBzZXBhcmF0ZSB0aGUgdGVzdCBhbmQgdGhlIG1vZGlmaWNhdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgX3Byb2Nlc3NDaGFyYWN0ZXJJbnNlcnRpb24oKSB7XG4gICAgICAgIGxldCBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0VW5mb3JtYXR0ZWRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50S2V5ICE9PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5BbmRyb2lkRGVmYXVsdCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0lucHV0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHJ1bGVzIHdoZW4gdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGtleSBpcyBwcmVzc2VkIGFsd2F5cyB1c2UgbnVtZXJpYyBwYWQgZG90IHRvIGluc2VydCBkZWNpbWFsIHNlcGFyYXRvclxuICAgICAgICAvLyBEbyBub3QgYWxsb3cgZGVjaW1hbCBjaGFyYWN0ZXIgaWYgbm8gZGVjaW1hbCBwYXJ0IGFsbG93ZWRcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXkgPT09IHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciB8fFxuICAgICAgICAgICAgKHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlICYmIHRoaXMuZXZlbnRLZXkgPT09IHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSB8fFxuICAgICAgICAgICAgKHRoaXMuZXZlbnRLZXkgPT09ICcuJyB8fCB0aGlzLmV2ZW50S2V5ID09PSAnLCcgfHwgdGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuTnVtcGFkRG90KSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0RlY2ltYWxDaGFyYWN0ZXJJbnNlcnRpb25BbGxvd2VkKCkgfHwgIXRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEbyBub3QgYWxsb3cgZGVjaW1hbCBjaGFyYWN0ZXIgYmVmb3JlIG5lZ2F0aXZlU2lnbkNoYXJhY3RlciBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAmJiBBdXRvTnVtZXJpY0hlbHBlci5jb250YWlucyhyaWdodCwgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERvIG5vdCBhbGxvdyBhIGRlY2ltYWwgY2hhcmFjdGVyIGlmIGFub3RoZXIgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYWxyZWFkeSBwcmVzZW50XG4gICAgICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuY29udGFpbnMobGVmdCwgdGhpcy5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmlnaHQuaW5kZXhPZih0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmlnaHQuaW5kZXhPZih0aGlzLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHIoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlUGFydHMobGVmdCArIHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgcmlnaHQpO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXZlbnQgZW50ZXJpbmcgdGhlIG1pbnVzIHNpZ24gaWYgaXQncyBub3QgYWxsb3dlZCAoTm90ZTogYHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyYCBpcyBvbmx5IHNldCBpZiB0aGUgbWluaW11bVZhbHVlIG9yIG1heGltdW1WYWx1ZSBpcyBsb3dlciB0aGFuIHplcm8sIGFsbG93aW5nIG5lZ2F0aXZlIG51bWJlcnMgdG8gYmUgZW50ZXJlZClcbiAgICAgICAgaWYgKCh0aGlzLmV2ZW50S2V5ID09PSAnLScgfHwgdGhpcy5ldmVudEtleSA9PT0gJysnKSAmJiB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciA9PT0gJy0nKSB7XG4gICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgQXV0b051bWVyaWNIZWxwZXIuY29udGFpbnMocmlnaHQsIHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBpcyBvcmlnaW5hbGx5IG5lZ2F0aXZlICh3aXRoIGEgdHJhaWxpbmcgbmVnYXRpdmUgc2lnbilcbiAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnJlcGxhY2UodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIsICcnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNOZWdhdGl2ZShsZWZ0KSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBpcyBvcmlnaW5hbGx5IG5lZ2F0aXZlICh3aXRoIGEgbGVhZGluZyBuZWdhdGl2ZSBzaWduKVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbmVnYXRpdmUgc2lnbiwgZWZmZWN0aXZlbHkgY29udmVydGluZyB0aGUgdmFsdWUgdG8gYSBwb3NpdGl2ZSBvbmVcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5yZXBsYWNlKCctJywgJycpOyAvL1RPRE8gcmVwbGFjZSB3aXRoICcrJyBpZiBgc2hvd1Bvc2l0aXZlU2lnbmA/XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBpcyBvcmlnaW5hbGx5IHBvc2l0aXZlXG4gICAgICAgICAgICAgICAgbGVmdCA9IHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICsgbGVmdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgdHJpZXMgdG8gaW5zZXJ0IGEgZGlnaXQgYmVmb3JlIHRoZSBtaW51cyBzaWduXG4gICAgICAgIGNvbnN0IGV2ZW50TnVtYmVyID0gTnVtYmVyKHRoaXMuZXZlbnRLZXkpO1xuICAgICAgICBpZiAoZXZlbnROdW1iZXIgPj0gMCAmJiBldmVudE51bWJlciA8PSA5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgJiYgbGVmdCA9PT0gJycgJiYgQXV0b051bWVyaWNIZWxwZXIuY29udGFpbnMocmlnaHQsIHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcjtcbiAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5tYXhpbXVtVmFsdWUgPD0gMCAmJiB0aGlzLnNldHRpbmdzLm1pbmltdW1WYWx1ZSA8IHRoaXMuc2V0dGluZ3MubWF4aW11bVZhbHVlICYmICFBdXRvTnVtZXJpY0hlbHBlci5jb250YWlucyhBdXRvTnVtZXJpY0hlbHBlci5nZXRFbGVtZW50VmFsdWUodGhpcy5kb21FbGVtZW50KSwgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICYmIHRoaXMuZXZlbnRLZXkgIT09ICcwJykge1xuICAgICAgICAgICAgICAgIGxlZnQgPSB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciArIGxlZnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlUGFydHMobGVmdCArIHRoaXMuZXZlbnRLZXksIHJpZ2h0KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmV2ZW50IGFueSBvdGhlciBjaGFyYWN0ZXJzXG4gICAgICAgIHRoaXMudGhyb3dJbnB1dCA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXR0aW5nIG9mIGp1c3QgcHJvY2Vzc2VkIHZhbHVlIHdoaWxlIGtlZXBpbmcgdGhlIGN1cnNvciBwb3NpdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Zvcm1hdFZhbHVlKGUpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudFZhbHVlID0gQXV0b051bWVyaWNIZWxwZXIuZ2V0RWxlbWVudFZhbHVlKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgICAgIGxldCBbbGVmdF0gPSB0aGlzLl9nZXRVbmZvcm1hdHRlZExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcblxuICAgICAgICAvLyBObyBncm91cGluZyBzZXBhcmF0b3IgYW5kIG5vIGN1cnJlbmN5IHNpZ25cbiAgICAgICAgaWYgKCh0aGlzLnNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgID09PSAnJyB8fCAodGhpcy5zZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yICE9PSAnJyAgJiYgIUF1dG9OdW1lcmljSGVscGVyLmNvbnRhaW5zKGVsZW1lbnRWYWx1ZSwgdGhpcy5zZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yKSkpICYmXG4gICAgICAgICAgICAodGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCA9PT0gJycgfHwgKHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgIT09ICcnICYmICFBdXRvTnVtZXJpY0hlbHBlci5jb250YWlucyhlbGVtZW50VmFsdWUsIHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wpKSkpIHtcbiAgICAgICAgICAgIGxldCBbc3ViUGFydHNdID0gZWxlbWVudFZhbHVlLnNwbGl0KHRoaXMuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgICAgICBsZXQgbmVnYXRpdmVTaWduID0gJyc7XG4gICAgICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNOZWdhdGl2ZShzdWJQYXJ0cykpIHtcbiAgICAgICAgICAgICAgICBuZWdhdGl2ZVNpZ24gPSAnLSc7XG4gICAgICAgICAgICAgICAgc3ViUGFydHMgPSBzdWJQYXJ0cy5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgemVybyBvbiBwb3NpdGl2ZSB2YWx1ZSBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmIChuZWdhdGl2ZVNpZ24gPT09ICcnICYmIHN1YlBhcnRzLmxlbmd0aCA+IHRoaXMuc2V0dGluZ3MubUludFBvcyAmJiBsZWZ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgemVybyBvbiBuZWdhdGl2ZSB2YWx1ZSBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmIChuZWdhdGl2ZVNpZ24gPT09ICctJyAmJiBzdWJQYXJ0cy5sZW5ndGggPiB0aGlzLnNldHRpbmdzLm1JbnROZWcgJiYgbGVmdC5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZWZ0ID0gbmVnYXRpdmVTaWduICsgbGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rvci5fYWRkR3JvdXBTZXBhcmF0b3JzKGVsZW1lbnRWYWx1ZSwgdGhpcy5zZXR0aW5ncywgdGhpcy5pc0ZvY3VzZWQsIHRoaXMucmF3VmFsdWUpO1xuICAgICAgICBsZXQgcG9zaXRpb24gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gUHJlcGFyZSByZWdleHAgd2hpY2ggc2VhcmNoZXMgZm9yIGN1cnNvciBwb3NpdGlvbiBmcm9tIHVuZm9ybWF0dGVkIGxlZnQgcGFydFxuICAgICAgICAgICAgY29uc3QgbGVmdEFyID0gbGVmdC5zcGxpdCgnJyk7XG5cbiAgICAgICAgICAgIC8vIEZpeGVzIGNhcmV0IHBvc2l0aW9uIHdpdGggdHJhaWxpbmcgbWludXMgc2lnblxuICAgICAgICAgICAgaWYgKCh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnN1ZmZpeCB8fFxuICAgICAgICAgICAgICAgICh0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnByZWZpeCAmJiB0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnN1ZmZpeCkpICYmXG4gICAgICAgICAgICAgICAgbGVmdEFyWzBdID09PSAnLScgJiYgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgbGVmdEFyLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuZXZlbnRLZXkgPT09IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkJhY2tzcGFjZSB8fCB0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5EZWxldGUpICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FyZXRGaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnN1ZmZpeCAmJiB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LmxlZnQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5wcmVmaXggJiYgdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5zdWZmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXIucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXJldEZpeCA9IGUudHlwZSA9PT0gJ2tleWRvd24nO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQuc3VmZml4ICYmIHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25QYXJ0cyA9IHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlQ2hyID0gWydcXFxcJywgJ14nLCAnJCcsICcuJywgJ3wnLCAnPycsICcqJywgJysnLCAnKCcsICcpJywgJ1snXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVzY2FwZWRQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnblBhcnRzLmZvckVhY2goKGksIG1pbmlQYXJ0cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmlQYXJ0cyA9IHNpZ25QYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNJbkFycmF5KG1pbmlQYXJ0cywgZXNjYXBlQ2hyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaCgnXFxcXCcgKyBtaW5pUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWRQYXJ0cy5wdXNoKG1pbmlQYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5CYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXNoaW5nIHRoZSBlc2NhcGVkIHNpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKGVzY2FwZWRQYXJ0cy5qb2luKCcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcmV0Rml4ID0gZS50eXBlID09PSAna2V5ZG93bic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsZWZ0QXJbaV0ubWF0Y2goJ1xcXFxkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdEFyW2ldID0gJ1xcXFwnICsgbGVmdEFyW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbGVmdFJlZyA9IG5ldyBSZWdFeHAoJ14uKj8nICsgbGVmdEFyLmpvaW4oJy4qPycpKTtcblxuICAgICAgICAgICAgLy8gU2VhcmNoIGN1cnNvciBwb3NpdGlvbiBpbiBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgICAgICAgIGNvbnN0IG5ld0xlZnQgPSB2YWx1ZS5tYXRjaChsZWZ0UmVnKTtcbiAgICAgICAgICAgIGlmIChuZXdMZWZ0KSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBuZXdMZWZ0WzBdLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwb3NpdGl2ZSBzaWduIGlzIHNob3duLCBjYWxjdWxhdGUgdGhlIGNhcmV0IHBvc2l0aW9uIGFjY29yZGluZ2x5XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2hvd1Bvc2l0aXZlU2lnbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IDAgJiYgbmV3TGVmdC5pbnB1dC5jaGFyQXQoMCkgPT09IHRoaXMuc2V0dGluZ3MucG9zaXRpdmVTaWduQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IChuZXdMZWZ0LmlucHV0LmluZGV4T2YodGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCkgPT09IDEpID8gdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbC5sZW5ndGggKyAxIDogMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMCAmJiBuZXdMZWZ0LmlucHV0LmNoYXJBdCh0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCkgPT09IHRoaXMuc2V0dGluZ3MucG9zaXRpdmVTaWduQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBqdXN0IGJlZm9yZSB0aGUgc2lnbiB3aGljaCBpcyBpbiBwcmVmaXggcG9zaXRpb25cbiAgICAgICAgICAgICAgICBpZiAoKChwb3NpdGlvbiA9PT0gMCAmJiB2YWx1ZS5jaGFyQXQoMCkgIT09IHRoaXMuc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSB8fCAocG9zaXRpb24gPT09IDEgJiYgdmFsdWUuY2hhckF0KDApID09PSB0aGlzLnNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpICYmIHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgJiYgdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5wcmVmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgY2FyZXQgYWZ0ZXIgcHJlZml4IHNpZ25cbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIFNob3VsZCB0aGUgdGVzdCBiZSAnaXNOZWdhdGl2ZScgaW5zdGVhZCBvZiAnaXNOZWdhdGl2ZVN0cmljdCcgaW4gb3JkZXIgdG8gc2VhcmNoIGZvciAnLScgZXZlcnl3aGVyZSBpbiB0aGUgc3RyaW5nP1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wubGVuZ3RoICsgKEF1dG9OdW1lcmljSGVscGVyLmlzTmVnYXRpdmVTdHJpY3QodmFsdWUpID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgJiYgdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5zdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgY291bGQgbm90IGZpbmQgYSBwbGFjZSBmb3IgY3Vyc29yIGFuZCBoYXZlIGEgc2lnbiBhcyBhIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAvLyBQbGFjZSBjYXJldCBiZWZvcmUgc3VmZml4IGN1cnJlbmN5IHNpZ25cbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gLT0gdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3VmZml4VGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBjb3VsZCBub3QgZmluZCBhIHBsYWNlIGZvciBjdXJzb3IgYW5kIGhhdmUgYSBzdWZmaXhcbiAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgY2FyZXQgYmVmb3JlIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiAtPSB0aGlzLnNldHRpbmdzLnN1ZmZpeFRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgdXBkYXRlIHRoZSB2YWx1ZSBpZiBpdCBoYXMgY2hhbmdlZC4gVGhpcyBwcmV2ZW50cyBtb2RpZnlpbmcgdGhlIHNlbGVjdGlvbiwgaWYgYW55LlxuICAgICAgICBpZiAodmFsdWUgIT09IGVsZW1lbnRWYWx1ZSB8fFxuICAgICAgICAgICAgdmFsdWUgPT09IGVsZW1lbnRWYWx1ZSAmJiAodGhpcy5ldmVudEtleSA9PT0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUubnVtMCB8fCB0aGlzLmV2ZW50S2V5ID09PSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5udW1wYWQwKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3NldENhcmV0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYW5kcm9pZFNlbGVjdGlvblN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiBhbiBBbmRyb2lkIGJyb3dzZXIgaXMgZGV0ZWN0ZWQsIGZpeCB0aGUgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgICAgIC8vIFVuZm9ydHVuYXRlbHkgdGhpcyBkb2VzIG5vdCBmaXggYWxsIGFuZHJvaWQgYnJvd3NlcnMsIG9ubHkgQW5kcm9pZCBDaHJvbWUgY3VycmVudGx5LlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBkdWUgdG8gdGhlIGZhY3QgdGhvc2UgcHJvdmlkZSBkaWZmZXJlbnQgb3JkZXIgb2YgZXZlbnRzIGFuZC9vciBrZXljb2RlcyB0aHJvd24gKHRoaXMgaXMgYSByZWFsIG1lc3MgOnwpLlxuICAgICAgICAgICAgdGhpcy5fc2V0Q2FyZXRQb3NpdGlvbih0aGlzLmFuZHJvaWRTZWxlY3Rpb25TdGFydCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IHRydWU7IC8vVE9ETyBSZW5hbWUgYHRoaXMuZm9ybWF0dGVkYCB0byBgdGhpcy5fZm9ybWF0RXhlY3V0ZWRgLCBzaW5jZSBpdCdzIHBvc3NpYmxlIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgbmVlZCB0byBmb3JtYXQgYW55dGhpbmcgKGluIHRoZSBjYXNlIHdoZXJlIHRoZSBrZXljb2RlIGlzIGRyb3BwZWQgZm9yIGluc3RhbmNlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgZm9ybSBjaGlsZCA8aW5wdXQ+IGVsZW1lbnQgdmFsdWVzIHRvIGEgc3RyaW5nLCBvciBhbiBBcnJheS5cbiAgICAgKiBUaGUgb3V0cHV0IGZvcm1hdCBpcyBkZWZpbmVkIHdpdGggdGhlIGBmb3JtYXRUeXBlYCBhcmd1bWVudC5cbiAgICAgKiBUaGlzIGlzIGxvb3NlbHkgYmFzZWQgdXBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MDcwNTk5My8yODM0ODk4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRm9ybUVsZW1lbnR9IGZvcm1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGludG9BbkFycmF5IElmIGB0cnVlYCwgaW5zdGVhZCBvZiBnZW5lcmF0aW5nIGEgc3RyaW5nLCBpdCBnZW5lcmF0ZXMgYW4gQXJyYXkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdFR5cGUgSWYgYCd1bmZvcm1hdHRlZCdgLCB0aGVuIHRoZSBBdXRvTnVtZXJpYyBlbGVtZW50cyB2YWx1ZXMgYXJlIHVuZm9ybWF0dGVkLCBpZiBgJ2xvY2FsaXplZCdgLCB0aGVuIHRoZSBBdXRvTnVtZXJpYyBlbGVtZW50cyB2YWx1ZXMgYXJlIGxvY2FsaXplZCwgYW5kIGlmIGAnZm9ybWF0dGVkJ2AsIHRoZW4gdGhlIEF1dG9OdW1lcmljIGVsZW1lbnRzIHZhbHVlcyBhcmUga2VwdCBmb3JtYXR0ZWQuIEluIGVpdGhlciB3YXksIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgbW9kaWZ5IHRoZSB2YWx1ZSBvZiBlYWNoIERPTSBlbGVtZW50LCBidXQgb25seSBhZmZlY3QgdGhlIHZhbHVlIHRoYXQgaXMgcmV0dXJuZWQgYnkgdGhhdCBzZXJpYWxpemUgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcmlhbGl6ZWRTcGFjZUNoYXJhY3RlciBDYW4gZWl0aGVyIGJlIHRoZSAnKycgY2hhcmFjdGVyLCBvciB0aGUgJyUyMCcgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IGZvcmNlZE91dHB1dEZvcm1hdCBJZiBzZXQsIHRoZW4gdGhpcyBpcyB0aGUgZm9ybWF0IHRoYXQgaXMgdXNlZCBmb3IgdGhlIGxvY2FsaXphdGlvbiwgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBgb3V0cHV0Rm9ybWF0YCBvcHRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ3xBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBfc2VyaWFsaXplKGZvcm0sIGludG9BbkFycmF5ID0gZmFsc2UsIGZvcm1hdFR5cGUgPSAndW5mb3JtYXR0ZWQnLCBzZXJpYWxpemVkU3BhY2VDaGFyYWN0ZXIgPSAnKycsIGZvcmNlZE91dHB1dEZvcm1hdCA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtID09PSAnb2JqZWN0JyAmJiBmb3JtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdmb3JtJykge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZm9ybS5lbGVtZW50cykuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5uYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICFlbGVtZW50LmRpc2FibGVkICYmXG4gICAgICAgICAgICAgICAgICAgIFsnZmlsZScsICdyZXNldCcsICdzdWJtaXQnLCAnYnV0dG9uJ10uaW5kZXhPZihlbGVtZW50LnR5cGUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSAnc2VsZWN0LW11bHRpcGxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWxlbWVudC5vcHRpb25zKS5mb3JFYWNoKG9wdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gU2hvdWxkIHdlIHVuZm9ybWF0L2Zvcm1hdC9sb2NhbGl6ZSB0aGUgc2VsZWN0aW9uIG9wdGlvbiAod2hpY2ggYmUgZGVmYXVsdCBzaG91bGQgYmUgcmVhZC1vbmx5KT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGludG9BbkFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IG5hbWU6IGVsZW1lbnQubmFtZSwgdmFsdWU6IG9wdGlvbi52YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gaW50byBhIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGVsZW1lbnQubmFtZSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbi52YWx1ZSl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChbJ2NoZWNrYm94JywgJ3JhZGlvJ10uaW5kZXhPZihlbGVtZW50LnR5cGUpID09PSAtMSB8fCBlbGVtZW50LmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZVJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTWFuYWdlZEJ5QXV0b051bWVyaWMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYW5PYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VuZm9ybWF0dGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuT2JqZWN0ID0gdGhpcy5nZXRBdXRvTnVtZXJpY0VsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChhbk9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVJlc3VsdCA9IHRoaXMudW5mb3JtYXQoZWxlbWVudCwgYW5PYmplY3QuZ2V0U2V0dGluZ3MoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbG9jYWxpemVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuT2JqZWN0ID0gdGhpcy5nZXRBdXRvTnVtZXJpY0VsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChhbk9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIZXJlIEkgbmVlZCB0byBjbG9uZSB0aGUgc2V0dGluZyBvYmplY3QsIG90aGVyd2lzZSBJIHdvdWxkIG1vZGlmeSBpdCB3aGVuIGNoYW5naW5nIHRoZSBgb3V0cHV0Rm9ybWF0YCBvcHRpb24gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U2V0dGluZ3MgPSBBdXRvTnVtZXJpY0hlbHBlci5jbG9uZU9iamVjdChhbk9iamVjdC5nZXRTZXR0aW5ncygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUF1dG9OdW1lcmljSGVscGVyLmlzTnVsbChmb3JjZWRPdXRwdXRGb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXR0aW5ncy5vdXRwdXRGb3JtYXQgPSBmb3JjZWRPdXRwdXRGb3JtYXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVSZXN1bHQgPSB0aGlzLmxvY2FsaXplKGVsZW1lbnQsIGN1cnJlbnRTZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9ybWF0dGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlUmVzdWx0ID0gZWxlbWVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlUmVzdWx0ID0gZWxlbWVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEF1dG9OdW1lcmljSGVscGVyLmlzVW5kZWZpbmVkKHZhbHVlUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoJ1RoaXMgZXJyb3Igc2hvdWxkIG5ldmVyIGJlIGhpdC4gSWYgaXQgaGFzLCBzb21ldGhpbmcgcmVhbGx5IHdyb25nIGhhcHBlbmVkIScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW50b0FuQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IG5hbWU6IGVsZW1lbnQubmFtZSwgdmFsdWU6IHZhbHVlUmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gaW50byBhIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGAke2VuY29kZVVSSUNvbXBvbmVudChlbGVtZW50Lm5hbWUpfT0ke2VuY29kZVVSSUNvbXBvbmVudCh2YWx1ZVJlc3VsdCl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmaW5hbFJlc3VsdDtcblxuICAgICAgICBpZiAoaW50b0FuQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIFJlc3VsdCBhcyBhbiBBcnJheVxuICAgICAgICAgICAgLy8gTm90ZTogYHNlcmlhbGl6ZWRTcGFjZUNoYXJhY3RlcmAgZG9lcyBub3QgYWZmZWN0IHRoZSBhcnJheSByZXN1bHQgc2luY2Ugd2UgZG8gbm90IGNoYW5nZSB0aGUgc3BhY2UgY2hhcmFjdGVyIGZvciB0aGlzIG9uZVxuICAgICAgICAgICAgZmluYWxSZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZXN1bHQgYXMgYSBzdHJpbmdcbiAgICAgICAgICAgIGZpbmFsUmVzdWx0ID0gcmVzdWx0LmpvaW4oJyYnKTtcblxuICAgICAgICAgICAgaWYgKCcrJyA9PT0gc2VyaWFsaXplZFNwYWNlQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgZmluYWxSZXN1bHQgPSBmaW5hbFJlc3VsdC5yZXBsYWNlKC8lMjAvZywgJysnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaW5hbFJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIGZvcm0gdmFsdWVzIHRvIGEgc3RyaW5nLCBvdXRwdXR0aW5nIG51bWVyaWMgc3RyaW5ncyBmb3IgZWFjaCBBdXRvTnVtZXJpYy1tYW5hZ2VkIGVsZW1lbnQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRm9ybUVsZW1lbnR9IGZvcm1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VyaWFsaXplZFNwYWNlQ2hhcmFjdGVyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgX3NlcmlhbGl6ZU51bWVyaWNTdHJpbmcoZm9ybSwgc2VyaWFsaXplZFNwYWNlQ2hhcmFjdGVyID0gJysnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemUoZm9ybSwgZmFsc2UsICd1bmZvcm1hdHRlZCcsIHNlcmlhbGl6ZWRTcGFjZUNoYXJhY3Rlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBmb3JtIHZhbHVlcyB0byBhIHN0cmluZywgb3V0cHV0dGluZyB0aGUgZm9ybWF0dGVkIHZhbHVlIGFzIHN0cmluZ3MgZm9yIGVhY2ggQXV0b051bWVyaWMtbWFuYWdlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEZvcm1FbGVtZW50fSBmb3JtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcmlhbGl6ZWRTcGFjZUNoYXJhY3RlclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIF9zZXJpYWxpemVGb3JtYXR0ZWQoZm9ybSwgc2VyaWFsaXplZFNwYWNlQ2hhcmFjdGVyID0gJysnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemUoZm9ybSwgZmFsc2UsICdmb3JtYXR0ZWQnLCBzZXJpYWxpemVkU3BhY2VDaGFyYWN0ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgZm9ybSB2YWx1ZXMgdG8gYSBzdHJpbmcsIG91dHB1dHRpbmcgbG9jYWxpemVkIHN0cmluZ3MgZm9yIGVhY2ggQXV0b051bWVyaWMtbWFuYWdlZCBlbGVtZW50IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEZvcm1FbGVtZW50fSBmb3JtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcmlhbGl6ZWRTcGFjZUNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IGZvcmNlZE91dHB1dEZvcm1hdCBJZiBzZXQsIHRoZW4gdGhpcyBpcyB0aGUgZm9ybWF0IHRoYXQgaXMgdXNlZCBmb3IgdGhlIGxvY2FsaXphdGlvbiwgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBgb3V0cHV0Rm9ybWF0YCBvcHRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgX3NlcmlhbGl6ZUxvY2FsaXplZChmb3JtLCBzZXJpYWxpemVkU3BhY2VDaGFyYWN0ZXIgPSAnKycsIGZvcmNlZE91dHB1dEZvcm1hdCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZShmb3JtLCBmYWxzZSwgJ2xvY2FsaXplZCcsIHNlcmlhbGl6ZWRTcGFjZUNoYXJhY3RlciwgZm9yY2VkT3V0cHV0Rm9ybWF0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBBcnJheSB3aXRoIHRoZSBmb3JtIHZhbHVlcywgb3V0cHV0dGluZyBudW1lcmljIHN0cmluZ3MgZm9yIGVhY2ggQXV0b051bWVyaWMtbWFuYWdlZCBlbGVtZW50IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEZvcm1FbGVtZW50fSBmb3JtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcmlhbGl6ZWRTcGFjZUNoYXJhY3RlclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBzdGF0aWMgX3NlcmlhbGl6ZU51bWVyaWNTdHJpbmdBcnJheShmb3JtLCBzZXJpYWxpemVkU3BhY2VDaGFyYWN0ZXIgPSAnKycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZShmb3JtLCB0cnVlLCAndW5mb3JtYXR0ZWQnLCBzZXJpYWxpemVkU3BhY2VDaGFyYWN0ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGFuIEFycmF5IHdpdGggdGhlIGZvcm0gdmFsdWVzLCBvdXRwdXR0aW5nIHRoZSBmb3JtYXR0ZWQgdmFsdWUgYXMgc3RyaW5ncyBmb3IgZWFjaCBBdXRvTnVtZXJpYy1tYW5hZ2VkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRm9ybUVsZW1lbnR9IGZvcm1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VyaWFsaXplZFNwYWNlQ2hhcmFjdGVyXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBfc2VyaWFsaXplRm9ybWF0dGVkQXJyYXkoZm9ybSwgc2VyaWFsaXplZFNwYWNlQ2hhcmFjdGVyID0gJysnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemUoZm9ybSwgdHJ1ZSwgJ2Zvcm1hdHRlZCcsIHNlcmlhbGl6ZWRTcGFjZUNoYXJhY3Rlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW4gQXJyYXkgd2l0aCB0aGUgZm9ybSB2YWx1ZXMsIG91dHB1dHRpbmcgbG9jYWxpemVkIHN0cmluZ3MgZm9yIGVhY2ggQXV0b051bWVyaWMtbWFuYWdlZCBlbGVtZW50IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEZvcm1FbGVtZW50fSBmb3JtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcmlhbGl6ZWRTcGFjZUNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IGZvcmNlZE91dHB1dEZvcm1hdCBJZiBzZXQsIHRoZW4gdGhpcyBpcyB0aGUgZm9ybWF0IHRoYXQgaXMgdXNlZCBmb3IgdGhlIGxvY2FsaXphdGlvbiwgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBgb3V0cHV0Rm9ybWF0YCBvcHRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHN0YXRpYyBfc2VyaWFsaXplTG9jYWxpemVkQXJyYXkoZm9ybSwgc2VyaWFsaXplZFNwYWNlQ2hhcmFjdGVyID0gJysnLCBmb3JjZWRPdXRwdXRGb3JtYXQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemUoZm9ybSwgdHJ1ZSwgJ2xvY2FsaXplZCcsIHNlcmlhbGl6ZWRTcGFjZUNoYXJhY3RlciwgZm9yY2VkT3V0cHV0Rm9ybWF0KTtcbiAgICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBtdWx0aXBsZSBET00gZWxlbWVudHMgaW4gb25lIGNhbGwgKGFuZCBwb3NzaWJseSBwYXNzIG11bHRpcGxlIHZhbHVlcyB0aGF0IHdpbGwgYmUgbWFwcGVkIHRvIGVhY2ggRE9NIGVsZW1lbnQpLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJbml0IG11bHRpcGxlIERPTSBlbGVtZW50cyBpbiBvbmUgY2FsbCAoYW5kIHBvc3NpYmx5IHBhc3MgbXVsdGlwbGUgdmFsdWVzIHRoYXQgd2lsbCBiZSBtYXBwZWQgdG8gZWFjaCBET00gZWxlbWVudClcbiAqIFthbkVsZW1lbnQxLCBhbkVsZW1lbnQyLCBhbkVsZW1lbnQzXSA9IEF1dG9OdW1lcmljLm11bHRpcGxlKFtkb21FbGVtZW50MSwgZG9tRWxlbWVudDIsIGRvbUVsZW1lbnQzXSwgeyBvcHRpb25zIH0pO1xuICogW2FuRWxlbWVudDEsIGFuRWxlbWVudDIsIGFuRWxlbWVudDNdID0gQXV0b051bWVyaWMubXVsdGlwbGUoW2RvbUVsZW1lbnQxLCBkb21FbGVtZW50MiwgZG9tRWxlbWVudDNdLCBbeyBvcHRpb25zIH0sICdldXJvUG9zJ10pO1xuICogW2FuRWxlbWVudDEsIGFuRWxlbWVudDIsIGFuRWxlbWVudDNdID0gQXV0b051bWVyaWMubXVsdGlwbGUoW2RvbUVsZW1lbnQxLCBkb21FbGVtZW50MiwgZG9tRWxlbWVudDNdLCAxMjM0NS43ODksIHsgb3B0aW9ucyB9KTtcbiAqIFthbkVsZW1lbnQxLCBhbkVsZW1lbnQyLCBhbkVsZW1lbnQzXSA9IEF1dG9OdW1lcmljLm11bHRpcGxlKFtkb21FbGVtZW50MSwgZG9tRWxlbWVudDIsIGRvbUVsZW1lbnQzXSwgMTIzNDUuNzg5LCBbeyBvcHRpb25zIH0sICdldXJvUG9zJ10pO1xuICogW2FuRWxlbWVudDEsIGFuRWxlbWVudDIsIGFuRWxlbWVudDNdID0gQXV0b051bWVyaWMubXVsdGlwbGUuZnJlbmNoKFtkb21FbGVtZW50MSwgZG9tRWxlbWVudDIsIGRvbUVsZW1lbnQzXSwgWzEyMzQ1Ljc4OSwgMjM0Ljc4LCBudWxsXSwgeyBvcHRpb25zIH0pO1xuICogW2FuRWxlbWVudDEsIGFuRWxlbWVudDIsIGFuRWxlbWVudDNdID0gQXV0b051bWVyaWMubXVsdGlwbGUuZnJlbmNoKFtkb21FbGVtZW50MSwgZG9tRWxlbWVudDIsIGRvbUVsZW1lbnQzXSwgWzEyMzQ1Ljc4OSwgMjM0Ljc4LCBudWxsXSwgW3sgb3B0aW9ucyB9LCAnZXVyb1BvcyddKTtcbiAqXG4gKiAvLyBTcGVjaWFsIGNhc2UsIGlmIGEgPGZvcm0+IGVsZW1lbnQgaXMgcGFzc2VkIChvciBhbnkgb3RoZXIgJ3BhcmVudCcgKG9yICdyb290JykgRE9NIGVsZW1lbnQpLCB0aGVuIGF1dG9OdW1lcmljIHdpbGwgaW5pdGlhbGl6ZSBlYWNoIGNoaWxkIGA8aW5wdXQ+YCBlbGVtZW50cyByZWN1cnNpdmVseSwgaWdub3JpbmcgdGhvc2UgcmVmZXJlbmNlZCBpbiB0aGUgYGV4Y2x1ZGVgIGF0dHJpYnV0ZVxuICogW2FuRWxlbWVudDEsIGFuRWxlbWVudDJdID0gQXV0b051bWVyaWMubXVsdGlwbGUoeyByb290RWxlbWVudDogZm9ybUVsZW1lbnQgfSwgeyBvcHRpb25zIH0pO1xuICogW2FuRWxlbWVudDEsIGFuRWxlbWVudDJdID0gQXV0b051bWVyaWMubXVsdGlwbGUoeyByb290RWxlbWVudDogZm9ybUVsZW1lbnQsIGV4Y2x1ZGUgOiBbaGlkZGVuRWxlbWVudCwgdG9rZW5FbGVtZW50XSB9LCB7IG9wdGlvbnMgfSk7XG4gKiBbYW5FbGVtZW50MSwgYW5FbGVtZW50Ml0gPSBBdXRvTnVtZXJpYy5tdWx0aXBsZSh7IHJvb3RFbGVtZW50OiBmb3JtRWxlbWVudCwgZXhjbHVkZSA6IFtoaWRkZW5FbGVtZW50LCB0b2tlbkVsZW1lbnRdIH0sIFsxMjM0NS43ODksIG51bGxdLCB7IG9wdGlvbnMgfSk7XG4gKlxuICogLy8gSWYgeW91IHdhbnQgdG8gc2VsZWN0IG11bHRpcGxlIGVsZW1lbnRzIHZpYSBhIGNzcyBzZWxlY3RvciwgdGhlbiB5b3UgbXVzdCB1c2UgdGhlIGBtdWx0aXBsZWAgZnVuY3Rpb24uIFVuZGVyIHRoZSBob29kIGBRdWVyeVNlbGVjdG9yQWxsYCBpcyB1c2VkLlxuICogW2FuRWxlbWVudDEsIGFuRWxlbWVudDJdID0gQXV0b051bWVyaWMubXVsdGlwbGUoJy5teUNzc0NsYXNzID4gaW5wdXQnLCB7IG9wdGlvbnMgfSk7IC8vIFRoaXMgYWx3YXlzIHJldHVybiBhbiBBcnJheSwgZXZlbiBpZiB0aGVyZSBpcyBvbmx5IG9uZSBlbGVtZW50IHNlbGVjdGVkXG4gKiBbYW5FbGVtZW50MSwgYW5FbGVtZW50Ml0gPSBBdXRvTnVtZXJpYy5tdWx0aXBsZSgnLm15Q3NzQ2xhc3MgPiBpbnB1dCcsIFtudWxsLCAxMjM0NS43ODldLCB7IG9wdGlvbnMgfSk7IC8vIElkZW0gYWJvdmUsIGJ1dCB3aXRoIHBhc3NpbmcgdGhlIGluaXRpYWwgdmFsdWVzIHRvb1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fHsgcm9vdEVsZW1lbnQ6IEhUTUxFbGVtZW50IH18eyByb290RWxlbWVudDogSFRNTEVsZW1lbnQsIGV4Y2x1ZGU6IEFycmF5PEhUTUxJbnB1dEVsZW1lbnQ+fX0gYXJnMVxuICogQHBhcmFtIHtudW1iZXJ8QXJyYXl8b2JqZWN0fG51bGx9IGluaXRpYWxWYWx1ZVxuICogQHBhcmFtIHtvYmplY3R8QXJyYXl8bnVsbH0gb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5fVxuICovXG5BdXRvTnVtZXJpYy5tdWx0aXBsZSA9IChhcmcxLCBpbml0aWFsVmFsdWUgPSBudWxsLCBvcHRpb25zID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgLy8gQW5hbHl6ZSB0aGUgYXJndW1lbnRzIGFuZCB0cmFuc2Zvcm0gdGhlbSB0byBtYWtlIHRoZW0gZXhwbG9pdGFibGVcbiAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNPYmplY3QoaW5pdGlhbFZhbHVlKSkge1xuICAgICAgICAvLyBJZiB0aGUgdXNlciBnYXZlIGFuIG9wdGlvbiBvYmplY3QgYXMgdGhlIHNlY29uZCBhcmd1bWVudCwgaW5zdGVhZCBvZiB0aGUgaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgb3B0aW9ucyA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgaW5pdGlhbFZhbHVlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoQXV0b051bWVyaWNIZWxwZXIuaXNTdHJpbmcoYXJnMSkpIHtcbiAgICAgICAgYXJnMSA9IFsuLi4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChhcmcxKV07IC8vIENvbnZlcnQgYSBOb2RlTGlzdCB0byBhbiBBcnJheSAoY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM3Mjk3MjkyLzI4MzQ4OTgpXG4gICAgfSBlbHNlIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc09iamVjdChhcmcxKSkge1xuICAgICAgICBpZiAoIWFyZzEuaGFzT3duUHJvcGVydHkoJ3Jvb3RFbGVtZW50JykpIHtcbiAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSBvYmplY3QgcGFzc2VkIHRvIHRoZSAnbXVsdGlwbGUnIGZ1bmN0aW9uIGlzIGludmFsaWQgOyBubyAncm9vdEVsZW1lbnQnIGF0dHJpYnV0ZSBmb3VuZC5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHJpZXZlIHRoZSBET00gZWxlbWVudCBsaXN0IGZyb20gdGhlIGdpdmVuIDxmb3JtPiBlbGVtZW50XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gWy4uLiBhcmcxLnJvb3RFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0JyldO1xuICAgICAgICBpZiAoYXJnMS5oYXNPd25Qcm9wZXJ0eSgnZXhjbHVkZScpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnMS5leGNsdWRlKSkge1xuICAgICAgICAgICAgICAgIEF1dG9OdW1lcmljSGVscGVyLnRocm93RXJyb3IoYFRoZSAnZXhjbHVkZScgYXJyYXkgcGFzc2VkIHRvIHRoZSAnbXVsdGlwbGUnIGZ1bmN0aW9uIGlzIGludmFsaWQuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgdGhlIGV4Y2x1ZGVkIGVsZW1lbnRzXG4gICAgICAgICAgICBhcmcxID0gQXV0b051bWVyaWNIZWxwZXIuZmlsdGVyT3V0KGVsZW1lbnRzLCBhcmcxLmV4Y2x1ZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJnMSA9IGVsZW1lbnRzO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNBcnJheShhcmcxKSkge1xuICAgICAgICBBdXRvTnVtZXJpY0hlbHBlci50aHJvd0Vycm9yKGBUaGUgZ2l2ZW4gcGFyYW1ldGVycyB0byB0aGUgJ211bHRpcGxlJyBmdW5jdGlvbiBhcmUgaW52YWxpZC5gKTtcbiAgICB9XG5cbiAgICBpZiAoYXJnMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbGV0IHNob3dXYXJuaW5ncyA9IHRydWU7XG4gICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKG9wdGlvbnMpICYmIEF1dG9OdW1lcmljSGVscGVyLmlzQm9vbGVhbihvcHRpb25zLnNob3dXYXJuaW5ncykpIHtcbiAgICAgICAgICAgIHNob3dXYXJuaW5ncyA9IG9wdGlvbnMuc2hvd1dhcm5pbmdzO1xuICAgICAgICB9XG5cbiAgICAgICAgQXV0b051bWVyaWNIZWxwZXIud2FybmluZyhgTm8gdmFsaWQgRE9NIGVsZW1lbnRzIHdlcmUgZ2l2ZW4gaGVuY2Ugbm8gQXV0b051bWVyaWMgb2JqZWN0IHdlcmUgaW5zdGFudGlhdGVkLmAsIHNob3dXYXJuaW5ncyk7XG5cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGtub3cgYGFyZzFgIGlzIGFuIGFycmF5IG9mIERPTSBlbGVtZW50c1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBjYW4gYmUgaW5pdGlhbGl6ZWQgd2l0aCB0d28gdHlwZXMgb2YgYXJyYXksIG9uZSBmb3IgdGhlIGluaXRpYWwgdmFsdWVzLCBhbmQvb3Igb25lIGZvciB0aGUgb3B0aW9ucy5cbiAgICAvLyBTbyB3ZSBuZWVkIHRvIGZpbmQgb3V0IGlmIGFuIGFycmF5IGlzIGRldGVjdGVkIGlmIHRoZSB1c2VyIHBhc3NlZCBhbiBhcnJheSBvZiBpbml0aWFsIHZhbHVlcywgb3IgYW4gYXJyYXkgb2Ygb3B0aW9uc1xuICAgIC8vIFRoZXJlZm9yZSwgd2UgYW5hbHl6ZSB0aGUgY29udGVudCBvZiB0aGUgYXJyYXlzIGZvciB0aGUgc2Vjb25kIGFuZCB0aGlyZCBhcmd1bWVudHNcbiAgICAvLyAuLi5mb3IgdGhlIHNlY29uZCBwYXJhbWV0ZXIgOlxuICAgIGNvbnN0IGlzSW5pdGlhbFZhbHVlQXJyYXkgPSBBdXRvTnVtZXJpY0hlbHBlci5pc0FycmF5KGluaXRpYWxWYWx1ZSk7XG4gICAgY29uc3QgaXNJbml0aWFsVmFsdWVBcnJheUFuZE5vdEVtcHR5ID0gaXNJbml0aWFsVmFsdWVBcnJheSAmJiBpbml0aWFsVmFsdWUubGVuZ3RoID49IDE7XG4gICAgbGV0IHNlY29uZEFyZ3VtZW50SXNJbml0aWFsVmFsdWVBcnJheSA9IGZhbHNlO1xuICAgIGxldCBzZWNvbmRBcmd1bWVudElzT3B0aW9uQXJyYXkgPSBmYWxzZTtcbiAgICAvLyBBbnkgb2YgdGhlIGFycmF5cyBjYW4gYmUgZWl0aGVyIGFuIGFycmF5IG9mIGluaXRpYWwgdmFsdWVzLCBvciBhbiBhcnJheSBvZiBvcHRpb24gb2JqZWN0L3ByZS1kZWZpbmVkIG9wdGlvbiBuYW1lc1xuICAgIGlmIChpc0luaXRpYWxWYWx1ZUFycmF5QW5kTm90RW1wdHkpIHtcbiAgICAgICAgY29uc3QgdHlwZU9mRmlyc3RBcnJheUVsZW1lbnQgPSB0eXBlb2YgTnVtYmVyKGluaXRpYWxWYWx1ZVswXSk7XG4gICAgICAgIC8vIEZpcnN0IHdlIHRlc3QgdGhlIHNlY29uZCBhcmd1bWVudFxuICAgICAgICBzZWNvbmRBcmd1bWVudElzSW5pdGlhbFZhbHVlQXJyYXkgPSB0eXBlT2ZGaXJzdEFycmF5RWxlbWVudCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKE51bWJlcihpbml0aWFsVmFsdWVbMF0pKTtcblxuICAgICAgICBpZiAoIXNlY29uZEFyZ3VtZW50SXNJbml0aWFsVmFsdWVBcnJheSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHNlY29uZCBhcmd1bWVudCBpcyBhbiBhcnJheSwgYnV0IG5vdCBhbiBhcnJheSBvZiB2YWx1ZXMsIGNoZWNrIGlmIGl0J3MgaW5zdGVhZCBhbiBhcnJheSBvZiBvcHRpb25zL3ByZS1kZWZpbmVkIG9wdGlvbiBuYW1lc1xuICAgICAgICAgICAgaWYgKHR5cGVPZkZpcnN0QXJyYXlFbGVtZW50ID09PSAnc3RyaW5nJyB8fCBpc05hTih0eXBlT2ZGaXJzdEFycmF5RWxlbWVudCkgfHwgdHlwZU9mRmlyc3RBcnJheUVsZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgc2Vjb25kQXJndW1lbnRJc09wdGlvbkFycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIC4uLmZvciB0aGUgdGhpcmQgcGFyYW1ldGVyIDpcbiAgICBjb25zdCBpc09wdGlvbnNBcnJheUFuZE5vdEVtcHR5ID0gQXV0b051bWVyaWNIZWxwZXIuaXNBcnJheShvcHRpb25zKSAmJiBvcHRpb25zLmxlbmd0aCA+PSAxO1xuICAgIGxldCB0aGlyZEFyZ3VtZW50SXNPcHRpb25BcnJheSA9IGZhbHNlO1xuICAgIGlmIChpc09wdGlvbnNBcnJheUFuZE5vdEVtcHR5KSB7XG4gICAgICAgIGNvbnN0IHR5cGVPZkZpcnN0QXJyYXlFbGVtZW50ID0gdHlwZW9mIG9wdGlvbnNbMF07XG4gICAgICAgIGlmICh0eXBlT2ZGaXJzdEFycmF5RWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZU9mRmlyc3RBcnJheUVsZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdGhpcmQgYXJndW1lbnQgaXMgYW4gYXJyYXkgb2Ygb3B0aW9ucy9wcmUtZGVmaW5lZCBvcHRpb24gbmFtZXNcbiAgICAgICAgICAgIHRoaXJkQXJndW1lbnRJc09wdGlvbkFycmF5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlcGVuZGluZyBvZiBvdXIgZmluZGluZ3MsIHdlIGdlbmVyYXRlIHRoZSBvcHRpb25zIHZhcmlhYmxlIHRvIHVzZSBgb3B0aW9uc1RvVXNlYCwgZWl0aGVyIGRpcmVjdGx5LCBvciBtZXJnZWRcbiAgICBsZXQgb3B0aW9uc1RvVXNlO1xuICAgIGlmIChzZWNvbmRBcmd1bWVudElzT3B0aW9uQXJyYXkpIHtcbiAgICAgICAgb3B0aW9uc1RvVXNlID0gQXV0b051bWVyaWMubWVyZ2VPcHRpb25zKGluaXRpYWxWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlyZEFyZ3VtZW50SXNPcHRpb25BcnJheSkge1xuICAgICAgICBvcHRpb25zVG9Vc2UgPSBBdXRvTnVtZXJpYy5tZXJnZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9uc1RvVXNlID0gb3B0aW9ucztcbiAgICB9XG5cblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGluaXRpYWwgdmFsdWVzXG4gICAgY29uc3QgaXNJbml0aWFsVmFsdWVOdW1iZXIgPSBBdXRvTnVtZXJpY0hlbHBlci5pc051bWJlcihpbml0aWFsVmFsdWUpO1xuICAgIGxldCBpbml0aWFsVmFsdWVBcnJheVNpemU7XG4gICAgaWYgKHNlY29uZEFyZ3VtZW50SXNJbml0aWFsVmFsdWVBcnJheSkge1xuICAgICAgICBpbml0aWFsVmFsdWVBcnJheVNpemUgPSBpbml0aWFsVmFsdWUubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIEluc3RhbnRpYXRlIGVhY2ggQXV0b051bWVyaWMgb2JqZWN0c1xuICAgIGFyZzEuZm9yRWFjaCgoZG9tRWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGlzSW5pdGlhbFZhbHVlTnVtYmVyKSB7XG4gICAgICAgICAgICAvLyBXZSBzZXQgdGhlIHNhbWUgdmFsdWUgZm9yIGVhY2ggZWxlbWVudHNcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50LCBpbml0aWFsVmFsdWUsIG9wdGlvbnNUb1VzZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNlY29uZEFyZ3VtZW50SXNJbml0aWFsVmFsdWVBcnJheSAmJiBpbmRleCA8PSBpbml0aWFsVmFsdWVBcnJheVNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50LCBpbml0aWFsVmFsdWVbaW5kZXhdLCBvcHRpb25zVG9Vc2UpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50LCBudWxsLCBvcHRpb25zVG9Vc2UpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUG9seWZpbGwgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvQ3VzdG9tRXZlbnQgZm9yIG9ic29sZXRlIGJyb3dzZXJzIChJRSlcbiAqIC8vVE9ETyBNYWtlIHN1cmUgd2UgY2FsbCB0aGF0IGF0IGxlYXN0IG9uY2Ugd2hlbiBsb2FkaW5nIHRoZSBBdXRvTnVtZXJpYyBsaWJyYXJ5XG4gKi9cbihmdW5jdGlvbigpIHtcbmlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHsgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlLCBkZXRhaWw6IHZvaWQoMCkgfTtcbiAgICBjb25zdCBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgIHJldHVybiBldnQ7XG59XG5cbkN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG53aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudDtcbn0pKCk7XG5cblxuLyoqXG4gKiAvL1hYWCBUaGlzIGlzIG5lZWRlZCBpbiBvcmRlciB0byBnZXQgZGlyZWN0IGFjY2VzcyB0byB0aGUgYEF1dG9OdW1lcmljYCBjb25zdHJ1Y3RvciB3aXRob3V0IGhhdmluZyB0byB1c2UgYG5ldyBBdXRvTnVtZXJpYy5kZWZhdWx0KClgIChjZi4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzYzODkyNDQvMjgzNDg5OCkgOiB1c2luZyBgZXhwb3J0IHZhciBfX3VzZURlZmF1bHQgPSB0cnVlO2AgZG9lcyBub3Qgd29yayB0aG91Z2guXG4gKiAvL1hYWCBUaGUgd29ya2Fyb3VuZCAodXNpbmcgYG1vZHVsZS5leHBvcnRzID0gQXV0b051bWVyaWNgIGluc3RlYWQgb2YgYGV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dG9OdW1lcmljIHt9YCkgY29tZXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2lzc3Vlcy83MDYjaXNzdWVjb21tZW50LTE2NzkwODU3NlxuICogLy9YWFggQW5kIHRoZSBleHBsYW5hdGlvbiB3aHkgQmFiZWwgNiBjaGFuZ2VkIHRoZSB3YXkgQmFiZWwgNSB3b3JrZWQgOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMzUwNjE2OS8yODM0ODk4XG4gKiAvL1hYWCBJZGVhbGx5LCB3ZSBzaG91bGQgYmUgYWJsZSB0byBqdXN0IGRlY2xhcmUgYGV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dG9OdW1lcmljIHt9YCBpbiB0aGUgZnV0dXJlLCBhbmQgcmVtb3ZlIHRoZSBmb2xsb3dpbmcgYG1vZHVsZS5leHBvcnRzID0gQXV0b051bWVyaWM7YCBsaW5lXG4gKlxuICogQHR5cGUge0F1dG9OdW1lcmljfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEF1dG9OdW1lcmljO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0F1dG9OdW1lcmljLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n/**\n * Enumerations for autoNumeric.js\n * @author Alexandre Bonneau <alexandre.bonneau@linuxfr.eu>\n * @copyright © 2016 Alexandre Bonneau\n *\n * The MIT License (http://www.opensource.org/licenses/mit-license.php)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sub license, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * Object that store the helper enumerations\n * @type {{ allowedTagList: [string], keyCode: {}, fromCharCodeKeyCode: [string], keyName: {} }}\n */\nvar AutoNumericEnum = {\n    /**\n     * List of allowed tag on which autoNumeric can be used.\n     */\n    get allowedTagList() {\n        return ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'input', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'];\n    },\n\n    /**\n     * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\n     * cf. https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\n     *\n     * This deprecated information is used for obsolete browsers.\n     * @deprecated\n     */\n    get keyCode() {\n        return {\n            Backspace: 8,\n            Tab: 9,\n            // No 10, 11\n            // 12 === NumpadEqual on Windows\n            // 12 === NumLock on Mac\n            Enter: 13,\n            // 14 reserved, but not used\n            // 15 does not exists\n            Shift: 16,\n            Ctrl: 17,\n            Alt: 18,\n            Pause: 19,\n            CapsLock: 20,\n            // 21, 22, 23, 24, 25 : Asiatic key codes\n            // 26 does not exists\n            Esc: 27,\n            // 28, 29, 30, 31 : Convert, NonConvert, Accept and ModeChange keys\n            Space: 32,\n            PageUp: 33,\n            PageDown: 34,\n            End: 35,\n            Home: 36,\n            LeftArrow: 37,\n            UpArrow: 38,\n            RightArrow: 39,\n            DownArrow: 40,\n            Insert: 45,\n            Delete: 46,\n            num0: 48,\n            num1: 49,\n            num2: 50,\n            num3: 51,\n            num4: 52,\n            num5: 53,\n            num6: 54,\n            num7: 55,\n            num8: 56,\n            num9: 57,\n            a: 65,\n            b: 66,\n            c: 67,\n            d: 68,\n            e: 69,\n            f: 70,\n            g: 71,\n            h: 72,\n            i: 73,\n            j: 74,\n            k: 75,\n            l: 76,\n            m: 77,\n            n: 78,\n            o: 79,\n            p: 80,\n            q: 81,\n            r: 82,\n            s: 83,\n            t: 84,\n            u: 85,\n            v: 86,\n            w: 87,\n            x: 88,\n            y: 89,\n            z: 90,\n            OSLeft: 91,\n            OSRight: 92,\n            ContextMenu: 93,\n            numpad0: 96,\n            numpad1: 97,\n            numpad2: 98,\n            numpad3: 99,\n            numpad4: 100,\n            numpad5: 101,\n            numpad6: 102,\n            numpad7: 103,\n            numpad8: 104,\n            numpad9: 105,\n            MultiplyNumpad: 106,\n            PlusNumpad: 107,\n            MinusNumpad: 109,\n            DotNumpad: 110,\n            SlashNumpad: 111,\n            F1: 112,\n            F2: 113,\n            F3: 114,\n            F4: 115,\n            F5: 116,\n            F6: 117,\n            F7: 118,\n            F8: 119,\n            F9: 120,\n            F10: 121,\n            F11: 122,\n            F12: 123,\n            NumLock: 144,\n            ScrollLock: 145,\n            MyComputer: 182,\n            MyCalculator: 183,\n            Semicolon: 186,\n            Equal: 187,\n            Comma: 188,\n            Hyphen: 189,\n            Dot: 190,\n            Slash: 191,\n            Backquote: 192,\n            LeftBracket: 219,\n            Backslash: 220,\n            RightBracket: 221,\n            Quote: 222,\n            Command: 224,\n            AltGraph: 225,\n            AndroidDefault: 229 // Android Chrome returns the same keycode number 229 for all keys pressed\n        };\n    },\n\n    /**\n     * This object is the reverse of `keyCode`, and is used to translate the key code to named keys when no valid characters can be obtained by `String.fromCharCode`.\n     * This object keys correspond to the `event.keyCode` number, and returns the corresponding key name (à la event.key)\n     */\n    get fromCharCodeKeyCode() {\n        return {\n            0: 'LaunchCalculator',\n            8: 'Backspace',\n            9: 'Tab',\n            13: 'Enter',\n            16: 'Shift',\n            17: 'Ctrl',\n            18: 'Alt',\n            19: 'Pause',\n            20: 'CapsLock',\n            27: 'Escape',\n            32: ' ',\n            33: 'PageUp',\n            34: 'PageDown',\n            35: 'End',\n            36: 'Home',\n            37: 'ArrowLeft',\n            38: 'ArrowUp',\n            39: 'ArrowRight',\n            40: 'ArrowDown',\n            45: 'Insert',\n            46: 'Delete',\n            48: '0',\n            49: '1',\n            50: '2',\n            51: '3',\n            52: '4',\n            53: '5',\n            54: '6',\n            55: '7',\n            56: '8',\n            57: '9',\n            // 65: 'a',\n            // 66: 'b',\n            // 67: 'c',\n            // 68: 'd',\n            // 69: 'e',\n            // 70: 'f',\n            // 71: 'g',\n            // 72: 'h',\n            // 73: 'i',\n            // 74: 'j',\n            // 75: 'k',\n            // 76: 'l',\n            // 77: 'm',\n            // 78: 'n',\n            // 79: 'o',\n            // 80: 'p',\n            // 81: 'q',\n            // 82: 'r',\n            // 83: 's',\n            // 84: 't',\n            // 85: 'u',\n            // 86: 'v',\n            // 87: 'w',\n            // 88: 'x',\n            // 89: 'y',\n            // 90: 'z',\n            91: 'OS', // Note: Firefox and Chrome reports 'OS' instead of 'OSLeft'\n            92: 'OSRight',\n            93: 'ContextMenu',\n            96: '0',\n            97: '1',\n            98: '2',\n            99: '3',\n            100: '4',\n            101: '5',\n            102: '6',\n            103: '7',\n            104: '8',\n            105: '9',\n            106: '*',\n            107: '+',\n            109: '-',\n            110: '.',\n            111: '/',\n            112: 'F1',\n            113: 'F2',\n            114: 'F3',\n            115: 'F4',\n            116: 'F5',\n            117: 'F6',\n            118: 'F7',\n            119: 'F8',\n            120: 'F9',\n            121: 'F10',\n            122: 'F11',\n            123: 'F12',\n            144: 'NumLock',\n            145: 'ScrollLock',\n            182: 'MyComputer',\n            183: 'MyCalculator',\n            186: ';',\n            187: '=',\n            188: ',',\n            189: '-',\n            190: '.',\n            191: '/',\n            192: '`',\n            219: '[',\n            220: '\\\\',\n            221: ']',\n            222: '\\'',\n            224: 'Meta',\n            225: 'AltGraph'\n        };\n    },\n\n    /**\n     * Wrapper variable that hold named keyboard keys with their respective key name (as set in KeyboardEvent.key).\n     * Those names are listed here :\n     * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n     */\n    get keyName() {\n        return {\n            // Special values\n            Unidentified: 'Unidentified',\n            AndroidDefault: 'AndroidDefault',\n\n            // Modifier keys\n            Alt: 'Alt',\n            AltGr: 'AltGraph',\n            CapsLock: 'CapsLock', // Under Chrome, e.key is empty for CapsLock\n            Ctrl: 'Control',\n            Fn: 'Fn',\n            FnLock: 'FnLock',\n            Hyper: 'Hyper', // 'OS' under Firefox\n            Meta: 'Meta',\n            OSLeft: 'OS',\n            OSRight: 'OS',\n            Command: 'OS',\n            NumLock: 'NumLock',\n            ScrollLock: 'ScrollLock',\n            Shift: 'Shift',\n            Super: 'Super', // 'OS' under Firefox\n            Symbol: 'Symbol',\n            SymbolLock: 'SymbolLock',\n\n            // Whitespace keys\n            Enter: 'Enter',\n            Tab: 'Tab',\n            Space: ' ', // 'Spacebar' for Firefox <37, and IE9\n\n            // Navigation keys\n            LeftArrow: 'ArrowLeft', // 'Left' for Firefox <=36, and IE9\n            UpArrow: 'ArrowUp', // 'Up' for Firefox <=36, and IE9\n            RightArrow: 'ArrowRight', // 'Right' for Firefox <=36, and IE9\n            DownArrow: 'ArrowDown', // 'Down' for Firefox <=36, and IE9\n            End: 'End',\n            Home: 'Home',\n            PageUp: 'PageUp',\n            PageDown: 'PageDown',\n\n            // Editing keys\n            Backspace: 'Backspace',\n            Clear: 'Clear',\n            Copy: 'Copy',\n            CrSel: 'CrSel', // 'Crsel' for Firefox <=36, and IE9\n            Cut: 'Cut',\n            Delete: 'Delete', // 'Del' for Firefox <=36, and IE9\n            EraseEof: 'EraseEof',\n            ExSel: 'ExSel', // 'Exsel' for Firefox <=36, and IE9\n            Insert: 'Insert',\n            Paste: 'Paste',\n            Redo: 'Redo',\n            Undo: 'Undo',\n\n            // UI keys\n            Accept: 'Accept',\n            Again: 'Again',\n            Attn: 'Attn', // 'Unidentified' for Firefox, Chrome, and IE9 ('KanaMode' when using the Japanese keyboard layout)\n            Cancel: 'Cancel',\n            ContextMenu: 'ContextMenu', // 'Apps' for Firefox <=36, and IE9\n            Esc: 'Escape', // 'Esc' for Firefox <=36, and IE9\n            Execute: 'Execute',\n            Find: 'Find',\n            Finish: 'Finish', // 'Unidentified' for Firefox, Chrome, and IE9 ('Katakana' when using the Japanese keyboard layout)\n            Help: 'Help',\n            Pause: 'Pause',\n            Play: 'Play',\n            Props: 'Props',\n            Select: 'Select',\n            ZoomIn: 'ZoomIn',\n            ZoomOut: 'ZoomOut',\n\n            // Device keys\n            BrightnessDown: 'BrightnessDown',\n            BrightnessUp: 'BrightnessUp',\n            Eject: 'Eject',\n            LogOff: 'LogOff',\n            Power: 'Power',\n            PowerOff: 'PowerOff',\n            PrintScreen: 'PrintScreen',\n            Hibernate: 'Hibernate', // 'Unidentified' for Firefox <=37\n            Standby: 'Standby', // 'Unidentified' for Firefox <=36, and IE9\n            WakeUp: 'WakeUp',\n\n            // IME and composition keys\n            Compose: 'Compose',\n            Dead: 'Dead',\n\n            // Function keys\n            F1: 'F1',\n            F2: 'F2',\n            F3: 'F3',\n            F4: 'F4',\n            F5: 'F5',\n            F6: 'F6',\n            F7: 'F7',\n            F8: 'F8',\n            F9: 'F9',\n            F10: 'F10',\n            F11: 'F11',\n            F12: 'F12',\n\n            // Document keys\n            Print: 'Print',\n\n            // 'Normal' keys\n            num0: '0',\n            num1: '1',\n            num2: '2',\n            num3: '3',\n            num4: '4',\n            num5: '5',\n            num6: '6',\n            num7: '7',\n            num8: '8',\n            num9: '9',\n            a: 'a',\n            b: 'b',\n            c: 'c',\n            d: 'd',\n            e: 'e',\n            f: 'f',\n            g: 'g',\n            h: 'h',\n            i: 'i',\n            j: 'j',\n            k: 'k',\n            l: 'l',\n            m: 'm',\n            n: 'n',\n            o: 'o',\n            p: 'p',\n            q: 'q',\n            r: 'r',\n            s: 's',\n            t: 't',\n            u: 'u',\n            v: 'v',\n            w: 'w',\n            x: 'x',\n            y: 'y',\n            z: 'z',\n            A: 'A',\n            B: 'B',\n            C: 'C',\n            D: 'D',\n            E: 'E',\n            F: 'F',\n            G: 'G',\n            H: 'H',\n            I: 'I',\n            J: 'J',\n            K: 'K',\n            L: 'L',\n            M: 'M',\n            N: 'N',\n            O: 'O',\n            P: 'P',\n            Q: 'Q',\n            R: 'R',\n            S: 'S',\n            T: 'T',\n            U: 'U',\n            V: 'V',\n            W: 'W',\n            X: 'X',\n            Y: 'Y',\n            Z: 'Z',\n            Semicolon: ';',\n            Equal: '=',\n            Comma: ',',\n            Hyphen: '-',\n            Minus: '-',\n            Plus: '+',\n            Dot: '.',\n            Slash: '/',\n            Backquote: '`',\n            LeftBracket: '[',\n            RightBracket: ']',\n            Backslash: '\\\\',\n            Quote: \"'\",\n\n            // Numeric keypad keys\n            numpad0: '0',\n            numpad1: '1',\n            numpad2: '2',\n            numpad3: '3',\n            numpad4: '4',\n            numpad5: '5',\n            numpad6: '6',\n            numpad7: '7',\n            numpad8: '8',\n            numpad9: '9',\n            NumpadDot: '.',\n            NumpadDotAlt: ',', // Modern browsers automatically adapt the character sent by this key to the decimal character of the current language\n            NumpadMultiply: '*',\n            NumpadPlus: '+',\n            NumpadMinus: '-',\n            NumpadSlash: '/',\n            NumpadDotObsoleteBrowsers: 'Decimal',\n            NumpadMultiplyObsoleteBrowsers: 'Multiply',\n            NumpadPlusObsoleteBrowsers: 'Add',\n            NumpadMinusObsoleteBrowsers: 'Subtract',\n            NumpadSlashObsoleteBrowsers: 'Divide',\n\n            // Special arrays for quicker tests\n            _allFnKeys: ['F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12'],\n            _someNonPrintableKeys: ['Tab', 'Enter', 'Shift', 'ShiftLeft', 'ShiftRight', 'Control', 'ControlLeft', 'ControlRight', 'Alt', 'AltLeft', 'AltRight', 'Pause', 'CapsLock', 'Escape'],\n            _directionKeys: ['PageUp', 'PageDown', 'End', 'Home', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowUp']\n        };\n    }\n};\n\nexports.default = AutoNumericEnum;\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXV0b051bWVyaWNFbnVtLmpzP2M1N2MiXSwibmFtZXMiOlsiQXV0b051bWVyaWNFbnVtIiwiYWxsb3dlZFRhZ0xpc3QiLCJrZXlDb2RlIiwiQmFja3NwYWNlIiwiVGFiIiwiRW50ZXIiLCJTaGlmdCIsIkN0cmwiLCJBbHQiLCJQYXVzZSIsIkNhcHNMb2NrIiwiRXNjIiwiU3BhY2UiLCJQYWdlVXAiLCJQYWdlRG93biIsIkVuZCIsIkhvbWUiLCJMZWZ0QXJyb3ciLCJVcEFycm93IiwiUmlnaHRBcnJvdyIsIkRvd25BcnJvdyIsIkluc2VydCIsIkRlbGV0ZSIsIm51bTAiLCJudW0xIiwibnVtMiIsIm51bTMiLCJudW00IiwibnVtNSIsIm51bTYiLCJudW03IiwibnVtOCIsIm51bTkiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnIiwiaCIsImkiLCJqIiwiayIsImwiLCJtIiwibiIsIm8iLCJwIiwicSIsInIiLCJzIiwidCIsInUiLCJ2IiwidyIsIngiLCJ5IiwieiIsIk9TTGVmdCIsIk9TUmlnaHQiLCJDb250ZXh0TWVudSIsIm51bXBhZDAiLCJudW1wYWQxIiwibnVtcGFkMiIsIm51bXBhZDMiLCJudW1wYWQ0IiwibnVtcGFkNSIsIm51bXBhZDYiLCJudW1wYWQ3IiwibnVtcGFkOCIsIm51bXBhZDkiLCJNdWx0aXBseU51bXBhZCIsIlBsdXNOdW1wYWQiLCJNaW51c051bXBhZCIsIkRvdE51bXBhZCIsIlNsYXNoTnVtcGFkIiwiRjEiLCJGMiIsIkYzIiwiRjQiLCJGNSIsIkY2IiwiRjciLCJGOCIsIkY5IiwiRjEwIiwiRjExIiwiRjEyIiwiTnVtTG9jayIsIlNjcm9sbExvY2siLCJNeUNvbXB1dGVyIiwiTXlDYWxjdWxhdG9yIiwiU2VtaWNvbG9uIiwiRXF1YWwiLCJDb21tYSIsIkh5cGhlbiIsIkRvdCIsIlNsYXNoIiwiQmFja3F1b3RlIiwiTGVmdEJyYWNrZXQiLCJCYWNrc2xhc2giLCJSaWdodEJyYWNrZXQiLCJRdW90ZSIsIkNvbW1hbmQiLCJBbHRHcmFwaCIsIkFuZHJvaWREZWZhdWx0IiwiZnJvbUNoYXJDb2RlS2V5Q29kZSIsImtleU5hbWUiLCJVbmlkZW50aWZpZWQiLCJBbHRHciIsIkZuIiwiRm5Mb2NrIiwiSHlwZXIiLCJNZXRhIiwiU3VwZXIiLCJTeW1ib2wiLCJTeW1ib2xMb2NrIiwiQ2xlYXIiLCJDb3B5IiwiQ3JTZWwiLCJDdXQiLCJFcmFzZUVvZiIsIkV4U2VsIiwiUGFzdGUiLCJSZWRvIiwiVW5kbyIsIkFjY2VwdCIsIkFnYWluIiwiQXR0biIsIkNhbmNlbCIsIkV4ZWN1dGUiLCJGaW5kIiwiRmluaXNoIiwiSGVscCIsIlBsYXkiLCJQcm9wcyIsIlNlbGVjdCIsIlpvb21JbiIsIlpvb21PdXQiLCJCcmlnaHRuZXNzRG93biIsIkJyaWdodG5lc3NVcCIsIkVqZWN0IiwiTG9nT2ZmIiwiUG93ZXIiLCJQb3dlck9mZiIsIlByaW50U2NyZWVuIiwiSGliZXJuYXRlIiwiU3RhbmRieSIsIldha2VVcCIsIkNvbXBvc2UiLCJEZWFkIiwiUHJpbnQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsIkkiLCJKIiwiSyIsIkwiLCJNIiwiTiIsIk8iLCJQIiwiUSIsIlIiLCJTIiwiVCIsIlUiLCJWIiwiVyIsIlgiLCJZIiwiWiIsIk1pbnVzIiwiUGx1cyIsIk51bXBhZERvdCIsIk51bXBhZERvdEFsdCIsIk51bXBhZE11bHRpcGx5IiwiTnVtcGFkUGx1cyIsIk51bXBhZE1pbnVzIiwiTnVtcGFkU2xhc2giLCJOdW1wYWREb3RPYnNvbGV0ZUJyb3dzZXJzIiwiTnVtcGFkTXVsdGlwbHlPYnNvbGV0ZUJyb3dzZXJzIiwiTnVtcGFkUGx1c09ic29sZXRlQnJvd3NlcnMiLCJOdW1wYWRNaW51c09ic29sZXRlQnJvd3NlcnMiLCJOdW1wYWRTbGFzaE9ic29sZXRlQnJvd3NlcnMiLCJfYWxsRm5LZXlzIiwiX3NvbWVOb25QcmludGFibGVLZXlzIiwiX2RpcmVjdGlvbktleXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7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QXJELEVBQWdFLGFBQWhFLEVBQStFLGNBQS9FLEVBQStGLEtBQS9GLEVBQXNHLFNBQXRHLEVBQWlILFVBQWpILEVBQTZILE9BQTdILEVBQXNJLFVBQXRJLEVBQWtKLFFBQWxKLENBOU1wQjtBQStNSEMsNEJBQXVCLENBQUMsUUFBRCxFQUFXLFVBQVgsRUFBdUIsS0FBdkIsRUFBOEIsTUFBOUIsRUFBc0MsV0FBdEMsRUFBbUQsV0FBbkQsRUFBZ0UsWUFBaEUsRUFBOEUsU0FBOUU7QUEvTXBCLFNBQVA7QUFpTkg7QUE5ZW1CLENBQXhCOztrQkFpZmVsTSxlIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVudW1lcmF0aW9ucyBmb3IgYXV0b051bWVyaWMuanNcbiAqIEBhdXRob3IgQWxleGFuZHJlIEJvbm5lYXUgPGFsZXhhbmRyZS5ib25uZWF1QGxpbnV4ZnIuZXU+XG4gKiBAY29weXJpZ2h0IMKpIDIwMTYgQWxleGFuZHJlIEJvbm5lYXVcbiAqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwKVxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAqIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YiBsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKlxuICogT2JqZWN0IHRoYXQgc3RvcmUgdGhlIGhlbHBlciBlbnVtZXJhdGlvbnNcbiAqIEB0eXBlIHt7IGFsbG93ZWRUYWdMaXN0OiBbc3RyaW5nXSwga2V5Q29kZToge30sIGZyb21DaGFyQ29kZUtleUNvZGU6IFtzdHJpbmddLCBrZXlOYW1lOiB7fSB9fVxuICovXG5jb25zdCBBdXRvTnVtZXJpY0VudW0gPSB7XG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBhbGxvd2VkIHRhZyBvbiB3aGljaCBhdXRvTnVtZXJpYyBjYW4gYmUgdXNlZC5cbiAgICAgKi9cbiAgICBnZXQgYWxsb3dlZFRhZ0xpc3QoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnYicsXG4gICAgICAgICAgICAnY2FwdGlvbicsXG4gICAgICAgICAgICAnY2l0ZScsXG4gICAgICAgICAgICAnY29kZScsXG4gICAgICAgICAgICAnY29uc3QnLFxuICAgICAgICAgICAgJ2RkJyxcbiAgICAgICAgICAgICdkZWwnLFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAnZGZuJyxcbiAgICAgICAgICAgICdkdCcsXG4gICAgICAgICAgICAnZW0nLFxuICAgICAgICAgICAgJ2gxJyxcbiAgICAgICAgICAgICdoMicsXG4gICAgICAgICAgICAnaDMnLFxuICAgICAgICAgICAgJ2g0JyxcbiAgICAgICAgICAgICdoNScsXG4gICAgICAgICAgICAnaDYnLFxuICAgICAgICAgICAgJ2lucHV0JyxcbiAgICAgICAgICAgICdpbnMnLFxuICAgICAgICAgICAgJ2tkYicsXG4gICAgICAgICAgICAnbGFiZWwnLFxuICAgICAgICAgICAgJ2xpJyxcbiAgICAgICAgICAgICdvcHRpb24nLFxuICAgICAgICAgICAgJ291dHB1dCcsXG4gICAgICAgICAgICAncCcsXG4gICAgICAgICAgICAncScsXG4gICAgICAgICAgICAncycsXG4gICAgICAgICAgICAnc2FtcGxlJyxcbiAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICdzdHJvbmcnLFxuICAgICAgICAgICAgJ3RkJyxcbiAgICAgICAgICAgICd0aCcsXG4gICAgICAgICAgICAndScsXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdyYXBwZXIgdmFyaWFibGUgdGhhdCBob2xkIG5hbWVkIGtleWJvYXJkIGtleXMgd2l0aCB0aGVpciByZXNwZWN0aXZlIGtleUNvZGUgYXMgc2VlbiBpbiBET00gZXZlbnRzLlxuICAgICAqIGNmLiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXlDb2RlXG4gICAgICpcbiAgICAgKiBUaGlzIGRlcHJlY2F0ZWQgaW5mb3JtYXRpb24gaXMgdXNlZCBmb3Igb2Jzb2xldGUgYnJvd3NlcnMuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBnZXQga2V5Q29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEJhY2tzcGFjZSAgICAgOiA4LFxuICAgICAgICAgICAgVGFiICAgICAgICAgICA6IDksXG4gICAgICAgICAgICAvLyBObyAxMCwgMTFcbiAgICAgICAgICAgIC8vIDEyID09PSBOdW1wYWRFcXVhbCBvbiBXaW5kb3dzXG4gICAgICAgICAgICAvLyAxMiA9PT0gTnVtTG9jayBvbiBNYWNcbiAgICAgICAgICAgIEVudGVyICAgICAgICAgOiAxMyxcbiAgICAgICAgICAgIC8vIDE0IHJlc2VydmVkLCBidXQgbm90IHVzZWRcbiAgICAgICAgICAgIC8vIDE1IGRvZXMgbm90IGV4aXN0c1xuICAgICAgICAgICAgU2hpZnQgICAgICAgICA6IDE2LFxuICAgICAgICAgICAgQ3RybCAgICAgICAgICA6IDE3LFxuICAgICAgICAgICAgQWx0ICAgICAgICAgICA6IDE4LFxuICAgICAgICAgICAgUGF1c2UgICAgICAgICA6IDE5LFxuICAgICAgICAgICAgQ2Fwc0xvY2sgICAgICA6IDIwLFxuICAgICAgICAgICAgLy8gMjEsIDIyLCAyMywgMjQsIDI1IDogQXNpYXRpYyBrZXkgY29kZXNcbiAgICAgICAgICAgIC8vIDI2IGRvZXMgbm90IGV4aXN0c1xuICAgICAgICAgICAgRXNjICAgICAgICAgICA6IDI3LFxuICAgICAgICAgICAgLy8gMjgsIDI5LCAzMCwgMzEgOiBDb252ZXJ0LCBOb25Db252ZXJ0LCBBY2NlcHQgYW5kIE1vZGVDaGFuZ2Uga2V5c1xuICAgICAgICAgICAgU3BhY2UgICAgICAgICA6IDMyLFxuICAgICAgICAgICAgUGFnZVVwICAgICAgICA6IDMzLFxuICAgICAgICAgICAgUGFnZURvd24gICAgICA6IDM0LFxuICAgICAgICAgICAgRW5kICAgICAgICAgICA6IDM1LFxuICAgICAgICAgICAgSG9tZSAgICAgICAgICA6IDM2LFxuICAgICAgICAgICAgTGVmdEFycm93ICAgICA6IDM3LFxuICAgICAgICAgICAgVXBBcnJvdyAgICAgICA6IDM4LFxuICAgICAgICAgICAgUmlnaHRBcnJvdyAgICA6IDM5LFxuICAgICAgICAgICAgRG93bkFycm93ICAgICA6IDQwLFxuICAgICAgICAgICAgSW5zZXJ0ICAgICAgICA6IDQ1LFxuICAgICAgICAgICAgRGVsZXRlICAgICAgICA6IDQ2LFxuICAgICAgICAgICAgbnVtMCAgICAgICAgICA6IDQ4LFxuICAgICAgICAgICAgbnVtMSAgICAgICAgICA6IDQ5LFxuICAgICAgICAgICAgbnVtMiAgICAgICAgICA6IDUwLFxuICAgICAgICAgICAgbnVtMyAgICAgICAgICA6IDUxLFxuICAgICAgICAgICAgbnVtNCAgICAgICAgICA6IDUyLFxuICAgICAgICAgICAgbnVtNSAgICAgICAgICA6IDUzLFxuICAgICAgICAgICAgbnVtNiAgICAgICAgICA6IDU0LFxuICAgICAgICAgICAgbnVtNyAgICAgICAgICA6IDU1LFxuICAgICAgICAgICAgbnVtOCAgICAgICAgICA6IDU2LFxuICAgICAgICAgICAgbnVtOSAgICAgICAgICA6IDU3LFxuICAgICAgICAgICAgYSAgICAgICAgICAgICA6IDY1LFxuICAgICAgICAgICAgYiAgICAgICAgICAgICA6IDY2LFxuICAgICAgICAgICAgYyAgICAgICAgICAgICA6IDY3LFxuICAgICAgICAgICAgZCAgICAgICAgICAgICA6IDY4LFxuICAgICAgICAgICAgZSAgICAgICAgICAgICA6IDY5LFxuICAgICAgICAgICAgZiAgICAgICAgICAgICA6IDcwLFxuICAgICAgICAgICAgZyAgICAgICAgICAgICA6IDcxLFxuICAgICAgICAgICAgaCAgICAgICAgICAgICA6IDcyLFxuICAgICAgICAgICAgaSAgICAgICAgICAgICA6IDczLFxuICAgICAgICAgICAgaiAgICAgICAgICAgICA6IDc0LFxuICAgICAgICAgICAgayAgICAgICAgICAgICA6IDc1LFxuICAgICAgICAgICAgbCAgICAgICAgICAgICA6IDc2LFxuICAgICAgICAgICAgbSAgICAgICAgICAgICA6IDc3LFxuICAgICAgICAgICAgbiAgICAgICAgICAgICA6IDc4LFxuICAgICAgICAgICAgbyAgICAgICAgICAgICA6IDc5LFxuICAgICAgICAgICAgcCAgICAgICAgICAgICA6IDgwLFxuICAgICAgICAgICAgcSAgICAgICAgICAgICA6IDgxLFxuICAgICAgICAgICAgciAgICAgICAgICAgICA6IDgyLFxuICAgICAgICAgICAgcyAgICAgICAgICAgICA6IDgzLFxuICAgICAgICAgICAgdCAgICAgICAgICAgICA6IDg0LFxuICAgICAgICAgICAgdSAgICAgICAgICAgICA6IDg1LFxuICAgICAgICAgICAgdiAgICAgICAgICAgICA6IDg2LFxuICAgICAgICAgICAgdyAgICAgICAgICAgICA6IDg3LFxuICAgICAgICAgICAgeCAgICAgICAgICAgICA6IDg4LFxuICAgICAgICAgICAgeSAgICAgICAgICAgICA6IDg5LFxuICAgICAgICAgICAgeiAgICAgICAgICAgICA6IDkwLFxuICAgICAgICAgICAgT1NMZWZ0ICAgICAgICA6IDkxLFxuICAgICAgICAgICAgT1NSaWdodCAgICAgICA6IDkyLFxuICAgICAgICAgICAgQ29udGV4dE1lbnUgICA6IDkzLFxuICAgICAgICAgICAgbnVtcGFkMCAgICAgICA6IDk2LFxuICAgICAgICAgICAgbnVtcGFkMSAgICAgICA6IDk3LFxuICAgICAgICAgICAgbnVtcGFkMiAgICAgICA6IDk4LFxuICAgICAgICAgICAgbnVtcGFkMyAgICAgICA6IDk5LFxuICAgICAgICAgICAgbnVtcGFkNCAgICAgICA6IDEwMCxcbiAgICAgICAgICAgIG51bXBhZDUgICAgICAgOiAxMDEsXG4gICAgICAgICAgICBudW1wYWQ2ICAgICAgIDogMTAyLFxuICAgICAgICAgICAgbnVtcGFkNyAgICAgICA6IDEwMyxcbiAgICAgICAgICAgIG51bXBhZDggICAgICAgOiAxMDQsXG4gICAgICAgICAgICBudW1wYWQ5ICAgICAgIDogMTA1LFxuICAgICAgICAgICAgTXVsdGlwbHlOdW1wYWQ6IDEwNixcbiAgICAgICAgICAgIFBsdXNOdW1wYWQgICAgOiAxMDcsXG4gICAgICAgICAgICBNaW51c051bXBhZCAgIDogMTA5LFxuICAgICAgICAgICAgRG90TnVtcGFkICAgICA6IDExMCxcbiAgICAgICAgICAgIFNsYXNoTnVtcGFkICAgOiAxMTEsXG4gICAgICAgICAgICBGMSAgICAgICAgICAgIDogMTEyLFxuICAgICAgICAgICAgRjIgICAgICAgICAgICA6IDExMyxcbiAgICAgICAgICAgIEYzICAgICAgICAgICAgOiAxMTQsXG4gICAgICAgICAgICBGNCAgICAgICAgICAgIDogMTE1LFxuICAgICAgICAgICAgRjUgICAgICAgICAgICA6IDExNixcbiAgICAgICAgICAgIEY2ICAgICAgICAgICAgOiAxMTcsXG4gICAgICAgICAgICBGNyAgICAgICAgICAgIDogMTE4LFxuICAgICAgICAgICAgRjggICAgICAgICAgICA6IDExOSxcbiAgICAgICAgICAgIEY5ICAgICAgICAgICAgOiAxMjAsXG4gICAgICAgICAgICBGMTAgICAgICAgICAgIDogMTIxLFxuICAgICAgICAgICAgRjExICAgICAgICAgICA6IDEyMixcbiAgICAgICAgICAgIEYxMiAgICAgICAgICAgOiAxMjMsXG4gICAgICAgICAgICBOdW1Mb2NrICAgICAgIDogMTQ0LFxuICAgICAgICAgICAgU2Nyb2xsTG9jayAgICA6IDE0NSxcbiAgICAgICAgICAgIE15Q29tcHV0ZXIgICAgOiAxODIsXG4gICAgICAgICAgICBNeUNhbGN1bGF0b3IgIDogMTgzLFxuICAgICAgICAgICAgU2VtaWNvbG9uICAgICA6IDE4NixcbiAgICAgICAgICAgIEVxdWFsICAgICAgICAgOiAxODcsXG4gICAgICAgICAgICBDb21tYSAgICAgICAgIDogMTg4LFxuICAgICAgICAgICAgSHlwaGVuICAgICAgICA6IDE4OSxcbiAgICAgICAgICAgIERvdCAgICAgICAgICAgOiAxOTAsXG4gICAgICAgICAgICBTbGFzaCAgICAgICAgIDogMTkxLFxuICAgICAgICAgICAgQmFja3F1b3RlICAgICA6IDE5MixcbiAgICAgICAgICAgIExlZnRCcmFja2V0ICAgOiAyMTksXG4gICAgICAgICAgICBCYWNrc2xhc2ggICAgIDogMjIwLFxuICAgICAgICAgICAgUmlnaHRCcmFja2V0ICA6IDIyMSxcbiAgICAgICAgICAgIFF1b3RlICAgICAgICAgOiAyMjIsXG4gICAgICAgICAgICBDb21tYW5kICAgICAgIDogMjI0LFxuICAgICAgICAgICAgQWx0R3JhcGggICAgICA6IDIyNSxcbiAgICAgICAgICAgIEFuZHJvaWREZWZhdWx0OiAyMjksIC8vIEFuZHJvaWQgQ2hyb21lIHJldHVybnMgdGhlIHNhbWUga2V5Y29kZSBudW1iZXIgMjI5IGZvciBhbGwga2V5cyBwcmVzc2VkXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgb2JqZWN0IGlzIHRoZSByZXZlcnNlIG9mIGBrZXlDb2RlYCwgYW5kIGlzIHVzZWQgdG8gdHJhbnNsYXRlIHRoZSBrZXkgY29kZSB0byBuYW1lZCBrZXlzIHdoZW4gbm8gdmFsaWQgY2hhcmFjdGVycyBjYW4gYmUgb2J0YWluZWQgYnkgYFN0cmluZy5mcm9tQ2hhckNvZGVgLlxuICAgICAqIFRoaXMgb2JqZWN0IGtleXMgY29ycmVzcG9uZCB0byB0aGUgYGV2ZW50LmtleUNvZGVgIG51bWJlciwgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcga2V5IG5hbWUgKMOgIGxhIGV2ZW50LmtleSlcbiAgICAgKi9cbiAgICBnZXQgZnJvbUNoYXJDb2RlS2V5Q29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIDAgIDogJ0xhdW5jaENhbGN1bGF0b3InLFxuICAgICAgICAgICAgOCAgOiAnQmFja3NwYWNlJyxcbiAgICAgICAgICAgIDkgIDogJ1RhYicsXG4gICAgICAgICAgICAxMyA6ICdFbnRlcicsXG4gICAgICAgICAgICAxNiA6ICdTaGlmdCcsXG4gICAgICAgICAgICAxNyA6ICdDdHJsJyxcbiAgICAgICAgICAgIDE4IDogJ0FsdCcsXG4gICAgICAgICAgICAxOSA6ICdQYXVzZScsXG4gICAgICAgICAgICAyMCA6ICdDYXBzTG9jaycsXG4gICAgICAgICAgICAyNyA6ICdFc2NhcGUnLFxuICAgICAgICAgICAgMzIgOiAnICcsXG4gICAgICAgICAgICAzMyA6ICdQYWdlVXAnLFxuICAgICAgICAgICAgMzQgOiAnUGFnZURvd24nLFxuICAgICAgICAgICAgMzUgOiAnRW5kJyxcbiAgICAgICAgICAgIDM2IDogJ0hvbWUnLFxuICAgICAgICAgICAgMzcgOiAnQXJyb3dMZWZ0JyxcbiAgICAgICAgICAgIDM4IDogJ0Fycm93VXAnLFxuICAgICAgICAgICAgMzkgOiAnQXJyb3dSaWdodCcsXG4gICAgICAgICAgICA0MCA6ICdBcnJvd0Rvd24nLFxuICAgICAgICAgICAgNDUgOiAnSW5zZXJ0JyxcbiAgICAgICAgICAgIDQ2IDogJ0RlbGV0ZScsXG4gICAgICAgICAgICA0OCA6ICcwJyxcbiAgICAgICAgICAgIDQ5IDogJzEnLFxuICAgICAgICAgICAgNTAgOiAnMicsXG4gICAgICAgICAgICA1MSA6ICczJyxcbiAgICAgICAgICAgIDUyIDogJzQnLFxuICAgICAgICAgICAgNTMgOiAnNScsXG4gICAgICAgICAgICA1NCA6ICc2JyxcbiAgICAgICAgICAgIDU1IDogJzcnLFxuICAgICAgICAgICAgNTYgOiAnOCcsXG4gICAgICAgICAgICA1NyA6ICc5JyxcbiAgICAgICAgICAgIC8vIDY1OiAnYScsXG4gICAgICAgICAgICAvLyA2NjogJ2InLFxuICAgICAgICAgICAgLy8gNjc6ICdjJyxcbiAgICAgICAgICAgIC8vIDY4OiAnZCcsXG4gICAgICAgICAgICAvLyA2OTogJ2UnLFxuICAgICAgICAgICAgLy8gNzA6ICdmJyxcbiAgICAgICAgICAgIC8vIDcxOiAnZycsXG4gICAgICAgICAgICAvLyA3MjogJ2gnLFxuICAgICAgICAgICAgLy8gNzM6ICdpJyxcbiAgICAgICAgICAgIC8vIDc0OiAnaicsXG4gICAgICAgICAgICAvLyA3NTogJ2snLFxuICAgICAgICAgICAgLy8gNzY6ICdsJyxcbiAgICAgICAgICAgIC8vIDc3OiAnbScsXG4gICAgICAgICAgICAvLyA3ODogJ24nLFxuICAgICAgICAgICAgLy8gNzk6ICdvJyxcbiAgICAgICAgICAgIC8vIDgwOiAncCcsXG4gICAgICAgICAgICAvLyA4MTogJ3EnLFxuICAgICAgICAgICAgLy8gODI6ICdyJyxcbiAgICAgICAgICAgIC8vIDgzOiAncycsXG4gICAgICAgICAgICAvLyA4NDogJ3QnLFxuICAgICAgICAgICAgLy8gODU6ICd1JyxcbiAgICAgICAgICAgIC8vIDg2OiAndicsXG4gICAgICAgICAgICAvLyA4NzogJ3cnLFxuICAgICAgICAgICAgLy8gODg6ICd4JyxcbiAgICAgICAgICAgIC8vIDg5OiAneScsXG4gICAgICAgICAgICAvLyA5MDogJ3onLFxuICAgICAgICAgICAgOTEgOiAnT1MnLCAvLyBOb3RlOiBGaXJlZm94IGFuZCBDaHJvbWUgcmVwb3J0cyAnT1MnIGluc3RlYWQgb2YgJ09TTGVmdCdcbiAgICAgICAgICAgIDkyIDogJ09TUmlnaHQnLFxuICAgICAgICAgICAgOTMgOiAnQ29udGV4dE1lbnUnLFxuICAgICAgICAgICAgOTYgOiAnMCcsXG4gICAgICAgICAgICA5NyA6ICcxJyxcbiAgICAgICAgICAgIDk4IDogJzInLFxuICAgICAgICAgICAgOTkgOiAnMycsXG4gICAgICAgICAgICAxMDA6ICc0JyxcbiAgICAgICAgICAgIDEwMTogJzUnLFxuICAgICAgICAgICAgMTAyOiAnNicsXG4gICAgICAgICAgICAxMDM6ICc3JyxcbiAgICAgICAgICAgIDEwNDogJzgnLFxuICAgICAgICAgICAgMTA1OiAnOScsXG4gICAgICAgICAgICAxMDY6ICcqJyxcbiAgICAgICAgICAgIDEwNzogJysnLFxuICAgICAgICAgICAgMTA5OiAnLScsXG4gICAgICAgICAgICAxMTA6ICcuJyxcbiAgICAgICAgICAgIDExMTogJy8nLFxuICAgICAgICAgICAgMTEyOiAnRjEnLFxuICAgICAgICAgICAgMTEzOiAnRjInLFxuICAgICAgICAgICAgMTE0OiAnRjMnLFxuICAgICAgICAgICAgMTE1OiAnRjQnLFxuICAgICAgICAgICAgMTE2OiAnRjUnLFxuICAgICAgICAgICAgMTE3OiAnRjYnLFxuICAgICAgICAgICAgMTE4OiAnRjcnLFxuICAgICAgICAgICAgMTE5OiAnRjgnLFxuICAgICAgICAgICAgMTIwOiAnRjknLFxuICAgICAgICAgICAgMTIxOiAnRjEwJyxcbiAgICAgICAgICAgIDEyMjogJ0YxMScsXG4gICAgICAgICAgICAxMjM6ICdGMTInLFxuICAgICAgICAgICAgMTQ0OiAnTnVtTG9jaycsXG4gICAgICAgICAgICAxNDU6ICdTY3JvbGxMb2NrJyxcbiAgICAgICAgICAgIDE4MjogJ015Q29tcHV0ZXInLFxuICAgICAgICAgICAgMTgzOiAnTXlDYWxjdWxhdG9yJyxcbiAgICAgICAgICAgIDE4NjogJzsnLFxuICAgICAgICAgICAgMTg3OiAnPScsXG4gICAgICAgICAgICAxODg6ICcsJyxcbiAgICAgICAgICAgIDE4OTogJy0nLFxuICAgICAgICAgICAgMTkwOiAnLicsXG4gICAgICAgICAgICAxOTE6ICcvJyxcbiAgICAgICAgICAgIDE5MjogJ2AnLFxuICAgICAgICAgICAgMjE5OiAnWycsXG4gICAgICAgICAgICAyMjA6ICdcXFxcJyxcbiAgICAgICAgICAgIDIyMTogJ10nLFxuICAgICAgICAgICAgMjIyOiAnXFwnJyxcbiAgICAgICAgICAgIDIyNDogJ01ldGEnLFxuICAgICAgICAgICAgMjI1OiAnQWx0R3JhcGgnLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXcmFwcGVyIHZhcmlhYmxlIHRoYXQgaG9sZCBuYW1lZCBrZXlib2FyZCBrZXlzIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBrZXkgbmFtZSAoYXMgc2V0IGluIEtleWJvYXJkRXZlbnQua2V5KS5cbiAgICAgKiBUaG9zZSBuYW1lcyBhcmUgbGlzdGVkIGhlcmUgOlxuICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleS9LZXlfVmFsdWVzXG4gICAgICovXG4gICAgZ2V0IGtleU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBTcGVjaWFsIHZhbHVlc1xuICAgICAgICAgICAgVW5pZGVudGlmaWVkICA6ICdVbmlkZW50aWZpZWQnLFxuICAgICAgICAgICAgQW5kcm9pZERlZmF1bHQ6ICdBbmRyb2lkRGVmYXVsdCcsXG5cbiAgICAgICAgICAgIC8vIE1vZGlmaWVyIGtleXNcbiAgICAgICAgICAgIEFsdCAgICAgICA6ICdBbHQnLFxuICAgICAgICAgICAgQWx0R3IgICAgIDogJ0FsdEdyYXBoJyxcbiAgICAgICAgICAgIENhcHNMb2NrICA6ICdDYXBzTG9jaycsIC8vIFVuZGVyIENocm9tZSwgZS5rZXkgaXMgZW1wdHkgZm9yIENhcHNMb2NrXG4gICAgICAgICAgICBDdHJsICAgICAgOiAnQ29udHJvbCcsXG4gICAgICAgICAgICBGbiAgICAgICAgOiAnRm4nLFxuICAgICAgICAgICAgRm5Mb2NrICAgIDogJ0ZuTG9jaycsXG4gICAgICAgICAgICBIeXBlciAgICAgOiAnSHlwZXInLCAvLyAnT1MnIHVuZGVyIEZpcmVmb3hcbiAgICAgICAgICAgIE1ldGEgICAgICA6ICdNZXRhJyxcbiAgICAgICAgICAgIE9TTGVmdCAgICA6ICdPUycsXG4gICAgICAgICAgICBPU1JpZ2h0ICAgOiAnT1MnLFxuICAgICAgICAgICAgQ29tbWFuZCAgIDogJ09TJyxcbiAgICAgICAgICAgIE51bUxvY2sgICA6ICdOdW1Mb2NrJyxcbiAgICAgICAgICAgIFNjcm9sbExvY2s6ICdTY3JvbGxMb2NrJyxcbiAgICAgICAgICAgIFNoaWZ0ICAgICA6ICdTaGlmdCcsXG4gICAgICAgICAgICBTdXBlciAgICAgOiAnU3VwZXInLCAvLyAnT1MnIHVuZGVyIEZpcmVmb3hcbiAgICAgICAgICAgIFN5bWJvbCAgICA6ICdTeW1ib2wnLFxuICAgICAgICAgICAgU3ltYm9sTG9jazogJ1N5bWJvbExvY2snLFxuXG4gICAgICAgICAgICAvLyBXaGl0ZXNwYWNlIGtleXNcbiAgICAgICAgICAgIEVudGVyOiAnRW50ZXInLFxuICAgICAgICAgICAgVGFiICA6ICdUYWInLFxuICAgICAgICAgICAgU3BhY2U6ICcgJywgLy8gJ1NwYWNlYmFyJyBmb3IgRmlyZWZveCA8MzcsIGFuZCBJRTlcblxuICAgICAgICAgICAgLy8gTmF2aWdhdGlvbiBrZXlzXG4gICAgICAgICAgICBMZWZ0QXJyb3cgOiAnQXJyb3dMZWZ0JywgLy8gJ0xlZnQnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcbiAgICAgICAgICAgIFVwQXJyb3cgICA6ICdBcnJvd1VwJywgLy8gJ1VwJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XG4gICAgICAgICAgICBSaWdodEFycm93OiAnQXJyb3dSaWdodCcsIC8vICdSaWdodCcgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxuICAgICAgICAgICAgRG93bkFycm93IDogJ0Fycm93RG93bicsIC8vICdEb3duJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XG4gICAgICAgICAgICBFbmQgICAgICAgOiAnRW5kJyxcbiAgICAgICAgICAgIEhvbWUgICAgICA6ICdIb21lJyxcbiAgICAgICAgICAgIFBhZ2VVcCAgICA6ICdQYWdlVXAnLFxuICAgICAgICAgICAgUGFnZURvd24gIDogJ1BhZ2VEb3duJyxcblxuICAgICAgICAgICAgLy8gRWRpdGluZyBrZXlzXG4gICAgICAgICAgICBCYWNrc3BhY2U6ICdCYWNrc3BhY2UnLFxuICAgICAgICAgICAgQ2xlYXIgICAgOiAnQ2xlYXInLFxuICAgICAgICAgICAgQ29weSAgICAgOiAnQ29weScsXG4gICAgICAgICAgICBDclNlbCAgICA6ICdDclNlbCcsIC8vICdDcnNlbCcgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxuICAgICAgICAgICAgQ3V0ICAgICAgOiAnQ3V0JyxcbiAgICAgICAgICAgIERlbGV0ZSAgIDogJ0RlbGV0ZScsIC8vICdEZWwnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcbiAgICAgICAgICAgIEVyYXNlRW9mIDogJ0VyYXNlRW9mJyxcbiAgICAgICAgICAgIEV4U2VsICAgIDogJ0V4U2VsJywgLy8gJ0V4c2VsJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XG4gICAgICAgICAgICBJbnNlcnQgICA6ICdJbnNlcnQnLFxuICAgICAgICAgICAgUGFzdGUgICAgOiAnUGFzdGUnLFxuICAgICAgICAgICAgUmVkbyAgICAgOiAnUmVkbycsXG4gICAgICAgICAgICBVbmRvICAgICA6ICdVbmRvJyxcblxuICAgICAgICAgICAgLy8gVUkga2V5c1xuICAgICAgICAgICAgQWNjZXB0ICAgICA6ICdBY2NlcHQnLFxuICAgICAgICAgICAgQWdhaW4gICAgICA6ICdBZ2FpbicsXG4gICAgICAgICAgICBBdHRuICAgICAgIDogJ0F0dG4nLCAvLyAnVW5pZGVudGlmaWVkJyBmb3IgRmlyZWZveCwgQ2hyb21lLCBhbmQgSUU5ICgnS2FuYU1vZGUnIHdoZW4gdXNpbmcgdGhlIEphcGFuZXNlIGtleWJvYXJkIGxheW91dClcbiAgICAgICAgICAgIENhbmNlbCAgICAgOiAnQ2FuY2VsJyxcbiAgICAgICAgICAgIENvbnRleHRNZW51OiAnQ29udGV4dE1lbnUnLCAvLyAnQXBwcycgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxuICAgICAgICAgICAgRXNjICAgICAgICA6ICdFc2NhcGUnLCAvLyAnRXNjJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XG4gICAgICAgICAgICBFeGVjdXRlICAgIDogJ0V4ZWN1dGUnLFxuICAgICAgICAgICAgRmluZCAgICAgICA6ICdGaW5kJyxcbiAgICAgICAgICAgIEZpbmlzaCAgICAgOiAnRmluaXNoJywgLy8gJ1VuaWRlbnRpZmllZCcgZm9yIEZpcmVmb3gsIENocm9tZSwgYW5kIElFOSAoJ0thdGFrYW5hJyB3aGVuIHVzaW5nIHRoZSBKYXBhbmVzZSBrZXlib2FyZCBsYXlvdXQpXG4gICAgICAgICAgICBIZWxwICAgICAgIDogJ0hlbHAnLFxuICAgICAgICAgICAgUGF1c2UgICAgICA6ICdQYXVzZScsXG4gICAgICAgICAgICBQbGF5ICAgICAgIDogJ1BsYXknLFxuICAgICAgICAgICAgUHJvcHMgICAgICA6ICdQcm9wcycsXG4gICAgICAgICAgICBTZWxlY3QgICAgIDogJ1NlbGVjdCcsXG4gICAgICAgICAgICBab29tSW4gICAgIDogJ1pvb21JbicsXG4gICAgICAgICAgICBab29tT3V0ICAgIDogJ1pvb21PdXQnLFxuXG4gICAgICAgICAgICAvLyBEZXZpY2Uga2V5c1xuICAgICAgICAgICAgQnJpZ2h0bmVzc0Rvd246ICdCcmlnaHRuZXNzRG93bicsXG4gICAgICAgICAgICBCcmlnaHRuZXNzVXAgIDogJ0JyaWdodG5lc3NVcCcsXG4gICAgICAgICAgICBFamVjdCAgICAgICAgIDogJ0VqZWN0JyxcbiAgICAgICAgICAgIExvZ09mZiAgICAgICAgOiAnTG9nT2ZmJyxcbiAgICAgICAgICAgIFBvd2VyICAgICAgICAgOiAnUG93ZXInLFxuICAgICAgICAgICAgUG93ZXJPZmYgICAgICA6ICdQb3dlck9mZicsXG4gICAgICAgICAgICBQcmludFNjcmVlbiAgIDogJ1ByaW50U2NyZWVuJyxcbiAgICAgICAgICAgIEhpYmVybmF0ZSAgICAgOiAnSGliZXJuYXRlJywgLy8gJ1VuaWRlbnRpZmllZCcgZm9yIEZpcmVmb3ggPD0zN1xuICAgICAgICAgICAgU3RhbmRieSAgICAgICA6ICdTdGFuZGJ5JywgLy8gJ1VuaWRlbnRpZmllZCcgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxuICAgICAgICAgICAgV2FrZVVwICAgICAgICA6ICdXYWtlVXAnLFxuXG4gICAgICAgICAgICAvLyBJTUUgYW5kIGNvbXBvc2l0aW9uIGtleXNcbiAgICAgICAgICAgIENvbXBvc2U6ICdDb21wb3NlJyxcbiAgICAgICAgICAgIERlYWQgICA6ICdEZWFkJyxcblxuICAgICAgICAgICAgLy8gRnVuY3Rpb24ga2V5c1xuICAgICAgICAgICAgRjEgOiAnRjEnLFxuICAgICAgICAgICAgRjIgOiAnRjInLFxuICAgICAgICAgICAgRjMgOiAnRjMnLFxuICAgICAgICAgICAgRjQgOiAnRjQnLFxuICAgICAgICAgICAgRjUgOiAnRjUnLFxuICAgICAgICAgICAgRjYgOiAnRjYnLFxuICAgICAgICAgICAgRjcgOiAnRjcnLFxuICAgICAgICAgICAgRjggOiAnRjgnLFxuICAgICAgICAgICAgRjkgOiAnRjknLFxuICAgICAgICAgICAgRjEwOiAnRjEwJyxcbiAgICAgICAgICAgIEYxMTogJ0YxMScsXG4gICAgICAgICAgICBGMTI6ICdGMTInLFxuXG4gICAgICAgICAgICAvLyBEb2N1bWVudCBrZXlzXG4gICAgICAgICAgICBQcmludDogJ1ByaW50JyxcblxuICAgICAgICAgICAgLy8gJ05vcm1hbCcga2V5c1xuICAgICAgICAgICAgbnVtMCAgICAgICAgOiAnMCcsXG4gICAgICAgICAgICBudW0xICAgICAgICA6ICcxJyxcbiAgICAgICAgICAgIG51bTIgICAgICAgIDogJzInLFxuICAgICAgICAgICAgbnVtMyAgICAgICAgOiAnMycsXG4gICAgICAgICAgICBudW00ICAgICAgICA6ICc0JyxcbiAgICAgICAgICAgIG51bTUgICAgICAgIDogJzUnLFxuICAgICAgICAgICAgbnVtNiAgICAgICAgOiAnNicsXG4gICAgICAgICAgICBudW03ICAgICAgICA6ICc3JyxcbiAgICAgICAgICAgIG51bTggICAgICAgIDogJzgnLFxuICAgICAgICAgICAgbnVtOSAgICAgICAgOiAnOScsXG4gICAgICAgICAgICBhICAgICAgICAgICA6ICdhJyxcbiAgICAgICAgICAgIGIgICAgICAgICAgIDogJ2InLFxuICAgICAgICAgICAgYyAgICAgICAgICAgOiAnYycsXG4gICAgICAgICAgICBkICAgICAgICAgICA6ICdkJyxcbiAgICAgICAgICAgIGUgICAgICAgICAgIDogJ2UnLFxuICAgICAgICAgICAgZiAgICAgICAgICAgOiAnZicsXG4gICAgICAgICAgICBnICAgICAgICAgICA6ICdnJyxcbiAgICAgICAgICAgIGggICAgICAgICAgIDogJ2gnLFxuICAgICAgICAgICAgaSAgICAgICAgICAgOiAnaScsXG4gICAgICAgICAgICBqICAgICAgICAgICA6ICdqJyxcbiAgICAgICAgICAgIGsgICAgICAgICAgIDogJ2snLFxuICAgICAgICAgICAgbCAgICAgICAgICAgOiAnbCcsXG4gICAgICAgICAgICBtICAgICAgICAgICA6ICdtJyxcbiAgICAgICAgICAgIG4gICAgICAgICAgIDogJ24nLFxuICAgICAgICAgICAgbyAgICAgICAgICAgOiAnbycsXG4gICAgICAgICAgICBwICAgICAgICAgICA6ICdwJyxcbiAgICAgICAgICAgIHEgICAgICAgICAgIDogJ3EnLFxuICAgICAgICAgICAgciAgICAgICAgICAgOiAncicsXG4gICAgICAgICAgICBzICAgICAgICAgICA6ICdzJyxcbiAgICAgICAgICAgIHQgICAgICAgICAgIDogJ3QnLFxuICAgICAgICAgICAgdSAgICAgICAgICAgOiAndScsXG4gICAgICAgICAgICB2ICAgICAgICAgICA6ICd2JyxcbiAgICAgICAgICAgIHcgICAgICAgICAgIDogJ3cnLFxuICAgICAgICAgICAgeCAgICAgICAgICAgOiAneCcsXG4gICAgICAgICAgICB5ICAgICAgICAgICA6ICd5JyxcbiAgICAgICAgICAgIHogICAgICAgICAgIDogJ3onLFxuICAgICAgICAgICAgQSAgICAgICAgICAgOiAnQScsXG4gICAgICAgICAgICBCICAgICAgICAgICA6ICdCJyxcbiAgICAgICAgICAgIEMgICAgICAgICAgIDogJ0MnLFxuICAgICAgICAgICAgRCAgICAgICAgICAgOiAnRCcsXG4gICAgICAgICAgICBFICAgICAgICAgICA6ICdFJyxcbiAgICAgICAgICAgIEYgICAgICAgICAgIDogJ0YnLFxuICAgICAgICAgICAgRyAgICAgICAgICAgOiAnRycsXG4gICAgICAgICAgICBIICAgICAgICAgICA6ICdIJyxcbiAgICAgICAgICAgIEkgICAgICAgICAgIDogJ0knLFxuICAgICAgICAgICAgSiAgICAgICAgICAgOiAnSicsXG4gICAgICAgICAgICBLICAgICAgICAgICA6ICdLJyxcbiAgICAgICAgICAgIEwgICAgICAgICAgIDogJ0wnLFxuICAgICAgICAgICAgTSAgICAgICAgICAgOiAnTScsXG4gICAgICAgICAgICBOICAgICAgICAgICA6ICdOJyxcbiAgICAgICAgICAgIE8gICAgICAgICAgIDogJ08nLFxuICAgICAgICAgICAgUCAgICAgICAgICAgOiAnUCcsXG4gICAgICAgICAgICBRICAgICAgICAgICA6ICdRJyxcbiAgICAgICAgICAgIFIgICAgICAgICAgIDogJ1InLFxuICAgICAgICAgICAgUyAgICAgICAgICAgOiAnUycsXG4gICAgICAgICAgICBUICAgICAgICAgICA6ICdUJyxcbiAgICAgICAgICAgIFUgICAgICAgICAgIDogJ1UnLFxuICAgICAgICAgICAgViAgICAgICAgICAgOiAnVicsXG4gICAgICAgICAgICBXICAgICAgICAgICA6ICdXJyxcbiAgICAgICAgICAgIFggICAgICAgICAgIDogJ1gnLFxuICAgICAgICAgICAgWSAgICAgICAgICAgOiAnWScsXG4gICAgICAgICAgICBaICAgICAgICAgICA6ICdaJyxcbiAgICAgICAgICAgIFNlbWljb2xvbiAgIDogJzsnLFxuICAgICAgICAgICAgRXF1YWwgICAgICAgOiAnPScsXG4gICAgICAgICAgICBDb21tYSAgICAgICA6ICcsJyxcbiAgICAgICAgICAgIEh5cGhlbiAgICAgIDogJy0nLFxuICAgICAgICAgICAgTWludXMgICAgICAgOiAnLScsXG4gICAgICAgICAgICBQbHVzICAgICAgICA6ICcrJyxcbiAgICAgICAgICAgIERvdCAgICAgICAgIDogJy4nLFxuICAgICAgICAgICAgU2xhc2ggICAgICAgOiAnLycsXG4gICAgICAgICAgICBCYWNrcXVvdGUgICA6ICdgJyxcbiAgICAgICAgICAgIExlZnRCcmFja2V0IDogJ1snLFxuICAgICAgICAgICAgUmlnaHRCcmFja2V0OiAnXScsXG4gICAgICAgICAgICBCYWNrc2xhc2ggICA6ICdcXFxcJyxcbiAgICAgICAgICAgIFF1b3RlICAgICAgIDogXCInXCIsXG5cbiAgICAgICAgICAgIC8vIE51bWVyaWMga2V5cGFkIGtleXNcbiAgICAgICAgICAgIG51bXBhZDAgICAgICAgICAgICAgICAgICAgICAgIDogJzAnLFxuICAgICAgICAgICAgbnVtcGFkMSAgICAgICAgICAgICAgICAgICAgICAgOiAnMScsXG4gICAgICAgICAgICBudW1wYWQyICAgICAgICAgICAgICAgICAgICAgICA6ICcyJyxcbiAgICAgICAgICAgIG51bXBhZDMgICAgICAgICAgICAgICAgICAgICAgIDogJzMnLFxuICAgICAgICAgICAgbnVtcGFkNCAgICAgICAgICAgICAgICAgICAgICAgOiAnNCcsXG4gICAgICAgICAgICBudW1wYWQ1ICAgICAgICAgICAgICAgICAgICAgICA6ICc1JyxcbiAgICAgICAgICAgIG51bXBhZDYgICAgICAgICAgICAgICAgICAgICAgIDogJzYnLFxuICAgICAgICAgICAgbnVtcGFkNyAgICAgICAgICAgICAgICAgICAgICAgOiAnNycsXG4gICAgICAgICAgICBudW1wYWQ4ICAgICAgICAgICAgICAgICAgICAgICA6ICc4JyxcbiAgICAgICAgICAgIG51bXBhZDkgICAgICAgICAgICAgICAgICAgICAgIDogJzknLFxuICAgICAgICAgICAgTnVtcGFkRG90ICAgICAgICAgICAgICAgICAgICAgOiAnLicsXG4gICAgICAgICAgICBOdW1wYWREb3RBbHQgICAgICAgICAgICAgICAgICA6ICcsJywgLy8gTW9kZXJuIGJyb3dzZXJzIGF1dG9tYXRpY2FsbHkgYWRhcHQgdGhlIGNoYXJhY3RlciBzZW50IGJ5IHRoaXMga2V5IHRvIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBvZiB0aGUgY3VycmVudCBsYW5ndWFnZVxuICAgICAgICAgICAgTnVtcGFkTXVsdGlwbHkgICAgICAgICAgICAgICAgOiAnKicsXG4gICAgICAgICAgICBOdW1wYWRQbHVzICAgICAgICAgICAgICAgICAgICA6ICcrJyxcbiAgICAgICAgICAgIE51bXBhZE1pbnVzICAgICAgICAgICAgICAgICAgIDogJy0nLFxuICAgICAgICAgICAgTnVtcGFkU2xhc2ggICAgICAgICAgICAgICAgICAgOiAnLycsXG4gICAgICAgICAgICBOdW1wYWREb3RPYnNvbGV0ZUJyb3dzZXJzICAgICA6ICdEZWNpbWFsJyxcbiAgICAgICAgICAgIE51bXBhZE11bHRpcGx5T2Jzb2xldGVCcm93c2VyczogJ011bHRpcGx5JyxcbiAgICAgICAgICAgIE51bXBhZFBsdXNPYnNvbGV0ZUJyb3dzZXJzICAgIDogJ0FkZCcsXG4gICAgICAgICAgICBOdW1wYWRNaW51c09ic29sZXRlQnJvd3NlcnMgICA6ICdTdWJ0cmFjdCcsXG4gICAgICAgICAgICBOdW1wYWRTbGFzaE9ic29sZXRlQnJvd3NlcnMgICA6ICdEaXZpZGUnLFxuXG4gICAgICAgICAgICAvLyBTcGVjaWFsIGFycmF5cyBmb3IgcXVpY2tlciB0ZXN0c1xuICAgICAgICAgICAgX2FsbEZuS2V5cyAgICAgICAgICAgOiBbJ0YxJywgJ0YyJywgJ0YzJywgJ0Y0JywgJ0Y1JywgJ0Y2JywgJ0Y3JywgJ0Y4JywgJ0Y5JywgJ0YxMCcsICdGMTEnLCAnRjEyJ10sXG4gICAgICAgICAgICBfc29tZU5vblByaW50YWJsZUtleXM6IFsnVGFiJywgJ0VudGVyJywgJ1NoaWZ0JywgJ1NoaWZ0TGVmdCcsICdTaGlmdFJpZ2h0JywgJ0NvbnRyb2wnLCAnQ29udHJvbExlZnQnLCAnQ29udHJvbFJpZ2h0JywgJ0FsdCcsICdBbHRMZWZ0JywgJ0FsdFJpZ2h0JywgJ1BhdXNlJywgJ0NhcHNMb2NrJywgJ0VzY2FwZSddLFxuICAgICAgICAgICAgX2RpcmVjdGlvbktleXMgICAgICAgOiBbJ1BhZ2VVcCcsICdQYWdlRG93bicsICdFbmQnLCAnSG9tZScsICdBcnJvd0Rvd24nLCAnQXJyb3dMZWZ0JywgJ0Fycm93UmlnaHQnLCAnQXJyb3dVcCddLFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBBdXRvTnVtZXJpY0VudW07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQXV0b051bWVyaWNFbnVtLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Helper functions for autoNumeric.js\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @author Alexandre Bonneau <alexandre.bonneau@linuxfr.eu>\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @copyright © 2016 Alexandre Bonneau\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The MIT License (http://www.opensource.org/licenses/mit-license.php)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Permission is hereby granted, free of charge, to any person\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * obtaining a copy of this software and associated documentation\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * files (the \"Software\"), to deal in the Software without\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * restriction, including without limitation the rights to use,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copy, modify, merge, publish, distribute, sub license, and/or sell\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * copies of the Software, and to permit persons to whom the\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Software is furnished to do so, subject to the following\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * conditions:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * The above copyright notice and this permission notice shall be\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * included in all copies or substantial portions of the Software.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * OTHER DEALINGS IN THE SOFTWARE.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _AutoNumericEnum = __webpack_require__(2);\n\nvar _AutoNumericEnum2 = _interopRequireDefault(_AutoNumericEnum);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Static class that holds all the helper functions autoNumeric uses.\n * Note : none of the functions in there are aware of any autoNumeric internals (which means there are no references to autoNumeric-specific info like options names or data structures).\n */\nvar AutoNumericHelper = function () {\n    function AutoNumericHelper() {\n        _classCallCheck(this, AutoNumericHelper);\n    }\n\n    _createClass(AutoNumericHelper, null, [{\n        key: 'isNull',\n\n        /**\n         * Return `true` if the `value` is null\n         *\n         * @static\n         * @param {*} value The value to test\n         * @returns {boolean} Return `true` if the `value` is null, FALSE otherwise\n         */\n        value: function isNull(value) {\n            return value === null;\n        }\n\n        /**\n         * Return `true` if the `value` is undefined\n         *\n         * @static\n         * @param {*} value The value to test\n         * @returns {boolean} Return `true` if the `value` is undefined, FALSE otherwise\n         */\n\n    }, {\n        key: 'isUndefined',\n        value: function isUndefined(value) {\n            return value === void 0;\n        }\n\n        /**\n         * Return `true` if the `value` is undefined, null or empty\n         *\n         * @param {*} value\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isUndefinedOrNullOrEmpty',\n        value: function isUndefinedOrNullOrEmpty(value) {\n            return value === null || value === void 0 || '' === value;\n        }\n\n        /**\n         * Return `true` if the given parameter is a String\n         *\n         * @param {*} str\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isString',\n        value: function isString(str) {\n            return typeof str === 'string' || str instanceof String;\n        }\n        /**\n         * Return `true` if the `value` is an empty string ''\n         *\n         * @static\n         * @param {*} value The value to test\n         * @returns {boolean} Return `true` if the `value` is an empty string '', FALSE otherwise\n         */\n\n    }, {\n        key: 'isEmptyString',\n        value: function isEmptyString(value) {\n            return value === '';\n        }\n\n        /**\n         * Return `true` if the parameter is a boolean\n         *\n         * @static\n         * @param {*} value\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isBoolean',\n        value: function isBoolean(value) {\n            return typeof value === 'boolean';\n        }\n\n        /**\n         * Return `true` if the parameter is a string 'true' or 'false'\n         *\n         * This function accepts any cases for those strings.\n         * @param {string} value\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isTrueOrFalseString',\n        value: function isTrueOrFalseString(value) {\n            var lowercaseValue = String(value).toLowerCase();\n            return lowercaseValue === 'true' || lowercaseValue === 'false';\n        }\n\n        /**\n         * Return `true` if the parameter is an object\n         *\n         * @param {*} reference\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isObject',\n        value: function isObject(reference) {\n            return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n        }\n\n        /**\n         * Return `true` if the given object is empty\n         * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\n         *\n         * @param {object} obj\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isEmptyObj',\n        value: function isEmptyObj(obj) {\n            for (var prop in obj) {\n                if (obj.hasOwnProperty(prop)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        /**\n         * Return `true` if the parameter is a real number (and not a numeric string).\n         *\n         * @param {*} n\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isNumberStrict',\n        value: function isNumberStrict(n) {\n            return typeof n === 'number';\n        }\n\n        /**\n         * Return `true` if the parameter is a number (or a number written as a string).\n         *\n         * @param {*} n\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isNumber',\n        value: function isNumber(n) {\n            return !this.isArray(n) && !isNaN(parseFloat(n)) && isFinite(n);\n        }\n\n        /**\n         * Return `true` if the parameter is a number (or a number written as a string).\n         * This version also accepts Arabic and Persian numbers.\n         *\n         * @param {*} n\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isNumberOrArabic',\n        value: function isNumberOrArabic(n) {\n            var latinConvertedNumber = this.arabicToLatinNumbers(n, false, true, true);\n            return this.isNumber(latinConvertedNumber);\n        }\n\n        /**\n         * Return `true` if the parameter is an integer (and not a float).\n         *\n         * @param {*} n\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isInt',\n        value: function isInt(n) {\n            return typeof n === 'number' && parseFloat(n) === parseInt(n, 10) && !isNaN(n);\n        }\n\n        /**\n         * Return `true` if the parameter is a function.\n         *\n         * @param {function} func\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isFunction',\n        value: function isFunction(func) {\n            return typeof func === 'function';\n        }\n\n        /**\n         * Return `true` is the string `str` contains the string `needle`\n         * Note: this function does not coerce the parameters types\n         *\n         * @param {string} str\n         * @param {string} needle\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'contains',\n        value: function contains(str, needle) {\n            //TODO Use `Array.prototype.includes()` when available (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)\n            if (!this.isString(str) || !this.isString(needle) || str === '' || needle === '') {\n                return false;\n            }\n\n            return str.indexOf(needle) !== -1;\n        }\n\n        /**\n         * Return `true` if the `needle` is in the array\n         *\n         * @param {*} needle\n         * @param {Array} array\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isInArray',\n        value: function isInArray(needle, array) {\n            if (!this.isArray(array) || array === [] || this.isUndefined(needle)) {\n                return false;\n            }\n\n            return array.indexOf(needle) !== -1;\n        }\n\n        /**\n         * Return `true` if the parameter is an Array\n         * //TODO Replace this by the default `Array.isArray()` function?\n         *\n         * @param {*} arr\n         * @throws Error\n         * @returns {*|boolean}\n         */\n\n    }, {\n        key: 'isArray',\n        value: function isArray(arr) {\n            if (Object.prototype.toString.call([]) === '[object Array]') {\n                // Make sure an array has a class attribute of [object Array]\n                // Test passed, now check if is an Array\n                return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n            } else {\n                throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n            }\n        }\n\n        /**\n         * Return `true` if the parameter is a DOM element\n         * cf. http://stackoverflow.com/a/4754104/2834898\n         *\n         * @param {*} obj\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isElement',\n        value: function isElement(obj) {\n            // return !!(obj && obj.nodeName);\n            // return obj && 'nodeType' in obj;\n            // return obj instanceof Element || obj instanceof HTMLInputElement || obj instanceof HTMLElement;\n            return obj instanceof Element;\n        }\n\n        /**\n         * Return `true` in the given DOM element is an <input>.\n         *\n         * @param {HTMLElement|HTMLInputElement} domElement\n         * @returns {boolean}\n         * @private\n         */\n\n    }, {\n        key: 'isInputElement',\n        value: function isInputElement(domElement) {\n            return this.isElement(domElement) && domElement.tagName.toLowerCase() === 'input';\n        }\n\n        /**\n         * Return `true` if the parameter is a string that represents a float number, and that number has a decimal part\n         *\n         * @param {string} str\n         * @returns {boolean}\n         */\n        // static hasDecimals(str) {\n        //     const [, decimalPart] = str.split('.');\n        //     return !isUndefined(decimalPart);\n        // }\n\n        /**\n         * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\n         *\n         * @param {string} str\n         * @returns {int}\n         */\n\n    }, {\n        key: 'decimalPlaces',\n        value: function decimalPlaces(str) {\n            var _str$split = str.split('.'),\n                _str$split2 = _slicedToArray(_str$split, 2),\n                decimalPart = _str$split2[1];\n\n            if (!this.isUndefined(decimalPart)) {\n                return decimalPart.length;\n            }\n\n            return 0;\n        }\n\n        /**\n         * Return the index of the first non-zero decimal place in the given value.\n         * The index starts after the decimal point, if any, and begins at '1'.\n         * If no decimal places are found in the value, this function returns `0`.\n         *\n         * @example\n         * indexFirstNonZeroDecimalPlace('0.00') -> 0\n         * indexFirstNonZeroDecimalPlace('1.00') -> 0\n         * indexFirstNonZeroDecimalPlace('0.12') -> 1\n         * indexFirstNonZeroDecimalPlace('0.1234') -> 1\n         * indexFirstNonZeroDecimalPlace('0.01234') -> 2\n         * indexFirstNonZeroDecimalPlace('0.001234') -> 3\n         * indexFirstNonZeroDecimalPlace('0.0001234') -> 4\n         *\n         * @param {number} value\n         * @returns {Number|number}\n         */\n\n    }, {\n        key: 'indexFirstNonZeroDecimalPlace',\n        value: function indexFirstNonZeroDecimalPlace(value) {\n            var _String$split = String(Math.abs(value)).split('.'),\n                _String$split2 = _slicedToArray(_String$split, 2),\n                decimalPart = _String$split2[1];\n\n            if (this.isUndefined(decimalPart)) {\n                return 0;\n            }\n\n            var result = decimalPart.lastIndexOf('0');\n            if (result === -1) {\n                result = 0;\n            } else {\n                result += 2;\n            }\n\n            return result;\n        }\n\n        /**\n         * Return the code for the key used to generate the given event.\n         *\n         * @param {Event} event\n         * @returns {string|Number}\n         */\n\n    }, {\n        key: 'keyCodeNumber',\n        value: function keyCodeNumber(event) {\n            // `event.keyCode` and `event.which` are deprecated, `KeyboardEvent.key` (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) must be used now\n            // Also, do note that Firefox generate a 'keypress' event (e.keyCode === 0) for the keys that do not print a character (ie. 'Insert', 'Delete', 'Fn' keys, 'PageUp', 'PageDown' etc.). 'Shift' on the other hand does not generate a keypress event.\n            return typeof event.which === 'undefined' ? event.keyCode : event.which;\n        }\n\n        /**\n         * Return the character from the event key code.\n         * If the KeyboardEvent does not represent a printable character, then the key name is used (ie. 'Meta', 'Shift', 'F1', etc.)\n         * @example character(50) => '2'\n         *\n         * @param {KeyboardEvent} event\n         * @returns {string}\n         */\n\n    }, {\n        key: 'character',\n        value: function character(event) {\n            var result = void 0;\n            if (event.key === 'Unidentified' || event.key === void 0 || this.isSeleniumBot()) {\n                //XXX The selenium geckodriver do not understand `event.key`, hence when using it, we need to rely on the old deprecated `keyCode` attribute, cf. upstream issue https://github.com/mozilla/geckodriver/issues/440\n                // Use the old deprecated keyCode property, if the new `key` one is not supported\n                var keyCode = this.keyCodeNumber(event);\n                if (keyCode === _AutoNumericEnum2.default.keyCode.AndroidDefault) {\n                    return _AutoNumericEnum2.default.keyName.AndroidDefault;\n                }\n\n                var potentialResult = _AutoNumericEnum2.default.fromCharCodeKeyCode[keyCode];\n                if (!AutoNumericHelper.isUndefinedOrNullOrEmpty(potentialResult)) {\n                    // Since `String.fromCharCode` do not return named keys for some keys ('Escape' and 'Enter' for instance), we convert the characters to the key names\n                    result = potentialResult;\n                } else {\n                    result = String.fromCharCode(keyCode);\n                }\n            } else {\n                var browser = void 0;\n                switch (event.key) {\n                    // Manages all the special cases for obsolete browsers that return the non-standard names\n                    case 'Add':\n                        result = _AutoNumericEnum2.default.keyName.NumpadPlus;\n                        break;\n                    case 'Apps':\n                        result = _AutoNumericEnum2.default.keyName.ContextMenu;\n                        break;\n                    case 'Crsel':\n                        result = _AutoNumericEnum2.default.keyName.CrSel;\n                        break;\n                    case 'Decimal':\n                        result = _AutoNumericEnum2.default.keyName.NumpadDot;\n                        break;\n                    case 'Del':\n                        browser = this.browser();\n                        if ((browser.name = 'firefox' && browser.version <= 36) || (browser.name = 'ie' && browser.version <= 9)) {\n                            // Special workaround for the obsolete browser IE11 which output a 'Delete' key when using the numpad 'dot' one! This fixes issue #401\n                            // This workaround break the usage of the 'Delete' key for Firefox <=36, and IE9, since those browser send 'Del' instead of 'Delete', therefore we only use it for those obsolete browsers\n                            result = _AutoNumericEnum2.default.keyName.Dot;\n                        } else {\n                            result = _AutoNumericEnum2.default.keyName.Delete;\n                        }\n                        break;\n                    case 'Divide':\n                        result = _AutoNumericEnum2.default.keyName.NumpadSlash;\n                        break;\n                    case 'Down':\n                        result = _AutoNumericEnum2.default.keyName.DownArrow;\n                        break;\n                    case 'Esc':\n                        result = _AutoNumericEnum2.default.keyName.Esc;\n                        break;\n                    case 'Exsel':\n                        result = _AutoNumericEnum2.default.keyName.ExSel;\n                        break;\n                    case 'Left':\n                        result = _AutoNumericEnum2.default.keyName.LeftArrow;\n                        break;\n                    case 'Meta':\n                    case 'Super':\n                        result = _AutoNumericEnum2.default.keyName.OSLeft;\n                        break;\n                    case 'Multiply':\n                        result = _AutoNumericEnum2.default.keyName.NumpadMultiply;\n                        break;\n                    case 'Right':\n                        result = _AutoNumericEnum2.default.keyName.RightArrow;\n                        break;\n                    case 'Spacebar':\n                        result = _AutoNumericEnum2.default.keyName.Space;\n                        break;\n                    case 'Subtract':\n                        result = _AutoNumericEnum2.default.keyName.NumpadMinus;\n                        break;\n                    case 'Up':\n                        result = _AutoNumericEnum2.default.keyName.UpArrow;\n                        break;\n                    default:\n                        // The normal case\n                        result = event.key;\n                }\n            }\n\n            return result;\n        }\n\n        /**\n         * Return an object containing the name and version of the current browser.\n         * @example `browserVersion()` => { name: 'Firefox', version: '42' }\n         * Based on http://stackoverflow.com/a/38080051/2834898\n         *\n         * @returns {{ name: string, version: string }}\n         */\n\n    }, {\n        key: 'browser',\n        value: function browser() {\n            var ua = navigator.userAgent;\n            var tem = void 0;\n            var M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\\/))\\/?\\s*(\\d+)/i) || [];\n\n            if (/trident/i.test(M[1])) {\n                tem = /\\brv[ :]+(\\d+)/g.exec(ua) || [];\n                return { name: 'ie', version: tem[1] || '' };\n            }\n\n            if (M[1] === 'Chrome') {\n                tem = ua.match(/\\b(OPR|Edge)\\/(\\d+)/);\n                if (tem !== null) {\n                    return { name: tem[1].replace('OPR', 'opera'), version: tem[2] };\n                }\n            }\n\n            M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];\n            if ((tem = ua.match(/version\\/(\\d+)/i)) !== null) {\n                M.splice(1, 1, tem[1]);\n            }\n\n            return { name: M[0].toLowerCase(), version: M[1] };\n        }\n\n        /**\n         * Check if the browser is controlled by Selenium.\n         * Note: This only works within the geckodriver.\n         * cf. http://stackoverflow.com/questions/33225947/can-a-website-detect-when-you-are-using-selenium-with-chromedriver\n         *\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isSeleniumBot',\n        value: function isSeleniumBot() {\n            // noinspection JSUnresolvedVariable\n            return window.navigator.webdriver === true;\n        }\n\n        /**\n         * Return `true` if the given number is negative, or if the given string contains a negative sign :\n         * - everywhere in the string (by default), or\n         * - on the first character only if the `checkEverywhere` parameter is set to `false`.\n         *\n         * @param {number|string} numberOrNumericString A Number, or a number represented by a string\n         * @param {boolean} checkEverywhere If TRUE, then the negative sign is search everywhere in the numeric string (this is needed for instance if the string is '1234.56-')\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isNegative',\n        value: function isNegative(numberOrNumericString) {\n            var checkEverywhere = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n            if (numberOrNumericString === '-') {\n                return true;\n            }\n\n            if (numberOrNumericString === '') {\n                return false;\n            }\n\n            //TODO Use the `negativeSignCharacter` from the settings here\n            if (AutoNumericHelper.isNumber(numberOrNumericString)) {\n                return numberOrNumericString < 0;\n            }\n\n            if (checkEverywhere) {\n                return this.contains(numberOrNumericString, '-');\n            }\n\n            return this.isNegativeStrict(numberOrNumericString);\n        }\n\n        /**\n         * Return `true` if the given string contains a negative sign on the first character (on the far left).\n         *\n         * @example isNegativeStrict('1234.56')     => false\n         * @example isNegativeStrict('1234.56-')    => false\n         * @example isNegativeStrict('-1234.56')    => true\n         * @example isNegativeStrict('-1,234.56 €') => true\n         *\n         * @param {string} numericString\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isNegativeStrict',\n        value: function isNegativeStrict(numericString) {\n            //TODO Using the `negativeSignCharacter` from the settings here\n            return numericString.charAt(0) === '-';\n        }\n\n        /**\n         * Return `true` if the very first character is the opening bracket, and if the rest of the `valueString` also has the closing bracket.\n         *\n         * @param {string} valueString\n         * @param {string} leftBracket\n         * @param {string} rightBracket\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isNegativeWithBrackets',\n        value: function isNegativeWithBrackets(valueString, leftBracket, rightBracket) {\n            return valueString.charAt(0) === leftBracket && this.contains(valueString, rightBracket);\n        }\n\n        /**\n         * Return `true` if the formatted or unformatted numeric string represent the value 0 (ie. '0,00 €'), or is empty (' €').\n         * This works since we test if there are any numbers from 1 to 9 in the string. If there is none, then the number is zero (or the string is empty).\n         *\n         * @param {string} numericString\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isZeroOrHasNoValue',\n        value: function isZeroOrHasNoValue(numericString) {\n            return !/[1-9]/g.test(numericString);\n        }\n\n        /**\n         * Return the negative version of the value (represented as a string) given as a parameter.\n         *\n         * @param {string} value\n         * @returns {*}\n         */\n\n    }, {\n        key: 'setRawNegativeSign',\n        value: function setRawNegativeSign(value) {\n            if (!this.isNegativeStrict(value)) {\n                return '-' + value;\n            }\n\n            return value;\n        }\n\n        /**\n         * Replace the character at the position `index` in the string `string` by the character(s) `newCharacter`.\n         *\n         * @param {string} string\n         * @param {int} index\n         * @param {string} newCharacter\n         * @returns {string}\n         */\n\n    }, {\n        key: 'replaceCharAt',\n        value: function replaceCharAt(string, index, newCharacter) {\n            return '' + string.substr(0, index) + newCharacter + string.substr(index + newCharacter.length);\n        }\n\n        /**\n         * Return the value clamped to the nearest minimum/maximum value, as defined in the settings.\n         *\n         * @param {string|number} value\n         * @param {object} settings\n         * @returns {number}\n         */\n\n    }, {\n        key: 'clampToRangeLimits',\n        value: function clampToRangeLimits(value, settings) {\n            //XXX This function always assume `settings.minimumValue` is lower than `settings.maximumValue`\n            return Math.max(settings.minimumValue, Math.min(settings.maximumValue, value));\n        }\n\n        /**\n         * Return the number of number or dot characters on the left side of the caret, in a formatted number.\n         *\n         * @param {string} formattedNumberString\n         * @param {int} caretPosition This must be a positive integer\n         * @param {string} decimalCharacter\n         * @returns {number}\n         */\n\n    }, {\n        key: 'countNumberCharactersOnTheCaretLeftSide',\n        value: function countNumberCharactersOnTheCaretLeftSide(formattedNumberString, caretPosition, decimalCharacter) {\n            // Here we count the dot and report it as a number character too, since it will 'stay' in the Javascript number when unformatted\n            var numberDotOrNegativeSign = new RegExp('[0-9' + decimalCharacter + '-]'); // No need to escape the decimal character here, since it's in `[]`\n\n            var numberDotAndNegativeSignCount = 0;\n            for (var i = 0; i < caretPosition; i++) {\n                // Test if the character is a number, a dot or an hyphen. If it is, count it, otherwise ignore it\n                if (numberDotOrNegativeSign.test(formattedNumberString[i])) {\n                    numberDotAndNegativeSignCount++;\n                }\n            }\n\n            return numberDotAndNegativeSignCount;\n        }\n\n        /**\n         * Walk the `formattedNumberString` from left to right, one char by one, counting the `formattedNumberStringIndex`.\n         * If the char is in the `rawNumberString` (starting at index 0), then `rawNumberStringIndex++`, and continue until\n         * there is no more characters in `rawNumberString`) or that `rawNumberStringIndex === caretPositionInRawValue`.\n         * When you stop, the `formattedNumberStringIndex` is the position where the caret should be set.\n         *\n         * @example\n         * 1234567|89.01   : position 7 (rawNumberString)\n         * 123.456.7|89,01 : position 9 (formattedNumberString)\n         *\n         * @param {string} rawNumberString\n         * @param {int} caretPositionInRawValue\n         * @param {string} formattedNumberString\n         * @param {string} decimalCharacter\n         * @returns {*}\n         */\n\n    }, {\n        key: 'findCaretPositionInFormattedNumber',\n        value: function findCaretPositionInFormattedNumber(rawNumberString, caretPositionInRawValue, formattedNumberString, decimalCharacter) {\n            var formattedNumberStringSize = formattedNumberString.length;\n            var rawNumberStringSize = rawNumberString.length;\n\n            var formattedNumberStringIndex = void 0;\n            var rawNumberStringIndex = 0;\n            for (formattedNumberStringIndex = 0; formattedNumberStringIndex < formattedNumberStringSize && rawNumberStringIndex < rawNumberStringSize && rawNumberStringIndex < caretPositionInRawValue; formattedNumberStringIndex++) {\n                if (rawNumberString[rawNumberStringIndex] === formattedNumberString[formattedNumberStringIndex] || rawNumberString[rawNumberStringIndex] === '.' && formattedNumberString[formattedNumberStringIndex] === decimalCharacter) {\n                    rawNumberStringIndex++;\n                }\n            }\n\n            return formattedNumberStringIndex;\n        }\n\n        /**\n         * Count the number of occurrence of the given character, in the given text.\n         *\n         * @param {string} character\n         * @param {string} text\n         * @returns {number}\n         */\n\n    }, {\n        key: 'countCharInText',\n        value: function countCharInText(character, text) {\n            var charCounter = 0;\n            for (var i = 0; i < text.length; i++) {\n                if (text[i] === character) {\n                    charCounter++;\n                }\n            }\n\n            return charCounter;\n        }\n\n        /**\n         * Return the index that can be used to set the caret position.\n         * This takes into account that the position is starting at '0', not 1.\n         *\n         * @param {int} characterCount\n         * @returns {number}\n         */\n\n    }, {\n        key: 'convertCharacterCountToIndexPosition',\n        value: function convertCharacterCountToIndexPosition(characterCount) {\n            return Math.max(characterCount, characterCount - 1);\n        }\n\n        /**\n         * Cross browser routine for getting selected range/cursor position.\n         * Note: this also works with edge cases like contenteditable-enabled elements, and hidden inputs.\n         *\n         * @param {HTMLInputElement|EventTarget} element\n         * @returns {{}}\n         */\n\n    }, {\n        key: 'getElementSelection',\n        value: function getElementSelection(element) {\n            var position = {};\n\n            var isSelectionStartUndefined = void 0;\n            try {\n                isSelectionStartUndefined = this.isUndefined(element.selectionStart);\n            } catch (error) {\n                isSelectionStartUndefined = false;\n            }\n\n            try {\n                if (isSelectionStartUndefined) {\n                    var selection = window.getSelection();\n                    var selectionInfo = selection.getRangeAt(0);\n                    position.start = selectionInfo.startOffset;\n                    position.end = selectionInfo.endOffset;\n                    position.length = position.end - position.start;\n                } else {\n                    position.start = element.selectionStart;\n                    position.end = element.selectionEnd;\n                    position.length = position.end - position.start;\n                }\n            } catch (error) {\n                // Manages the cases where :\n                // - the 'contenteditable' elements that have no selections\n                // - the <input> element is of type 'hidden'\n                position.start = 0;\n                position.end = 0;\n                position.length = 0;\n            }\n\n            return position;\n        }\n\n        /**\n         * Cross browser routine for setting selected range/cursor position\n         *\n         * @param {HTMLInputElement|EventTarget} element\n         * @param {int} start\n         * @param {int|null} end\n         */\n\n    }, {\n        key: 'setElementSelection',\n        value: function setElementSelection(element, start) {\n            var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n            if (this.isUndefinedOrNullOrEmpty(end)) {\n                end = start;\n            }\n\n            if (this.isInputElement(element)) {\n                element.setSelectionRange(start, end);\n            } else if (!AutoNumericHelper.isNull(element.firstChild)) {\n                var range = document.createRange();\n                range.setStart(element.firstChild, start);\n                range.setEnd(element.firstChild, end);\n                var selection = window.getSelection();\n                selection.removeAllRanges();\n                selection.addRange(range);\n            }\n        }\n\n        /**\n         * Function that throw error messages\n         *\n         * @param {string} message\n         * @throws\n         */\n\n    }, {\n        key: 'throwError',\n        value: function throwError(message) {\n            throw new Error(message);\n        }\n\n        /**\n         * Function that display a warning messages, according to the debug level.\n         *\n         * @param {string} message\n         * @param {boolean} showWarning If FALSE, then the warning message is not displayed\n         */\n\n    }, {\n        key: 'warning',\n        value: function warning(message) {\n            var showWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n            if (showWarning) {\n                /* eslint no-console: 0 */\n                console.warn('Warning: ' + message);\n            }\n        }\n\n        /**\n         * Return `true` if the given event is a wheelup event\n         *\n         * @param {WheelEvent} wheelEvent\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isWheelUpEvent',\n        value: function isWheelUpEvent(wheelEvent) {\n            if (!wheelEvent.deltaY) {\n                this.throwError('The event passed as a parameter is not a valid wheel event, \\'' + wheelEvent.type + '\\' given.');\n            }\n\n            return wheelEvent.deltaY < 0;\n        }\n\n        /**\n         * Return `true` if the given event is a wheeldown event\n         *\n         * @param {WheelEvent} wheelEvent\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isWheelDownEvent',\n        value: function isWheelDownEvent(wheelEvent) {\n            if (!wheelEvent.deltaY) {\n                this.throwError('The event passed as a parameter is not a valid wheel event, \\'' + wheelEvent.type + '\\' given.');\n            }\n\n            return wheelEvent.deltaY > 0;\n        }\n\n        /**\n         * Return the given raw value truncated at the given number of decimal places `decimalPlaces`.\n         * This function does not round the value.\n         *\n         * @example\n         * forceDecimalPlaces(123.45678, 0) -> '123.45678'\n         * forceDecimalPlaces(123.45678, 1) -> '123.4'\n         * forceDecimalPlaces(123.45678, 2) -> '123.45'\n         * forceDecimalPlaces(123.45678, 3) -> '123.456'\n         *\n         * @param {number} value\n         * @param {int} decimalPlaces\n         * @returns {number|string}\n         */\n\n    }, {\n        key: 'forceDecimalPlaces',\n        value: function forceDecimalPlaces(value, decimalPlaces) {\n            // We could make sure `decimalPlaces` is an integer and positive, but we'll leave that to the dev calling this function.\n            var _String$split3 = String(value).split('.'),\n                _String$split4 = _slicedToArray(_String$split3, 2),\n                integerPart = _String$split4[0],\n                decimalPart = _String$split4[1];\n\n            if (!decimalPart) {\n                return value;\n            }\n\n            return integerPart + '.' + decimalPart.substr(0, decimalPlaces);\n        }\n\n        /**\n         * Return the 'nearest rounded' value, according to the given step size.\n         * @example roundToNearest(264789, 10000)) => 260000\n         *\n         * @param {number} value\n         * @param {number} stepPlace\n         * @returns {*}\n         */\n\n    }, {\n        key: 'roundToNearest',\n        value: function roundToNearest(value) {\n            var stepPlace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n\n            if (0 === value) {\n                return 0;\n            }\n\n            if (stepPlace === 0) {\n                this.throwError('The `stepPlace` used to round is equal to `0`. This value must not be equal to zero.');\n            }\n\n            return Math.round(value / stepPlace) * stepPlace;\n        }\n\n        /**\n         * Return the 'nearest rounded' value by automatically adding or subtracting the calculated offset to the initial value.\n         * This is done without having to pass a step to this function, and based on the size of the given `value`.\n         *\n         * @example                    Calculated offset\n         *           1 ->           1 (1)\n         *          14 ->          10 (10)\n         *         143 ->         140 (10)\n         *       1.278 ->       1.300 (100)\n         *      28.456 ->      28.500 (100)\n         *     276.345 ->     276.000 (1.000)\n         *   4.534.061 ->   4.530.000 (10.000)\n         *  66.723.844 ->  66.700.000 (100.000)\n         * 257.833.411 -> 258.000.000 (1.000.000)\n         *\n         *                           Initial   Added   Offset\n         * 2 decimalPlacesRawValue : 1.12   -> 2.00   (1)\n         * 3 decimalPlacesRawValue : 1.123  -> 2.000  (1)\n         *\n         * Special case when the `value` to round is between -1 and 1, excluded :\n         * @example\n         *     Number of             Initial   Result  Calculated\n         *     decimal places        value     (add)   offset\n         * 2 decimalPlacesRawValue : 0.12   -> 0.13    (0.01) : Math.pow(10, -2)\n         * 2 decimalPlacesRawValue : 0.01   -> 0.02    (0.01)\n         * 2 decimalPlacesRawValue : 0.00   -> 0.01    (0.01)\n         *\n         * 3 decimalPlacesRawValue : 0.123  -> 0.133   (0.01)  : Math.pow(10, -2)\n         * 3 decimalPlacesRawValue : 0.012  -> 0.013   (0.001) : Math.pow(10, -3)\n         * 3 decimalPlacesRawValue : 0.001  -> 0.001   (0.001)\n         * 3 decimalPlacesRawValue : 0.000  -> 0.001   (0.001)\n         *\n         * 4 decimalPlacesRawValue : 0.4123 -> 0.4200  (0.01)   : Math.pow(10, -2)\n         * 4 decimalPlacesRawValue : 0.0412 -> 0.0420  (0.001)  : Math.pow(10, -3)\n         * 4 decimalPlacesRawValue : 0.0041 -> 0.0042  (0.0001) : Math.pow(10, -4)\n         * 4 decimalPlacesRawValue : 0.0004 -> 0.0005  (0.0001)\n         * 4 decimalPlacesRawValue : 0.0000 -> 0.0001  (0.0001)\n         *\n         * @param {number} value\n         * @param {boolean} isAddition\n         * @param {int} decimalPlacesRawValue The precision needed by the `rawValue`\n         * @returns {*}\n         */\n\n    }, {\n        key: 'modifyAndRoundToNearestAuto',\n        value: function modifyAndRoundToNearestAuto(value, isAddition, decimalPlacesRawValue) {\n            value = Number(this.forceDecimalPlaces(value, decimalPlacesRawValue)); // Make sure that '0.13000000001' is converted to the number of rawValue decimal places '0.13'\n\n            var absValue = Math.abs(value);\n            if (absValue >= 0 && absValue < 1) {\n                var rawValueMinimumOffset = Math.pow(10, -decimalPlacesRawValue);\n                if (value === 0) {\n                    // 4 decimalPlacesRawValue : 0.0000 -> 0.0001 (0.0001)\n                    return isAddition ? rawValueMinimumOffset : -rawValueMinimumOffset;\n                }\n\n                var offset = void 0;\n                var minimumOffsetFirstDecimalPlaceIndex = decimalPlacesRawValue;\n                // Find where is the first non-zero decimal places\n                var indexFirstNonZeroDecimalPlace = this.indexFirstNonZeroDecimalPlace(value);\n                if (indexFirstNonZeroDecimalPlace >= minimumOffsetFirstDecimalPlaceIndex - 1) {\n                    /* 4 decimalPlacesRawValue : 0.0041 -> 0.0042 (0.0001) : Math.pow(10, -4)\n                     * 4 decimalPlacesRawValue : 0.0004 -> 0.0005 (0.0001)\n                     */\n                    offset = rawValueMinimumOffset;\n                } else {\n                    offset = Math.pow(10, -(indexFirstNonZeroDecimalPlace + 1));\n                }\n\n                var result = void 0;\n                if (isAddition) {\n                    result = value + offset;\n                } else {\n                    result = value - offset;\n                }\n\n                return this.roundToNearest(result, offset);\n            } else {\n                // For values >= 1\n                value = parseInt(value, 10);\n                var lengthValue = Math.abs(value).toString().length; // `Math.abs()` is needed here to omit the negative sign '-' in case of a negative value\n\n                var pow = void 0;\n                switch (lengthValue) {\n                    // Special cases for small numbers\n                    case 1:\n                        pow = 0;\n                        break;\n                    case 2:\n                    case 3:\n                        pow = 1;\n                        break;\n                    case 4:\n                    case 5:\n                        pow = 2;\n                        break;\n                    // Default behavior\n                    default:\n                        pow = lengthValue - 3;\n                }\n                var _offset = Math.pow(10, pow);\n\n                var _result = void 0;\n                if (isAddition) {\n                    _result = value + _offset;\n                } else {\n                    _result = value - _offset;\n                }\n\n                if (_result <= 10 && _result >= -10) {\n                    return _result;\n                }\n\n                return this.roundToNearest(_result, _offset);\n            }\n        }\n\n        /**\n         * Return the 'nearest rounded' value automatically by adding the calculated offset to the initial value.\n         * This will limit the result to the given number of decimal places `decimalPlacesLimit`.\n         *\n         * @param {number} value\n         * @param {int} decimalPlacesLimit\n         * @returns {*}\n         */\n\n    }, {\n        key: 'addAndRoundToNearestAuto',\n        value: function addAndRoundToNearestAuto(value, decimalPlacesLimit) {\n            return this.modifyAndRoundToNearestAuto(value, true, decimalPlacesLimit);\n        }\n\n        /**\n         * Return the 'nearest rounded' value automatically by subtracting the calculated offset to the initial value.\n         * This will limit the result to the given number of decimal places `decimalPlacesLimit`.\n         *\n         * @param {number} value\n         * @param {int} decimalPlacesLimit\n         * @returns {*}\n         */\n\n    }, {\n        key: 'subtractAndRoundToNearestAuto',\n        value: function subtractAndRoundToNearestAuto(value, decimalPlacesLimit) {\n            return this.modifyAndRoundToNearestAuto(value, false, decimalPlacesLimit);\n        }\n\n        /**\n         * Take an arabic number as a string and return a javascript number.\n         * By default, this function does not try to convert the arabic decimal and thousand separator characters.\n         * This returns `NaN` is the conversion is not possible.\n         * Based on http://stackoverflow.com/a/17025392/2834898\n         *\n         * @param {string} arabicNumbers\n         * @param {boolean} returnANumber If `true`, return a Number, otherwise return a String\n         * @param {boolean} parseDecimalCharacter\n         * @param {boolean} parseThousandSeparator\n         * @returns {string|number|NaN}\n         */\n\n    }, {\n        key: 'arabicToLatinNumbers',\n        value: function arabicToLatinNumbers(arabicNumbers) {\n            var returnANumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            var parseDecimalCharacter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n            var parseThousandSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n            if (this.isNull(arabicNumbers)) {\n                return arabicNumbers;\n            }\n\n            var result = arabicNumbers.toString();\n            if (result === '') {\n                return arabicNumbers;\n            }\n\n            if (result.match(/[٠١٢٣٤٥٦٧٨٩۴۵۶]/g) === null) {\n                // If no Arabic/Persian numbers are found, return the numeric string or number directly\n                if (returnANumber) {\n                    result = Number(result);\n                }\n\n                return result;\n            }\n\n            if (parseDecimalCharacter) {\n                result = result.replace(/٫/, '.'); // Decimal character\n            }\n\n            if (parseThousandSeparator) {\n                result = result.replace(/٬/g, ''); // Thousand separator\n            }\n\n            // Replace the numbers only\n            result = result.replace(/[٠١٢٣٤٥٦٧٨٩]/g, function (d) {\n                return d.charCodeAt(0) - 1632;\n            }) // Arabic numbers\n            .replace(/[۰۱۲۳۴۵۶۷۸۹]/g, function (d) {\n                return d.charCodeAt(0) - 1776;\n            }); // Persian numbers\n\n            // `NaN` has precedence over the string `'NaN'`\n            var resultAsNumber = Number(result);\n            if (isNaN(resultAsNumber)) {\n                return resultAsNumber;\n            }\n\n            if (returnANumber) {\n                result = resultAsNumber;\n            }\n\n            return result;\n        }\n\n        /**\n         * Create a custom event and immediately sent it from the given element.\n         * By default, if no element is given, the event is thrown from `document`.\n         *\n         * @param {string} eventName\n         * @param {HTMLElement|HTMLDocument} element\n         * @param {object} detail\n         */\n\n    }, {\n        key: 'triggerEvent',\n        value: function triggerEvent(eventName) {\n            var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n            var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n            var event = void 0;\n            if (window.CustomEvent) {\n                event = new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n            } else {\n                event = document.createEvent('CustomEvent');\n                event.initCustomEvent(eventName, true, true, { detail: detail });\n            }\n\n            element.dispatchEvent(event);\n        }\n\n        /**\n         * Function to parse minimumValue, maximumValue & the input value to prepare for testing to determine if the value falls within the min / max range.\n         * Return an object example: minimumValue: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\".\n         *\n         * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\n         *\n         * @param {number|string} n A numeric value.\n         * @returns {{}}\n         */\n\n    }, {\n        key: 'parseStr',\n        value: function parseStr(n) {\n            var x = {}; // A Big number instance.\n            var e = void 0;\n            var i = void 0;\n            var nL = void 0;\n            var j = void 0;\n\n            // Minus zero?\n            if (n === 0 && 1 / n < 0) {\n                n = '-0';\n            }\n\n            // Determine sign. 1 positive, -1 negative\n            n = n.toString();\n            if (this.isNegativeStrict(n)) {\n                n = n.slice(1);\n                x.s = -1;\n            } else {\n                x.s = 1;\n            }\n\n            // Decimal point?\n            e = n.indexOf('.');\n            if (e > -1) {\n                n = n.replace('.', '');\n            }\n\n            // length of string if no decimal character\n            if (e < 0) {\n                // Integer\n                e = n.length;\n            }\n\n            // Determine leading zeros\n            i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n            nL = n.length;\n            if (i === nL) {\n                // Zero\n                x.e = 0;\n                x.c = [0];\n            } else {\n                // Determine trailing zeros\n                for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                    nL -= 1;\n                }\n                nL -= 1;\n\n                // Decimal location\n                x.e = e - i - 1;\n                x.c = [];\n\n                // Convert string to array of digits without leading/trailing zeros\n                for (e = 0; i <= nL; i += 1) {\n                    x.c[e] = +n.charAt(i);\n                    e += 1;\n                }\n            }\n\n            return x;\n        }\n\n        /**\n         * Function to test if the input value falls with the Min / Max settings.\n         * This uses the parsed strings for the above parseStr function.\n         *\n         * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\n         *\n         * @param {object} y Big number instance\n         * @param {object} x Big number instance\n         * @returns {*}\n         */\n\n    }, {\n        key: 'testMinMax',\n        value: function testMinMax(y, x) {\n            var xc = x.c;\n            var yc = y.c;\n            var i = x.s;\n            var j = y.s;\n            var k = x.e;\n            var l = y.e;\n\n            // Either zero?\n            if (!xc[0] || !yc[0]) {\n                var _result2 = void 0;\n                if (!xc[0]) {\n                    _result2 = !yc[0] ? 0 : -j;\n                } else {\n                    _result2 = i;\n                }\n                return _result2;\n            }\n\n            // Signs differ?\n            if (i !== j) {\n                return i;\n            }\n            var xNeg = i < 0;\n\n            // Compare exponents\n            if (k !== l) {\n                return k > l ^ xNeg ? 1 : -1;\n            }\n            i = -1;\n            k = xc.length;\n            l = yc.length;\n            j = k < l ? k : l;\n\n            // Compare digit by digit\n            for (i += 1; i < j; i += 1) {\n                if (xc[i] !== yc[i]) {\n                    return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n                }\n            }\n\n            // Compare lengths\n            var result = void 0;\n            if (k === l) {\n                result = 0;\n            } else {\n                result = k > l ^ xNeg ? 1 : -1;\n            }\n\n            return result;\n        }\n\n        /**\n         * Generate a random string.\n         * cf. http://stackoverflow.com/a/8084248/2834898\n         *\n         * @param {Number} strLength Length of the generated string (in character count)\n         * @returns {string}\n         */\n\n    }, {\n        key: 'randomString',\n        value: function randomString() {\n            var strLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n\n            return Math.random().toString(36).substr(2, strLength);\n        }\n\n        /**\n         * Retrieve the current element value.\n         *\n         * @param {HTMLElement|HTMLInputElement|EventTarget} element\n         * @returns {number|string|null}\n         */\n\n    }, {\n        key: 'getElementValue',\n        value: function getElementValue(element) {\n            if (element.tagName.toLowerCase() === 'input') {\n                return element.value;\n            }\n\n            return this.text(element);\n        }\n\n        /**\n         * Modify the element value directly.\n         *\n         * @param {HTMLElement|HTMLInputElement} element\n         * @param {number|string|null} value\n         */\n\n    }, {\n        key: 'setElementValue',\n        value: function setElementValue(element) {\n            var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            if (element.tagName.toLowerCase() === 'input') {\n                element.value = value;\n            } else {\n                element.textContent = value;\n            }\n        }\n\n        /**\n         * This clone the given object, and return it.\n         * WARNING: This does not do a deep cloning.\n         * cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Examples\n         * //TODO Add a `deep` option to clone object with more than one depth\n         *\n         * @param {object} obj\n         * @returns {object}\n         */\n\n    }, {\n        key: 'cloneObject',\n        value: function cloneObject(obj) {\n            return _extends({}, obj);\n        }\n\n        /**\n         * Return a 'camelized' version of the given string.\n         * By default, this assume that :\n         * - the separators are hyphens '-',\n         * - the 'data-' string should be removed, and\n         * - that the very first word should not be capitalized.\n         *\n         * @example camelize('data-currency-symbol') => 'currencySymbol'\n         *\n         * @param {string} str Text to camelize\n         * @param {string} separator Character that separate each word\n         * @param {boolean} removeData If set to `true`, remove the `data-` part that you can find on some html attributes\n         * @param {boolean} skipFirstWord If set to `true`, do not capitalize the very first word\n         * @returns {string|null}\n         */\n\n    }, {\n        key: 'camelize',\n        value: function camelize(str) {\n            var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';\n            var removeData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n            var skipFirstWord = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n            if (this.isNull(str)) {\n                return null;\n            }\n\n            if (removeData) {\n                str = str.replace(/^data-/, '');\n            }\n\n            // Cut the string into words\n            var words = str.split(separator);\n\n            // Capitalize each word\n            var result = words.map(function (word) {\n                return '' + word.charAt(0).toUpperCase() + word.slice(1);\n            });\n\n            // Then concatenate them back\n            result = result.join('');\n\n            if (skipFirstWord) {\n                // Skip the very first letter\n                result = '' + result.charAt(0).toLowerCase() + result.slice(1);\n            }\n\n            return result;\n        }\n\n        /**\n         * Return the text component of the given DOM element.\n         *\n         * @param {Element} domElement\n         * @returns {string}\n         */\n\n    }, {\n        key: 'text',\n        value: function text(domElement) {\n            var nodeType = domElement.nodeType;\n\n            var result = void 0;\n            // cf. https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n            if (nodeType === Node.ELEMENT_NODE || nodeType === Node.DOCUMENT_NODE || nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                result = domElement.textContent;\n            } else if (nodeType === Node.TEXT_NODE) {\n                result = domElement.nodeValue;\n            } else {\n                result = '';\n            }\n\n            return result;\n        }\n\n        /**\n         * Set the text content of the given DOM element.\n         * @param {Element} domElement\n         * @param {string} text\n         */\n\n    }, {\n        key: 'setText',\n        value: function setText(domElement, text) {\n            var nodeType = domElement.nodeType;\n            if (nodeType === Node.ELEMENT_NODE || nodeType === Node.DOCUMENT_NODE || nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                domElement.textContent = text;\n            }\n            //TODO Display a warning if that function does not do anything?\n        }\n\n        /**\n         * Filter out the given `arr` array with the elements found in `excludedElements`.\n         * This returns a new array and does not modify the source.\n         * cf. verification here : http://codepen.io/AnotherLinuxUser/pen/XpvrMg?editors=0012\n         *\n         * @param {Array} arr\n         * @param {Array} excludedElements\n         * @returns {*|Array.<T>}\n         */\n\n    }, {\n        key: 'filterOut',\n        value: function filterOut(arr, excludedElements) {\n            var _this = this;\n\n            return arr.filter(function (element) {\n                return !_this.isInArray(element, excludedElements);\n            });\n        }\n\n        /**\n         * Remove the trailing zeros in the decimal part of a number.\n         *\n         * @param {string} numericString\n         * @returns {*}\n         */\n\n    }, {\n        key: 'trimPaddedZerosFromDecimalPlaces',\n        value: function trimPaddedZerosFromDecimalPlaces(numericString) {\n            numericString = String(numericString);\n            if (numericString === '') {\n                return '';\n            }\n\n            var _numericString$split = numericString.split('.'),\n                _numericString$split2 = _slicedToArray(_numericString$split, 2),\n                integerPart = _numericString$split2[0],\n                decimalPart = _numericString$split2[1];\n\n            if (this.isUndefinedOrNullOrEmpty(decimalPart)) {\n                return integerPart;\n            }\n\n            var trimmedDecimalPart = decimalPart.replace(/0+$/g, '');\n\n            var result = void 0;\n            if (trimmedDecimalPart === '') {\n                result = integerPart;\n            } else {\n                result = integerPart + '.' + trimmedDecimalPart;\n            }\n\n            return result;\n        }\n\n        /**\n         * Return the top-most hovered item by the mouse cursor.\n         *\n         * @returns {*}\n         */\n\n    }, {\n        key: 'getHoveredElement',\n        value: function getHoveredElement() {\n            var hoveredElements = [].concat(_toConsumableArray(document.querySelectorAll(':hover')));\n            return hoveredElements[hoveredElements.length - 1];\n        }\n\n        /**\n         * Return the given array trimmed to the given length.\n         * @example arrayTrim([1, 2, 3, 4], 2) -> [1, 2]\n         *\n         * @param {Array} array\n         * @param {Number} length\n         * @returns {*}\n         */\n\n    }, {\n        key: 'arrayTrim',\n        value: function arrayTrim(array, length) {\n            var arrLength = array.length;\n            if (arrLength === 0 || length > arrLength) {\n                // Also manage the case where `length` is higher than the current length\n                return array;\n            }\n\n            if (length < 0) {\n                return [];\n            }\n\n            array.length = parseInt(length, 10);\n\n            return array;\n        }\n\n        /**\n         * Merge all the given arrays by keeping only unique elements, and return an array with de-duplicated values.\n         * cf. http://stackoverflow.com/a/27664971/2834898\n         *\n         * @param {...array} arrays\n         * @returns {[*]}\n         */\n\n    }, {\n        key: 'arrayUnique',\n        value: function arrayUnique() {\n            var _ref;\n\n            //FIXME à tester\n            return [].concat(_toConsumableArray(new Set((_ref = []).concat.apply(_ref, arguments))));\n        }\n\n        /**\n         * Merge all the given Maps by keeping only unique elements, and return a new Map with de-duplicated keys.\n         *\n         * @param {...Map} mapObjects\n         * @returns {Map}\n         */\n\n    }, {\n        key: 'mergeMaps',\n        value: function mergeMaps() {\n            for (var _len = arguments.length, mapObjects = Array(_len), _key = 0; _key < _len; _key++) {\n                mapObjects[_key] = arguments[_key];\n            }\n\n            return new Map(mapObjects.reduce(function (as, b) {\n                return as.concat([].concat(_toConsumableArray(b)));\n            }, []));\n        }\n    }]);\n\n    return AutoNumericHelper;\n}();\n\nexports.default = AutoNumericHelper;\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXV0b051bWVyaWNIZWxwZXIuanM/ODU0YyJdLCJuYW1lcyI6WyJBdXRvTnVtZXJpY0hlbHBlciIsInZhbHVlIiwic3RyIiwiU3RyaW5nIiwibG93ZXJjYXNlVmFsdWUiLCJ0b0xvd2VyQ2FzZSIsInJlZmVyZW5jZSIsIkFycmF5IiwiaXNBcnJheSIsIm9iaiIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsIm4iLCJpc05hTiIsInBhcnNlRmxvYXQiLCJpc0Zpbml0ZSIsImxhdGluQ29udmVydGVkTnVtYmVyIiwiYXJhYmljVG9MYXRpbk51bWJlcnMiLCJpc051bWJlciIsInBhcnNlSW50IiwiZnVuYyIsIm5lZWRsZSIsImlzU3RyaW5nIiwiaW5kZXhPZiIsImFycmF5IiwiaXNVbmRlZmluZWQiLCJhcnIiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJFcnJvciIsIkVsZW1lbnQiLCJkb21FbGVtZW50IiwiaXNFbGVtZW50IiwidGFnTmFtZSIsInNwbGl0IiwiZGVjaW1hbFBhcnQiLCJsZW5ndGgiLCJNYXRoIiwiYWJzIiwicmVzdWx0IiwibGFzdEluZGV4T2YiLCJldmVudCIsIndoaWNoIiwia2V5Q29kZSIsImtleSIsImlzU2VsZW5pdW1Cb3QiLCJrZXlDb2RlTnVtYmVyIiwiQW5kcm9pZERlZmF1bHQiLCJrZXlOYW1lIiwicG90ZW50aWFsUmVzdWx0IiwiZnJvbUNoYXJDb2RlS2V5Q29kZSIsImlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSIsImZyb21DaGFyQ29kZSIsImJyb3dzZXIiLCJOdW1wYWRQbHVzIiwiQ29udGV4dE1lbnUiLCJDclNlbCIsIk51bXBhZERvdCIsIm5hbWUiLCJ2ZXJzaW9uIiwiRG90IiwiRGVsZXRlIiwiTnVtcGFkU2xhc2giLCJEb3duQXJyb3ciLCJFc2MiLCJFeFNlbCIsIkxlZnRBcnJvdyIsIk9TTGVmdCIsIk51bXBhZE11bHRpcGx5IiwiUmlnaHRBcnJvdyIsIlNwYWNlIiwiTnVtcGFkTWludXMiLCJVcEFycm93IiwidWEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ0ZW0iLCJNIiwibWF0Y2giLCJ0ZXN0IiwiZXhlYyIsInJlcGxhY2UiLCJhcHBOYW1lIiwiYXBwVmVyc2lvbiIsInNwbGljZSIsIndpbmRvdyIsIndlYmRyaXZlciIsIm51bWJlck9yTnVtZXJpY1N0cmluZyIsImNoZWNrRXZlcnl3aGVyZSIsImNvbnRhaW5zIiwiaXNOZWdhdGl2ZVN0cmljdCIsIm51bWVyaWNTdHJpbmciLCJjaGFyQXQiLCJ2YWx1ZVN0cmluZyIsImxlZnRCcmFja2V0IiwicmlnaHRCcmFja2V0Iiwic3RyaW5nIiwiaW5kZXgiLCJuZXdDaGFyYWN0ZXIiLCJzdWJzdHIiLCJzZXR0aW5ncyIsIm1heCIsIm1pbmltdW1WYWx1ZSIsIm1pbiIsIm1heGltdW1WYWx1ZSIsImZvcm1hdHRlZE51bWJlclN0cmluZyIsImNhcmV0UG9zaXRpb24iLCJkZWNpbWFsQ2hhcmFjdGVyIiwibnVtYmVyRG90T3JOZWdhdGl2ZVNpZ24iLCJSZWdFeHAiLCJudW1iZXJEb3RBbmROZWdhdGl2ZVNpZ25Db3VudCIsImkiLCJyYXdOdW1iZXJTdHJpbmciLCJjYXJldFBvc2l0aW9uSW5SYXdWYWx1ZSIsImZvcm1hdHRlZE51bWJlclN0cmluZ1NpemUiLCJyYXdOdW1iZXJTdHJpbmdTaXplIiwiZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXgiLCJyYXdOdW1iZXJTdHJpbmdJbmRleCIsImNoYXJhY3RlciIsInRleHQiLCJjaGFyQ291bnRlciIsImNoYXJhY3RlckNvdW50IiwiZWxlbWVudCIsInBvc2l0aW9uIiwiaXNTZWxlY3Rpb25TdGFydFVuZGVmaW5lZCIsInNlbGVjdGlvblN0YXJ0IiwiZXJyb3IiLCJzZWxlY3Rpb24iLCJnZXRTZWxlY3Rpb24iLCJzZWxlY3Rpb25JbmZvIiwiZ2V0UmFuZ2VBdCIsInN0YXJ0Iiwic3RhcnRPZmZzZXQiLCJlbmQiLCJlbmRPZmZzZXQiLCJzZWxlY3Rpb25FbmQiLCJpc0lucHV0RWxlbWVudCIsInNldFNlbGVjdGlvblJhbmdlIiwiaXNOdWxsIiwiZmlyc3RDaGlsZCIsInJhbmdlIiwiZG9jdW1lbnQiLCJjcmVhdGVSYW5nZSIsInNldFN0YXJ0Iiwic2V0RW5kIiwicmVtb3ZlQWxsUmFuZ2VzIiwiYWRkUmFuZ2UiLCJtZXNzYWdlIiwic2hvd1dhcm5pbmciLCJjb25zb2xlIiwid2FybiIsIndoZWVsRXZlbnQiLCJkZWx0YVkiLCJ0aHJvd0Vycm9yIiwidHlwZSIsImRlY2ltYWxQbGFjZXMiLCJpbnRlZ2VyUGFydCIsInN0ZXBQbGFjZSIsInJvdW5kIiwiaXNBZGRpdGlvbiIsImRlY2ltYWxQbGFjZXNSYXdWYWx1ZSIsIk51bWJlciIsImZvcmNlRGVjaW1hbFBsYWNlcyIsImFic1ZhbHVlIiwicmF3VmFsdWVNaW5pbXVtT2Zmc2V0IiwicG93Iiwib2Zmc2V0IiwibWluaW11bU9mZnNldEZpcnN0RGVjaW1hbFBsYWNlSW5kZXgiLCJpbmRleEZpcnN0Tm9uWmVyb0RlY2ltYWxQbGFjZSIsInJvdW5kVG9OZWFyZXN0IiwibGVuZ3RoVmFsdWUiLCJkZWNpbWFsUGxhY2VzTGltaXQiLCJtb2RpZnlBbmRSb3VuZFRvTmVhcmVzdEF1dG8iLCJhcmFiaWNOdW1iZXJzIiwicmV0dXJuQU51bWJlciIsInBhcnNlRGVjaW1hbENoYXJhY3RlciIsInBhcnNlVGhvdXNhbmRTZXBhcmF0b3IiLCJkIiwiY2hhckNvZGVBdCIsInJlc3VsdEFzTnVtYmVyIiwiZXZlbnROYW1lIiwiZGV0YWlsIiwiQ3VzdG9tRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImNyZWF0ZUV2ZW50IiwiaW5pdEN1c3RvbUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsIngiLCJlIiwibkwiLCJqIiwic2xpY2UiLCJzIiwic2VhcmNoIiwiYyIsInkiLCJ4YyIsInljIiwiayIsImwiLCJ4TmVnIiwic3RyTGVuZ3RoIiwicmFuZG9tIiwidGV4dENvbnRlbnQiLCJzZXBhcmF0b3IiLCJyZW1vdmVEYXRhIiwic2tpcEZpcnN0V29yZCIsIndvcmRzIiwibWFwIiwid29yZCIsInRvVXBwZXJDYXNlIiwiam9pbiIsIm5vZGVUeXBlIiwiTm9kZSIsIkVMRU1FTlRfTk9ERSIsIkRPQ1VNRU5UX05PREUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwiVEVYVF9OT0RFIiwibm9kZVZhbHVlIiwiZXhjbHVkZWRFbGVtZW50cyIsImZpbHRlciIsImlzSW5BcnJheSIsInRyaW1tZWREZWNpbWFsUGFydCIsImhvdmVyZWRFbGVtZW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJhcnJMZW5ndGgiLCJTZXQiLCJjb25jYXQiLCJtYXBPYmplY3RzIiwiTWFwIiwicmVkdWNlIiwiYXMiLCJiIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7cWpCQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQTs7Ozs7Ozs7OztBQUVBOzs7O0lBSXFCQSxpQjs7Ozs7Ozs7QUFDakI7Ozs7Ozs7K0JBT2NDLEssRUFBTztBQUNqQixtQkFBT0EsVUFBVSxJQUFqQjtBQUNIOztBQUVEOzs7Ozs7Ozs7O29DQU9tQkEsSyxFQUFPO0FBQ3RCLG1CQUFPQSxVQUFVLEtBQUssQ0FBdEI7QUFDSDs7QUFFRDs7Ozs7Ozs7O2lEQU1nQ0EsSyxFQUFPO0FBQ25DLG1CQUFPQSxVQUFVLElBQVYsSUFBa0JBLFVBQVUsS0FBSyxDQUFqQyxJQUF1QyxPQUFPQSxLQUFyRDtBQUNIOztBQUVEOzs7Ozs7Ozs7aUNBTWdCQyxHLEVBQUs7QUFDakIsbUJBQVEsT0FBT0EsR0FBUCxLQUFlLFFBQWYsSUFBMkJBLGVBQWVDLE1BQWxEO0FBQ0g7QUFDRDs7Ozs7Ozs7OztzQ0FPcUJGLEssRUFBTztBQUN4QixtQkFBT0EsVUFBVSxFQUFqQjtBQUNIOztBQUVEOzs7Ozs7Ozs7O2tDQU9pQkEsSyxFQUFPO0FBQ3BCLG1CQUFPLE9BQU9BLEtBQVAsS0FBa0IsU0FBekI7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs0Q0FPMkJBLEssRUFBTztBQUM5QixnQkFBTUcsaUJBQWlCRCxPQUFPRixL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QU1nQztBQUFBLDhDQUFaQyxVQUFZO0FBQVpBLDBCQUFZO0FBQUE7O0FBQzVCLG1CQUFPLElBQUlDLEdBQUosQ0FBUUQsV0FBV0UsTUFBWCxDQUFrQixVQUFDQyxFQUFELEVBQUtDLENBQUw7QUFBQSx1QkFBV0QsR0FBR0osTUFBSCw4QkFBY0ssQ0FBZCxHQUFYO0FBQUEsYUFBbEIsRUFBZ0QsRUFBaEQsQ0FBUixDQUFQO0FBQ0g7Ozs7OztrQkEzMUNnQjNPLGlCIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIGF1dG9OdW1lcmljLmpzXG4gKiBAYXV0aG9yIEFsZXhhbmRyZSBCb25uZWF1IDxhbGV4YW5kcmUuYm9ubmVhdUBsaW51eGZyLmV1PlxuICogQGNvcHlyaWdodCDCqSAyMDE2IEFsZXhhbmRyZSBCb25uZWF1XG4gKlxuICogVGhlIE1JVCBMaWNlbnNlIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWIgbGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgQXV0b051bWVyaWNFbnVtIGZyb20gJy4vQXV0b051bWVyaWNFbnVtJztcblxuLyoqXG4gKiBTdGF0aWMgY2xhc3MgdGhhdCBob2xkcyBhbGwgdGhlIGhlbHBlciBmdW5jdGlvbnMgYXV0b051bWVyaWMgdXNlcy5cbiAqIE5vdGUgOiBub25lIG9mIHRoZSBmdW5jdGlvbnMgaW4gdGhlcmUgYXJlIGF3YXJlIG9mIGFueSBhdXRvTnVtZXJpYyBpbnRlcm5hbHMgKHdoaWNoIG1lYW5zIHRoZXJlIGFyZSBubyByZWZlcmVuY2VzIHRvIGF1dG9OdW1lcmljLXNwZWNpZmljIGluZm8gbGlrZSBvcHRpb25zIG5hbWVzIG9yIGRhdGEgc3RydWN0dXJlcykuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dG9OdW1lcmljSGVscGVyIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIG51bGxcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybiBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgbnVsbCwgRkFMU0Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgc3RhdGljIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyB1bmRlZmluZWRcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybiBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCBGQUxTRSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB2b2lkKDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCBudWxsIG9yIGVtcHR5XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQoMCkgfHwgJycgPT09IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHBhcmFtZXRlciBpcyBhIFN0cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBzdHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNTdHJpbmcoc3RyKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgfHwgc3RyIGluc3RhbmNlb2YgU3RyaW5nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBlbXB0eSBzdHJpbmcgJydcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybiBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYW4gZW1wdHkgc3RyaW5nICcnLCBGQUxTRSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFbXB0eVN0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09ICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIHBhcmFtZXRlciBpcyBhIGJvb2xlYW5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mKHZhbHVlKSA9PT0gJ2Jvb2xlYW4nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyAndHJ1ZScgb3IgJ2ZhbHNlJ1xuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFueSBjYXNlcyBmb3IgdGhvc2Ugc3RyaW5ncy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNUcnVlT3JGYWxzZVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBsb3dlcmNhc2VWYWx1ZSA9IFN0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGxvd2VyY2FzZVZhbHVlID09PSAndHJ1ZScgfHwgbG93ZXJjYXNlVmFsdWUgPT09ICdmYWxzZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgcGFyYW1ldGVyIGlzIGFuIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSByZWZlcmVuY2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNPYmplY3QocmVmZXJlbmNlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmVmZXJlbmNlID09PSAnb2JqZWN0JyAmJiByZWZlcmVuY2UgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkocmVmZXJlbmNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgZW1wdHlcbiAgICAgKiBjZi4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82Nzk5MTUvaG93LWRvLWktdGVzdC1mb3ItYW4tZW1wdHktamF2YXNjcmlwdC1vYmplY3QgYW5kIGh0dHA6Ly9qc3BlcmYuY29tL2VtcHR5LW9iamVjdC10ZXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzRW1wdHlPYmoob2JqKSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgcmVhbCBudW1iZXIgKGFuZCBub3QgYSBudW1lcmljIHN0cmluZykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IG5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNOdW1iZXJTdHJpY3Qobikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG4gPT09ICdudW1iZXInO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIHBhcmFtZXRlciBpcyBhIG51bWJlciAob3IgYSBudW1iZXIgd3JpdHRlbiBhcyBhIHN0cmluZykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IG5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNOdW1iZXIobikge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNBcnJheShuKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgbnVtYmVyIChvciBhIG51bWJlciB3cml0dGVuIGFzIGEgc3RyaW5nKS5cbiAgICAgKiBUaGlzIHZlcnNpb24gYWxzbyBhY2NlcHRzIEFyYWJpYyBhbmQgUGVyc2lhbiBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzTnVtYmVyT3JBcmFiaWMobikge1xuICAgICAgICBjb25zdCBsYXRpbkNvbnZlcnRlZE51bWJlciA9IHRoaXMuYXJhYmljVG9MYXRpbk51bWJlcnMobiwgZmFsc2UsIHRydWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc051bWJlcihsYXRpbkNvbnZlcnRlZE51bWJlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgcGFyYW1ldGVyIGlzIGFuIGludGVnZXIgKGFuZCBub3QgYSBmbG9hdCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IG5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNJbnQobikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG4gPT09ICdudW1iZXInICYmIHBhcnNlRmxvYXQobikgPT09IHBhcnNlSW50KG4sIDEwKSAmJiAhaXNOYU4obik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzRnVuY3Rpb24oZnVuYykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpcyB0aGUgc3RyaW5nIGBzdHJgIGNvbnRhaW5zIHRoZSBzdHJpbmcgYG5lZWRsZWBcbiAgICAgKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNvZXJjZSB0aGUgcGFyYW1ldGVycyB0eXBlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZWVkbGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgY29udGFpbnMoc3RyLCBuZWVkbGUpIHtcbiAgICAgICAgLy9UT0RPIFVzZSBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzKClgIHdoZW4gYXZhaWxhYmxlIChjZi4gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5jbHVkZXMpXG4gICAgICAgIGlmICghdGhpcy5pc1N0cmluZyhzdHIpIHx8ICF0aGlzLmlzU3RyaW5nKG5lZWRsZSkgfHwgc3RyID09PSAnJyB8fCBuZWVkbGUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyLmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgYG5lZWRsZWAgaXMgaW4gdGhlIGFycmF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IG5lZWRsZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzSW5BcnJheShuZWVkbGUsIGFycmF5KSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FycmF5KGFycmF5KSB8fCBhcnJheSA9PT0gW10gfHwgdGhpcy5pc1VuZGVmaW5lZChuZWVkbGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYW4gQXJyYXlcbiAgICAgKiAvL1RPRE8gUmVwbGFjZSB0aGlzIGJ5IHRoZSBkZWZhdWx0IGBBcnJheS5pc0FycmF5KClgIGZ1bmN0aW9uP1xuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBhcnJcbiAgICAgKiBAdGhyb3dzIEVycm9yXG4gICAgICogQHJldHVybnMgeyp8Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNBcnJheShhcnIpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChbXSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHsgLy8gTWFrZSBzdXJlIGFuIGFycmF5IGhhcyBhIGNsYXNzIGF0dHJpYnV0ZSBvZiBbb2JqZWN0IEFycmF5XVxuICAgICAgICAgICAgLy8gVGVzdCBwYXNzZWQsIG5vdyBjaGVjayBpZiBpcyBhbiBBcnJheVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKSB8fCAodHlwZW9mIGFyciA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b1N0cmluZyBtZXNzYWdlIGNoYW5nZWQgZm9yIE9iamVjdCBBcnJheScpOyAvLyBWZXJpZnkgdGhhdCB0aGUgc3RyaW5nIHJldHVybmVkIGJ5IGB0b1N0cmluZ2AgZG9lcyBub3QgY2hhbmdlIGluIHRoZSBmdXR1cmUgKGNmLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84MzY1MjE1KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgRE9NIGVsZW1lbnRcbiAgICAgKiBjZi4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDc1NDEwNC8yODM0ODk4XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IG9ialxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc0VsZW1lbnQob2JqKSB7XG4gICAgICAgIC8vIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVOYW1lKTtcbiAgICAgICAgLy8gcmV0dXJuIG9iaiAmJiAnbm9kZVR5cGUnIGluIG9iajtcbiAgICAgICAgLy8gcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgb2JqIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCB8fCBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpbiB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQgaXMgYW4gPGlucHV0Pi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTElucHV0RWxlbWVudH0gZG9tRWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIGlzSW5wdXRFbGVtZW50KGRvbUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFbGVtZW50KGRvbUVsZW1lbnQpICYmIGRvbUVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBmbG9hdCBudW1iZXIsIGFuZCB0aGF0IG51bWJlciBoYXMgYSBkZWNpbWFsIHBhcnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICAvLyBzdGF0aWMgaGFzRGVjaW1hbHMoc3RyKSB7XG4gICAgLy8gICAgIGNvbnN0IFssIGRlY2ltYWxQYXJ0XSA9IHN0ci5zcGxpdCgnLicpO1xuICAgIC8vICAgICByZXR1cm4gIWlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KTtcbiAgICAvLyB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIGZsb2F0IG51bWJlciwgYW5kIHRoYXQgbnVtYmVyIGhhcyBhIGRlY2ltYWwgcGFydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcmV0dXJucyB7aW50fVxuICAgICAqL1xuICAgIHN0YXRpYyBkZWNpbWFsUGxhY2VzKHN0cikge1xuICAgICAgICBjb25zdCBbLCBkZWNpbWFsUGFydF0gPSBzdHIuc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlY2ltYWxQYXJ0Lmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG5vbi16ZXJvIGRlY2ltYWwgcGxhY2UgaW4gdGhlIGdpdmVuIHZhbHVlLlxuICAgICAqIFRoZSBpbmRleCBzdGFydHMgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQsIGlmIGFueSwgYW5kIGJlZ2lucyBhdCAnMScuXG4gICAgICogSWYgbm8gZGVjaW1hbCBwbGFjZXMgYXJlIGZvdW5kIGluIHRoZSB2YWx1ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGAwYC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW5kZXhGaXJzdE5vblplcm9EZWNpbWFsUGxhY2UoJzAuMDAnKSAtPiAwXG4gICAgICogaW5kZXhGaXJzdE5vblplcm9EZWNpbWFsUGxhY2UoJzEuMDAnKSAtPiAwXG4gICAgICogaW5kZXhGaXJzdE5vblplcm9EZWNpbWFsUGxhY2UoJzAuMTInKSAtPiAxXG4gICAgICogaW5kZXhGaXJzdE5vblplcm9EZWNpbWFsUGxhY2UoJzAuMTIzNCcpIC0+IDFcbiAgICAgKiBpbmRleEZpcnN0Tm9uWmVyb0RlY2ltYWxQbGFjZSgnMC4wMTIzNCcpIC0+IDJcbiAgICAgKiBpbmRleEZpcnN0Tm9uWmVyb0RlY2ltYWxQbGFjZSgnMC4wMDEyMzQnKSAtPiAzXG4gICAgICogaW5kZXhGaXJzdE5vblplcm9EZWNpbWFsUGxhY2UoJzAuMDAwMTIzNCcpIC0+IDRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ8bnVtYmVyfVxuICAgICAqL1xuICAgIHN0YXRpYyBpbmRleEZpcnN0Tm9uWmVyb0RlY2ltYWxQbGFjZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBbLCBkZWNpbWFsUGFydF0gPSBTdHJpbmcoTWF0aC5hYnModmFsdWUpKS5zcGxpdCgnLicpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0ID0gZGVjaW1hbFBhcnQubGFzdEluZGV4T2YoJzAnKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjb2RlIGZvciB0aGUga2V5IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGdpdmVuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfE51bWJlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMga2V5Q29kZU51bWJlcihldmVudCkge1xuICAgICAgICAvLyBgZXZlbnQua2V5Q29kZWAgYW5kIGBldmVudC53aGljaGAgYXJlIGRlcHJlY2F0ZWQsIGBLZXlib2FyZEV2ZW50LmtleWAgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleSkgbXVzdCBiZSB1c2VkIG5vd1xuICAgICAgICAvLyBBbHNvLCBkbyBub3RlIHRoYXQgRmlyZWZveCBnZW5lcmF0ZSBhICdrZXlwcmVzcycgZXZlbnQgKGUua2V5Q29kZSA9PT0gMCkgZm9yIHRoZSBrZXlzIHRoYXQgZG8gbm90IHByaW50IGEgY2hhcmFjdGVyIChpZS4gJ0luc2VydCcsICdEZWxldGUnLCAnRm4nIGtleXMsICdQYWdlVXAnLCAnUGFnZURvd24nIGV0Yy4pLiAnU2hpZnQnIG9uIHRoZSBvdGhlciBoYW5kIGRvZXMgbm90IGdlbmVyYXRlIGEga2V5cHJlc3MgZXZlbnQuXG4gICAgICAgIHJldHVybiAodHlwZW9mIGV2ZW50LndoaWNoID09PSAndW5kZWZpbmVkJyk/ZXZlbnQua2V5Q29kZTpldmVudC53aGljaDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGNoYXJhY3RlciBmcm9tIHRoZSBldmVudCBrZXkgY29kZS5cbiAgICAgKiBJZiB0aGUgS2V5Ym9hcmRFdmVudCBkb2VzIG5vdCByZXByZXNlbnQgYSBwcmludGFibGUgY2hhcmFjdGVyLCB0aGVuIHRoZSBrZXkgbmFtZSBpcyB1c2VkIChpZS4gJ01ldGEnLCAnU2hpZnQnLCAnRjEnLCBldGMuKVxuICAgICAqIEBleGFtcGxlIGNoYXJhY3Rlcig1MCkgPT4gJzInXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgY2hhcmFjdGVyKGV2ZW50KSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChldmVudC5rZXkgPT09ICdVbmlkZW50aWZpZWQnIHx8IGV2ZW50LmtleSA9PT0gdm9pZCgwKSB8fCB0aGlzLmlzU2VsZW5pdW1Cb3QoKSkge1xuICAgICAgICAgICAgLy9YWFggVGhlIHNlbGVuaXVtIGdlY2tvZHJpdmVyIGRvIG5vdCB1bmRlcnN0YW5kIGBldmVudC5rZXlgLCBoZW5jZSB3aGVuIHVzaW5nIGl0LCB3ZSBuZWVkIHRvIHJlbHkgb24gdGhlIG9sZCBkZXByZWNhdGVkIGBrZXlDb2RlYCBhdHRyaWJ1dGUsIGNmLiB1cHN0cmVhbSBpc3N1ZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9nZWNrb2RyaXZlci9pc3N1ZXMvNDQwXG4gICAgICAgICAgICAvLyBVc2UgdGhlIG9sZCBkZXByZWNhdGVkIGtleUNvZGUgcHJvcGVydHksIGlmIHRoZSBuZXcgYGtleWAgb25lIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgIGNvbnN0IGtleUNvZGUgPSB0aGlzLmtleUNvZGVOdW1iZXIoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IEF1dG9OdW1lcmljRW51bS5rZXlDb2RlLkFuZHJvaWREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkFuZHJvaWREZWZhdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwb3RlbnRpYWxSZXN1bHQgPSBBdXRvTnVtZXJpY0VudW0uZnJvbUNoYXJDb2RlS2V5Q29kZVtrZXlDb2RlXTtcbiAgICAgICAgICAgIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHBvdGVudGlhbFJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBgU3RyaW5nLmZyb21DaGFyQ29kZWAgZG8gbm90IHJldHVybiBuYW1lZCBrZXlzIGZvciBzb21lIGtleXMgKCdFc2NhcGUnIGFuZCAnRW50ZXInIGZvciBpbnN0YW5jZSksIHdlIGNvbnZlcnQgdGhlIGNoYXJhY3RlcnMgdG8gdGhlIGtleSBuYW1lc1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBvdGVudGlhbFJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShrZXlDb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBicm93c2VyO1xuICAgICAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBNYW5hZ2VzIGFsbCB0aGUgc3BlY2lhbCBjYXNlcyBmb3Igb2Jzb2xldGUgYnJvd3NlcnMgdGhhdCByZXR1cm4gdGhlIG5vbi1zdGFuZGFyZCBuYW1lc1xuICAgICAgICAgICAgICAgIGNhc2UgJ0FkZCc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLk51bXBhZFBsdXM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0FwcHMnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5Db250ZXh0TWVudTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQ3JzZWwnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5DclNlbDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnRGVjaW1hbCc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLk51bXBhZERvdDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnRGVsJzpcbiAgICAgICAgICAgICAgICAgICAgYnJvd3NlciA9IHRoaXMuYnJvd3NlcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGJyb3dzZXIubmFtZSA9ICdmaXJlZm94JyAmJiBicm93c2VyLnZlcnNpb24gPD0gMzYpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYnJvd3Nlci5uYW1lID0gJ2llJyAmJiBicm93c2VyLnZlcnNpb24gPD0gOSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgd29ya2Fyb3VuZCBmb3IgdGhlIG9ic29sZXRlIGJyb3dzZXIgSUUxMSB3aGljaCBvdXRwdXQgYSAnRGVsZXRlJyBrZXkgd2hlbiB1c2luZyB0aGUgbnVtcGFkICdkb3QnIG9uZSEgVGhpcyBmaXhlcyBpc3N1ZSAjNDAxXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdvcmthcm91bmQgYnJlYWsgdGhlIHVzYWdlIG9mIHRoZSAnRGVsZXRlJyBrZXkgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOSwgc2luY2UgdGhvc2UgYnJvd3NlciBzZW5kICdEZWwnIGluc3RlYWQgb2YgJ0RlbGV0ZScsIHRoZXJlZm9yZSB3ZSBvbmx5IHVzZSBpdCBmb3IgdGhvc2Ugb2Jzb2xldGUgYnJvd3NlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkRvdDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkRlbGV0ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdEaXZpZGUnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5OdW1wYWRTbGFzaDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnRG93bic6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkRvd25BcnJvdztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnRXNjJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuRXNjO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdFeHNlbCc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLkV4U2VsO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdMZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQXV0b051bWVyaWNFbnVtLmtleU5hbWUuTGVmdEFycm93O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdNZXRhJzpcbiAgICAgICAgICAgICAgICBjYXNlICdTdXBlcic6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLk9TTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnTXVsdGlwbHknOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5OdW1wYWRNdWx0aXBseTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnUmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBBdXRvTnVtZXJpY0VudW0ua2V5TmFtZS5SaWdodEFycm93O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdTcGFjZWJhcic6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLlNwYWNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdTdWJ0cmFjdCc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLk51bXBhZE1pbnVzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdVcCc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEF1dG9OdW1lcmljRW51bS5rZXlOYW1lLlVwQXJyb3c7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBub3JtYWwgY2FzZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBldmVudC5rZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmFtZSBhbmQgdmVyc2lvbiBvZiB0aGUgY3VycmVudCBicm93c2VyLlxuICAgICAqIEBleGFtcGxlIGBicm93c2VyVmVyc2lvbigpYCA9PiB7IG5hbWU6ICdGaXJlZm94JywgdmVyc2lvbjogJzQyJyB9XG4gICAgICogQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzgwODAwNTEvMjgzNDg5OFxuICAgICAqXG4gICAgICogQHJldHVybnMge3sgbmFtZTogc3RyaW5nLCB2ZXJzaW9uOiBzdHJpbmcgfX1cbiAgICAgKi9cbiAgICBzdGF0aWMgYnJvd3NlcigpIHtcbiAgICAgICAgY29uc3QgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgICAgICBsZXQgdGVtO1xuICAgICAgICBsZXQgTSA9IHVhLm1hdGNoKC8ob3BlcmF8Y2hyb21lfHNhZmFyaXxmaXJlZm94fG1zaWV8dHJpZGVudCg/PVxcLykpXFwvP1xccyooXFxkKykvaSkgfHwgW107XG5cbiAgICAgICAgaWYgKC90cmlkZW50L2kudGVzdChNWzFdKSkge1xuICAgICAgICAgICAgdGVtID0gL1xcYnJ2WyA6XSsoXFxkKykvZy5leGVjKHVhKSB8fCBbXTtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6ICdpZScsIHZlcnNpb246ICh0ZW1bMV0gfHwgJycpIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTVsxXSA9PT0gJ0Nocm9tZScpIHtcbiAgICAgICAgICAgIHRlbSA9IHVhLm1hdGNoKC9cXGIoT1BSfEVkZ2UpXFwvKFxcZCspLyk7XG4gICAgICAgICAgICBpZiAodGVtICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogdGVtWzFdLnJlcGxhY2UoJ09QUicsICdvcGVyYScpLCB2ZXJzaW9uOiB0ZW1bMl0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIE0gPSBNWzJdP1tNWzFdLCBNWzJdXTpbbmF2aWdhdG9yLmFwcE5hbWUsIG5hdmlnYXRvci5hcHBWZXJzaW9uLCAnLT8nXTtcbiAgICAgICAgaWYgKCh0ZW0gPSB1YS5tYXRjaCgvdmVyc2lvblxcLyhcXGQrKS9pKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIE0uc3BsaWNlKDEsIDEsIHRlbVsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBuYW1lOiBNWzBdLnRvTG93ZXJDYXNlKCksIHZlcnNpb246IE1bMV0gfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgYnJvd3NlciBpcyBjb250cm9sbGVkIGJ5IFNlbGVuaXVtLlxuICAgICAqIE5vdGU6IFRoaXMgb25seSB3b3JrcyB3aXRoaW4gdGhlIGdlY2tvZHJpdmVyLlxuICAgICAqIGNmLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMzMjI1OTQ3L2Nhbi1hLXdlYnNpdGUtZGV0ZWN0LXdoZW4teW91LWFyZS11c2luZy1zZWxlbml1bS13aXRoLWNocm9tZWRyaXZlclxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzU2VsZW5pdW1Cb3QoKSB7XG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VucmVzb2x2ZWRWYXJpYWJsZVxuICAgICAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci53ZWJkcml2ZXIgPT09IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gbnVtYmVyIGlzIG5lZ2F0aXZlLCBvciBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGNvbnRhaW5zIGEgbmVnYXRpdmUgc2lnbiA6XG4gICAgICogLSBldmVyeXdoZXJlIGluIHRoZSBzdHJpbmcgKGJ5IGRlZmF1bHQpLCBvclxuICAgICAqIC0gb24gdGhlIGZpcnN0IGNoYXJhY3RlciBvbmx5IGlmIHRoZSBgY2hlY2tFdmVyeXdoZXJlYCBwYXJhbWV0ZXIgaXMgc2V0IHRvIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG51bWJlck9yTnVtZXJpY1N0cmluZyBBIE51bWJlciwgb3IgYSBudW1iZXIgcmVwcmVzZW50ZWQgYnkgYSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrRXZlcnl3aGVyZSBJZiBUUlVFLCB0aGVuIHRoZSBuZWdhdGl2ZSBzaWduIGlzIHNlYXJjaCBldmVyeXdoZXJlIGluIHRoZSBudW1lcmljIHN0cmluZyAodGhpcyBpcyBuZWVkZWQgZm9yIGluc3RhbmNlIGlmIHRoZSBzdHJpbmcgaXMgJzEyMzQuNTYtJylcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNOZWdhdGl2ZShudW1iZXJPck51bWVyaWNTdHJpbmcsIGNoZWNrRXZlcnl3aGVyZSA9IHRydWUpIHtcbiAgICAgICAgaWYgKG51bWJlck9yTnVtZXJpY1N0cmluZyA9PT0gJy0nKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChudW1iZXJPck51bWVyaWNTdHJpbmcgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvL1RPRE8gVXNlIHRoZSBgbmVnYXRpdmVTaWduQ2hhcmFjdGVyYCBmcm9tIHRoZSBzZXR0aW5ncyBoZXJlXG4gICAgICAgIGlmIChBdXRvTnVtZXJpY0hlbHBlci5pc051bWJlcihudW1iZXJPck51bWVyaWNTdHJpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyT3JOdW1lcmljU3RyaW5nIDwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGVja0V2ZXJ5d2hlcmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5zKG51bWJlck9yTnVtZXJpY1N0cmluZywgJy0nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmlzTmVnYXRpdmVTdHJpY3QobnVtYmVyT3JOdW1lcmljU3RyaW5nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBnaXZlbiBzdHJpbmcgY29udGFpbnMgYSBuZWdhdGl2ZSBzaWduIG9uIHRoZSBmaXJzdCBjaGFyYWN0ZXIgKG9uIHRoZSBmYXIgbGVmdCkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBpc05lZ2F0aXZlU3RyaWN0KCcxMjM0LjU2JykgICAgID0+IGZhbHNlXG4gICAgICogQGV4YW1wbGUgaXNOZWdhdGl2ZVN0cmljdCgnMTIzNC41Ni0nKSAgICA9PiBmYWxzZVxuICAgICAqIEBleGFtcGxlIGlzTmVnYXRpdmVTdHJpY3QoJy0xMjM0LjU2JykgICAgPT4gdHJ1ZVxuICAgICAqIEBleGFtcGxlIGlzTmVnYXRpdmVTdHJpY3QoJy0xLDIzNC41NiDigqwnKSA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbnVtZXJpY1N0cmluZ1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc05lZ2F0aXZlU3RyaWN0KG51bWVyaWNTdHJpbmcpIHtcbiAgICAgICAgLy9UT0RPIFVzaW5nIHRoZSBgbmVnYXRpdmVTaWduQ2hhcmFjdGVyYCBmcm9tIHRoZSBzZXR0aW5ncyBoZXJlXG4gICAgICAgIHJldHVybiBudW1lcmljU3RyaW5nLmNoYXJBdCgwKSA9PT0gJy0nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIHZlcnkgZmlyc3QgY2hhcmFjdGVyIGlzIHRoZSBvcGVuaW5nIGJyYWNrZXQsIGFuZCBpZiB0aGUgcmVzdCBvZiB0aGUgYHZhbHVlU3RyaW5nYCBhbHNvIGhhcyB0aGUgY2xvc2luZyBicmFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxlZnRCcmFja2V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJpZ2h0QnJhY2tldFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc05lZ2F0aXZlV2l0aEJyYWNrZXRzKHZhbHVlU3RyaW5nLCBsZWZ0QnJhY2tldCwgcmlnaHRCcmFja2V0KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVN0cmluZy5jaGFyQXQoMCkgPT09IGxlZnRCcmFja2V0ICYmIHRoaXMuY29udGFpbnModmFsdWVTdHJpbmcsIHJpZ2h0QnJhY2tldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZm9ybWF0dGVkIG9yIHVuZm9ybWF0dGVkIG51bWVyaWMgc3RyaW5nIHJlcHJlc2VudCB0aGUgdmFsdWUgMCAoaWUuICcwLDAwIOKCrCcpLCBvciBpcyBlbXB0eSAoJyDigqwnKS5cbiAgICAgKiBUaGlzIHdvcmtzIHNpbmNlIHdlIHRlc3QgaWYgdGhlcmUgYXJlIGFueSBudW1iZXJzIGZyb20gMSB0byA5IGluIHRoZSBzdHJpbmcuIElmIHRoZXJlIGlzIG5vbmUsIHRoZW4gdGhlIG51bWJlciBpcyB6ZXJvIChvciB0aGUgc3RyaW5nIGlzIGVtcHR5KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBudW1lcmljU3RyaW5nXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzWmVyb09ySGFzTm9WYWx1ZShudW1lcmljU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAhKC9bMS05XS9nKS50ZXN0KG51bWVyaWNTdHJpbmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbmVnYXRpdmUgdmVyc2lvbiBvZiB0aGUgdmFsdWUgKHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nKSBnaXZlbiBhcyBhIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHN0YXRpYyBzZXRSYXdOZWdhdGl2ZVNpZ24odmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTmVnYXRpdmVTdHJpY3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYC0ke3ZhbHVlfWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZSB0aGUgY2hhcmFjdGVyIGF0IHRoZSBwb3NpdGlvbiBgaW5kZXhgIGluIHRoZSBzdHJpbmcgYHN0cmluZ2AgYnkgdGhlIGNoYXJhY3RlcihzKSBgbmV3Q2hhcmFjdGVyYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge2ludH0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3Q2hhcmFjdGVyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVwbGFjZUNoYXJBdChzdHJpbmcsIGluZGV4LCBuZXdDaGFyYWN0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGAke3N0cmluZy5zdWJzdHIoMCwgaW5kZXgpfSR7bmV3Q2hhcmFjdGVyfSR7c3RyaW5nLnN1YnN0cihpbmRleCArIG5ld0NoYXJhY3Rlci5sZW5ndGgpfWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBjbGFtcGVkIHRvIHRoZSBuZWFyZXN0IG1pbmltdW0vbWF4aW11bSB2YWx1ZSwgYXMgZGVmaW5lZCBpbiB0aGUgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgY2xhbXBUb1JhbmdlTGltaXRzKHZhbHVlLCBzZXR0aW5ncykge1xuICAgICAgICAvL1hYWCBUaGlzIGZ1bmN0aW9uIGFsd2F5cyBhc3N1bWUgYHNldHRpbmdzLm1pbmltdW1WYWx1ZWAgaXMgbG93ZXIgdGhhbiBgc2V0dGluZ3MubWF4aW11bVZhbHVlYFxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoc2V0dGluZ3MubWluaW11bVZhbHVlLCBNYXRoLm1pbihzZXR0aW5ncy5tYXhpbXVtVmFsdWUsIHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbnVtYmVyIG9yIGRvdCBjaGFyYWN0ZXJzIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGNhcmV0LCBpbiBhIGZvcm1hdHRlZCBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0dGVkTnVtYmVyU3RyaW5nXG4gICAgICogQHBhcmFtIHtpbnR9IGNhcmV0UG9zaXRpb24gVGhpcyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZWNpbWFsQ2hhcmFjdGVyXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlKGZvcm1hdHRlZE51bWJlclN0cmluZywgY2FyZXRQb3NpdGlvbiwgZGVjaW1hbENoYXJhY3Rlcikge1xuICAgICAgICAvLyBIZXJlIHdlIGNvdW50IHRoZSBkb3QgYW5kIHJlcG9ydCBpdCBhcyBhIG51bWJlciBjaGFyYWN0ZXIgdG9vLCBzaW5jZSBpdCB3aWxsICdzdGF5JyBpbiB0aGUgSmF2YXNjcmlwdCBudW1iZXIgd2hlbiB1bmZvcm1hdHRlZFxuICAgICAgICBjb25zdCBudW1iZXJEb3RPck5lZ2F0aXZlU2lnbiA9IG5ldyBSZWdFeHAoYFswLTkke2RlY2ltYWxDaGFyYWN0ZXJ9LV1gKTsgLy8gTm8gbmVlZCB0byBlc2NhcGUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGhlcmUsIHNpbmNlIGl0J3MgaW4gYFtdYFxuXG4gICAgICAgIGxldCBudW1iZXJEb3RBbmROZWdhdGl2ZVNpZ25Db3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FyZXRQb3NpdGlvbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBUZXN0IGlmIHRoZSBjaGFyYWN0ZXIgaXMgYSBudW1iZXIsIGEgZG90IG9yIGFuIGh5cGhlbi4gSWYgaXQgaXMsIGNvdW50IGl0LCBvdGhlcndpc2UgaWdub3JlIGl0XG4gICAgICAgICAgICBpZiAobnVtYmVyRG90T3JOZWdhdGl2ZVNpZ24udGVzdChmb3JtYXR0ZWROdW1iZXJTdHJpbmdbaV0pKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyRG90QW5kTmVnYXRpdmVTaWduQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudW1iZXJEb3RBbmROZWdhdGl2ZVNpZ25Db3VudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXYWxrIHRoZSBgZm9ybWF0dGVkTnVtYmVyU3RyaW5nYCBmcm9tIGxlZnQgdG8gcmlnaHQsIG9uZSBjaGFyIGJ5IG9uZSwgY291bnRpbmcgdGhlIGBmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleGAuXG4gICAgICogSWYgdGhlIGNoYXIgaXMgaW4gdGhlIGByYXdOdW1iZXJTdHJpbmdgIChzdGFydGluZyBhdCBpbmRleCAwKSwgdGhlbiBgcmF3TnVtYmVyU3RyaW5nSW5kZXgrK2AsIGFuZCBjb250aW51ZSB1bnRpbFxuICAgICAqIHRoZXJlIGlzIG5vIG1vcmUgY2hhcmFjdGVycyBpbiBgcmF3TnVtYmVyU3RyaW5nYCkgb3IgdGhhdCBgcmF3TnVtYmVyU3RyaW5nSW5kZXggPT09IGNhcmV0UG9zaXRpb25JblJhd1ZhbHVlYC5cbiAgICAgKiBXaGVuIHlvdSBzdG9wLCB0aGUgYGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4YCBpcyB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIGNhcmV0IHNob3VsZCBiZSBzZXQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIDEyMzQ1Njd8ODkuMDEgICA6IHBvc2l0aW9uIDcgKHJhd051bWJlclN0cmluZylcbiAgICAgKiAxMjMuNDU2Ljd8ODksMDEgOiBwb3NpdGlvbiA5IChmb3JtYXR0ZWROdW1iZXJTdHJpbmcpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmF3TnVtYmVyU3RyaW5nXG4gICAgICogQHBhcmFtIHtpbnR9IGNhcmV0UG9zaXRpb25JblJhd1ZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdHRlZE51bWJlclN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZWNpbWFsQ2hhcmFjdGVyXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc3RhdGljIGZpbmRDYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIocmF3TnVtYmVyU3RyaW5nLCBjYXJldFBvc2l0aW9uSW5SYXdWYWx1ZSwgZm9ybWF0dGVkTnVtYmVyU3RyaW5nLCBkZWNpbWFsQ2hhcmFjdGVyKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZE51bWJlclN0cmluZ1NpemUgPSBmb3JtYXR0ZWROdW1iZXJTdHJpbmcubGVuZ3RoO1xuICAgICAgICBjb25zdCByYXdOdW1iZXJTdHJpbmdTaXplID0gcmF3TnVtYmVyU3RyaW5nLmxlbmd0aDtcblxuICAgICAgICBsZXQgZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXg7XG4gICAgICAgIGxldCByYXdOdW1iZXJTdHJpbmdJbmRleCA9IDA7XG4gICAgICAgIGZvciAoZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXggPSAwO1xuICAgICAgICAgICAgZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXggPCBmb3JtYXR0ZWROdW1iZXJTdHJpbmdTaXplICYmXG4gICAgICAgICAgICByYXdOdW1iZXJTdHJpbmdJbmRleCA8IHJhd051bWJlclN0cmluZ1NpemUgJiZcbiAgICAgICAgICAgIHJhd051bWJlclN0cmluZ0luZGV4IDwgY2FyZXRQb3NpdGlvbkluUmF3VmFsdWU7XG4gICAgICAgICAgICBmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAocmF3TnVtYmVyU3RyaW5nW3Jhd051bWJlclN0cmluZ0luZGV4XSA9PT0gZm9ybWF0dGVkTnVtYmVyU3RyaW5nW2Zvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4XSB8fFxuICAgICAgICAgICAgICAgIChyYXdOdW1iZXJTdHJpbmdbcmF3TnVtYmVyU3RyaW5nSW5kZXhdID09PSAnLicgJiYgZm9ybWF0dGVkTnVtYmVyU3RyaW5nW2Zvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4XSA9PT0gZGVjaW1hbENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICByYXdOdW1iZXJTdHJpbmdJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvdW50IHRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZSBvZiB0aGUgZ2l2ZW4gY2hhcmFjdGVyLCBpbiB0aGUgZ2l2ZW4gdGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyYWN0ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgc3RhdGljIGNvdW50Q2hhckluVGV4dChjaGFyYWN0ZXIsIHRleHQpIHtcbiAgICAgICAgbGV0IGNoYXJDb3VudGVyID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGV4dFtpXSA9PT0gY2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgY2hhckNvdW50ZXIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGFyQ291bnRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGluZGV4IHRoYXQgY2FuIGJlIHVzZWQgdG8gc2V0IHRoZSBjYXJldCBwb3NpdGlvbi5cbiAgICAgKiBUaGlzIHRha2VzIGludG8gYWNjb3VudCB0aGF0IHRoZSBwb3NpdGlvbiBpcyBzdGFydGluZyBhdCAnMCcsIG5vdCAxLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbnR9IGNoYXJhY3RlckNvdW50XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uKGNoYXJhY3RlckNvdW50KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChjaGFyYWN0ZXJDb3VudCwgY2hhcmFjdGVyQ291bnQgLSAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcm9zcyBicm93c2VyIHJvdXRpbmUgZm9yIGdldHRpbmcgc2VsZWN0ZWQgcmFuZ2UvY3Vyc29yIHBvc2l0aW9uLlxuICAgICAqIE5vdGU6IHRoaXMgYWxzbyB3b3JrcyB3aXRoIGVkZ2UgY2FzZXMgbGlrZSBjb250ZW50ZWRpdGFibGUtZW5hYmxlZCBlbGVtZW50cywgYW5kIGhpZGRlbiBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR8RXZlbnRUYXJnZXR9IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICovXG4gICAgc3RhdGljIGdldEVsZW1lbnRTZWxlY3Rpb24oZWxlbWVudCkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHt9O1xuXG4gICAgICAgIGxldCBpc1NlbGVjdGlvblN0YXJ0VW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaXNTZWxlY3Rpb25TdGFydFVuZGVmaW5lZCA9IHRoaXMuaXNVbmRlZmluZWQoZWxlbWVudC5zZWxlY3Rpb25TdGFydCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpc1NlbGVjdGlvblN0YXJ0VW5kZWZpbmVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGlzU2VsZWN0aW9uU3RhcnRVbmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uSW5mbyA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0ID0gc2VsZWN0aW9uSW5mby5zdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5lbmQgPSBzZWxlY3Rpb25JbmZvLmVuZE9mZnNldDtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5sZW5ndGggPSBwb3NpdGlvbi5lbmQgLSBwb3NpdGlvbi5zdGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24uc3RhcnQgPSBlbGVtZW50LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uLmVuZCA9IGVsZW1lbnQuc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uLmxlbmd0aCA9IHBvc2l0aW9uLmVuZCAtIHBvc2l0aW9uLnN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gTWFuYWdlcyB0aGUgY2FzZXMgd2hlcmUgOlxuICAgICAgICAgICAgLy8gLSB0aGUgJ2NvbnRlbnRlZGl0YWJsZScgZWxlbWVudHMgdGhhdCBoYXZlIG5vIHNlbGVjdGlvbnNcbiAgICAgICAgICAgIC8vIC0gdGhlIDxpbnB1dD4gZWxlbWVudCBpcyBvZiB0eXBlICdoaWRkZW4nXG4gICAgICAgICAgICBwb3NpdGlvbi5zdGFydCA9IDA7XG4gICAgICAgICAgICBwb3NpdGlvbi5lbmQgPSAwO1xuICAgICAgICAgICAgcG9zaXRpb24ubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcm9zcyBicm93c2VyIHJvdXRpbmUgZm9yIHNldHRpbmcgc2VsZWN0ZWQgcmFuZ2UvY3Vyc29yIHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR8RXZlbnRUYXJnZXR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRcbiAgICAgKiBAcGFyYW0ge2ludHxudWxsfSBlbmRcbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0RWxlbWVudFNlbGVjdGlvbihlbGVtZW50LCBzdGFydCwgZW5kID0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5pc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkoZW5kKSkge1xuICAgICAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0lucHV0RWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZShzdGFydCwgZW5kKTtcbiAgICAgICAgfSBlbHNlIGlmICghQXV0b051bWVyaWNIZWxwZXIuaXNOdWxsKGVsZW1lbnQuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KGVsZW1lbnQuZmlyc3RDaGlsZCwgc3RhcnQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGVsZW1lbnQuZmlyc3RDaGlsZCwgZW5kKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IHRocm93IGVycm9yIG1lc3NhZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgICAqIEB0aHJvd3NcbiAgICAgKi9cbiAgICBzdGF0aWMgdGhyb3dFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IGRpc3BsYXkgYSB3YXJuaW5nIG1lc3NhZ2VzLCBhY2NvcmRpbmcgdG8gdGhlIGRlYnVnIGxldmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3dXYXJuaW5nIElmIEZBTFNFLCB0aGVuIHRoZSB3YXJuaW5nIG1lc3NhZ2UgaXMgbm90IGRpc3BsYXllZFxuICAgICAqL1xuICAgIHN0YXRpYyB3YXJuaW5nKG1lc3NhZ2UsIHNob3dXYXJuaW5nID0gdHJ1ZSkge1xuICAgICAgICBpZiAoc2hvd1dhcm5pbmcpIHtcbiAgICAgICAgICAgIC8qIGVzbGludCBuby1jb25zb2xlOiAwICovXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6ICR7bWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGEgd2hlZWx1cCBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtXaGVlbEV2ZW50fSB3aGVlbEV2ZW50XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzV2hlZWxVcEV2ZW50KHdoZWVsRXZlbnQpIHtcbiAgICAgICAgaWYgKCF3aGVlbEV2ZW50LmRlbHRhWSkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKGBUaGUgZXZlbnQgcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGlzIG5vdCBhIHZhbGlkIHdoZWVsIGV2ZW50LCAnJHt3aGVlbEV2ZW50LnR5cGV9JyBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB3aGVlbEV2ZW50LmRlbHRhWSA8IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gZXZlbnQgaXMgYSB3aGVlbGRvd24gZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2hlZWxFdmVudH0gd2hlZWxFdmVudFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc1doZWVsRG93bkV2ZW50KHdoZWVsRXZlbnQpIHtcbiAgICAgICAgaWYgKCF3aGVlbEV2ZW50LmRlbHRhWSkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKGBUaGUgZXZlbnQgcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGlzIG5vdCBhIHZhbGlkIHdoZWVsIGV2ZW50LCAnJHt3aGVlbEV2ZW50LnR5cGV9JyBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB3aGVlbEV2ZW50LmRlbHRhWSA+IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBnaXZlbiByYXcgdmFsdWUgdHJ1bmNhdGVkIGF0IHRoZSBnaXZlbiBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgYGRlY2ltYWxQbGFjZXNgLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3Qgcm91bmQgdGhlIHZhbHVlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBmb3JjZURlY2ltYWxQbGFjZXMoMTIzLjQ1Njc4LCAwKSAtPiAnMTIzLjQ1Njc4J1xuICAgICAqIGZvcmNlRGVjaW1hbFBsYWNlcygxMjMuNDU2NzgsIDEpIC0+ICcxMjMuNCdcbiAgICAgKiBmb3JjZURlY2ltYWxQbGFjZXMoMTIzLjQ1Njc4LCAyKSAtPiAnMTIzLjQ1J1xuICAgICAqIGZvcmNlRGVjaW1hbFBsYWNlcygxMjMuNDU2NzgsIDMpIC0+ICcxMjMuNDU2J1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtpbnR9IGRlY2ltYWxQbGFjZXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfHN0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZm9yY2VEZWNpbWFsUGxhY2VzKHZhbHVlLCBkZWNpbWFsUGxhY2VzKSB7XG4gICAgICAgIC8vIFdlIGNvdWxkIG1ha2Ugc3VyZSBgZGVjaW1hbFBsYWNlc2AgaXMgYW4gaW50ZWdlciBhbmQgcG9zaXRpdmUsIGJ1dCB3ZSdsbCBsZWF2ZSB0aGF0IHRvIHRoZSBkZXYgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAgICBjb25zdCBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IFN0cmluZyh2YWx1ZSkuc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKCFkZWNpbWFsUGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGAke2ludGVnZXJQYXJ0fS4ke2RlY2ltYWxQYXJ0LnN1YnN0cigwLCBkZWNpbWFsUGxhY2VzKX1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgJ25lYXJlc3Qgcm91bmRlZCcgdmFsdWUsIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gc3RlcCBzaXplLlxuICAgICAqIEBleGFtcGxlIHJvdW5kVG9OZWFyZXN0KDI2NDc4OSwgMTAwMDApKSA9PiAyNjAwMDBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwUGxhY2VcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzdGF0aWMgcm91bmRUb05lYXJlc3QodmFsdWUsIHN0ZXBQbGFjZSA9IDEwMDApIHtcbiAgICAgICAgaWYgKDAgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGVwUGxhY2UgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcignVGhlIGBzdGVwUGxhY2VgIHVzZWQgdG8gcm91bmQgaXMgZXF1YWwgdG8gYDBgLiBUaGlzIHZhbHVlIG11c3Qgbm90IGJlIGVxdWFsIHRvIHplcm8uJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAvIHN0ZXBQbGFjZSkgKiBzdGVwUGxhY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSAnbmVhcmVzdCByb3VuZGVkJyB2YWx1ZSBieSBhdXRvbWF0aWNhbGx5IGFkZGluZyBvciBzdWJ0cmFjdGluZyB0aGUgY2FsY3VsYXRlZCBvZmZzZXQgdG8gdGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogVGhpcyBpcyBkb25lIHdpdGhvdXQgaGF2aW5nIHRvIHBhc3MgYSBzdGVwIHRvIHRoaXMgZnVuY3Rpb24sIGFuZCBiYXNlZCBvbiB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlICAgICAgICAgICAgICAgICAgICBDYWxjdWxhdGVkIG9mZnNldFxuICAgICAqICAgICAgICAgICAxIC0+ICAgICAgICAgICAxICgxKVxuICAgICAqICAgICAgICAgIDE0IC0+ICAgICAgICAgIDEwICgxMClcbiAgICAgKiAgICAgICAgIDE0MyAtPiAgICAgICAgIDE0MCAoMTApXG4gICAgICogICAgICAgMS4yNzggLT4gICAgICAgMS4zMDAgKDEwMClcbiAgICAgKiAgICAgIDI4LjQ1NiAtPiAgICAgIDI4LjUwMCAoMTAwKVxuICAgICAqICAgICAyNzYuMzQ1IC0+ICAgICAyNzYuMDAwICgxLjAwMClcbiAgICAgKiAgIDQuNTM0LjA2MSAtPiAgIDQuNTMwLjAwMCAoMTAuMDAwKVxuICAgICAqICA2Ni43MjMuODQ0IC0+ICA2Ni43MDAuMDAwICgxMDAuMDAwKVxuICAgICAqIDI1Ny44MzMuNDExIC0+IDI1OC4wMDAuMDAwICgxLjAwMC4wMDApXG4gICAgICpcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIEluaXRpYWwgICBBZGRlZCAgIE9mZnNldFxuICAgICAqIDIgZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlIDogMS4xMiAgIC0+IDIuMDAgICAoMSlcbiAgICAgKiAzIGRlY2ltYWxQbGFjZXNSYXdWYWx1ZSA6IDEuMTIzICAtPiAyLjAwMCAgKDEpXG4gICAgICpcbiAgICAgKiBTcGVjaWFsIGNhc2Ugd2hlbiB0aGUgYHZhbHVlYCB0byByb3VuZCBpcyBiZXR3ZWVuIC0xIGFuZCAxLCBleGNsdWRlZCA6XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgTnVtYmVyIG9mICAgICAgICAgICAgIEluaXRpYWwgICBSZXN1bHQgIENhbGN1bGF0ZWRcbiAgICAgKiAgICAgZGVjaW1hbCBwbGFjZXMgICAgICAgIHZhbHVlICAgICAoYWRkKSAgIG9mZnNldFxuICAgICAqIDIgZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlIDogMC4xMiAgIC0+IDAuMTMgICAgKDAuMDEpIDogTWF0aC5wb3coMTAsIC0yKVxuICAgICAqIDIgZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlIDogMC4wMSAgIC0+IDAuMDIgICAgKDAuMDEpXG4gICAgICogMiBkZWNpbWFsUGxhY2VzUmF3VmFsdWUgOiAwLjAwICAgLT4gMC4wMSAgICAoMC4wMSlcbiAgICAgKlxuICAgICAqIDMgZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlIDogMC4xMjMgIC0+IDAuMTMzICAgKDAuMDEpICA6IE1hdGgucG93KDEwLCAtMilcbiAgICAgKiAzIGRlY2ltYWxQbGFjZXNSYXdWYWx1ZSA6IDAuMDEyICAtPiAwLjAxMyAgICgwLjAwMSkgOiBNYXRoLnBvdygxMCwgLTMpXG4gICAgICogMyBkZWNpbWFsUGxhY2VzUmF3VmFsdWUgOiAwLjAwMSAgLT4gMC4wMDEgICAoMC4wMDEpXG4gICAgICogMyBkZWNpbWFsUGxhY2VzUmF3VmFsdWUgOiAwLjAwMCAgLT4gMC4wMDEgICAoMC4wMDEpXG4gICAgICpcbiAgICAgKiA0IGRlY2ltYWxQbGFjZXNSYXdWYWx1ZSA6IDAuNDEyMyAtPiAwLjQyMDAgICgwLjAxKSAgIDogTWF0aC5wb3coMTAsIC0yKVxuICAgICAqIDQgZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlIDogMC4wNDEyIC0+IDAuMDQyMCAgKDAuMDAxKSAgOiBNYXRoLnBvdygxMCwgLTMpXG4gICAgICogNCBkZWNpbWFsUGxhY2VzUmF3VmFsdWUgOiAwLjAwNDEgLT4gMC4wMDQyICAoMC4wMDAxKSA6IE1hdGgucG93KDEwLCAtNClcbiAgICAgKiA0IGRlY2ltYWxQbGFjZXNSYXdWYWx1ZSA6IDAuMDAwNCAtPiAwLjAwMDUgICgwLjAwMDEpXG4gICAgICogNCBkZWNpbWFsUGxhY2VzUmF3VmFsdWUgOiAwLjAwMDAgLT4gMC4wMDAxICAoMC4wMDAxKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0FkZGl0aW9uXG4gICAgICogQHBhcmFtIHtpbnR9IGRlY2ltYWxQbGFjZXNSYXdWYWx1ZSBUaGUgcHJlY2lzaW9uIG5lZWRlZCBieSB0aGUgYHJhd1ZhbHVlYFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHN0YXRpYyBtb2RpZnlBbmRSb3VuZFRvTmVhcmVzdEF1dG8odmFsdWUsIGlzQWRkaXRpb24sIGRlY2ltYWxQbGFjZXNSYXdWYWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IE51bWJlcih0aGlzLmZvcmNlRGVjaW1hbFBsYWNlcyh2YWx1ZSwgZGVjaW1hbFBsYWNlc1Jhd1ZhbHVlKSk7IC8vIE1ha2Ugc3VyZSB0aGF0ICcwLjEzMDAwMDAwMDAxJyBpcyBjb252ZXJ0ZWQgdG8gdGhlIG51bWJlciBvZiByYXdWYWx1ZSBkZWNpbWFsIHBsYWNlcyAnMC4xMydcblxuICAgICAgICBjb25zdCBhYnNWYWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcbiAgICAgICAgaWYgKGFic1ZhbHVlID49IDAgJiYgYWJzVmFsdWUgPCAxKSB7XG4gICAgICAgICAgICBjb25zdCByYXdWYWx1ZU1pbmltdW1PZmZzZXQgPSBNYXRoLnBvdygxMCwgLWRlY2ltYWxQbGFjZXNSYXdWYWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyA0IGRlY2ltYWxQbGFjZXNSYXdWYWx1ZSA6IDAuMDAwMCAtPiAwLjAwMDEgKDAuMDAwMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gKGlzQWRkaXRpb24pP3Jhd1ZhbHVlTWluaW11bU9mZnNldDotcmF3VmFsdWVNaW5pbXVtT2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgb2Zmc2V0O1xuICAgICAgICAgICAgY29uc3QgbWluaW11bU9mZnNldEZpcnN0RGVjaW1hbFBsYWNlSW5kZXggPSBkZWNpbWFsUGxhY2VzUmF3VmFsdWU7XG4gICAgICAgICAgICAvLyBGaW5kIHdoZXJlIGlzIHRoZSBmaXJzdCBub24temVybyBkZWNpbWFsIHBsYWNlc1xuICAgICAgICAgICAgY29uc3QgaW5kZXhGaXJzdE5vblplcm9EZWNpbWFsUGxhY2UgPSB0aGlzLmluZGV4Rmlyc3ROb25aZXJvRGVjaW1hbFBsYWNlKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpbmRleEZpcnN0Tm9uWmVyb0RlY2ltYWxQbGFjZSA+PSBtaW5pbXVtT2Zmc2V0Rmlyc3REZWNpbWFsUGxhY2VJbmRleCAtIDEpIHtcbiAgICAgICAgICAgICAgICAvKiA0IGRlY2ltYWxQbGFjZXNSYXdWYWx1ZSA6IDAuMDA0MSAtPiAwLjAwNDIgKDAuMDAwMSkgOiBNYXRoLnBvdygxMCwgLTQpXG4gICAgICAgICAgICAgICAgICogNCBkZWNpbWFsUGxhY2VzUmF3VmFsdWUgOiAwLjAwMDQgLT4gMC4wMDA1ICgwLjAwMDEpXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gcmF3VmFsdWVNaW5pbXVtT2Zmc2V0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBNYXRoLnBvdygxMCwgLShpbmRleEZpcnN0Tm9uWmVyb0RlY2ltYWxQbGFjZSArIDEpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChpc0FkZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUgKyBvZmZzZXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlIC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3VuZFRvTmVhcmVzdChyZXN1bHQsIG9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgdmFsdWVzID49IDFcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aFZhbHVlID0gTWF0aC5hYnModmFsdWUpLnRvU3RyaW5nKCkubGVuZ3RoOyAvLyBgTWF0aC5hYnMoKWAgaXMgbmVlZGVkIGhlcmUgdG8gb21pdCB0aGUgbmVnYXRpdmUgc2lnbiAnLScgaW4gY2FzZSBvZiBhIG5lZ2F0aXZlIHZhbHVlXG5cbiAgICAgICAgICAgIGxldCBwb3c7XG4gICAgICAgICAgICBzd2l0Y2ggKGxlbmd0aFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlcyBmb3Igc21hbGwgbnVtYmVyc1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcG93ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcG93ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgcG93ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBiZWhhdmlvclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHBvdyA9IGxlbmd0aFZhbHVlIC0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IE1hdGgucG93KDEwLCBwb3cpO1xuXG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKGlzQWRkaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZSArIG9mZnNldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUgLSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPD0gMTAgJiYgcmVzdWx0ID49IC0xMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdW5kVG9OZWFyZXN0KHJlc3VsdCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgJ25lYXJlc3Qgcm91bmRlZCcgdmFsdWUgYXV0b21hdGljYWxseSBieSBhZGRpbmcgdGhlIGNhbGN1bGF0ZWQgb2Zmc2V0IHRvIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIFRoaXMgd2lsbCBsaW1pdCB0aGUgcmVzdWx0IHRvIHRoZSBnaXZlbiBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgYGRlY2ltYWxQbGFjZXNMaW1pdGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge2ludH0gZGVjaW1hbFBsYWNlc0xpbWl0XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc3RhdGljIGFkZEFuZFJvdW5kVG9OZWFyZXN0QXV0byh2YWx1ZSwgZGVjaW1hbFBsYWNlc0xpbWl0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGlmeUFuZFJvdW5kVG9OZWFyZXN0QXV0byh2YWx1ZSwgdHJ1ZSwgZGVjaW1hbFBsYWNlc0xpbWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlICduZWFyZXN0IHJvdW5kZWQnIHZhbHVlIGF1dG9tYXRpY2FsbHkgYnkgc3VidHJhY3RpbmcgdGhlIGNhbGN1bGF0ZWQgb2Zmc2V0IHRvIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIFRoaXMgd2lsbCBsaW1pdCB0aGUgcmVzdWx0IHRvIHRoZSBnaXZlbiBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgYGRlY2ltYWxQbGFjZXNMaW1pdGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge2ludH0gZGVjaW1hbFBsYWNlc0xpbWl0XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc3RhdGljIHN1YnRyYWN0QW5kUm91bmRUb05lYXJlc3RBdXRvKHZhbHVlLCBkZWNpbWFsUGxhY2VzTGltaXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kaWZ5QW5kUm91bmRUb05lYXJlc3RBdXRvKHZhbHVlLCBmYWxzZSwgZGVjaW1hbFBsYWNlc0xpbWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUYWtlIGFuIGFyYWJpYyBudW1iZXIgYXMgYSBzdHJpbmcgYW5kIHJldHVybiBhIGphdmFzY3JpcHQgbnVtYmVyLlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgdHJ5IHRvIGNvbnZlcnQgdGhlIGFyYWJpYyBkZWNpbWFsIGFuZCB0aG91c2FuZCBzZXBhcmF0b3IgY2hhcmFjdGVycy5cbiAgICAgKiBUaGlzIHJldHVybnMgYE5hTmAgaXMgdGhlIGNvbnZlcnNpb24gaXMgbm90IHBvc3NpYmxlLlxuICAgICAqIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE3MDI1MzkyLzI4MzQ4OThcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmFiaWNOdW1iZXJzXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXR1cm5BTnVtYmVyIElmIGB0cnVlYCwgcmV0dXJuIGEgTnVtYmVyLCBvdGhlcndpc2UgcmV0dXJuIGEgU3RyaW5nXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJzZURlY2ltYWxDaGFyYWN0ZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcnNlVGhvdXNhbmRTZXBhcmF0b3JcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bWJlcnxOYU59XG4gICAgICovXG4gICAgc3RhdGljIGFyYWJpY1RvTGF0aW5OdW1iZXJzKGFyYWJpY051bWJlcnMsIHJldHVybkFOdW1iZXIgPSB0cnVlLCBwYXJzZURlY2ltYWxDaGFyYWN0ZXIgPSBmYWxzZSwgcGFyc2VUaG91c2FuZFNlcGFyYXRvciA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTnVsbChhcmFiaWNOdW1iZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyYWJpY051bWJlcnM7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0ID0gYXJhYmljTnVtYmVycy50b1N0cmluZygpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGFyYWJpY051bWJlcnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0Lm1hdGNoKC9b2aDZodmi2aPZpNml2abZp9mo2anbtNu127ZdL2cpID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiBubyBBcmFiaWMvUGVyc2lhbiBudW1iZXJzIGFyZSBmb3VuZCwgcmV0dXJuIHRoZSBudW1lcmljIHN0cmluZyBvciBudW1iZXIgZGlyZWN0bHlcbiAgICAgICAgICAgIGlmIChyZXR1cm5BTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gTnVtYmVyKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VEZWNpbWFsQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgv2asvLCAnLicpOyAvLyBEZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnNlVGhvdXNhbmRTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC/ZrC9nLCAnJyk7IC8vIFRob3VzYW5kIHNlcGFyYXRvclxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgbnVtYmVycyBvbmx5XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9b2aDZodmi2aPZpNml2abZp9mo2aldL2csIGQgPT4gZC5jaGFyQ29kZUF0KDApIC0gMTYzMikgLy8gQXJhYmljIG51bWJlcnNcbiAgICAgICAgICAgIC5yZXBsYWNlKC9b27Dbsduy27PbtNu127bbt9u427ldL2csIGQgPT4gZC5jaGFyQ29kZUF0KDApIC0gMTc3Nik7IC8vIFBlcnNpYW4gbnVtYmVyc1xuXG4gICAgICAgIC8vIGBOYU5gIGhhcyBwcmVjZWRlbmNlIG92ZXIgdGhlIHN0cmluZyBgJ05hTidgXG4gICAgICAgIGNvbnN0IHJlc3VsdEFzTnVtYmVyID0gTnVtYmVyKHJlc3VsdCk7XG4gICAgICAgIGlmIChpc05hTihyZXN1bHRBc051bWJlcikpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRBc051bWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXR1cm5BTnVtYmVyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRBc051bWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY3VzdG9tIGV2ZW50IGFuZCBpbW1lZGlhdGVseSBzZW50IGl0IGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICogQnkgZGVmYXVsdCwgaWYgbm8gZWxlbWVudCBpcyBnaXZlbiwgdGhlIGV2ZW50IGlzIHRocm93biBmcm9tIGBkb2N1bWVudGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MRG9jdW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGV0YWlsXG4gICAgICovXG4gICAgc3RhdGljIHRyaWdnZXJFdmVudChldmVudE5hbWUsIGVsZW1lbnQgPSBkb2N1bWVudCwgZGV0YWlsID0gbnVsbCkge1xuICAgICAgICBsZXQgZXZlbnQ7XG4gICAgICAgIGlmICh3aW5kb3cuQ3VzdG9tRXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBkZXRhaWwsIGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSB9KTsgLy8gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGRlZmF1bHQgYnkgSUUgOyBXZSB1c2UgdGhlIHBvbHlmaWxsIGZvciBJRTkgYW5kIGxhdGVyLlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgICAgICAgIGV2ZW50LmluaXRDdXN0b21FdmVudChldmVudE5hbWUsIHRydWUsIHRydWUsIHsgZGV0YWlsIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBwYXJzZSBtaW5pbXVtVmFsdWUsIG1heGltdW1WYWx1ZSAmIHRoZSBpbnB1dCB2YWx1ZSB0byBwcmVwYXJlIGZvciB0ZXN0aW5nIHRvIGRldGVybWluZSBpZiB0aGUgdmFsdWUgZmFsbHMgd2l0aGluIHRoZSBtaW4gLyBtYXggcmFuZ2UuXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCBleGFtcGxlOiBtaW5pbXVtVmFsdWU6IFwiOTk5OTk5OTk5OTk5OTk5Ljk5XCIgcmV0dXJucyB0aGUgZm9sbG93aW5nIFwie3M6IC0xLCBlOiAxMiwgYzogQXJyYXlbMTVdfVwiLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhZGFwdGVkIGZyb20gQmlnLmpzIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZy5qcy8uIE1hbnkgdGhhbmtzIHRvIE1pa2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG4gQSBudW1lcmljIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHt7fX1cbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VTdHIobikge1xuICAgICAgICBjb25zdCB4ID0ge307IC8vIEEgQmlnIG51bWJlciBpbnN0YW5jZS5cbiAgICAgICAgbGV0IGU7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbkw7XG4gICAgICAgIGxldCBqO1xuXG4gICAgICAgIC8vIE1pbnVzIHplcm8/XG4gICAgICAgIGlmIChuID09PSAwICYmIDEgLyBuIDwgMCkge1xuICAgICAgICAgICAgbiA9ICctMCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgc2lnbi4gMSBwb3NpdGl2ZSwgLTEgbmVnYXRpdmVcbiAgICAgICAgbiA9IG4udG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZVN0cmljdChuKSkge1xuICAgICAgICAgICAgbiA9IG4uc2xpY2UoMSk7XG4gICAgICAgICAgICB4LnMgPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHgucyA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xuICAgICAgICBlID0gbi5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmIChlID4gLTEpIHtcbiAgICAgICAgICAgIG4gPSBuLnJlcGxhY2UoJy4nLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsZW5ndGggb2Ygc3RyaW5nIGlmIG5vIGRlY2ltYWwgY2hhcmFjdGVyXG4gICAgICAgIGlmIChlIDwgMCkge1xuICAgICAgICAgICAgLy8gSW50ZWdlclxuICAgICAgICAgICAgZSA9IG4ubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3NcbiAgICAgICAgaSA9IChuLnNlYXJjaCgvWzEtOV0vaSkgPT09IC0xKSA/IG4ubGVuZ3RoIDogbi5zZWFyY2goL1sxLTldL2kpO1xuICAgICAgICBuTCA9IG4ubGVuZ3RoO1xuICAgICAgICBpZiAoaSA9PT0gbkwpIHtcbiAgICAgICAgICAgIC8vIFplcm9cbiAgICAgICAgICAgIHguZSA9IDA7XG4gICAgICAgICAgICB4LmMgPSBbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3NcbiAgICAgICAgICAgIGZvciAoaiA9IG5MIC0gMTsgbi5jaGFyQXQoaikgPT09ICcwJzsgaiAtPSAxKSB7XG4gICAgICAgICAgICAgICAgbkwgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5MIC09IDE7XG5cbiAgICAgICAgICAgIC8vIERlY2ltYWwgbG9jYXRpb25cbiAgICAgICAgICAgIHguZSA9IGUgLSBpIC0gMTtcbiAgICAgICAgICAgIHguYyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBhcnJheSBvZiBkaWdpdHMgd2l0aG91dCBsZWFkaW5nL3RyYWlsaW5nIHplcm9zXG4gICAgICAgICAgICBmb3IgKGUgPSAwOyBpIDw9IG5MOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB4LmNbZV0gPSArbi5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgZSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gdGVzdCBpZiB0aGUgaW5wdXQgdmFsdWUgZmFsbHMgd2l0aCB0aGUgTWluIC8gTWF4IHNldHRpbmdzLlxuICAgICAqIFRoaXMgdXNlcyB0aGUgcGFyc2VkIHN0cmluZ3MgZm9yIHRoZSBhYm92ZSBwYXJzZVN0ciBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tIEJpZy5qcyBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvLiBNYW55IHRoYW5rcyB0byBNaWtlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHkgQmlnIG51bWJlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB4IEJpZyBudW1iZXIgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzdGF0aWMgdGVzdE1pbk1heCh5LCB4KSB7XG4gICAgICAgIGNvbnN0IHhjID0geC5jO1xuICAgICAgICBjb25zdCB5YyA9IHkuYztcbiAgICAgICAgbGV0IGkgPSB4LnM7XG4gICAgICAgIGxldCBqID0geS5zO1xuICAgICAgICBsZXQgayA9IHguZTtcbiAgICAgICAgbGV0IGwgPSB5LmU7XG5cbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKCF4Y1swXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICF5Y1swXT8wOi1qO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpZ25zIGRpZmZlcj9cbiAgICAgICAgaWYgKGkgIT09IGopIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHhOZWcgPSBpIDwgMDtcblxuICAgICAgICAvLyBDb21wYXJlIGV4cG9uZW50c1xuICAgICAgICBpZiAoayAhPT0gbCkge1xuICAgICAgICAgICAgcmV0dXJuIChrID4gbCBeIHhOZWcpPzE6LTE7XG4gICAgICAgIH1cbiAgICAgICAgaSA9IC0xO1xuICAgICAgICBrID0geGMubGVuZ3RoO1xuICAgICAgICBsID0geWMubGVuZ3RoO1xuICAgICAgICBqID0gKGsgPCBsKSA/IGsgOiBsO1xuXG4gICAgICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXRcbiAgICAgICAgZm9yIChpICs9IDE7IGkgPCBqOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICh4Y1tpXSAhPT0geWNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHhjW2ldID4geWNbaV0gXiB4TmVnKT8xOi0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcGFyZSBsZW5ndGhzXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChrID09PSBsKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gKGsgPiBsIF4geE5lZyk/MTotMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSByYW5kb20gc3RyaW5nLlxuICAgICAqIGNmLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84MDg0MjQ4LzI4MzQ4OThcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdHJMZW5ndGggTGVuZ3RoIG9mIHRoZSBnZW5lcmF0ZWQgc3RyaW5nIChpbiBjaGFyYWN0ZXIgY291bnQpXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgcmFuZG9tU3RyaW5nKHN0ckxlbmd0aCA9IDUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKClcbiAgICAgICAgICAgIC50b1N0cmluZygzNilcbiAgICAgICAgICAgIC5zdWJzdHIoMiwgc3RyTGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBlbGVtZW50IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MSW5wdXRFbGVtZW50fEV2ZW50VGFyZ2V0fSBlbGVtZW50XG4gICAgICogQHJldHVybnMge251bWJlcnxzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RWxlbWVudFZhbHVlKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kaWZ5IHRoZSBlbGVtZW50IHZhbHVlIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MSW5wdXRFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfG51bGx9IHZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIHNldEVsZW1lbnRWYWx1ZShlbGVtZW50LCB2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICAgICAgICBlbGVtZW50LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNsb25lIHRoZSBnaXZlbiBvYmplY3QsIGFuZCByZXR1cm4gaXQuXG4gICAgICogV0FSTklORzogVGhpcyBkb2VzIG5vdCBkbyBhIGRlZXAgY2xvbmluZy5cbiAgICAgKiBjZi4gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnbiNFeGFtcGxlc1xuICAgICAqIC8vVE9ETyBBZGQgYSBgZGVlcGAgb3B0aW9uIHRvIGNsb25lIG9iamVjdCB3aXRoIG1vcmUgdGhhbiBvbmUgZGVwdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIHN0YXRpYyBjbG9uZU9iamVjdChvYmopIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9iaik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgJ2NhbWVsaXplZCcgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgYXNzdW1lIHRoYXQgOlxuICAgICAqIC0gdGhlIHNlcGFyYXRvcnMgYXJlIGh5cGhlbnMgJy0nLFxuICAgICAqIC0gdGhlICdkYXRhLScgc3RyaW5nIHNob3VsZCBiZSByZW1vdmVkLCBhbmRcbiAgICAgKiAtIHRoYXQgdGhlIHZlcnkgZmlyc3Qgd29yZCBzaG91bGQgbm90IGJlIGNhcGl0YWxpemVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgY2FtZWxpemUoJ2RhdGEtY3VycmVuY3ktc3ltYm9sJykgPT4gJ2N1cnJlbmN5U3ltYm9sJ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUZXh0IHRvIGNhbWVsaXplXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcGFyYXRvciBDaGFyYWN0ZXIgdGhhdCBzZXBhcmF0ZSBlYWNoIHdvcmRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlbW92ZURhdGEgSWYgc2V0IHRvIGB0cnVlYCwgcmVtb3ZlIHRoZSBgZGF0YS1gIHBhcnQgdGhhdCB5b3UgY2FuIGZpbmQgb24gc29tZSBodG1sIGF0dHJpYnV0ZXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNraXBGaXJzdFdvcmQgSWYgc2V0IHRvIGB0cnVlYCwgZG8gbm90IGNhcGl0YWxpemUgdGhlIHZlcnkgZmlyc3Qgd29yZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICBzdGF0aWMgY2FtZWxpemUoc3RyLCBzZXBhcmF0b3IgPSAnLScsIHJlbW92ZURhdGEgPSB0cnVlLCBza2lwRmlyc3RXb3JkID0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc051bGwoc3RyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVtb3ZlRGF0YSkge1xuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL15kYXRhLS8sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEN1dCB0aGUgc3RyaW5nIGludG8gd29yZHNcbiAgICAgICAgY29uc3Qgd29yZHMgPSBzdHIuc3BsaXQoc2VwYXJhdG9yKTtcblxuICAgICAgICAvLyBDYXBpdGFsaXplIGVhY2ggd29yZFxuICAgICAgICBsZXQgcmVzdWx0ID0gd29yZHMubWFwKHdvcmQgPT4gYCR7d29yZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke3dvcmQuc2xpY2UoMSl9YCk7XG5cbiAgICAgICAgLy8gVGhlbiBjb25jYXRlbmF0ZSB0aGVtIGJhY2tcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmpvaW4oJycpO1xuXG4gICAgICAgIGlmIChza2lwRmlyc3RXb3JkKSB7XG4gICAgICAgICAgICAvLyBTa2lwIHRoZSB2ZXJ5IGZpcnN0IGxldHRlclxuICAgICAgICAgICAgcmVzdWx0ID0gYCR7cmVzdWx0LmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpfSR7cmVzdWx0LnNsaWNlKDEpfWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdGV4dCBjb21wb25lbnQgb2YgdGhlIGdpdmVuIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBkb21FbGVtZW50XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgdGV4dChkb21FbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IG5vZGVUeXBlID0gZG9tRWxlbWVudC5ub2RlVHlwZTtcblxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAvLyBjZi4gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUvbm9kZVR5cGVcbiAgICAgICAgaWYgKG5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSB8fFxuICAgICAgICAgICAgbm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERSB8fFxuICAgICAgICAgICAgbm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZG9tRWxlbWVudC50ZXh0Q29udGVudDtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGRvbUVsZW1lbnQubm9kZVZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBnaXZlbiBET00gZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGRvbUVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqL1xuICAgIHN0YXRpYyBzZXRUZXh0KGRvbUVsZW1lbnQsIHRleHQpIHtcbiAgICAgICAgY29uc3Qgbm9kZVR5cGUgPSBkb21FbGVtZW50Lm5vZGVUeXBlO1xuICAgICAgICBpZiAobm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFIHx8XG4gICAgICAgICAgICBub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFIHx8XG4gICAgICAgICAgICBub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICBkb21FbGVtZW50LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICAvL1RPRE8gRGlzcGxheSBhIHdhcm5pbmcgaWYgdGhhdCBmdW5jdGlvbiBkb2VzIG5vdCBkbyBhbnl0aGluZz9cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgb3V0IHRoZSBnaXZlbiBgYXJyYCBhcnJheSB3aXRoIHRoZSBlbGVtZW50cyBmb3VuZCBpbiBgZXhjbHVkZWRFbGVtZW50c2AuXG4gICAgICogVGhpcyByZXR1cm5zIGEgbmV3IGFycmF5IGFuZCBkb2VzIG5vdCBtb2RpZnkgdGhlIHNvdXJjZS5cbiAgICAgKiBjZi4gdmVyaWZpY2F0aW9uIGhlcmUgOiBodHRwOi8vY29kZXBlbi5pby9Bbm90aGVyTGludXhVc2VyL3Blbi9YcHZyTWc/ZWRpdG9ycz0wMDEyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBleGNsdWRlZEVsZW1lbnRzXG4gICAgICogQHJldHVybnMgeyp8QXJyYXkuPFQ+fVxuICAgICAqL1xuICAgIHN0YXRpYyBmaWx0ZXJPdXQoYXJyLCBleGNsdWRlZEVsZW1lbnRzKSB7XG4gICAgICAgIHJldHVybiBhcnIuZmlsdGVyKGVsZW1lbnQgPT4gIXRoaXMuaXNJbkFycmF5KGVsZW1lbnQsIGV4Y2x1ZGVkRWxlbWVudHMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIHRyYWlsaW5nIHplcm9zIGluIHRoZSBkZWNpbWFsIHBhcnQgb2YgYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbnVtZXJpY1N0cmluZ1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHN0YXRpYyB0cmltUGFkZGVkWmVyb3NGcm9tRGVjaW1hbFBsYWNlcyhudW1lcmljU3RyaW5nKSB7XG4gICAgICAgIG51bWVyaWNTdHJpbmcgPSBTdHJpbmcobnVtZXJpY1N0cmluZyk7XG4gICAgICAgIGlmIChudW1lcmljU3RyaW5nID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBudW1lcmljU3RyaW5nLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmICh0aGlzLmlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eShkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlZ2VyUGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRyaW1tZWREZWNpbWFsUGFydCA9IGRlY2ltYWxQYXJ0LnJlcGxhY2UoLzArJC9nLCAnJyk7XG5cbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKHRyaW1tZWREZWNpbWFsUGFydCA9PT0gJycpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGludGVnZXJQYXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gYCR7aW50ZWdlclBhcnR9LiR7dHJpbW1lZERlY2ltYWxQYXJ0fWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdG9wLW1vc3QgaG92ZXJlZCBpdGVtIGJ5IHRoZSBtb3VzZSBjdXJzb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0SG92ZXJlZEVsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IGhvdmVyZWRFbGVtZW50cyA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCc6aG92ZXInKV07XG4gICAgICAgIHJldHVybiBob3ZlcmVkRWxlbWVudHNbaG92ZXJlZEVsZW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZ2l2ZW4gYXJyYXkgdHJpbW1lZCB0byB0aGUgZ2l2ZW4gbGVuZ3RoLlxuICAgICAqIEBleGFtcGxlIGFycmF5VHJpbShbMSwgMiwgMywgNF0sIDIpIC0+IFsxLCAyXVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc3RhdGljIGFycmF5VHJpbShhcnJheSwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGFyckxlbmd0aCA9PT0gMCB8fCBsZW5ndGggPiBhcnJMZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEFsc28gbWFuYWdlIHRoZSBjYXNlIHdoZXJlIGBsZW5ndGhgIGlzIGhpZ2hlciB0aGFuIHRoZSBjdXJyZW50IGxlbmd0aFxuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5Lmxlbmd0aCA9IHBhcnNlSW50KGxlbmd0aCwgMTApO1xuXG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZSBhbGwgdGhlIGdpdmVuIGFycmF5cyBieSBrZWVwaW5nIG9ubHkgdW5pcXVlIGVsZW1lbnRzLCBhbmQgcmV0dXJuIGFuIGFycmF5IHdpdGggZGUtZHVwbGljYXRlZCB2YWx1ZXMuXG4gICAgICogY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI3NjY0OTcxLzI4MzQ4OThcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4uYXJyYXl9IGFycmF5c1xuICAgICAqIEByZXR1cm5zIHtbKl19XG4gICAgICovXG4gICAgc3RhdGljIGFycmF5VW5pcXVlKC4uLmFycmF5cykgeyAvL0ZJWE1FIMOgIHRlc3RlclxuICAgICAgICByZXR1cm4gWy4uLm5ldyBTZXQoW10uY29uY2F0KC4uLmFycmF5cykpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZSBhbGwgdGhlIGdpdmVuIE1hcHMgYnkga2VlcGluZyBvbmx5IHVuaXF1ZSBlbGVtZW50cywgYW5kIHJldHVybiBhIG5ldyBNYXAgd2l0aCBkZS1kdXBsaWNhdGVkIGtleXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gey4uLk1hcH0gbWFwT2JqZWN0c1xuICAgICAqIEByZXR1cm5zIHtNYXB9XG4gICAgICovXG4gICAgc3RhdGljIG1lcmdlTWFwcyguLi5tYXBPYmplY3RzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKG1hcE9iamVjdHMucmVkdWNlKChhcywgYikgPT4gYXMuY29uY2F0KFsuLi5iXSksIFtdKSk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0F1dG9OdW1lcmljSGVscGVyLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n'use strict';\n\nvar _AutoNumeric = __webpack_require__(1);\n\nvar _AutoNumeric2 = _interopRequireDefault(_AutoNumeric);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Options values enumeration\n */\nObject.defineProperty(_AutoNumeric2.default, 'options', {\n    get: function get() {\n        return {\n            /* Defines if the decimal places should be padded with zeroes\n             * `true`     : always pad decimals with zeros (ie. '12.3400')\n             * `false`    : never pad with zeros (ie. '12.34')\n             * `'floats'` : pad with zeroes only when there are decimals (ie. '12' and '12.3400')\n             * Note: setting allowDecimalPadding to 'false' will override the 'decimalPlaces' setting.\n             */\n            allowDecimalPadding: {\n                always: true,\n                never: false,\n                floats: 'floats'\n            },\n\n            /* Defines where should be positioned the caret on focus\n             * null : Do not enforce any caret positioning on focus (this is needed when using `selectOnFocus`)\n             * `'start'` : put the caret of the far left side of the value (excluding the positive/negative sign and currency symbol, if any)\n             * `'end'` : put the caret of the far right side of the value (excluding the positive/negative sign and currency symbol, if any)\n             * `'decimalLeft'` : put the caret of the left of the decimal character if any\n             * `'decimalRight'` : put the caret of the right of the decimal character if any\n             */\n            caretPositionOnFocus: {\n                start: 'start',\n                end: 'end',\n                decimalLeft: 'decimalLeft',\n                decimalRight: 'decimalRight',\n                doNoForceCaretPosition: null\n            },\n\n            /* Defines if a local list of AutoNumeric objects should be kept when initializing this object.\n             * This list is used by the `global.*` functions.\n             */\n            createLocalList: {\n                createList: true,\n                doNotCreateList: false\n            },\n\n            /* Defines the currency symbol string.\n             * It can be a string of more than one character (allowing for instance to use a space on either side of it, example: '$ ' or ' $')\n             * cf. https://en.wikipedia.org/wiki/Currency_symbol\n             */\n            currencySymbol: {\n                none: '',\n                currencySign: '¤',\n                austral: '₳', // ARA\n                australCentavo: '¢',\n                baht: '฿', // THB\n                cedi: '₵', // GHS\n                cent: '¢',\n                colon: '₡', // CRC\n                cruzeiro: '₢', // BRB - Not used anymore since 1993\n                dollar: '$',\n                dong: '₫', // VND\n                drachma: '₯', // GRD (or 'Δρχ.' or 'Δρ.')\n                dram: '​֏', // AMD\n                european: '₠', // XEU (old currency before the Euro)\n                euro: '€', // EUR\n                florin: 'ƒ',\n                franc: '₣', // FRF\n                guarani: '₲', // PYG\n                hryvnia: '₴', // грн\n                kip: '₭', // LAK\n                att: 'ອັດ', // cents of the Kip\n                lepton: 'Λ.', // cents of the Drachma\n                lira: '₺', // TRY\n                liraOld: '₤',\n                lari: '₾', // GEL\n                mark: 'ℳ',\n                mill: '₥',\n                naira: '₦', // NGN\n                peseta: '₧',\n                peso: '₱', // PHP\n                pfennig: '₰', // cents of the Mark\n                pound: '£',\n                real: 'R$', // Brazilian real\n                riel: '៛', // KHR\n                ruble: '₽', // RUB\n                rupee: '₹', // INR\n                rupeeOld: '₨',\n                shekel: '₪',\n                shekelAlt: 'ש״ח‎‎',\n                taka: '৳', // BDT\n                tenge: '₸', // KZT\n                togrog: '₮', // MNT\n                won: '₩',\n                yen: '¥'\n            },\n\n            /* Defines where the currency symbol should be placed (before of after the numbers)\n             * for prefix currencySymbolPlacement: \"p\" (default)\n             * for suffix currencySymbolPlacement: \"s\"\n             */\n            currencySymbolPlacement: {\n                prefix: 'p',\n                suffix: 's'\n            },\n\n            /* Defines what decimal separator character is used\n             */\n            decimalCharacter: {\n                comma: ',',\n                dot: '.',\n                middleDot: '·',\n                arabicDecimalSeparator: '٫',\n                decimalSeparatorKeySymbol: '⎖'\n            },\n\n            /* Allow to declare an alternative decimal separator which is automatically replaced by `decimalCharacter` when typed.\n             * This is used by countries that use a comma \",\" as the decimal character and have keyboards\\numeric pads that have\n             * a period 'full stop' as the decimal character (France or Spain for instance).\n             */\n            decimalCharacterAlternative: {\n                none: null,\n                comma: ',',\n                dot: '.'\n            },\n\n            /* Defines the default number of decimal places to show on the formatted value, and keep for the precision.\n             * Incidentally, since we need to be able to show that many decimal places, this also defines the raw value precision by default.\n             */\n            decimalPlaces: {\n                none: 0,\n                one: 1,\n                two: 2,\n                three: 3,\n                four: 4,\n                five: 5,\n                six: 6\n            },\n\n            /* Defines how many decimal places should be kept for the raw value (ie. This is the precision for float values).\n             *\n             * If this option is set to `null` (which is the default), then the value of `decimalPlaces` is used for `decimalPlacesRawValue` as well.\n             * Note: Setting this to a lower number of decimal places than the one to be shown will lead to confusion for the users.\n             */\n            decimalPlacesRawValue: {\n                useDefault: null,\n                none: 0,\n                one: 1,\n                two: 2,\n                three: 3,\n                four: 4,\n                five: 5,\n                six: 6\n            },\n\n            /* Defines how many decimal places should be visible when the element is unfocused.\n             * If this is set to `null`, then this option is ignored, and the `decimalPlaces` option value will be used instead.\n             * This means this is optional ; if omitted the decimal places will be the same when the input has the focus.\n             *\n             * This option can be used in conjonction with the two other `scale*` options, which allows to display a different formatted value when the element is unfocused, while another formatted value is shown when focused.\n             * For those `scale*` option to have any effect, `divisorWhenUnfocused` must not be `null`.\n             */\n            decimalPlacesShownOnBlur: {\n                useDefault: null,\n                none: 0,\n                one: 1,\n                two: 2,\n                three: 3,\n                four: 4,\n                five: 5,\n                six: 6\n            },\n\n            /* Defines how many decimal places should be visible when the element has the focus.\n             * If this is set to `null`, then this option is ignored, and the `decimalPlaces` option value will be used instead.\n             *\n             * Example:\n             * Fon instance if `decimalPlacesShownOnFocus` is set to `5` and the default number of decimal places is `2`, then on focus `1,000.12345` will be shown, while without focus `1,000.12` will be set back.\n             * Note 1: the results depends on the rounding method used.\n             * Note 2: the `getNumericString()` method returns the extended decimal places\n             */\n            decimalPlacesShownOnFocus: {\n                useDefault: null,\n                none: 0,\n                one: 1,\n                two: 2,\n                three: 3,\n                four: 4,\n                five: 5,\n                six: 6\n            },\n\n            /* Helper option for ASP.NET postback\n             * This should be set as the value of the unformatted default value\n             * examples:\n             * no default value=\"\" {defaultValueOverride: \"\"}\n             * value=1234.56 {defaultValueOverride: '1234.56'}\n             */\n            defaultValueOverride: {\n                doNotOverride: null\n            },\n\n            /* Defines how many numbers should be grouped together (usually for the thousand separator)\n             * - \"2\",  results in 99,99,99,999 India's lakhs\n             * - \"2s\", results in 99,999,99,99,999 India's lakhs scaled\n             * - \"3\",  results in 999,999,999 (default)\n             * - \"4\",  results in 9999,9999,9999 used in some Asian countries\n             */\n            digitalGroupSpacing: {\n                two: '2',\n                twoScaled: '2s',\n                three: '3',\n                four: '4'\n            },\n\n            /* Defines the thousand grouping separator character\n             * Example : If `'.'` is set, then you'll get `'1.234.567'`\n             */\n            digitGroupSeparator: {\n                comma: ',',\n                dot: '.',\n                normalSpace: ' ',\n                thinSpace: '\\u2009',\n                narrowNoBreakSpace: '\\u202F',\n                noBreakSpace: '\\xA0',\n                noSeparator: '',\n                apostrophe: '\\'',\n                arabicThousandsSeparator: '٬',\n                dotAbove: '˙'\n            },\n\n            /* The `divisorWhenUnfocused` divide the element value on focus.\n             * On blur, the element value is multiplied back.\n             *\n             * Example : Given the option { divisorWhenUnfocused: 1000 } (or directly in the html `<input data-divisor-when-unfocused=\"1000\">`)\n             * The divisor value does not need to be an integer, but please understand that Javascript has limited accuracy in math ; use with caution.\n             * Note: The `getNumericString` method returns the full value, including the 'hidden' decimals.\n             */\n            divisorWhenUnfocused: {\n                none: null,\n                percentage: 100,\n                permille: 1000,\n                basisPoint: 10000\n            },\n\n            /* Defines what should be displayed in the element if the raw value is an empty string ('').\n             * - 'focus'  : The currency sign is displayed when the input receives focus (default)\n             * - 'press'  : The currency sign is displayed whenever a key is being pressed\n             * - 'always' : The currency sign is always displayed\n             * - 'zero'   : A zero is displayed ('rounded' with or without a currency sign) if the input has no value on focus out\n             * - 'null'   : When the element is empty, the `rawValue` and the element value/text is set to `null`. This also allows to set the value to `null` using `anElement.set(null)`.\n             */\n            emptyInputBehavior: {\n                null: 'null',\n                focus: 'focus',\n                press: 'press',\n                always: 'always',\n                zero: 'zero'\n            },\n\n            /* This option is the 'strict mode' (aka 'debug' mode), which allows autoNumeric to strictly analyse the options passed, and fails if an unknown options is used in the settings object.\n             * You should set that to `true` if you want to make sure you are only using 'pure' autoNumeric settings objects in your code.\n             * If you see uncaught errors in the console and your code starts to fail, this means somehow those options gets polluted by another program (which usually happens when using frameworks).\n             */\n            failOnUnknownOption: {\n                fail: true,\n                ignore: false\n            },\n\n            /* Determine if the default value will be formatted on initialization.\n             */\n            formatOnPageLoad: {\n                format: true, // automatically formats the default value on initialization\n                doNotFormat: false // will not format the default value on initialization\n            },\n\n            /* Set the undo/redo history table size.\n             * Each record keeps the raw value as well and the last known caret/selection positions.\n             */\n            historySize: {\n                verySmall: 5,\n                small: 10,\n                medium: 20,\n                large: 50,\n                veryLarge: 100,\n                insane: Number.MAX_SAFE_INTEGER\n            },\n\n            /* Allow the user to 'cancel' and undo the changes he made to the given autonumeric-managed element, by pressing the 'Escape' key.\n             * Whenever the user 'validate' the input (either by hitting 'Enter', or blurring the element), the new value is saved for subsequent 'cancellation'.\n             *\n             * The process :\n             *   - save the input value on focus\n             *   - if the user change the input value, and hit `Escape`, then the initial value saved on focus is set back\n             *   - on the other hand if the user either have used `Enter` to validate (`Enter` throws a change event) his entries, or if the input value has been changed by another script in the mean time, then we save the new input value\n             *   - on a successful 'cancel', select the whole value (while respecting the `selectNumberOnly` option)\n             *   - bonus; if the value has not changed, hitting 'Esc' just select all the input value (while respecting the `selectNumberOnly` option)\n             */\n            isCancellable: {\n                cancellable: true,\n                notCancellable: false\n            },\n\n            /* Controls the leading zero behavior\n             * - 'allow' : allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted\n             * - 'deny'  : allows only one leading zero on values that are between 1 and -1\n             * - 'keep'  : allows leading zeros to be entered. on focusout zeros will be retained\n             */\n            leadingZero: {\n                allow: 'allow',\n                deny: 'deny',\n                keep: 'keep'\n            },\n\n            /* Defines the maximum possible value a user can enter.\n             * Notes:\n             * - this value must a string and use the period for the decimal point\n             * - this value needs to be larger than `minimumValue`\n             */\n            maximumValue: {\n                tenTrillions: '9999999999999.99', // 9.999.999.999.999,99 ~= 10000 billions\n                tenTrillionsNoDecimals: '9999999999999', //FIXME Update all those limits to the 'real' numbers\n                oneBillion: '999999999.99',\n                zero: '0'\n            },\n\n            /* Defines the minimum possible value a user can enter.\n             * Notes:\n             * - this value must a string and use the period for the decimal point\n             * - this value needs to be smaller than `maximumValue`\n             * - if this is superior to 0, then you'll effectively prevent your user to entirely delete the content of your element\n             */\n            minimumValue: {\n                tenTrillions: '-9999999999999.99', // -9.999.999.999.999,99 ~= 10000 billions\n                tenTrillionsNoDecimals: '-9999999999999',\n                oneBillion: '-999999999.99',\n                zero: '0'\n            },\n\n            /* Allow the user to increment or decrement the element value with the mouse wheel.\n             * The wheel behavior can by modified by the `wheelStep` option.\n             * This `wheelStep` options can be used in two ways, either by setting :\n             * - a 'fixed' step value (`wheelStep : 1000`), or\n             * - the 'progressive' string (`wheelStep : 'progressive'`), which will then activate a special mode where the step is automatically calculated based on the element value size.\n             *\n             * Note :\n             * A special behavior is applied in order to avoid preventing the user to scroll the page if the inputs are covering the whole available space.\n             * You can use the 'Shift' modifier key while using the mouse wheel in order to temporarily disable the increment/decrement feature (useful on small screen where some badly configured inputs could use all the available space).\n             */\n            modifyValueOnWheel: {\n                modifyValue: true,\n                doNothing: false\n            },\n\n            /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\n             * Those brackets are visible only when the field does NOT have the focus.\n             * The left and right symbols should be enclosed in quotes and separated by a comma.\n             */\n            negativeBracketsTypeOnBlur: {\n                parentheses: '(,)',\n                brackets: '[,]',\n                chevrons: '<,>',\n                curlyBraces: '{,}',\n                angleBrackets: '〈,〉',\n                japaneseQuotationMarks: '｢,｣',\n                halfBrackets: '⸤,⸥',\n                whiteSquareBrackets: '⟦,⟧',\n                quotationMarks: '‹,›',\n                guillemets: '«,»',\n                none: null // This is the default value, which deactivate this feature\n            },\n\n            /* Placement of the negative/positive sign relative to the `currencySymbol` option.\n             *\n             * Example:\n             * -1,234.56  => default no options required\n             * -$1,234.56 => {currencySymbol: \"$\"} or {currencySymbol: \"$\", negativePositiveSignPlacement: \"l\"}\n             * $-1,234.56 => {currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\n             * -1,234.56$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\n             * 1,234.56-  => {negativePositiveSignPlacement: \"s\"}\n             * $1,234.56- => {currencySymbol: \"$\", negativePositiveSignPlacement: \"s\"}\n             * 1,234.56-$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\"}\n             * 1,234.56$- => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"r\"}\n             */\n            negativePositiveSignPlacement: {\n                prefix: 'p',\n                suffix: 's',\n                left: 'l',\n                right: 'r',\n                none: null\n            },\n\n            /* Defines if the element should have event listeners activated on it.\n             * By default, those event listeners are only added to <input> elements and html element with the `contenteditable` attribute set to `true`, but not on the other html tags.\n             * This allows to initialize elements without any event listeners.\n             * Warning: Since AutoNumeric will not check the input content after its initialization, using some autoNumeric methods afterwards *will* probably leads to formatting problems.\n             */\n            noEventListeners: {\n                noEvents: true,\n                addEvents: false\n            },\n\n            /* Manage how autoNumeric react when the user tries to paste an invalid number.\n             * - 'error'    : (This is the default behavior) The input value is not changed and an error is output in the console.\n             * - 'ignore'   : idem than 'error', but fail silently without outputting any error/warning in the console.\n             * - 'clamp'    : if the pasted value is either too small or too big regarding the minimumValue and maximumValue range, then the result is clamped to those limits.\n             * - 'truncate' : autoNumeric will insert as many pasted numbers it can at the initial caret/selection, until everything is pasted, or the range limit is hit.\n             *                The non-pasted numbers are dropped and therefore not used at all.\n             * - 'replace'  : autoNumeric will first insert as many pasted numbers it can at the initial caret/selection, then if the range limit is hit, it will try\n             *                to replace one by one the remaining initial numbers (on the right side of the caret) with the rest of the pasted numbers.\n             *\n             * Note 1 : A paste content starting with a negative sign '-' will be accepted anywhere in the input, and will set the resulting value as a negative number\n             * Note 2 : A paste content starting with a number will be accepted, even if the rest is gibberish (ie. '123foobar456').\n             *          Only the first number will be used (here '123').\n             * Note 3 : The paste event works with the `decimalPlacesShownOnFocus` option too.\n             */\n            onInvalidPaste: {\n                error: 'error',\n                ignore: 'ignore',\n                clamp: 'clamp',\n                truncate: 'truncate',\n                replace: 'replace'\n            },\n\n            /* Defines how the value should be formatted when wanting a 'localized' version of it.\n             * - null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\n             * - 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\n             * - ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\n             * - '.-'             => 'nnnn.nn' or 'nnnn.nn-'\n             * - ',-'             => 'nnnn,nn' or 'nnnn,nn-'\n             */\n            outputFormat: {\n                string: 'string',\n                number: 'number',\n                dot: '.',\n                negativeDot: '-.',\n                comma: ',',\n                negativeComma: '-,',\n                dotNegative: '.-',\n                commaNegative: ',-',\n                none: null\n            },\n\n            /* Override the minimum and maximum limits\n             * overrideMinMaxLimits: \"ceiling\" adheres to maximumValue and ignores minimumValue settings\n             * overrideMinMaxLimits: \"floor\" adheres to minimumValue and ignores maximumValue settings\n             * overrideMinMaxLimits: \"ignore\" ignores both minimumValue & maximumValue\n             */\n            overrideMinMaxLimits: {\n                ceiling: 'ceiling',\n                floor: 'floor',\n                ignore: 'ignore',\n                doNotOverride: null\n            },\n\n            /* The `rawValueDivisor` divides the formatted value shown in the AutoNumeric element and store the result in `rawValue`.\n             * @example { rawValueDivisor: '100' } or <input data-raw-value-divisor=\"100\">\n             * Given the `0.01234` raw value, the formatted value will be displayed as `'1.234'`.\n             * This is useful when displaying percentage for instance, and avoid the need to divide/multiply by 100 between the number shown and the raw value.\n             */\n            rawValueDivisor: {\n                none: null,\n                percentage: 100,\n                permille: 1000,\n                basisPoint: 10000\n            },\n\n            /* Defines if the <input> element should be set as read only on initialization.\n             * When set to `true`, then the `readonly` html property is added to the <input> element on initialization.\n             */\n            readOnly: {\n                readOnly: true,\n                readWrite: false\n            },\n\n            /* Defines the rounding method to use.\n             * roundingMethod: \"S\", Round-Half-Up Symmetric (default)\n             * roundingMethod: \"A\", Round-Half-Up Asymmetric\n             * roundingMethod: \"s\", Round-Half-Down Symmetric (lower case s)\n             * roundingMethod: \"a\", Round-Half-Down Asymmetric (lower case a)\n             * roundingMethod: \"B\", Round-Half-Even \"Bankers Rounding\"\n             * roundingMethod: \"U\", Round Up \"Round-Away-From-Zero\"\n             * roundingMethod: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\n             * roundingMethod: \"C\", Round to Ceiling \"Toward Positive Infinity\"\n             * roundingMethod: \"F\", Round to Floor \"Toward Negative Infinity\"\n             * roundingMethod: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\n             * roundingMethod: \"U05\" Rounds up to next .05\n             * roundingMethod: \"D05\" Rounds down to next .05\n             */\n            roundingMethod: {\n                halfUpSymmetric: 'S',\n                halfUpAsymmetric: 'A',\n                halfDownSymmetric: 's',\n                halfDownAsymmetric: 'a',\n                halfEvenBankersRounding: 'B',\n                upRoundAwayFromZero: 'U',\n                downRoundTowardZero: 'D',\n                toCeilingTowardPositiveInfinity: 'C',\n                toFloorTowardNegativeInfinity: 'F',\n                toNearest05: 'N05',\n                toNearest05Alt: 'CHF',\n                upToNext05: 'U05',\n                downToNext05: 'D05'\n            },\n\n            /* Set to `true` to allow the `decimalPlacesShownOnFocus` value to be saved with sessionStorage\n             * If IE 6 or 7 is detected, the value will be saved as a session cookie.\n             */\n            saveValueToSessionStorage: {\n                save: true,\n                doNotSave: false\n            },\n\n            /* Determine if the select all keyboard command will select the complete input text, or only the input numeric value\n             * Note : If the currency symbol is between the numeric value and the negative sign, only the numeric value will be selected\n             */\n            selectNumberOnly: {\n                selectNumbersOnly: true,\n                selectAll: false\n            },\n\n            /* Defines if the element value should be selected on focus.\n             * Note: The selection is done using the `selectNumberOnly` option.\n             */\n            selectOnFocus: {\n                select: true,\n                doNotSelect: false\n            },\n\n            /* Defines how the serialize functions should treat the spaces.\n             * Those spaces ' ' can either be converted to the plus sign '+', which is the default, or to '%20'.\n             * Both values being valid per the spec (http://www.w3.org/Addressing/URL/uri-spec.html).\n             * Also see the summed up answer on http://stackoverflow.com/a/33939287.\n             *\n             * tl;dr : Spaces should be converted to '%20' before the '?' sign, then converted to '+' after.\n             * In our case since we serialize the query, we use '+' as the default (but allow the user to get back the old *wrong* behavior).\n             */\n            serializeSpaces: {\n                plus: '+',\n                percent: '%20'\n            },\n\n            /* Defines if the element value should be converted to the raw value on focus (and back to the formatted on blur).\n             * If set to `true`, then autoNumeric remove the thousand separator, currency symbol and suffix on focus.\n             * Example:\n             * If the input value is '$ 1,999.88 suffix', on focus it becomes '1999.88' and back to '$ 1,999.88 suffix' on focus out.\n             */\n            showOnlyNumbersOnFocus: {\n                onlyNumbers: true,\n                showAll: false\n            },\n\n            /* Allow the positive sign symbol `+` to be displayed for positive numbers.\n             * By default, this positive sign is not shown.\n             * The sign placement is controlled by the 'negativePositiveSignPlacement' option, mimicking the negative sign placement rules.\n             */\n            showPositiveSign: {\n                show: true,\n                hide: false\n            },\n\n            /* Defines if warnings should be shown in the console\n             * Those warnings can be ignored, but are usually printed when something could be improved by the user (ie. option conflicts).\n             */\n            showWarnings: {\n                show: true, // All warning are shown\n                hide: false // No warnings are shown, only the thrown errors\n            },\n\n            /* Defines the rules that calculate the CSS class(es) to apply on the element, based on the raw unformatted value.\n             * This can also be used to call callbacks whenever the `rawValue` is updated.\n             * Important: all callbacks must return `null` if no ranges/userDefined classes are selected\n             * @example\n             * {\n             *     positive   : 'autoNumeric-positive', // Or `null` to not use it\n             *     negative   : 'autoNumeric-negative',\n             *     ranges     : [\n             *         { min: 0, max: 25, class: 'autoNumeric-red' },\n             *         { min: 25, max: 50, class: 'autoNumeric-orange' },\n             *         { min: 50, max: 75, class: 'autoNumeric-yellow' },\n             *         { min: 75, max: Number.MAX_SAFE_INTEGER, class: 'autoNumeric-green' },\n             *     ],\n             *     userDefined: [\n             *         // If 'classes' is a string, set it if `true`, remove it if `false`\n             *         { callback: rawValue => { return true; }, classes: 'thisIsTrue' },\n             *         // If 'classes' is an array with only 2 elements, set the first class if `true`, the second if `false`\n             *         { callback: rawValue => rawValue % 2 === 0, classes: ['autoNumeric-even', 'autoNumeric-odd'] },\n             *         // Return only one index to use on the `classes` array (here, 'class3')\n             *         { callback: rawValue => { return 2; }, classes: ['class1', 'class2', 'class3'] },\n             *         // Return an array of indexes to use on the `classes` array (here, 'class1' and 'class3')\n             *         { callback: rawValue => { return [0, 2]; }, classes: ['class1', 'class2', 'class3'] },\n             *         // If 'classes' is `undefined` or `null`, then the callback is called with the AutoNumeric object passed as a parameter\n             *         { callback: anElement => { return anElement.getFormatted(); } },\n             *     ],\n             * }\n             */\n            styleRules: {\n                none: null,\n                positiveNegative: {\n                    positive: 'autoNumeric-positive',\n                    negative: 'autoNumeric-negative'\n                },\n                range0To100With4Steps: {\n                    ranges: [{ min: 0, max: 25, class: 'autoNumeric-red' }, { min: 25, max: 50, class: 'autoNumeric-orange' }, { min: 50, max: 75, class: 'autoNumeric-yellow' }, { min: 75, max: 100, class: 'autoNumeric-green' }]\n                },\n                evenOdd: {\n                    userDefined: [{ callback: function callback(rawValue) {\n                            return rawValue % 2 === 0;\n                        }, classes: ['autoNumeric-even', 'autoNumeric-odd'] }]\n                },\n                rangeSmallAndZero: {\n                    userDefined: [{\n                        callback: function callback(rawValue) {\n                            if (rawValue >= -1 && rawValue < 0) {\n                                return 0;\n                            }\n                            if (Number(rawValue) === 0) {\n                                return 1;\n                            }\n                            if (rawValue > 0 && rawValue <= 1) {\n                                return 2;\n                            }\n\n                            return null; // In case the rawValue is outside those ranges\n                        }, classes: ['autoNumeric-small-negative', 'autoNumeric-zero', 'autoNumeric-small-positive']\n                    }]\n                }\n            },\n\n            /* Add a text on the right hand side of the element value.\n             * This suffix text can have any characters in its string, except numeric characters and the negative/positive sign.\n             * Example: ' dollars'\n             */\n            suffixText: {\n                none: '',\n                percentage: '%',\n                permille: '‰',\n                basisPoint: '‱'\n            },\n\n            /* The three options (divisorWhenUnfocused, decimalPlacesShownOnBlur & symbolWhenUnfocused) handle scaling of the input when the input does not have focus\n             * Please note that the non-scaled value is held in data and it is advised that you use the `saveValueToSessionStorage` option to ensure retaining the value\n             * [\"divisor\", \"decimal places\", \"symbol\"]\n             * Example: with the following options set {divisorWhenUnfocused: '1000', decimalPlacesShownOnBlur: '1', symbolWhenUnfocused: ' K'}\n             * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\n             */\n\n            /* The `symbolWhenUnfocused` option is a symbol placed as a suffix when not in focus.\n             * This is optional too.\n             */\n            symbolWhenUnfocused: {\n                none: null,\n                percentage: '%',\n                permille: '‰',\n                basisPoint: '‱'\n            },\n\n            /* Defines if the element value should be unformatted when the user hover his mouse over it while holding the `Alt` key.\n             * Unformatting there means that this removes any non-number characters and displays the *raw* value, as understood by Javascript (ie. `12.34` is a valid number, while `12,34` is not).\n             *\n             * We reformat back before anything else if :\n             * - the user focus on the element by tabbing or clicking into it,\n             * - the user releases the `Alt` key, and\n             * - if we detect a mouseleave event.\n             *\n             * We unformat again if :\n             * - while the mouse is over the element, the user hit ctrl again\n             */\n            unformatOnHover: {\n                unformat: true,\n                doNotUnformat: false\n            },\n\n            /* Removes the formatting and use the raw value in each autoNumeric elements of the parent form element, on the form `submit` event.\n             * The output format is a numeric string (nnnn.nn or -nnnn.nn).\n             */\n            unformatOnSubmit: {\n                unformat: true,\n                keepCurrentValue: false\n            },\n\n            /* Provide a way for automatically replacing the formatted value with a pre-defined string, when the raw value is equal to a specific value\n             * Here you can specify as many 'conversion' as possible.\n             */\n            valuesToStrings: {\n                none: null,\n                zeroDash: {\n                    0: '-'\n                },\n                oneAroundZero: {\n                    '-1': 'Min',\n                    1: 'Max'\n                }\n            },\n\n            /* That option is linked to the `modifyValueOnWheel` one and will only be used if the latter is set to `true`.\n             * This option will modify the wheel behavior and can be used in two ways, either by setting :\n             * - a 'fixed' step value (a positive float or integer number `1000`), or\n             * - the `'progressive'` string.\n             *\n             * The 'fixed' mode always increment/decrement the element value by that amount, while respecting the `minimumValue` and `maximumValue` settings.\n             * The 'progressive' mode will increment/decrement the element value based on its current value. The bigger the number, the bigger the step, and vice versa.\n             */\n            wheelStep: {\n                progressive: 'progressive'\n            }\n        };\n    }\n}); /**\n     * Options for autoNumeric.js\n     * @author Alexandre Bonneau <alexandre.bonneau@linuxfr.eu>\n     * @copyright © 2016 Alexandre Bonneau\n     *\n     * The MIT License (http://www.opensource.org/licenses/mit-license.php)\n     *\n     * Permission is hereby granted, free of charge, to any person\n     * obtaining a copy of this software and associated documentation\n     * files (the \"Software\"), to deal in the Software without\n     * restriction, including without limitation the rights to use,\n     * copy, modify, merge, publish, distribute, sub license, and/or sell\n     * copies of the Software, and to permit persons to whom the\n     * Software is furnished to do so, subject to the following\n     * conditions:\n     *\n     * The above copyright notice and this permission notice shall be\n     * included in all copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n     * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n     * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n     * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n     * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n     * OTHER DEALINGS IN THE SOFTWARE.\n     */\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXV0b051bWVyaWNPcHRpb25zLmpzP2NlNWQiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJhbGxvd0RlY2ltYWxQYWRkaW5nIiwiYWx3YXlzIiwibmV2ZXIiLCJmbG9hdHMiLCJjYXJldFBvc2l0aW9uT25Gb2N1cyIsInN0YXJ0IiwiZW5kIiwiZGVjaW1hbExlZnQiLCJkZWNpbWFsUmlnaHQiLCJkb05vRm9yY2VDYXJldFBvc2l0aW9uIiwiY3JlYXRlTG9jYWxMaXN0IiwiY3JlYXRlTGlzdCIsImRvTm90Q3JlYXRlTGlzdCIsImN1cnJlbmN5U3ltYm9sIiwibm9uZSIsImN1cnJlbmN5U2lnbiIsImF1c3RyYWwiLCJhdXN0cmFsQ2VudGF2byIsImJhaHQiLCJjZWRpIiwiY2VudCIsImNvbG9uIiwiY3J1emVpcm8iLCJkb2xsYXIiLCJkb25nIiwiZHJhY2htYSIsImRyYW0iLCJldXJvcGVhbiIsImV1cm8iLCJmbG9yaW4iLCJmcmFuYyIsImd1YXJhbmkiLCJocnl2bmlhIiwia2lwIiwiYXR0IiwibGVwdG9uIiwibGlyYSIsImxpcmFPbGQiLCJsYXJpIiwibWFyayIsIm1pbGwiLCJuYWlyYSIsInBlc2V0YSIsInBlc28iLCJwZmVubmlnIiwicG91bmQiLCJyZWFsIiwicmllbCIsInJ1YmxlIiwicnVwZWUiLCJydXBlZU9sZCIsInNoZWtlbCIsInNoZWtlbEFsdCIsInRha2EiLCJ0ZW5nZSIsInRvZ3JvZyIsIndvbiIsInllbiIsImN1cnJlbmN5U3ltYm9sUGxhY2VtZW50IiwicHJlZml4Iiwic3VmZml4IiwiZGVjaW1hbENoYXJhY3RlciIsImNvbW1hIiwiZG90IiwibWlkZGxlRG90IiwiYXJhYmljRGVjaW1hbFNlcGFyYXRvciIsImRlY2ltYWxTZXBhcmF0b3JLZXlTeW1ib2wiLCJkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUiLCJkZWNpbWFsUGxhY2VzIiwib25lIiwidHdvIiwidGhyZWUiLCJmb3VyIiwiZml2ZSIsInNpeCIsImRlY2ltYWxQbGFjZXNSYXdWYWx1ZSIsInVzZURlZmF1bHQiLCJkZWNpbWFsUGxhY2VzU2hvd25PbkJsdXIiLCJkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIiwiZGVmYXVsdFZhbHVlT3ZlcnJpZGUiLCJkb05vdE92ZXJyaWRlIiwiZGlnaXRhbEdyb3VwU3BhY2luZyIsInR3b1NjYWxlZCIsImRpZ2l0R3JvdXBTZXBhcmF0b3IiLCJub3JtYWxTcGFjZSIsInRoaW5TcGFjZSIsIm5hcnJvd05vQnJlYWtTcGFjZSIsIm5vQnJlYWtTcGFjZSIsIm5vU2VwYXJhdG9yIiwiYXBvc3Ryb3BoZSIsImFyYWJpY1Rob3VzYW5kc1NlcGFyYXRvciIsImRvdEFib3ZlIiwiZGl2aXNvcldoZW5VbmZvY3VzZWQiLCJwZXJjZW50YWdlIiwicGVybWlsbGUiLCJiYXNpc1BvaW50IiwiZW1wdHlJbnB1dEJlaGF2aW9yIiwibnVsbCIsImZvY3VzIiwicHJlc3MiLCJ6ZXJvIiwiZmFpbE9uVW5rbm93bk9wdGlvbiIsImZhaWwiLCJpZ25vcmUiLCJmb3JtYXRPblBhZ2VMb2FkIiwiZm9ybWF0IiwiZG9Ob3RGb3JtYXQiLCJoaXN0b3J5U2l6ZSIsInZlcnlTbWFsbCIsInNtYWxsIiwibWVkaXVtIiwibGFyZ2UiLCJ2ZXJ5TGFyZ2UiLCJpbnNhbmUiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiaXNDYW5jZWxsYWJsZSIsImNhbmNlbGxhYmxlIiwibm90Q2FuY2VsbGFibGUiLCJsZWFkaW5nWmVybyIsImFsbG93IiwiZGVueSIsImtlZXAiLCJtYXhpbXVtVmFsdWUiLCJ0ZW5UcmlsbGlvbnMiLCJ0ZW5UcmlsbGlvbnNOb0RlY2ltYWxzIiwib25lQmlsbGlvbiIsIm1pbmltdW1WYWx1ZSIsIm1vZGlmeVZhbHVlT25XaGVlbCIsIm1vZGlmeVZhbHVlIiwiZG9Ob3RoaW5nIiwibmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIiLCJwYXJlbnRoZXNlcyIsImJyYWNrZXRzIiwiY2hldnJvbnMiLCJjdXJseUJyYWNlcyIsImFuZ2xlQnJhY2tldHMiLCJqYXBhbmVzZVF1b3RhdGlvbk1hcmtzIiwiaGFsZkJyYWNrZXRzIiwid2hpdGVTcXVhcmVCcmFja2V0cyIsInF1b3RhdGlvbk1hcmtzIiwiZ3VpbGxlbWV0cyIsIm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50IiwibGVmdCIsInJpZ2h0Iiwibm9FdmVudExpc3RlbmVycyIsIm5vRXZlbnRzIiwiYWRkRXZlbnRzIiwib25JbnZhbGlkUGFzdGUiLCJlcnJvciIsImNsYW1wIiwidHJ1bmNhdGUiLCJyZXBsYWNlIiwib3V0cHV0Rm9ybWF0Iiwic3RyaW5nIiwibnVtYmVyIiwibmVnYXRpdmVEb3QiLCJuZWdhdGl2ZUNvbW1hIiwiZG90TmVnYXRpdmUiLCJjb21tYU5lZ2F0aXZlIiwib3ZlcnJpZGVNaW5NYXhMaW1pdHMiLCJjZWlsaW5nIiwiZmxvb3IiLCJyYXdWYWx1ZURpdmlzb3IiLCJyZWFkT25seSIsInJlYWRXcml0ZSIsInJvdW5kaW5nTWV0aG9kIiwiaGFsZlVwU3ltbWV0cmljIiwiaGFsZlVwQXN5bW1ldHJpYyIsImhhbGZEb3duU3ltbWV0cmljIiwiaGFsZkRvd25Bc3ltbWV0cmljIiwiaGFsZkV2ZW5CYW5rZXJzUm91bmRpbmciLCJ1cFJvdW5kQXdheUZyb21aZXJvIiwiZG93blJvdW5kVG93YXJkWmVybyIsInRvQ2VpbGluZ1Rvd2FyZFBvc2l0aXZlSW5maW5pdHkiLCJ0b0Zsb29yVG93YXJkTmVnYXRpdmVJbmZpbml0eSIsInRvTmVhcmVzdDA1IiwidG9OZWFyZXN0MDVBbHQiLCJ1cFRvTmV4dDA1IiwiZG93blRvTmV4dDA1Iiwic2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSIsInNhdmUiLCJkb05vdFNhdmUiLCJzZWxlY3ROdW1iZXJPbmx5Iiwic2VsZWN0TnVtYmVyc09ubHkiLCJzZWxlY3RBbGwiLCJzZWxlY3RPbkZvY3VzIiwic2VsZWN0IiwiZG9Ob3RTZWxlY3QiLCJzZXJpYWxpemVTcGFjZXMiLCJwbHVzIiwicGVyY2VudCIsInNob3dPbmx5TnVtYmVyc09uRm9jdXMiLCJvbmx5TnVtYmVycyIsInNob3dBbGwiLCJzaG93UG9zaXRpdmVTaWduIiwic2hvdyIsImhpZGUiLCJzaG93V2FybmluZ3MiLCJzdHlsZVJ1bGVzIiwicG9zaXRpdmVOZWdhdGl2ZSIsInBvc2l0aXZlIiwibmVnYXRpdmUiLCJyYW5nZTBUbzEwMFdpdGg0U3RlcHMiLCJyYW5nZXMiLCJtaW4iLCJtYXgiLCJjbGFzcyIsImV2ZW5PZGQiLCJ1c2VyRGVmaW5lZCIsImNhbGxiYWNrIiwicmF3VmFsdWUiLCJjbGFzc2VzIiwicmFuZ2VTbWFsbEFuZFplcm8iLCJzdWZmaXhUZXh0Iiwic3ltYm9sV2hlblVuZm9jdXNlZCIsInVuZm9ybWF0T25Ib3ZlciIsInVuZm9ybWF0IiwiZG9Ob3RVbmZvcm1hdCIsInVuZm9ybWF0T25TdWJtaXQiLCJrZWVwQ3VycmVudFZhbHVlIiwidmFsdWVzVG9TdHJpbmdzIiwiemVyb0Rhc2giLCJvbmVBcm91bmRaZXJvIiwid2hlZWxTdGVwIiwicHJvZ3Jlc3NpdmUiXSwibWFwcGluZ3MiOiI7Ozs7O0FBNkJBOzs7Ozs7QUFFQTs7O0FBR0FBLE9BQU9DLGNBQVAsd0JBQW1DLFNBQW5DLEVBQThDO0FBQzFDQyxPQUQwQyxpQkFDcEM7QUFDRixlQUFPO0FBQ0g7Ozs7OztBQU1BQyxpQ0FBcUI7QUFDakJDLHdCQUFRLElBRFM7QUFFakJDLHVCQUFRLEtBRlM7QUFHakJDLHdCQUFRO0FBSFMsYUFQbEI7O0FBYUg7Ozs7Ozs7QUFPQUMsa0NBQXNCO0FBQ2xCQyx1QkFBd0IsT0FETjtBQUVsQkMscUJBQXdCLEtBRk47QUFHbEJDLDZCQUF3QixhQUhOO0FBSWxCQyw4QkFBd0IsY0FKTjtBQUtsQkMsd0NBQXdCO0FBTE4sYUFwQm5COztBQTRCSDs7O0FBR0FDLDZCQUFpQjtBQUNiQyw0QkFBaUIsSUFESjtBQUViQyxpQ0FBaUI7QUFGSixhQS9CZDs7QUFvQ0g7Ozs7QUFJQUMsNEJBQWdCO0FBQ1pDLHNCQUFnQixFQURKO0FBRVpDLDhC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SDs7O0FBR0FDLDhCQUFrQjtBQUNkRiwwQkFBa0IsSUFESjtBQUVkRyxrQ0FBa0I7QUFGSixhQXJxQmY7O0FBMHFCSDs7O0FBR0FDLDZCQUFpQjtBQUNiL00sc0JBQWUsSUFERjtBQUViZ04sMEJBQWU7QUFDWCx1QkFBRztBQURRLGlCQUZGO0FBS2JDLCtCQUFlO0FBQ1gsMEJBQU0sS0FESztBQUVYLHVCQUFNO0FBRks7QUFMRixhQTdxQmQ7O0FBd3JCSDs7Ozs7Ozs7QUFRQUMsdUJBQVc7QUFDUEMsNkJBQWE7QUFETjtBQWhzQlIsU0FBUDtBQW9zQkg7QUF0c0J5QyxDQUE5QyxFLENBbENBIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE9wdGlvbnMgZm9yIGF1dG9OdW1lcmljLmpzXG4gKiBAYXV0aG9yIEFsZXhhbmRyZSBCb25uZWF1IDxhbGV4YW5kcmUuYm9ubmVhdUBsaW51eGZyLmV1PlxuICogQGNvcHlyaWdodCDCqSAyMDE2IEFsZXhhbmRyZSBCb25uZWF1XG4gKlxuICogVGhlIE1JVCBMaWNlbnNlIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWIgbGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgQXV0b051bWVyaWMgZnJvbSAnLi9BdXRvTnVtZXJpYyc7XG5cbi8qKlxuICogT3B0aW9ucyB2YWx1ZXMgZW51bWVyYXRpb25cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEF1dG9OdW1lcmljLCAnb3B0aW9ucycsIHtcbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvKiBEZWZpbmVzIGlmIHRoZSBkZWNpbWFsIHBsYWNlcyBzaG91bGQgYmUgcGFkZGVkIHdpdGggemVyb2VzXG4gICAgICAgICAgICAgKiBgdHJ1ZWAgICAgIDogYWx3YXlzIHBhZCBkZWNpbWFscyB3aXRoIHplcm9zIChpZS4gJzEyLjM0MDAnKVxuICAgICAgICAgICAgICogYGZhbHNlYCAgICA6IG5ldmVyIHBhZCB3aXRoIHplcm9zIChpZS4gJzEyLjM0JylcbiAgICAgICAgICAgICAqIGAnZmxvYXRzJ2AgOiBwYWQgd2l0aCB6ZXJvZXMgb25seSB3aGVuIHRoZXJlIGFyZSBkZWNpbWFscyAoaWUuICcxMicgYW5kICcxMi4zNDAwJylcbiAgICAgICAgICAgICAqIE5vdGU6IHNldHRpbmcgYWxsb3dEZWNpbWFsUGFkZGluZyB0byAnZmFsc2UnIHdpbGwgb3ZlcnJpZGUgdGhlICdkZWNpbWFsUGxhY2VzJyBzZXR0aW5nLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhbGxvd0RlY2ltYWxQYWRkaW5nOiB7XG4gICAgICAgICAgICAgICAgYWx3YXlzOiB0cnVlLFxuICAgICAgICAgICAgICAgIG5ldmVyIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZmxvYXRzOiAnZmxvYXRzJyxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qIERlZmluZXMgd2hlcmUgc2hvdWxkIGJlIHBvc2l0aW9uZWQgdGhlIGNhcmV0IG9uIGZvY3VzXG4gICAgICAgICAgICAgKiBudWxsIDogRG8gbm90IGVuZm9yY2UgYW55IGNhcmV0IHBvc2l0aW9uaW5nIG9uIGZvY3VzICh0aGlzIGlzIG5lZWRlZCB3aGVuIHVzaW5nIGBzZWxlY3RPbkZvY3VzYClcbiAgICAgICAgICAgICAqIGAnc3RhcnQnYCA6IHB1dCB0aGUgY2FyZXQgb2YgdGhlIGZhciBsZWZ0IHNpZGUgb2YgdGhlIHZhbHVlIChleGNsdWRpbmcgdGhlIHBvc2l0aXZlL25lZ2F0aXZlIHNpZ24gYW5kIGN1cnJlbmN5IHN5bWJvbCwgaWYgYW55KVxuICAgICAgICAgICAgICogYCdlbmQnYCA6IHB1dCB0aGUgY2FyZXQgb2YgdGhlIGZhciByaWdodCBzaWRlIG9mIHRoZSB2YWx1ZSAoZXhjbHVkaW5nIHRoZSBwb3NpdGl2ZS9uZWdhdGl2ZSBzaWduIGFuZCBjdXJyZW5jeSBzeW1ib2wsIGlmIGFueSlcbiAgICAgICAgICAgICAqIGAnZGVjaW1hbExlZnQnYCA6IHB1dCB0aGUgY2FyZXQgb2YgdGhlIGxlZnQgb2YgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlmIGFueVxuICAgICAgICAgICAgICogYCdkZWNpbWFsUmlnaHQnYCA6IHB1dCB0aGUgY2FyZXQgb2YgdGhlIHJpZ2h0IG9mIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpZiBhbnlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uRm9jdXM6IHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgICAgICAgICAgICAgOiAnc3RhcnQnLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgICAgICAgICAgICAgICA6ICdlbmQnLFxuICAgICAgICAgICAgICAgIGRlY2ltYWxMZWZ0ICAgICAgICAgICA6ICdkZWNpbWFsTGVmdCcsXG4gICAgICAgICAgICAgICAgZGVjaW1hbFJpZ2h0ICAgICAgICAgIDogJ2RlY2ltYWxSaWdodCcsXG4gICAgICAgICAgICAgICAgZG9Ob0ZvcmNlQ2FyZXRQb3NpdGlvbjogbnVsbCxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qIERlZmluZXMgaWYgYSBsb2NhbCBsaXN0IG9mIEF1dG9OdW1lcmljIG9iamVjdHMgc2hvdWxkIGJlIGtlcHQgd2hlbiBpbml0aWFsaXppbmcgdGhpcyBvYmplY3QuXG4gICAgICAgICAgICAgKiBUaGlzIGxpc3QgaXMgdXNlZCBieSB0aGUgYGdsb2JhbC4qYCBmdW5jdGlvbnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNyZWF0ZUxvY2FsTGlzdDoge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUxpc3QgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkb05vdENyZWF0ZUxpc3Q6IGZhbHNlLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyogRGVmaW5lcyB0aGUgY3VycmVuY3kgc3ltYm9sIHN0cmluZy5cbiAgICAgICAgICAgICAqIEl0IGNhbiBiZSBhIHN0cmluZyBvZiBtb3JlIHRoYW4gb25lIGNoYXJhY3RlciAoYWxsb3dpbmcgZm9yIGluc3RhbmNlIHRvIHVzZSBhIHNwYWNlIG9uIGVpdGhlciBzaWRlIG9mIGl0LCBleGFtcGxlOiAnJCAnIG9yICcgJCcpXG4gICAgICAgICAgICAgKiBjZi4gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3VycmVuY3lfc3ltYm9sXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGN1cnJlbmN5U3ltYm9sOiB7XG4gICAgICAgICAgICAgICAgbm9uZSAgICAgICAgICA6ICcnLFxuICAgICAgICAgICAgICAgIGN1cnJlbmN5U2lnbiAgOiAnwqQnLFxuICAgICAgICAgICAgICAgIGF1c3RyYWwgICAgICAgOiAn4oKzJywgLy8gQVJBXG4gICAgICAgICAgICAgICAgYXVzdHJhbENlbnRhdm86ICfCoicsXG4gICAgICAgICAgICAgICAgYmFodCAgICAgICAgICA6ICfguL8nLCAvLyBUSEJcbiAgICAgICAgICAgICAgICBjZWRpICAgICAgICAgIDogJ+KCtScsIC8vIEdIU1xuICAgICAgICAgICAgICAgIGNlbnQgICAgICAgICAgOiAnwqInLFxuICAgICAgICAgICAgICAgIGNvbG9uICAgICAgICAgOiAn4oKhJywgLy8gQ1JDXG4gICAgICAgICAgICAgICAgY3J1emVpcm8gICAgICA6ICfigqInLCAvLyBCUkIgLSBOb3QgdXNlZCBhbnltb3JlIHNpbmNlIDE5OTNcbiAgICAgICAgICAgICAgICBkb2xsYXIgICAgICAgIDogJyQnLFxuICAgICAgICAgICAgICAgIGRvbmcgICAgICAgICAgOiAn4oKrJywgLy8gVk5EXG4gICAgICAgICAgICAgICAgZHJhY2htYSAgICAgICA6ICfigq8nLCAvLyBHUkQgKG9yICfOlM+Bz4cuJyBvciAnzpTPgS4nKVxuICAgICAgICAgICAgICAgIGRyYW0gICAgICAgICAgOiAn4oCL1o8nLCAvLyBBTURcbiAgICAgICAgICAgICAgICBldXJvcGVhbiAgICAgIDogJ+KCoCcsIC8vIFhFVSAob2xkIGN1cnJlbmN5IGJlZm9yZSB0aGUgRXVybylcbiAgICAgICAgICAgICAgICBldXJvICAgICAgICAgIDogJ+KCrCcsIC8vIEVVUlxuICAgICAgICAgICAgICAgIGZsb3JpbiAgICAgICAgOiAnxpInLFxuICAgICAgICAgICAgICAgIGZyYW5jICAgICAgICAgOiAn4oKjJywgLy8gRlJGXG4gICAgICAgICAgICAgICAgZ3VhcmFuaSAgICAgICA6ICfigrInLCAvLyBQWUdcbiAgICAgICAgICAgICAgICBocnl2bmlhICAgICAgIDogJ+KCtCcsIC8vINCz0YDQvVxuICAgICAgICAgICAgICAgIGtpcCAgICAgICAgICAgOiAn4oKtJywgLy8gTEFLXG4gICAgICAgICAgICAgICAgYXR0ICAgICAgICAgICA6ICfguq3gurHgupQnLCAvLyBjZW50cyBvZiB0aGUgS2lwXG4gICAgICAgICAgICAgICAgbGVwdG9uICAgICAgICA6ICfOmy4nLCAvLyBjZW50cyBvZiB0aGUgRHJhY2htYVxuICAgICAgICAgICAgICAgIGxpcmEgICAgICAgICAgOiAn4oK6JywgLy8gVFJZXG4gICAgICAgICAgICAgICAgbGlyYU9sZCAgICAgICA6ICfigqQnLFxuICAgICAgICAgICAgICAgIGxhcmkgICAgICAgICAgOiAn4oK+JywgLy8gR0VMXG4gICAgICAgICAgICAgICAgbWFyayAgICAgICAgICA6ICfihLMnLFxuICAgICAgICAgICAgICAgIG1pbGwgICAgICAgICAgOiAn4oKlJyxcbiAgICAgICAgICAgICAgICBuYWlyYSAgICAgICAgIDogJ+KCpicsIC8vIE5HTlxuICAgICAgICAgICAgICAgIHBlc2V0YSAgICAgICAgOiAn4oKnJyxcbiAgICAgICAgICAgICAgICBwZXNvICAgICAgICAgIDogJ+KCsScsIC8vIFBIUFxuICAgICAgICAgICAgICAgIHBmZW5uaWcgICAgICAgOiAn4oKwJywgLy8gY2VudHMgb2YgdGhlIE1hcmtcbiAgICAgICAgICAgICAgICBwb3VuZCAgICAgICAgIDogJ8KjJyxcbiAgICAgICAgICAgICAgICByZWFsICAgICAgICAgIDogJ1IkJywgLy8gQnJhemlsaWFuIHJlYWxcbiAgICAgICAgICAgICAgICByaWVsICAgICAgICAgIDogJ+GfmycsIC8vIEtIUlxuICAgICAgICAgICAgICAgIHJ1YmxlICAgICAgICAgOiAn4oK9JywgLy8gUlVCXG4gICAgICAgICAgICAgICAgcnVwZWUgICAgICAgICA6ICfigrknLCAvLyBJTlJcbiAgICAgICAgICAgICAgICBydXBlZU9sZCAgICAgIDogJ+KCqCcsXG4gICAgICAgICAgICAgICAgc2hla2VsICAgICAgICA6ICfigqonLFxuICAgICAgICAgICAgICAgIHNoZWtlbEFsdCAgICAgOiAn16nXtNeX4oCO4oCOJyxcbiAgICAgICAgICAgICAgICB0YWthICAgICAgICAgIDogJ+CnsycsIC8vIEJEVFxuICAgICAgICAgICAgICAgIHRlbmdlICAgICAgICAgOiAn4oK4JywgLy8gS1pUXG4gICAgICAgICAgICAgICAgdG9ncm9nICAgICAgICA6ICfigq4nLCAvLyBNTlRcbiAgICAgICAgICAgICAgICB3b24gICAgICAgICAgIDogJ+KCqScsXG4gICAgICAgICAgICAgICAgeWVuICAgICAgICAgICA6ICfCpScsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKiBEZWZpbmVzIHdoZXJlIHRoZSBjdXJyZW5jeSBzeW1ib2wgc2hvdWxkIGJlIHBsYWNlZCAoYmVmb3JlIG9mIGFmdGVyIHRoZSBudW1iZXJzKVxuICAgICAgICAgICAgICogZm9yIHByZWZpeCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJwXCIgKGRlZmF1bHQpXG4gICAgICAgICAgICAgKiBmb3Igc3VmZml4IGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiBcInNcIlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDoge1xuICAgICAgICAgICAgICAgIHByZWZpeDogJ3AnLFxuICAgICAgICAgICAgICAgIHN1ZmZpeDogJ3MnLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyogRGVmaW5lcyB3aGF0IGRlY2ltYWwgc2VwYXJhdG9yIGNoYXJhY3RlciBpcyB1c2VkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRlY2ltYWxDaGFyYWN0ZXI6IHtcbiAgICAgICAgICAgICAgICBjb21tYSAgICAgICAgICAgICAgICAgICAgOiAnLCcsXG4gICAgICAgICAgICAgICAgZG90ICAgICAgICAgICAgICAgICAgICAgIDogJy4nLFxuICAgICAgICAgICAgICAgIG1pZGRsZURvdCAgICAgICAgICAgICAgICA6ICfCtycsXG4gICAgICAgICAgICAgICAgYXJhYmljRGVjaW1hbFNlcGFyYXRvciAgIDogJ9mrJyxcbiAgICAgICAgICAgICAgICBkZWNpbWFsU2VwYXJhdG9yS2V5U3ltYm9sOiAn4o6WJyxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qIEFsbG93IHRvIGRlY2xhcmUgYW4gYWx0ZXJuYXRpdmUgZGVjaW1hbCBzZXBhcmF0b3Igd2hpY2ggaXMgYXV0b21hdGljYWxseSByZXBsYWNlZCBieSBgZGVjaW1hbENoYXJhY3RlcmAgd2hlbiB0eXBlZC5cbiAgICAgICAgICAgICAqIFRoaXMgaXMgdXNlZCBieSBjb3VudHJpZXMgdGhhdCB1c2UgYSBjb21tYSBcIixcIiBhcyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgYW5kIGhhdmUga2V5Ym9hcmRzXFxudW1lcmljIHBhZHMgdGhhdCBoYXZlXG4gICAgICAgICAgICAgKiBhIHBlcmlvZCAnZnVsbCBzdG9wJyBhcyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgKEZyYW5jZSBvciBTcGFpbiBmb3IgaW5zdGFuY2UpLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmU6IHtcbiAgICAgICAgICAgICAgICBub25lIDogbnVsbCxcbiAgICAgICAgICAgICAgICBjb21tYTogJywnLFxuICAgICAgICAgICAgICAgIGRvdCAgOiAnLicsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKiBEZWZpbmVzIHRoZSBkZWZhdWx0IG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0byBzaG93IG9uIHRoZSBmb3JtYXR0ZWQgdmFsdWUsIGFuZCBrZWVwIGZvciB0aGUgcHJlY2lzaW9uLlxuICAgICAgICAgICAgICogSW5jaWRlbnRhbGx5LCBzaW5jZSB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gc2hvdyB0aGF0IG1hbnkgZGVjaW1hbCBwbGFjZXMsIHRoaXMgYWxzbyBkZWZpbmVzIHRoZSByYXcgdmFsdWUgcHJlY2lzaW9uIGJ5IGRlZmF1bHQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRlY2ltYWxQbGFjZXM6IHtcbiAgICAgICAgICAgICAgICBub25lIDogMCxcbiAgICAgICAgICAgICAgICBvbmUgIDogMSxcbiAgICAgICAgICAgICAgICB0d28gIDogMixcbiAgICAgICAgICAgICAgICB0aHJlZTogMyxcbiAgICAgICAgICAgICAgICBmb3VyIDogNCxcbiAgICAgICAgICAgICAgICBmaXZlIDogNSxcbiAgICAgICAgICAgICAgICBzaXggIDogNixcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qIERlZmluZXMgaG93IG1hbnkgZGVjaW1hbCBwbGFjZXMgc2hvdWxkIGJlIGtlcHQgZm9yIHRoZSByYXcgdmFsdWUgKGllLiBUaGlzIGlzIHRoZSBwcmVjaXNpb24gZm9yIGZsb2F0IHZhbHVlcykuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSWYgdGhpcyBvcHRpb24gaXMgc2V0IHRvIGBudWxsYCAod2hpY2ggaXMgdGhlIGRlZmF1bHQpLCB0aGVuIHRoZSB2YWx1ZSBvZiBgZGVjaW1hbFBsYWNlc2AgaXMgdXNlZCBmb3IgYGRlY2ltYWxQbGFjZXNSYXdWYWx1ZWAgYXMgd2VsbC5cbiAgICAgICAgICAgICAqIE5vdGU6IFNldHRpbmcgdGhpcyB0byBhIGxvd2VyIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGFuIHRoZSBvbmUgdG8gYmUgc2hvd24gd2lsbCBsZWFkIHRvIGNvbmZ1c2lvbiBmb3IgdGhlIHVzZXJzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkZWNpbWFsUGxhY2VzUmF3VmFsdWU6IHtcbiAgICAgICAgICAgICAgICB1c2VEZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgICAgIG5vbmUgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgb25lICAgICAgIDogMSxcbiAgICAgICAgICAgICAgICB0d28gICAgICAgOiAyLFxuICAgICAgICAgICAgICAgIHRocmVlICAgICA6IDMsXG4gICAgICAgICAgICAgICAgZm91ciAgICAgIDogNCxcbiAgICAgICAgICAgICAgICBmaXZlICAgICAgOiA1LFxuICAgICAgICAgICAgICAgIHNpeCAgICAgICA6IDYsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKiBEZWZpbmVzIGhvdyBtYW55IGRlY2ltYWwgcGxhY2VzIHNob3VsZCBiZSB2aXNpYmxlIHdoZW4gdGhlIGVsZW1lbnQgaXMgdW5mb2N1c2VkLlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyBzZXQgdG8gYG51bGxgLCB0aGVuIHRoaXMgb3B0aW9uIGlzIGlnbm9yZWQsIGFuZCB0aGUgYGRlY2ltYWxQbGFjZXNgIG9wdGlvbiB2YWx1ZSB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cbiAgICAgICAgICAgICAqIFRoaXMgbWVhbnMgdGhpcyBpcyBvcHRpb25hbCA7IGlmIG9taXR0ZWQgdGhlIGRlY2ltYWwgcGxhY2VzIHdpbGwgYmUgdGhlIHNhbWUgd2hlbiB0aGUgaW5wdXQgaGFzIHRoZSBmb2N1cy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGlzIG9wdGlvbiBjYW4gYmUgdXNlZCBpbiBjb25qb25jdGlvbiB3aXRoIHRoZSB0d28gb3RoZXIgYHNjYWxlKmAgb3B0aW9ucywgd2hpY2ggYWxsb3dzIHRvIGRpc3BsYXkgYSBkaWZmZXJlbnQgZm9ybWF0dGVkIHZhbHVlIHdoZW4gdGhlIGVsZW1lbnQgaXMgdW5mb2N1c2VkLCB3aGlsZSBhbm90aGVyIGZvcm1hdHRlZCB2YWx1ZSBpcyBzaG93biB3aGVuIGZvY3VzZWQuXG4gICAgICAgICAgICAgKiBGb3IgdGhvc2UgYHNjYWxlKmAgb3B0aW9uIHRvIGhhdmUgYW55IGVmZmVjdCwgYGRpdmlzb3JXaGVuVW5mb2N1c2VkYCBtdXN0IG5vdCBiZSBgbnVsbGAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRlY2ltYWxQbGFjZXNTaG93bk9uQmx1cjoge1xuICAgICAgICAgICAgICAgIHVzZURlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgbm9uZSAgICAgIDogMCxcbiAgICAgICAgICAgICAgICBvbmUgICAgICAgOiAxLFxuICAgICAgICAgICAgICAgIHR3byAgICAgICA6IDIsXG4gICAgICAgICAgICAgICAgdGhyZWUgICAgIDogMyxcbiAgICAgICAgICAgICAgICBmb3VyICAgICAgOiA0LFxuICAgICAgICAgICAgICAgIGZpdmUgICAgICA6IDUsXG4gICAgICAgICAgICAgICAgc2l4ICAgICAgIDogNixcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qIERlZmluZXMgaG93IG1hbnkgZGVjaW1hbCBwbGFjZXMgc2hvdWxkIGJlIHZpc2libGUgd2hlbiB0aGUgZWxlbWVudCBoYXMgdGhlIGZvY3VzLlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyBzZXQgdG8gYG51bGxgLCB0aGVuIHRoaXMgb3B0aW9uIGlzIGlnbm9yZWQsIGFuZCB0aGUgYGRlY2ltYWxQbGFjZXNgIG9wdGlvbiB2YWx1ZSB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBFeGFtcGxlOlxuICAgICAgICAgICAgICogRm9uIGluc3RhbmNlIGlmIGBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzYCBpcyBzZXQgdG8gYDVgIGFuZCB0aGUgZGVmYXVsdCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgaXMgYDJgLCB0aGVuIG9uIGZvY3VzIGAxLDAwMC4xMjM0NWAgd2lsbCBiZSBzaG93biwgd2hpbGUgd2l0aG91dCBmb2N1cyBgMSwwMDAuMTJgIHdpbGwgYmUgc2V0IGJhY2suXG4gICAgICAgICAgICAgKiBOb3RlIDE6IHRoZSByZXN1bHRzIGRlcGVuZHMgb24gdGhlIHJvdW5kaW5nIG1ldGhvZCB1c2VkLlxuICAgICAgICAgICAgICogTm90ZSAyOiB0aGUgYGdldE51bWVyaWNTdHJpbmcoKWAgbWV0aG9kIHJldHVybnMgdGhlIGV4dGVuZGVkIGRlY2ltYWwgcGxhY2VzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXM6IHtcbiAgICAgICAgICAgICAgICB1c2VEZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgICAgIG5vbmUgICAgICA6IDAsXG4gICAgICAgICAgICAgICAgb25lICAgICAgIDogMSxcbiAgICAgICAgICAgICAgICB0d28gICAgICAgOiAyLFxuICAgICAgICAgICAgICAgIHRocmVlICAgICA6IDMsXG4gICAgICAgICAgICAgICAgZm91ciAgICAgIDogNCxcbiAgICAgICAgICAgICAgICBmaXZlICAgICAgOiA1LFxuICAgICAgICAgICAgICAgIHNpeCAgICAgICA6IDYsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKiBIZWxwZXIgb3B0aW9uIGZvciBBU1AuTkVUIHBvc3RiYWNrXG4gICAgICAgICAgICAgKiBUaGlzIHNob3VsZCBiZSBzZXQgYXMgdGhlIHZhbHVlIG9mIHRoZSB1bmZvcm1hdHRlZCBkZWZhdWx0IHZhbHVlXG4gICAgICAgICAgICAgKiBleGFtcGxlczpcbiAgICAgICAgICAgICAqIG5vIGRlZmF1bHQgdmFsdWU9XCJcIiB7ZGVmYXVsdFZhbHVlT3ZlcnJpZGU6IFwiXCJ9XG4gICAgICAgICAgICAgKiB2YWx1ZT0xMjM0LjU2IHtkZWZhdWx0VmFsdWVPdmVycmlkZTogJzEyMzQuNTYnfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVPdmVycmlkZToge1xuICAgICAgICAgICAgICAgIGRvTm90T3ZlcnJpZGU6IG51bGwsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKiBEZWZpbmVzIGhvdyBtYW55IG51bWJlcnMgc2hvdWxkIGJlIGdyb3VwZWQgdG9nZXRoZXIgKHVzdWFsbHkgZm9yIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IpXG4gICAgICAgICAgICAgKiAtIFwiMlwiLCAgcmVzdWx0cyBpbiA5OSw5OSw5OSw5OTkgSW5kaWEncyBsYWtoc1xuICAgICAgICAgICAgICogLSBcIjJzXCIsIHJlc3VsdHMgaW4gOTksOTk5LDk5LDk5LDk5OSBJbmRpYSdzIGxha2hzIHNjYWxlZFxuICAgICAgICAgICAgICogLSBcIjNcIiwgIHJlc3VsdHMgaW4gOTk5LDk5OSw5OTkgKGRlZmF1bHQpXG4gICAgICAgICAgICAgKiAtIFwiNFwiLCAgcmVzdWx0cyBpbiA5OTk5LDk5OTksOTk5OSB1c2VkIGluIHNvbWUgQXNpYW4gY291bnRyaWVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRpZ2l0YWxHcm91cFNwYWNpbmc6IHtcbiAgICAgICAgICAgICAgICB0d28gICAgICA6ICcyJyxcbiAgICAgICAgICAgICAgICB0d29TY2FsZWQ6ICcycycsXG4gICAgICAgICAgICAgICAgdGhyZWUgICAgOiAnMycsXG4gICAgICAgICAgICAgICAgZm91ciAgICAgOiAnNCcsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKiBEZWZpbmVzIHRoZSB0aG91c2FuZCBncm91cGluZyBzZXBhcmF0b3IgY2hhcmFjdGVyXG4gICAgICAgICAgICAgKiBFeGFtcGxlIDogSWYgYCcuJ2AgaXMgc2V0LCB0aGVuIHlvdSdsbCBnZXQgYCcxLjIzNC41NjcnYFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkaWdpdEdyb3VwU2VwYXJhdG9yOiB7XG4gICAgICAgICAgICAgICAgY29tbWEgICAgICAgICAgICAgICAgICAgOiAnLCcsXG4gICAgICAgICAgICAgICAgZG90ICAgICAgICAgICAgICAgICAgICAgOiAnLicsXG4gICAgICAgICAgICAgICAgbm9ybWFsU3BhY2UgICAgICAgICAgICAgOiAnICcsXG4gICAgICAgICAgICAgICAgdGhpblNwYWNlICAgICAgICAgICAgICAgOiAnXFx1MjAwOScsXG4gICAgICAgICAgICAgICAgbmFycm93Tm9CcmVha1NwYWNlICAgICAgOiAnXFx1MjAyZicsXG4gICAgICAgICAgICAgICAgbm9CcmVha1NwYWNlICAgICAgICAgICAgOiAnXFx1MDBhMCcsXG4gICAgICAgICAgICAgICAgbm9TZXBhcmF0b3IgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgICAgICAgICBhcG9zdHJvcGhlICAgICAgICAgICAgICA6IGAnYCxcbiAgICAgICAgICAgICAgICBhcmFiaWNUaG91c2FuZHNTZXBhcmF0b3I6ICfZrCcsXG4gICAgICAgICAgICAgICAgZG90QWJvdmUgICAgICAgICAgICAgICAgOiAny5knLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyogVGhlIGBkaXZpc29yV2hlblVuZm9jdXNlZGAgZGl2aWRlIHRoZSBlbGVtZW50IHZhbHVlIG9uIGZvY3VzLlxuICAgICAgICAgICAgICogT24gYmx1ciwgdGhlIGVsZW1lbnQgdmFsdWUgaXMgbXVsdGlwbGllZCBiYWNrLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEV4YW1wbGUgOiBHaXZlbiB0aGUgb3B0aW9uIHsgZGl2aXNvcldoZW5VbmZvY3VzZWQ6IDEwMDAgfSAob3IgZGlyZWN0bHkgaW4gdGhlIGh0bWwgYDxpbnB1dCBkYXRhLWRpdmlzb3Itd2hlbi11bmZvY3VzZWQ9XCIxMDAwXCI+YClcbiAgICAgICAgICAgICAqIFRoZSBkaXZpc29yIHZhbHVlIGRvZXMgbm90IG5lZWQgdG8gYmUgYW4gaW50ZWdlciwgYnV0IHBsZWFzZSB1bmRlcnN0YW5kIHRoYXQgSmF2YXNjcmlwdCBoYXMgbGltaXRlZCBhY2N1cmFjeSBpbiBtYXRoIDsgdXNlIHdpdGggY2F1dGlvbi5cbiAgICAgICAgICAgICAqIE5vdGU6IFRoZSBgZ2V0TnVtZXJpY1N0cmluZ2AgbWV0aG9kIHJldHVybnMgdGhlIGZ1bGwgdmFsdWUsIGluY2x1ZGluZyB0aGUgJ2hpZGRlbicgZGVjaW1hbHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRpdmlzb3JXaGVuVW5mb2N1c2VkOiB7XG4gICAgICAgICAgICAgICAgbm9uZSAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICBwZXJjZW50YWdlOiAxMDAsXG4gICAgICAgICAgICAgICAgcGVybWlsbGUgIDogMTAwMCxcbiAgICAgICAgICAgICAgICBiYXNpc1BvaW50OiAxMDAwMCxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qIERlZmluZXMgd2hhdCBzaG91bGQgYmUgZGlzcGxheWVkIGluIHRoZSBlbGVtZW50IGlmIHRoZSByYXcgdmFsdWUgaXMgYW4gZW1wdHkgc3RyaW5nICgnJykuXG4gICAgICAgICAgICAgKiAtICdmb2N1cycgIDogVGhlIGN1cnJlbmN5IHNpZ24gaXMgZGlzcGxheWVkIHdoZW4gdGhlIGlucHV0IHJlY2VpdmVzIGZvY3VzIChkZWZhdWx0KVxuICAgICAgICAgICAgICogLSAncHJlc3MnICA6IFRoZSBjdXJyZW5jeSBzaWduIGlzIGRpc3BsYXllZCB3aGVuZXZlciBhIGtleSBpcyBiZWluZyBwcmVzc2VkXG4gICAgICAgICAgICAgKiAtICdhbHdheXMnIDogVGhlIGN1cnJlbmN5IHNpZ24gaXMgYWx3YXlzIGRpc3BsYXllZFxuICAgICAgICAgICAgICogLSAnemVybycgICA6IEEgemVybyBpcyBkaXNwbGF5ZWQgKCdyb3VuZGVkJyB3aXRoIG9yIHdpdGhvdXQgYSBjdXJyZW5jeSBzaWduKSBpZiB0aGUgaW5wdXQgaGFzIG5vIHZhbHVlIG9uIGZvY3VzIG91dFxuICAgICAgICAgICAgICogLSAnbnVsbCcgICA6IFdoZW4gdGhlIGVsZW1lbnQgaXMgZW1wdHksIHRoZSBgcmF3VmFsdWVgIGFuZCB0aGUgZWxlbWVudCB2YWx1ZS90ZXh0IGlzIHNldCB0byBgbnVsbGAuIFRoaXMgYWxzbyBhbGxvd3MgdG8gc2V0IHRoZSB2YWx1ZSB0byBgbnVsbGAgdXNpbmcgYGFuRWxlbWVudC5zZXQobnVsbClgLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlbXB0eUlucHV0QmVoYXZpb3I6IHtcbiAgICAgICAgICAgICAgICBudWxsICA6ICdudWxsJyxcbiAgICAgICAgICAgICAgICBmb2N1cyA6ICdmb2N1cycsXG4gICAgICAgICAgICAgICAgcHJlc3MgOiAncHJlc3MnLFxuICAgICAgICAgICAgICAgIGFsd2F5czogJ2Fsd2F5cycsXG4gICAgICAgICAgICAgICAgemVybyAgOiAnemVybycsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKiBUaGlzIG9wdGlvbiBpcyB0aGUgJ3N0cmljdCBtb2RlJyAoYWthICdkZWJ1ZycgbW9kZSksIHdoaWNoIGFsbG93cyBhdXRvTnVtZXJpYyB0byBzdHJpY3RseSBhbmFseXNlIHRoZSBvcHRpb25zIHBhc3NlZCwgYW5kIGZhaWxzIGlmIGFuIHVua25vd24gb3B0aW9ucyBpcyB1c2VkIGluIHRoZSBzZXR0aW5ncyBvYmplY3QuXG4gICAgICAgICAgICAgKiBZb3Ugc2hvdWxkIHNldCB0aGF0IHRvIGB0cnVlYCBpZiB5b3Ugd2FudCB0byBtYWtlIHN1cmUgeW91IGFyZSBvbmx5IHVzaW5nICdwdXJlJyBhdXRvTnVtZXJpYyBzZXR0aW5ncyBvYmplY3RzIGluIHlvdXIgY29kZS5cbiAgICAgICAgICAgICAqIElmIHlvdSBzZWUgdW5jYXVnaHQgZXJyb3JzIGluIHRoZSBjb25zb2xlIGFuZCB5b3VyIGNvZGUgc3RhcnRzIHRvIGZhaWwsIHRoaXMgbWVhbnMgc29tZWhvdyB0aG9zZSBvcHRpb25zIGdldHMgcG9sbHV0ZWQgYnkgYW5vdGhlciBwcm9ncmFtICh3aGljaCB1c3VhbGx5IGhhcHBlbnMgd2hlbiB1c2luZyBmcmFtZXdvcmtzKS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZmFpbE9uVW5rbm93bk9wdGlvbjoge1xuICAgICAgICAgICAgICAgIGZhaWwgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpZ25vcmU6IGZhbHNlLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyogRGV0ZXJtaW5lIGlmIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgZm9ybWF0dGVkIG9uIGluaXRpYWxpemF0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3JtYXRPblBhZ2VMb2FkOiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0ICAgICA6IHRydWUsIC8vIGF1dG9tYXRpY2FsbHkgZm9ybWF0cyB0aGUgZGVmYXVsdCB2YWx1ZSBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICAgICAgICAgIGRvTm90Rm9ybWF0OiBmYWxzZSwgLy8gd2lsbCBub3QgZm9ybWF0IHRoZSBkZWZhdWx0IHZhbHVlIG9uIGluaXRpYWxpemF0aW9uXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKiBTZXQgdGhlIHVuZG8vcmVkbyBoaXN0b3J5IHRhYmxlIHNpemUuXG4gICAgICAgICAgICAgKiBFYWNoIHJlY29yZCBrZWVwcyB0aGUgcmF3IHZhbHVlIGFzIHdlbGwgYW5kIHRoZSBsYXN0IGtub3duIGNhcmV0L3NlbGVjdGlvbiBwb3NpdGlvbnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGhpc3RvcnlTaXplOiB7XG4gICAgICAgICAgICAgICAgdmVyeVNtYWxsOiA1LFxuICAgICAgICAgICAgICAgIHNtYWxsICAgIDogMTAsXG4gICAgICAgICAgICAgICAgbWVkaXVtICAgOiAyMCxcbiAgICAgICAgICAgICAgICBsYXJnZSAgICA6IDUwLFxuICAgICAgICAgICAgICAgIHZlcnlMYXJnZTogMTAwLFxuICAgICAgICAgICAgICAgIGluc2FuZSAgIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKiBBbGxvdyB0aGUgdXNlciB0byAnY2FuY2VsJyBhbmQgdW5kbyB0aGUgY2hhbmdlcyBoZSBtYWRlIHRvIHRoZSBnaXZlbiBhdXRvbnVtZXJpYy1tYW5hZ2VkIGVsZW1lbnQsIGJ5IHByZXNzaW5nIHRoZSAnRXNjYXBlJyBrZXkuXG4gICAgICAgICAgICAgKiBXaGVuZXZlciB0aGUgdXNlciAndmFsaWRhdGUnIHRoZSBpbnB1dCAoZWl0aGVyIGJ5IGhpdHRpbmcgJ0VudGVyJywgb3IgYmx1cnJpbmcgdGhlIGVsZW1lbnQpLCB0aGUgbmV3IHZhbHVlIGlzIHNhdmVkIGZvciBzdWJzZXF1ZW50ICdjYW5jZWxsYXRpb24nLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRoZSBwcm9jZXNzIDpcbiAgICAgICAgICAgICAqICAgLSBzYXZlIHRoZSBpbnB1dCB2YWx1ZSBvbiBmb2N1c1xuICAgICAgICAgICAgICogICAtIGlmIHRoZSB1c2VyIGNoYW5nZSB0aGUgaW5wdXQgdmFsdWUsIGFuZCBoaXQgYEVzY2FwZWAsIHRoZW4gdGhlIGluaXRpYWwgdmFsdWUgc2F2ZWQgb24gZm9jdXMgaXMgc2V0IGJhY2tcbiAgICAgICAgICAgICAqICAgLSBvbiB0aGUgb3RoZXIgaGFuZCBpZiB0aGUgdXNlciBlaXRoZXIgaGF2ZSB1c2VkIGBFbnRlcmAgdG8gdmFsaWRhdGUgKGBFbnRlcmAgdGhyb3dzIGEgY2hhbmdlIGV2ZW50KSBoaXMgZW50cmllcywgb3IgaWYgdGhlIGlucHV0IHZhbHVlIGhhcyBiZWVuIGNoYW5nZWQgYnkgYW5vdGhlciBzY3JpcHQgaW4gdGhlIG1lYW4gdGltZSwgdGhlbiB3ZSBzYXZlIHRoZSBuZXcgaW5wdXQgdmFsdWVcbiAgICAgICAgICAgICAqICAgLSBvbiBhIHN1Y2Nlc3NmdWwgJ2NhbmNlbCcsIHNlbGVjdCB0aGUgd2hvbGUgdmFsdWUgKHdoaWxlIHJlc3BlY3RpbmcgdGhlIGBzZWxlY3ROdW1iZXJPbmx5YCBvcHRpb24pXG4gICAgICAgICAgICAgKiAgIC0gYm9udXM7IGlmIHRoZSB2YWx1ZSBoYXMgbm90IGNoYW5nZWQsIGhpdHRpbmcgJ0VzYycganVzdCBzZWxlY3QgYWxsIHRoZSBpbnB1dCB2YWx1ZSAod2hpbGUgcmVzcGVjdGluZyB0aGUgYHNlbGVjdE51bWJlck9ubHlgIG9wdGlvbilcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaXNDYW5jZWxsYWJsZToge1xuICAgICAgICAgICAgICAgIGNhbmNlbGxhYmxlICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgIG5vdENhbmNlbGxhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qIENvbnRyb2xzIHRoZSBsZWFkaW5nIHplcm8gYmVoYXZpb3JcbiAgICAgICAgICAgICAqIC0gJ2FsbG93JyA6IGFsbG93cyBsZWFkaW5nIHplcm9zIHRvIGJlIGVudGVyZWQuIFplcm9zIHdpbGwgYmUgdHJ1bmNhdGVkIHdoZW4gZW50ZXJpbmcgYWRkaXRpb25hbCBkaWdpdHMuIE9uIGZvY3Vzb3V0IHplcm9zIHdpbGwgYmUgZGVsZXRlZFxuICAgICAgICAgICAgICogLSAnZGVueScgIDogYWxsb3dzIG9ubHkgb25lIGxlYWRpbmcgemVybyBvbiB2YWx1ZXMgdGhhdCBhcmUgYmV0d2VlbiAxIGFuZCAtMVxuICAgICAgICAgICAgICogLSAna2VlcCcgIDogYWxsb3dzIGxlYWRpbmcgemVyb3MgdG8gYmUgZW50ZXJlZC4gb24gZm9jdXNvdXQgemVyb3Mgd2lsbCBiZSByZXRhaW5lZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZWFkaW5nWmVybzoge1xuICAgICAgICAgICAgICAgIGFsbG93OiAnYWxsb3cnLFxuICAgICAgICAgICAgICAgIGRlbnkgOiAnZGVueScsXG4gICAgICAgICAgICAgICAga2VlcCA6ICdrZWVwJyxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qIERlZmluZXMgdGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUgYSB1c2VyIGNhbiBlbnRlci5cbiAgICAgICAgICAgICAqIE5vdGVzOlxuICAgICAgICAgICAgICogLSB0aGlzIHZhbHVlIG11c3QgYSBzdHJpbmcgYW5kIHVzZSB0aGUgcGVyaW9kIGZvciB0aGUgZGVjaW1hbCBwb2ludFxuICAgICAgICAgICAgICogLSB0aGlzIHZhbHVlIG5lZWRzIHRvIGJlIGxhcmdlciB0aGFuIGBtaW5pbXVtVmFsdWVgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG1heGltdW1WYWx1ZToge1xuICAgICAgICAgICAgICAgIHRlblRyaWxsaW9ucyAgICAgICAgICA6ICc5OTk5OTk5OTk5OTk5Ljk5JywgLy8gOS45OTkuOTk5Ljk5OS45OTksOTkgfj0gMTAwMDAgYmlsbGlvbnNcbiAgICAgICAgICAgICAgICB0ZW5UcmlsbGlvbnNOb0RlY2ltYWxzOiAnOTk5OTk5OTk5OTk5OScsIC8vRklYTUUgVXBkYXRlIGFsbCB0aG9zZSBsaW1pdHMgdG8gdGhlICdyZWFsJyBudW1iZXJzXG4gICAgICAgICAgICAgICAgb25lQmlsbGlvbiAgICAgICAgICAgIDogJzk5OTk5OTk5OS45OScsXG4gICAgICAgICAgICAgICAgemVybyAgICAgICAgICAgICAgICAgIDogJzAnLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyogRGVmaW5lcyB0aGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZSBhIHVzZXIgY2FuIGVudGVyLlxuICAgICAgICAgICAgICogTm90ZXM6XG4gICAgICAgICAgICAgKiAtIHRoaXMgdmFsdWUgbXVzdCBhIHN0cmluZyBhbmQgdXNlIHRoZSBwZXJpb2QgZm9yIHRoZSBkZWNpbWFsIHBvaW50XG4gICAgICAgICAgICAgKiAtIHRoaXMgdmFsdWUgbmVlZHMgdG8gYmUgc21hbGxlciB0aGFuIGBtYXhpbXVtVmFsdWVgXG4gICAgICAgICAgICAgKiAtIGlmIHRoaXMgaXMgc3VwZXJpb3IgdG8gMCwgdGhlbiB5b3UnbGwgZWZmZWN0aXZlbHkgcHJldmVudCB5b3VyIHVzZXIgdG8gZW50aXJlbHkgZGVsZXRlIHRoZSBjb250ZW50IG9mIHlvdXIgZWxlbWVudFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtaW5pbXVtVmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0ZW5UcmlsbGlvbnMgICAgICAgICAgOiAnLTk5OTk5OTk5OTk5OTkuOTknLCAvLyAtOS45OTkuOTk5Ljk5OS45OTksOTkgfj0gMTAwMDAgYmlsbGlvbnNcbiAgICAgICAgICAgICAgICB0ZW5UcmlsbGlvbnNOb0RlY2ltYWxzOiAnLTk5OTk5OTk5OTk5OTknLFxuICAgICAgICAgICAgICAgIG9uZUJpbGxpb24gICAgICAgICAgICA6ICctOTk5OTk5OTk5Ljk5JyxcbiAgICAgICAgICAgICAgICB6ZXJvICAgICAgICAgICAgICAgICAgOiAnMCcsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKiBBbGxvdyB0aGUgdXNlciB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IHRoZSBlbGVtZW50IHZhbHVlIHdpdGggdGhlIG1vdXNlIHdoZWVsLlxuICAgICAgICAgICAgICogVGhlIHdoZWVsIGJlaGF2aW9yIGNhbiBieSBtb2RpZmllZCBieSB0aGUgYHdoZWVsU3RlcGAgb3B0aW9uLlxuICAgICAgICAgICAgICogVGhpcyBgd2hlZWxTdGVwYCBvcHRpb25zIGNhbiBiZSB1c2VkIGluIHR3byB3YXlzLCBlaXRoZXIgYnkgc2V0dGluZyA6XG4gICAgICAgICAgICAgKiAtIGEgJ2ZpeGVkJyBzdGVwIHZhbHVlIChgd2hlZWxTdGVwIDogMTAwMGApLCBvclxuICAgICAgICAgICAgICogLSB0aGUgJ3Byb2dyZXNzaXZlJyBzdHJpbmcgKGB3aGVlbFN0ZXAgOiAncHJvZ3Jlc3NpdmUnYCksIHdoaWNoIHdpbGwgdGhlbiBhY3RpdmF0ZSBhIHNwZWNpYWwgbW9kZSB3aGVyZSB0aGUgc3RlcCBpcyBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIGVsZW1lbnQgdmFsdWUgc2l6ZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBOb3RlIDpcbiAgICAgICAgICAgICAqIEEgc3BlY2lhbCBiZWhhdmlvciBpcyBhcHBsaWVkIGluIG9yZGVyIHRvIGF2b2lkIHByZXZlbnRpbmcgdGhlIHVzZXIgdG8gc2Nyb2xsIHRoZSBwYWdlIGlmIHRoZSBpbnB1dHMgYXJlIGNvdmVyaW5nIHRoZSB3aG9sZSBhdmFpbGFibGUgc3BhY2UuXG4gICAgICAgICAgICAgKiBZb3UgY2FuIHVzZSB0aGUgJ1NoaWZ0JyBtb2RpZmllciBrZXkgd2hpbGUgdXNpbmcgdGhlIG1vdXNlIHdoZWVsIGluIG9yZGVyIHRvIHRlbXBvcmFyaWx5IGRpc2FibGUgdGhlIGluY3JlbWVudC9kZWNyZW1lbnQgZmVhdHVyZSAodXNlZnVsIG9uIHNtYWxsIHNjcmVlbiB3aGVyZSBzb21lIGJhZGx5IGNvbmZpZ3VyZWQgaW5wdXRzIGNvdWxkIHVzZSBhbGwgdGhlIGF2YWlsYWJsZSBzcGFjZSkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG1vZGlmeVZhbHVlT25XaGVlbDoge1xuICAgICAgICAgICAgICAgIG1vZGlmeVZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRvTm90aGluZyAgOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qIEFkZHMgYnJhY2tldHMgb24gbmVnYXRpdmUgdmFsdWVzIChpZS4gdHJhbnNmb3JtcyAnLSQgOTk5Ljk5JyB0byAnKDk5OS45OSknKVxuICAgICAgICAgICAgICogVGhvc2UgYnJhY2tldHMgYXJlIHZpc2libGUgb25seSB3aGVuIHRoZSBmaWVsZCBkb2VzIE5PVCBoYXZlIHRoZSBmb2N1cy5cbiAgICAgICAgICAgICAqIFRoZSBsZWZ0IGFuZCByaWdodCBzeW1ib2xzIHNob3VsZCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgYW5kIHNlcGFyYXRlZCBieSBhIGNvbW1hLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cjoge1xuICAgICAgICAgICAgICAgIHBhcmVudGhlc2VzICAgICAgICAgICA6ICcoLCknLFxuICAgICAgICAgICAgICAgIGJyYWNrZXRzICAgICAgICAgICAgICA6ICdbLF0nLFxuICAgICAgICAgICAgICAgIGNoZXZyb25zICAgICAgICAgICAgICA6ICc8LD4nLFxuICAgICAgICAgICAgICAgIGN1cmx5QnJhY2VzICAgICAgICAgICA6ICd7LH0nLFxuICAgICAgICAgICAgICAgIGFuZ2xlQnJhY2tldHMgICAgICAgICA6ICfjgIgs44CJJyxcbiAgICAgICAgICAgICAgICBqYXBhbmVzZVF1b3RhdGlvbk1hcmtzOiAn772iLO+9oycsXG4gICAgICAgICAgICAgICAgaGFsZkJyYWNrZXRzICAgICAgICAgIDogJ+K4pCziuKUnLFxuICAgICAgICAgICAgICAgIHdoaXRlU3F1YXJlQnJhY2tldHMgICA6ICfin6Ys4p+nJyxcbiAgICAgICAgICAgICAgICBxdW90YXRpb25NYXJrcyAgICAgICAgOiAn4oC5LOKAuicsXG4gICAgICAgICAgICAgICAgZ3VpbGxlbWV0cyAgICAgICAgICAgIDogJ8KrLMK7JyxcbiAgICAgICAgICAgICAgICBub25lICAgICAgICAgICAgICAgICAgOiBudWxsLCAvLyBUaGlzIGlzIHRoZSBkZWZhdWx0IHZhbHVlLCB3aGljaCBkZWFjdGl2YXRlIHRoaXMgZmVhdHVyZVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyogUGxhY2VtZW50IG9mIHRoZSBuZWdhdGl2ZS9wb3NpdGl2ZSBzaWduIHJlbGF0aXZlIHRvIHRoZSBgY3VycmVuY3lTeW1ib2xgIG9wdGlvbi5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBFeGFtcGxlOlxuICAgICAgICAgICAgICogLTEsMjM0LjU2ICA9PiBkZWZhdWx0IG5vIG9wdGlvbnMgcmVxdWlyZWRcbiAgICAgICAgICAgICAqIC0kMSwyMzQuNTYgPT4ge2N1cnJlbmN5U3ltYm9sOiBcIiRcIn0gb3Ige2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwibFwifVxuICAgICAgICAgICAgICogJC0xLDIzNC41NiA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJyXCJ9IC8vIERlZmF1bHQgaWYgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgaXMgJ251bGwnIGFuZCBjdXJyZW5jeVN5bWJvbCBpcyBub3QgZW1wdHlcbiAgICAgICAgICAgICAqIC0xLDIzNC41NiQgPT4ge2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6IFwic1wiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJwXCJ9IC8vIERlZmF1bHQgaWYgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgaXMgJ251bGwnIGFuZCBjdXJyZW5jeVN5bWJvbCBpcyBub3QgZW1wdHlcbiAgICAgICAgICAgICAqIDEsMjM0LjU2LSAgPT4ge25lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInNcIn1cbiAgICAgICAgICAgICAqICQxLDIzNC41Ni0gPT4ge2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwic1wifVxuICAgICAgICAgICAgICogMSwyMzQuNTYtJCA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCJ9XG4gICAgICAgICAgICAgKiAxLDIzNC41NiQtID0+IHtjdXJyZW5jeVN5bWJvbDogXCIkXCIsIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiBcInNcIiwgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwiclwifVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDoge1xuICAgICAgICAgICAgICAgIHByZWZpeDogJ3AnLFxuICAgICAgICAgICAgICAgIHN1ZmZpeDogJ3MnLFxuICAgICAgICAgICAgICAgIGxlZnQgIDogJ2wnLFxuICAgICAgICAgICAgICAgIHJpZ2h0IDogJ3InLFxuICAgICAgICAgICAgICAgIG5vbmUgIDogbnVsbCxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qIERlZmluZXMgaWYgdGhlIGVsZW1lbnQgc2hvdWxkIGhhdmUgZXZlbnQgbGlzdGVuZXJzIGFjdGl2YXRlZCBvbiBpdC5cbiAgICAgICAgICAgICAqIEJ5IGRlZmF1bHQsIHRob3NlIGV2ZW50IGxpc3RlbmVycyBhcmUgb25seSBhZGRlZCB0byA8aW5wdXQ+IGVsZW1lbnRzIGFuZCBodG1sIGVsZW1lbnQgd2l0aCB0aGUgYGNvbnRlbnRlZGl0YWJsZWAgYXR0cmlidXRlIHNldCB0byBgdHJ1ZWAsIGJ1dCBub3Qgb24gdGhlIG90aGVyIGh0bWwgdGFncy5cbiAgICAgICAgICAgICAqIFRoaXMgYWxsb3dzIHRvIGluaXRpYWxpemUgZWxlbWVudHMgd2l0aG91dCBhbnkgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgICAgICAgICogV2FybmluZzogU2luY2UgQXV0b051bWVyaWMgd2lsbCBub3QgY2hlY2sgdGhlIGlucHV0IGNvbnRlbnQgYWZ0ZXIgaXRzIGluaXRpYWxpemF0aW9uLCB1c2luZyBzb21lIGF1dG9OdW1lcmljIG1ldGhvZHMgYWZ0ZXJ3YXJkcyAqd2lsbCogcHJvYmFibHkgbGVhZHMgdG8gZm9ybWF0dGluZyBwcm9ibGVtcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbm9FdmVudExpc3RlbmVyczoge1xuICAgICAgICAgICAgICAgIG5vRXZlbnRzIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhZGRFdmVudHM6IGZhbHNlLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyogTWFuYWdlIGhvdyBhdXRvTnVtZXJpYyByZWFjdCB3aGVuIHRoZSB1c2VyIHRyaWVzIHRvIHBhc3RlIGFuIGludmFsaWQgbnVtYmVyLlxuICAgICAgICAgICAgICogLSAnZXJyb3InICAgIDogKFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IpIFRoZSBpbnB1dCB2YWx1ZSBpcyBub3QgY2hhbmdlZCBhbmQgYW4gZXJyb3IgaXMgb3V0cHV0IGluIHRoZSBjb25zb2xlLlxuICAgICAgICAgICAgICogLSAnaWdub3JlJyAgIDogaWRlbSB0aGFuICdlcnJvcicsIGJ1dCBmYWlsIHNpbGVudGx5IHdpdGhvdXQgb3V0cHV0dGluZyBhbnkgZXJyb3Ivd2FybmluZyBpbiB0aGUgY29uc29sZS5cbiAgICAgICAgICAgICAqIC0gJ2NsYW1wJyAgICA6IGlmIHRoZSBwYXN0ZWQgdmFsdWUgaXMgZWl0aGVyIHRvbyBzbWFsbCBvciB0b28gYmlnIHJlZ2FyZGluZyB0aGUgbWluaW11bVZhbHVlIGFuZCBtYXhpbXVtVmFsdWUgcmFuZ2UsIHRoZW4gdGhlIHJlc3VsdCBpcyBjbGFtcGVkIHRvIHRob3NlIGxpbWl0cy5cbiAgICAgICAgICAgICAqIC0gJ3RydW5jYXRlJyA6IGF1dG9OdW1lcmljIHdpbGwgaW5zZXJ0IGFzIG1hbnkgcGFzdGVkIG51bWJlcnMgaXQgY2FuIGF0IHRoZSBpbml0aWFsIGNhcmV0L3NlbGVjdGlvbiwgdW50aWwgZXZlcnl0aGluZyBpcyBwYXN0ZWQsIG9yIHRoZSByYW5nZSBsaW1pdCBpcyBoaXQuXG4gICAgICAgICAgICAgKiAgICAgICAgICAgICAgICBUaGUgbm9uLXBhc3RlZCBudW1iZXJzIGFyZSBkcm9wcGVkIGFuZCB0aGVyZWZvcmUgbm90IHVzZWQgYXQgYWxsLlxuICAgICAgICAgICAgICogLSAncmVwbGFjZScgIDogYXV0b051bWVyaWMgd2lsbCBmaXJzdCBpbnNlcnQgYXMgbWFueSBwYXN0ZWQgbnVtYmVycyBpdCBjYW4gYXQgdGhlIGluaXRpYWwgY2FyZXQvc2VsZWN0aW9uLCB0aGVuIGlmIHRoZSByYW5nZSBsaW1pdCBpcyBoaXQsIGl0IHdpbGwgdHJ5XG4gICAgICAgICAgICAgKiAgICAgICAgICAgICAgICB0byByZXBsYWNlIG9uZSBieSBvbmUgdGhlIHJlbWFpbmluZyBpbml0aWFsIG51bWJlcnMgKG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBjYXJldCkgd2l0aCB0aGUgcmVzdCBvZiB0aGUgcGFzdGVkIG51bWJlcnMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogTm90ZSAxIDogQSBwYXN0ZSBjb250ZW50IHN0YXJ0aW5nIHdpdGggYSBuZWdhdGl2ZSBzaWduICctJyB3aWxsIGJlIGFjY2VwdGVkIGFueXdoZXJlIGluIHRoZSBpbnB1dCwgYW5kIHdpbGwgc2V0IHRoZSByZXN1bHRpbmcgdmFsdWUgYXMgYSBuZWdhdGl2ZSBudW1iZXJcbiAgICAgICAgICAgICAqIE5vdGUgMiA6IEEgcGFzdGUgY29udGVudCBzdGFydGluZyB3aXRoIGEgbnVtYmVyIHdpbGwgYmUgYWNjZXB0ZWQsIGV2ZW4gaWYgdGhlIHJlc3QgaXMgZ2liYmVyaXNoIChpZS4gJzEyM2Zvb2JhcjQ1NicpLlxuICAgICAgICAgICAgICogICAgICAgICAgT25seSB0aGUgZmlyc3QgbnVtYmVyIHdpbGwgYmUgdXNlZCAoaGVyZSAnMTIzJykuXG4gICAgICAgICAgICAgKiBOb3RlIDMgOiBUaGUgcGFzdGUgZXZlbnQgd29ya3Mgd2l0aCB0aGUgYGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXNgIG9wdGlvbiB0b28uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9uSW52YWxpZFBhc3RlOiB7XG4gICAgICAgICAgICAgICAgZXJyb3IgICA6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgaWdub3JlICA6ICdpZ25vcmUnLFxuICAgICAgICAgICAgICAgIGNsYW1wICAgOiAnY2xhbXAnLFxuICAgICAgICAgICAgICAgIHRydW5jYXRlOiAndHJ1bmNhdGUnLFxuICAgICAgICAgICAgICAgIHJlcGxhY2UgOiAncmVwbGFjZScsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKiBEZWZpbmVzIGhvdyB0aGUgdmFsdWUgc2hvdWxkIGJlIGZvcm1hdHRlZCB3aGVuIHdhbnRpbmcgYSAnbG9jYWxpemVkJyB2ZXJzaW9uIG9mIGl0LlxuICAgICAgICAgICAgICogLSBudWxsIG9yICdzdHJpbmcnID0+ICdubm5uLm5uJyBvciAnLW5ubm4ubm4nIGFzIHRleHQgdHlwZS4gVGhpcyBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvci5cbiAgICAgICAgICAgICAqIC0gJ251bWJlcicgICAgICAgICA9PiBubm5uLm5uIG9yIC1ubm5uLm5uIGFzIGEgTnVtYmVyIChXYXJuaW5nOiB0aGlzIHdvcmtzIG9ubHkgZm9yIGludGVnZXJzIGluZmVyaW9yIHRvIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKVxuICAgICAgICAgICAgICogLSAnLCcgb3IgJy0sJyAgICAgID0+ICdubm5uLG5uJyBvciAnLW5ubm4sbm4nXG4gICAgICAgICAgICAgKiAtICcuLScgICAgICAgICAgICAgPT4gJ25ubm4ubm4nIG9yICdubm5uLm5uLSdcbiAgICAgICAgICAgICAqIC0gJywtJyAgICAgICAgICAgICA9PiAnbm5ubixubicgb3IgJ25ubm4sbm4tJ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXQ6IHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgICAgICAgOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICBudW1iZXIgICAgICAgOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICBkb3QgICAgICAgICAgOiAnLicsXG4gICAgICAgICAgICAgICAgbmVnYXRpdmVEb3QgIDogJy0uJyxcbiAgICAgICAgICAgICAgICBjb21tYSAgICAgICAgOiAnLCcsXG4gICAgICAgICAgICAgICAgbmVnYXRpdmVDb21tYTogJy0sJyxcbiAgICAgICAgICAgICAgICBkb3ROZWdhdGl2ZSAgOiAnLi0nLFxuICAgICAgICAgICAgICAgIGNvbW1hTmVnYXRpdmU6ICcsLScsXG4gICAgICAgICAgICAgICAgbm9uZSAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qIE92ZXJyaWRlIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGxpbWl0c1xuICAgICAgICAgICAgICogb3ZlcnJpZGVNaW5NYXhMaW1pdHM6IFwiY2VpbGluZ1wiIGFkaGVyZXMgdG8gbWF4aW11bVZhbHVlIGFuZCBpZ25vcmVzIG1pbmltdW1WYWx1ZSBzZXR0aW5nc1xuICAgICAgICAgICAgICogb3ZlcnJpZGVNaW5NYXhMaW1pdHM6IFwiZmxvb3JcIiBhZGhlcmVzIHRvIG1pbmltdW1WYWx1ZSBhbmQgaWdub3JlcyBtYXhpbXVtVmFsdWUgc2V0dGluZ3NcbiAgICAgICAgICAgICAqIG92ZXJyaWRlTWluTWF4TGltaXRzOiBcImlnbm9yZVwiIGlnbm9yZXMgYm90aCBtaW5pbXVtVmFsdWUgJiBtYXhpbXVtVmFsdWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb3ZlcnJpZGVNaW5NYXhMaW1pdHM6IHtcbiAgICAgICAgICAgICAgICBjZWlsaW5nICAgICAgOiAnY2VpbGluZycsXG4gICAgICAgICAgICAgICAgZmxvb3IgICAgICAgIDogJ2Zsb29yJyxcbiAgICAgICAgICAgICAgICBpZ25vcmUgICAgICAgOiAnaWdub3JlJyxcbiAgICAgICAgICAgICAgICBkb05vdE92ZXJyaWRlOiBudWxsLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyogVGhlIGByYXdWYWx1ZURpdmlzb3JgIGRpdmlkZXMgdGhlIGZvcm1hdHRlZCB2YWx1ZSBzaG93biBpbiB0aGUgQXV0b051bWVyaWMgZWxlbWVudCBhbmQgc3RvcmUgdGhlIHJlc3VsdCBpbiBgcmF3VmFsdWVgLlxuICAgICAgICAgICAgICogQGV4YW1wbGUgeyByYXdWYWx1ZURpdmlzb3I6ICcxMDAnIH0gb3IgPGlucHV0IGRhdGEtcmF3LXZhbHVlLWRpdmlzb3I9XCIxMDBcIj5cbiAgICAgICAgICAgICAqIEdpdmVuIHRoZSBgMC4wMTIzNGAgcmF3IHZhbHVlLCB0aGUgZm9ybWF0dGVkIHZhbHVlIHdpbGwgYmUgZGlzcGxheWVkIGFzIGAnMS4yMzQnYC5cbiAgICAgICAgICAgICAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gZGlzcGxheWluZyBwZXJjZW50YWdlIGZvciBpbnN0YW5jZSwgYW5kIGF2b2lkIHRoZSBuZWVkIHRvIGRpdmlkZS9tdWx0aXBseSBieSAxMDAgYmV0d2VlbiB0aGUgbnVtYmVyIHNob3duIGFuZCB0aGUgcmF3IHZhbHVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByYXdWYWx1ZURpdmlzb3I6IHtcbiAgICAgICAgICAgICAgICBub25lICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIHBlcmNlbnRhZ2U6IDEwMCxcbiAgICAgICAgICAgICAgICBwZXJtaWxsZSAgOiAxMDAwLFxuICAgICAgICAgICAgICAgIGJhc2lzUG9pbnQ6IDEwMDAwLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyogRGVmaW5lcyBpZiB0aGUgPGlucHV0PiBlbGVtZW50IHNob3VsZCBiZSBzZXQgYXMgcmVhZCBvbmx5IG9uIGluaXRpYWxpemF0aW9uLlxuICAgICAgICAgICAgICogV2hlbiBzZXQgdG8gYHRydWVgLCB0aGVuIHRoZSBgcmVhZG9ubHlgIGh0bWwgcHJvcGVydHkgaXMgYWRkZWQgdG8gdGhlIDxpbnB1dD4gZWxlbWVudCBvbiBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVhZE9ubHk6IHtcbiAgICAgICAgICAgICAgICByZWFkT25seSA6IHRydWUsXG4gICAgICAgICAgICAgICAgcmVhZFdyaXRlOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qIERlZmluZXMgdGhlIHJvdW5kaW5nIG1ldGhvZCB0byB1c2UuXG4gICAgICAgICAgICAgKiByb3VuZGluZ01ldGhvZDogXCJTXCIsIFJvdW5kLUhhbGYtVXAgU3ltbWV0cmljIChkZWZhdWx0KVxuICAgICAgICAgICAgICogcm91bmRpbmdNZXRob2Q6IFwiQVwiLCBSb3VuZC1IYWxmLVVwIEFzeW1tZXRyaWNcbiAgICAgICAgICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcInNcIiwgUm91bmQtSGFsZi1Eb3duIFN5bW1ldHJpYyAobG93ZXIgY2FzZSBzKVxuICAgICAgICAgICAgICogcm91bmRpbmdNZXRob2Q6IFwiYVwiLCBSb3VuZC1IYWxmLURvd24gQXN5bW1ldHJpYyAobG93ZXIgY2FzZSBhKVxuICAgICAgICAgICAgICogcm91bmRpbmdNZXRob2Q6IFwiQlwiLCBSb3VuZC1IYWxmLUV2ZW4gXCJCYW5rZXJzIFJvdW5kaW5nXCJcbiAgICAgICAgICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIlVcIiwgUm91bmQgVXAgXCJSb3VuZC1Bd2F5LUZyb20tWmVyb1wiXG4gICAgICAgICAgICAgKiByb3VuZGluZ01ldGhvZDogXCJEXCIsIFJvdW5kIERvd24gXCJSb3VuZC1Ub3dhcmQtWmVyb1wiIC0gc2FtZSBhcyB0cnVuY2F0ZVxuICAgICAgICAgICAgICogcm91bmRpbmdNZXRob2Q6IFwiQ1wiLCBSb3VuZCB0byBDZWlsaW5nIFwiVG93YXJkIFBvc2l0aXZlIEluZmluaXR5XCJcbiAgICAgICAgICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIkZcIiwgUm91bmQgdG8gRmxvb3IgXCJUb3dhcmQgTmVnYXRpdmUgSW5maW5pdHlcIlxuICAgICAgICAgICAgICogcm91bmRpbmdNZXRob2Q6IFwiTjA1XCIgUm91bmRzIHRvIHRoZSBuZWFyZXN0IC4wNSA9PiBzYW1lIGFzIFwiQ0hGXCIgdXNlZCBpbiAxLjlYIGFuZCBzdGlsbCB2YWxpZFxuICAgICAgICAgICAgICogcm91bmRpbmdNZXRob2Q6IFwiVTA1XCIgUm91bmRzIHVwIHRvIG5leHQgLjA1XG4gICAgICAgICAgICAgKiByb3VuZGluZ01ldGhvZDogXCJEMDVcIiBSb3VuZHMgZG93biB0byBuZXh0IC4wNVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByb3VuZGluZ01ldGhvZDoge1xuICAgICAgICAgICAgICAgIGhhbGZVcFN5bW1ldHJpYyAgICAgICAgICAgICAgICA6ICdTJyxcbiAgICAgICAgICAgICAgICBoYWxmVXBBc3ltbWV0cmljICAgICAgICAgICAgICAgOiAnQScsXG4gICAgICAgICAgICAgICAgaGFsZkRvd25TeW1tZXRyaWMgICAgICAgICAgICAgIDogJ3MnLFxuICAgICAgICAgICAgICAgIGhhbGZEb3duQXN5bW1ldHJpYyAgICAgICAgICAgICA6ICdhJyxcbiAgICAgICAgICAgICAgICBoYWxmRXZlbkJhbmtlcnNSb3VuZGluZyAgICAgICAgOiAnQicsXG4gICAgICAgICAgICAgICAgdXBSb3VuZEF3YXlGcm9tWmVybyAgICAgICAgICAgIDogJ1UnLFxuICAgICAgICAgICAgICAgIGRvd25Sb3VuZFRvd2FyZFplcm8gICAgICAgICAgICA6ICdEJyxcbiAgICAgICAgICAgICAgICB0b0NlaWxpbmdUb3dhcmRQb3NpdGl2ZUluZmluaXR5OiAnQycsXG4gICAgICAgICAgICAgICAgdG9GbG9vclRvd2FyZE5lZ2F0aXZlSW5maW5pdHkgIDogJ0YnLFxuICAgICAgICAgICAgICAgIHRvTmVhcmVzdDA1ICAgICAgICAgICAgICAgICAgICA6ICdOMDUnLFxuICAgICAgICAgICAgICAgIHRvTmVhcmVzdDA1QWx0ICAgICAgICAgICAgICAgICA6ICdDSEYnLFxuICAgICAgICAgICAgICAgIHVwVG9OZXh0MDUgICAgICAgICAgICAgICAgICAgICA6ICdVMDUnLFxuICAgICAgICAgICAgICAgIGRvd25Ub05leHQwNSAgICAgICAgICAgICAgICAgICA6ICdEMDUnLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyogU2V0IHRvIGB0cnVlYCB0byBhbGxvdyB0aGUgYGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXNgIHZhbHVlIHRvIGJlIHNhdmVkIHdpdGggc2Vzc2lvblN0b3JhZ2VcbiAgICAgICAgICAgICAqIElmIElFIDYgb3IgNyBpcyBkZXRlY3RlZCwgdGhlIHZhbHVlIHdpbGwgYmUgc2F2ZWQgYXMgYSBzZXNzaW9uIGNvb2tpZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZToge1xuICAgICAgICAgICAgICAgIHNhdmUgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkb05vdFNhdmU6IGZhbHNlLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyogRGV0ZXJtaW5lIGlmIHRoZSBzZWxlY3QgYWxsIGtleWJvYXJkIGNvbW1hbmQgd2lsbCBzZWxlY3QgdGhlIGNvbXBsZXRlIGlucHV0IHRleHQsIG9yIG9ubHkgdGhlIGlucHV0IG51bWVyaWMgdmFsdWVcbiAgICAgICAgICAgICAqIE5vdGUgOiBJZiB0aGUgY3VycmVuY3kgc3ltYm9sIGlzIGJldHdlZW4gdGhlIG51bWVyaWMgdmFsdWUgYW5kIHRoZSBuZWdhdGl2ZSBzaWduLCBvbmx5IHRoZSBudW1lcmljIHZhbHVlIHdpbGwgYmUgc2VsZWN0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2VsZWN0TnVtYmVyT25seToge1xuICAgICAgICAgICAgICAgIHNlbGVjdE51bWJlcnNPbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIHNlbGVjdEFsbCAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qIERlZmluZXMgaWYgdGhlIGVsZW1lbnQgdmFsdWUgc2hvdWxkIGJlIHNlbGVjdGVkIG9uIGZvY3VzLlxuICAgICAgICAgICAgICogTm90ZTogVGhlIHNlbGVjdGlvbiBpcyBkb25lIHVzaW5nIHRoZSBgc2VsZWN0TnVtYmVyT25seWAgb3B0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZWxlY3RPbkZvY3VzOiB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ICAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgZG9Ob3RTZWxlY3Q6IGZhbHNlLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyogRGVmaW5lcyBob3cgdGhlIHNlcmlhbGl6ZSBmdW5jdGlvbnMgc2hvdWxkIHRyZWF0IHRoZSBzcGFjZXMuXG4gICAgICAgICAgICAgKiBUaG9zZSBzcGFjZXMgJyAnIGNhbiBlaXRoZXIgYmUgY29udmVydGVkIHRvIHRoZSBwbHVzIHNpZ24gJysnLCB3aGljaCBpcyB0aGUgZGVmYXVsdCwgb3IgdG8gJyUyMCcuXG4gICAgICAgICAgICAgKiBCb3RoIHZhbHVlcyBiZWluZyB2YWxpZCBwZXIgdGhlIHNwZWMgKGh0dHA6Ly93d3cudzMub3JnL0FkZHJlc3NpbmcvVVJML3VyaS1zcGVjLmh0bWwpLlxuICAgICAgICAgICAgICogQWxzbyBzZWUgdGhlIHN1bW1lZCB1cCBhbnN3ZXIgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzM5MzkyODcuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogdGw7ZHIgOiBTcGFjZXMgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byAnJTIwJyBiZWZvcmUgdGhlICc/JyBzaWduLCB0aGVuIGNvbnZlcnRlZCB0byAnKycgYWZ0ZXIuXG4gICAgICAgICAgICAgKiBJbiBvdXIgY2FzZSBzaW5jZSB3ZSBzZXJpYWxpemUgdGhlIHF1ZXJ5LCB3ZSB1c2UgJysnIGFzIHRoZSBkZWZhdWx0IChidXQgYWxsb3cgdGhlIHVzZXIgdG8gZ2V0IGJhY2sgdGhlIG9sZCAqd3JvbmcqIGJlaGF2aW9yKS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2VyaWFsaXplU3BhY2VzOiB7XG4gICAgICAgICAgICAgICAgcGx1cyAgIDogJysnLFxuICAgICAgICAgICAgICAgIHBlcmNlbnQ6ICclMjAnLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyogRGVmaW5lcyBpZiB0aGUgZWxlbWVudCB2YWx1ZSBzaG91bGQgYmUgY29udmVydGVkIHRvIHRoZSByYXcgdmFsdWUgb24gZm9jdXMgKGFuZCBiYWNrIHRvIHRoZSBmb3JtYXR0ZWQgb24gYmx1cikuXG4gICAgICAgICAgICAgKiBJZiBzZXQgdG8gYHRydWVgLCB0aGVuIGF1dG9OdW1lcmljIHJlbW92ZSB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yLCBjdXJyZW5jeSBzeW1ib2wgYW5kIHN1ZmZpeCBvbiBmb2N1cy5cbiAgICAgICAgICAgICAqIEV4YW1wbGU6XG4gICAgICAgICAgICAgKiBJZiB0aGUgaW5wdXQgdmFsdWUgaXMgJyQgMSw5OTkuODggc3VmZml4Jywgb24gZm9jdXMgaXQgYmVjb21lcyAnMTk5OS44OCcgYW5kIGJhY2sgdG8gJyQgMSw5OTkuODggc3VmZml4JyBvbiBmb2N1cyBvdXQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNob3dPbmx5TnVtYmVyc09uRm9jdXM6IHtcbiAgICAgICAgICAgICAgICBvbmx5TnVtYmVyczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzaG93QWxsICAgIDogZmFsc2UsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKiBBbGxvdyB0aGUgcG9zaXRpdmUgc2lnbiBzeW1ib2wgYCtgIHRvIGJlIGRpc3BsYXllZCBmb3IgcG9zaXRpdmUgbnVtYmVycy5cbiAgICAgICAgICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgcG9zaXRpdmUgc2lnbiBpcyBub3Qgc2hvd24uXG4gICAgICAgICAgICAgKiBUaGUgc2lnbiBwbGFjZW1lbnQgaXMgY29udHJvbGxlZCBieSB0aGUgJ25lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50JyBvcHRpb24sIG1pbWlja2luZyB0aGUgbmVnYXRpdmUgc2lnbiBwbGFjZW1lbnQgcnVsZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNob3dQb3NpdGl2ZVNpZ246IHtcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgIGhpZGU6IGZhbHNlLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyogRGVmaW5lcyBpZiB3YXJuaW5ncyBzaG91bGQgYmUgc2hvd24gaW4gdGhlIGNvbnNvbGVcbiAgICAgICAgICAgICAqIFRob3NlIHdhcm5pbmdzIGNhbiBiZSBpZ25vcmVkLCBidXQgYXJlIHVzdWFsbHkgcHJpbnRlZCB3aGVuIHNvbWV0aGluZyBjb3VsZCBiZSBpbXByb3ZlZCBieSB0aGUgdXNlciAoaWUuIG9wdGlvbiBjb25mbGljdHMpLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzaG93V2FybmluZ3M6IHtcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlLCAvLyBBbGwgd2FybmluZyBhcmUgc2hvd25cbiAgICAgICAgICAgICAgICBoaWRlOiBmYWxzZSwgLy8gTm8gd2FybmluZ3MgYXJlIHNob3duLCBvbmx5IHRoZSB0aHJvd24gZXJyb3JzXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKiBEZWZpbmVzIHRoZSBydWxlcyB0aGF0IGNhbGN1bGF0ZSB0aGUgQ1NTIGNsYXNzKGVzKSB0byBhcHBseSBvbiB0aGUgZWxlbWVudCwgYmFzZWQgb24gdGhlIHJhdyB1bmZvcm1hdHRlZCB2YWx1ZS5cbiAgICAgICAgICAgICAqIFRoaXMgY2FuIGFsc28gYmUgdXNlZCB0byBjYWxsIGNhbGxiYWNrcyB3aGVuZXZlciB0aGUgYHJhd1ZhbHVlYCBpcyB1cGRhdGVkLlxuICAgICAgICAgICAgICogSW1wb3J0YW50OiBhbGwgY2FsbGJhY2tzIG11c3QgcmV0dXJuIGBudWxsYCBpZiBubyByYW5nZXMvdXNlckRlZmluZWQgY2xhc3NlcyBhcmUgc2VsZWN0ZWRcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiB7XG4gICAgICAgICAgICAgKiAgICAgcG9zaXRpdmUgICA6ICdhdXRvTnVtZXJpYy1wb3NpdGl2ZScsIC8vIE9yIGBudWxsYCB0byBub3QgdXNlIGl0XG4gICAgICAgICAgICAgKiAgICAgbmVnYXRpdmUgICA6ICdhdXRvTnVtZXJpYy1uZWdhdGl2ZScsXG4gICAgICAgICAgICAgKiAgICAgcmFuZ2VzICAgICA6IFtcbiAgICAgICAgICAgICAqICAgICAgICAgeyBtaW46IDAsIG1heDogMjUsIGNsYXNzOiAnYXV0b051bWVyaWMtcmVkJyB9LFxuICAgICAgICAgICAgICogICAgICAgICB7IG1pbjogMjUsIG1heDogNTAsIGNsYXNzOiAnYXV0b051bWVyaWMtb3JhbmdlJyB9LFxuICAgICAgICAgICAgICogICAgICAgICB7IG1pbjogNTAsIG1heDogNzUsIGNsYXNzOiAnYXV0b051bWVyaWMteWVsbG93JyB9LFxuICAgICAgICAgICAgICogICAgICAgICB7IG1pbjogNzUsIG1heDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIGNsYXNzOiAnYXV0b051bWVyaWMtZ3JlZW4nIH0sXG4gICAgICAgICAgICAgKiAgICAgXSxcbiAgICAgICAgICAgICAqICAgICB1c2VyRGVmaW5lZDogW1xuICAgICAgICAgICAgICogICAgICAgICAvLyBJZiAnY2xhc3NlcycgaXMgYSBzdHJpbmcsIHNldCBpdCBpZiBgdHJ1ZWAsIHJlbW92ZSBpdCBpZiBgZmFsc2VgXG4gICAgICAgICAgICAgKiAgICAgICAgIHsgY2FsbGJhY2s6IHJhd1ZhbHVlID0+IHsgcmV0dXJuIHRydWU7IH0sIGNsYXNzZXM6ICd0aGlzSXNUcnVlJyB9LFxuICAgICAgICAgICAgICogICAgICAgICAvLyBJZiAnY2xhc3NlcycgaXMgYW4gYXJyYXkgd2l0aCBvbmx5IDIgZWxlbWVudHMsIHNldCB0aGUgZmlyc3QgY2xhc3MgaWYgYHRydWVgLCB0aGUgc2Vjb25kIGlmIGBmYWxzZWBcbiAgICAgICAgICAgICAqICAgICAgICAgeyBjYWxsYmFjazogcmF3VmFsdWUgPT4gcmF3VmFsdWUgJSAyID09PSAwLCBjbGFzc2VzOiBbJ2F1dG9OdW1lcmljLWV2ZW4nLCAnYXV0b051bWVyaWMtb2RkJ10gfSxcbiAgICAgICAgICAgICAqICAgICAgICAgLy8gUmV0dXJuIG9ubHkgb25lIGluZGV4IHRvIHVzZSBvbiB0aGUgYGNsYXNzZXNgIGFycmF5IChoZXJlLCAnY2xhc3MzJylcbiAgICAgICAgICAgICAqICAgICAgICAgeyBjYWxsYmFjazogcmF3VmFsdWUgPT4geyByZXR1cm4gMjsgfSwgY2xhc3NlczogWydjbGFzczEnLCAnY2xhc3MyJywgJ2NsYXNzMyddIH0sXG4gICAgICAgICAgICAgKiAgICAgICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiBpbmRleGVzIHRvIHVzZSBvbiB0aGUgYGNsYXNzZXNgIGFycmF5IChoZXJlLCAnY2xhc3MxJyBhbmQgJ2NsYXNzMycpXG4gICAgICAgICAgICAgKiAgICAgICAgIHsgY2FsbGJhY2s6IHJhd1ZhbHVlID0+IHsgcmV0dXJuIFswLCAyXTsgfSwgY2xhc3NlczogWydjbGFzczEnLCAnY2xhc3MyJywgJ2NsYXNzMyddIH0sXG4gICAgICAgICAgICAgKiAgICAgICAgIC8vIElmICdjbGFzc2VzJyBpcyBgdW5kZWZpbmVkYCBvciBgbnVsbGAsIHRoZW4gdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIHRoZSBBdXRvTnVtZXJpYyBvYmplY3QgcGFzc2VkIGFzIGEgcGFyYW1ldGVyXG4gICAgICAgICAgICAgKiAgICAgICAgIHsgY2FsbGJhY2s6IGFuRWxlbWVudCA9PiB7IHJldHVybiBhbkVsZW1lbnQuZ2V0Rm9ybWF0dGVkKCk7IH0gfSxcbiAgICAgICAgICAgICAqICAgICBdLFxuICAgICAgICAgICAgICogfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzdHlsZVJ1bGVzOiB7XG4gICAgICAgICAgICAgICAgbm9uZSAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIHBvc2l0aXZlTmVnYXRpdmUgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGl2ZTogJ2F1dG9OdW1lcmljLXBvc2l0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgbmVnYXRpdmU6ICdhdXRvTnVtZXJpYy1uZWdhdGl2ZScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByYW5nZTBUbzEwMFdpdGg0U3RlcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG1pbjogMCwgbWF4OiAyNSwgY2xhc3M6ICdhdXRvTnVtZXJpYy1yZWQnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG1pbjogMjUsIG1heDogNTAsIGNsYXNzOiAnYXV0b051bWVyaWMtb3JhbmdlJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBtaW46IDUwLCBtYXg6IDc1LCBjbGFzczogJ2F1dG9OdW1lcmljLXllbGxvdycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbWluOiA3NSwgbWF4OiAxMDAsIGNsYXNzOiAnYXV0b051bWVyaWMtZ3JlZW4nIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBldmVuT2RkICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgdXNlckRlZmluZWQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgY2FsbGJhY2s6IHJhd1ZhbHVlID0+IHJhd1ZhbHVlICUgMiA9PT0gMCwgY2xhc3NlczogWydhdXRvTnVtZXJpYy1ldmVuJywgJ2F1dG9OdW1lcmljLW9kZCddIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByYW5nZVNtYWxsQW5kWmVybyAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgdXNlckRlZmluZWQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayAgOiByYXdWYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYXdWYWx1ZSA+PSAtMSAmJiByYXdWYWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOdW1iZXIocmF3VmFsdWUpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmF3VmFsdWUgPiAwICYmIHJhd1ZhbHVlIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7ICAvLyBJbiBjYXNlIHRoZSByYXdWYWx1ZSBpcyBvdXRzaWRlIHRob3NlIHJhbmdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dG9OdW1lcmljLXNtYWxsLW5lZ2F0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dG9OdW1lcmljLXplcm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYXV0b051bWVyaWMtc21hbGwtcG9zaXRpdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKiBBZGQgYSB0ZXh0IG9uIHRoZSByaWdodCBoYW5kIHNpZGUgb2YgdGhlIGVsZW1lbnQgdmFsdWUuXG4gICAgICAgICAgICAgKiBUaGlzIHN1ZmZpeCB0ZXh0IGNhbiBoYXZlIGFueSBjaGFyYWN0ZXJzIGluIGl0cyBzdHJpbmcsIGV4Y2VwdCBudW1lcmljIGNoYXJhY3RlcnMgYW5kIHRoZSBuZWdhdGl2ZS9wb3NpdGl2ZSBzaWduLlxuICAgICAgICAgICAgICogRXhhbXBsZTogJyBkb2xsYXJzJ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzdWZmaXhUZXh0OiB7XG4gICAgICAgICAgICAgICAgbm9uZSAgICAgIDogJycsXG4gICAgICAgICAgICAgICAgcGVyY2VudGFnZTogJyUnLFxuICAgICAgICAgICAgICAgIHBlcm1pbGxlICA6ICfigLAnLFxuICAgICAgICAgICAgICAgIGJhc2lzUG9pbnQ6ICfigLEnLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyogVGhlIHRocmVlIG9wdGlvbnMgKGRpdmlzb3JXaGVuVW5mb2N1c2VkLCBkZWNpbWFsUGxhY2VzU2hvd25PbkJsdXIgJiBzeW1ib2xXaGVuVW5mb2N1c2VkKSBoYW5kbGUgc2NhbGluZyBvZiB0aGUgaW5wdXQgd2hlbiB0aGUgaW5wdXQgZG9lcyBub3QgaGF2ZSBmb2N1c1xuICAgICAgICAgICAgICogUGxlYXNlIG5vdGUgdGhhdCB0aGUgbm9uLXNjYWxlZCB2YWx1ZSBpcyBoZWxkIGluIGRhdGEgYW5kIGl0IGlzIGFkdmlzZWQgdGhhdCB5b3UgdXNlIHRoZSBgc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZWAgb3B0aW9uIHRvIGVuc3VyZSByZXRhaW5pbmcgdGhlIHZhbHVlXG4gICAgICAgICAgICAgKiBbXCJkaXZpc29yXCIsIFwiZGVjaW1hbCBwbGFjZXNcIiwgXCJzeW1ib2xcIl1cbiAgICAgICAgICAgICAqIEV4YW1wbGU6IHdpdGggdGhlIGZvbGxvd2luZyBvcHRpb25zIHNldCB7ZGl2aXNvcldoZW5VbmZvY3VzZWQ6ICcxMDAwJywgZGVjaW1hbFBsYWNlc1Nob3duT25CbHVyOiAnMScsIHN5bWJvbFdoZW5VbmZvY3VzZWQ6ICcgSyd9XG4gICAgICAgICAgICAgKiBFeGFtcGxlOiBmb2N1c2luIHZhbHVlIFwiMSwxMTEuMTFcIiBmb2N1c291dCB2YWx1ZSBcIjEuMSBLXCJcbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvKiBUaGUgYHN5bWJvbFdoZW5VbmZvY3VzZWRgIG9wdGlvbiBpcyBhIHN5bWJvbCBwbGFjZWQgYXMgYSBzdWZmaXggd2hlbiBub3QgaW4gZm9jdXMuXG4gICAgICAgICAgICAgKiBUaGlzIGlzIG9wdGlvbmFsIHRvby5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc3ltYm9sV2hlblVuZm9jdXNlZDoge1xuICAgICAgICAgICAgICAgIG5vbmUgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgcGVyY2VudGFnZTogJyUnLFxuICAgICAgICAgICAgICAgIHBlcm1pbGxlICA6ICfigLAnLFxuICAgICAgICAgICAgICAgIGJhc2lzUG9pbnQ6ICfigLEnLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyogRGVmaW5lcyBpZiB0aGUgZWxlbWVudCB2YWx1ZSBzaG91bGQgYmUgdW5mb3JtYXR0ZWQgd2hlbiB0aGUgdXNlciBob3ZlciBoaXMgbW91c2Ugb3ZlciBpdCB3aGlsZSBob2xkaW5nIHRoZSBgQWx0YCBrZXkuXG4gICAgICAgICAgICAgKiBVbmZvcm1hdHRpbmcgdGhlcmUgbWVhbnMgdGhhdCB0aGlzIHJlbW92ZXMgYW55IG5vbi1udW1iZXIgY2hhcmFjdGVycyBhbmQgZGlzcGxheXMgdGhlICpyYXcqIHZhbHVlLCBhcyB1bmRlcnN0b29kIGJ5IEphdmFzY3JpcHQgKGllLiBgMTIuMzRgIGlzIGEgdmFsaWQgbnVtYmVyLCB3aGlsZSBgMTIsMzRgIGlzIG5vdCkuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogV2UgcmVmb3JtYXQgYmFjayBiZWZvcmUgYW55dGhpbmcgZWxzZSBpZiA6XG4gICAgICAgICAgICAgKiAtIHRoZSB1c2VyIGZvY3VzIG9uIHRoZSBlbGVtZW50IGJ5IHRhYmJpbmcgb3IgY2xpY2tpbmcgaW50byBpdCxcbiAgICAgICAgICAgICAqIC0gdGhlIHVzZXIgcmVsZWFzZXMgdGhlIGBBbHRgIGtleSwgYW5kXG4gICAgICAgICAgICAgKiAtIGlmIHdlIGRldGVjdCBhIG1vdXNlbGVhdmUgZXZlbnQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogV2UgdW5mb3JtYXQgYWdhaW4gaWYgOlxuICAgICAgICAgICAgICogLSB3aGlsZSB0aGUgbW91c2UgaXMgb3ZlciB0aGUgZWxlbWVudCwgdGhlIHVzZXIgaGl0IGN0cmwgYWdhaW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdW5mb3JtYXRPbkhvdmVyOiB7XG4gICAgICAgICAgICAgICAgdW5mb3JtYXQgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkb05vdFVuZm9ybWF0OiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qIFJlbW92ZXMgdGhlIGZvcm1hdHRpbmcgYW5kIHVzZSB0aGUgcmF3IHZhbHVlIGluIGVhY2ggYXV0b051bWVyaWMgZWxlbWVudHMgb2YgdGhlIHBhcmVudCBmb3JtIGVsZW1lbnQsIG9uIHRoZSBmb3JtIGBzdWJtaXRgIGV2ZW50LlxuICAgICAgICAgICAgICogVGhlIG91dHB1dCBmb3JtYXQgaXMgYSBudW1lcmljIHN0cmluZyAobm5ubi5ubiBvciAtbm5ubi5ubikuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHVuZm9ybWF0T25TdWJtaXQ6IHtcbiAgICAgICAgICAgICAgICB1bmZvcm1hdCAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgIGtlZXBDdXJyZW50VmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyogUHJvdmlkZSBhIHdheSBmb3IgYXV0b21hdGljYWxseSByZXBsYWNpbmcgdGhlIGZvcm1hdHRlZCB2YWx1ZSB3aXRoIGEgcHJlLWRlZmluZWQgc3RyaW5nLCB3aGVuIHRoZSByYXcgdmFsdWUgaXMgZXF1YWwgdG8gYSBzcGVjaWZpYyB2YWx1ZVxuICAgICAgICAgICAgICogSGVyZSB5b3UgY2FuIHNwZWNpZnkgYXMgbWFueSAnY29udmVyc2lvbicgYXMgcG9zc2libGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhbHVlc1RvU3RyaW5nczoge1xuICAgICAgICAgICAgICAgIG5vbmUgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgemVyb0Rhc2ggICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAwOiAnLScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbmVBcm91bmRaZXJvOiB7XG4gICAgICAgICAgICAgICAgICAgICctMSc6ICdNaW4nLFxuICAgICAgICAgICAgICAgICAgICAxICAgOiAnTWF4JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyogVGhhdCBvcHRpb24gaXMgbGlua2VkIHRvIHRoZSBgbW9kaWZ5VmFsdWVPbldoZWVsYCBvbmUgYW5kIHdpbGwgb25seSBiZSB1c2VkIGlmIHRoZSBsYXR0ZXIgaXMgc2V0IHRvIGB0cnVlYC5cbiAgICAgICAgICAgICAqIFRoaXMgb3B0aW9uIHdpbGwgbW9kaWZ5IHRoZSB3aGVlbCBiZWhhdmlvciBhbmQgY2FuIGJlIHVzZWQgaW4gdHdvIHdheXMsIGVpdGhlciBieSBzZXR0aW5nIDpcbiAgICAgICAgICAgICAqIC0gYSAnZml4ZWQnIHN0ZXAgdmFsdWUgKGEgcG9zaXRpdmUgZmxvYXQgb3IgaW50ZWdlciBudW1iZXIgYDEwMDBgKSwgb3JcbiAgICAgICAgICAgICAqIC0gdGhlIGAncHJvZ3Jlc3NpdmUnYCBzdHJpbmcuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVGhlICdmaXhlZCcgbW9kZSBhbHdheXMgaW5jcmVtZW50L2RlY3JlbWVudCB0aGUgZWxlbWVudCB2YWx1ZSBieSB0aGF0IGFtb3VudCwgd2hpbGUgcmVzcGVjdGluZyB0aGUgYG1pbmltdW1WYWx1ZWAgYW5kIGBtYXhpbXVtVmFsdWVgIHNldHRpbmdzLlxuICAgICAgICAgICAgICogVGhlICdwcm9ncmVzc2l2ZScgbW9kZSB3aWxsIGluY3JlbWVudC9kZWNyZW1lbnQgdGhlIGVsZW1lbnQgdmFsdWUgYmFzZWQgb24gaXRzIGN1cnJlbnQgdmFsdWUuIFRoZSBiaWdnZXIgdGhlIG51bWJlciwgdGhlIGJpZ2dlciB0aGUgc3RlcCwgYW5kIHZpY2UgdmVyc2EuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHdoZWVsU3RlcDoge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzaXZlOiAncHJvZ3Jlc3NpdmUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQXV0b051bWVyaWNPcHRpb25zLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n'use strict';\n\nvar _AutoNumeric = __webpack_require__(1);\n\nvar _AutoNumeric2 = _interopRequireDefault(_AutoNumeric);\n\nvar _AutoNumericOptions = __webpack_require__(4);\n\nvar _AutoNumericOptions2 = _interopRequireDefault(_AutoNumericOptions);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint no-unused-vars: 0 */\n\n/**\n * The defaults options.\n * These can be overridden by the following methods:\n * - HTML5 data attributes (ie. `<input type=\"text\" data-currency-symbol=\" €\">`)\n * - Options passed to the `update` method (ie. `anElement.update({ currencySymbol: ' €' });`), or simply during the initialization (ie. `new AutoNumeric(domElement, {options});`)\n */\n/**\n * Default settings for autoNumeric.js\n * @author Alexandre Bonneau <alexandre.bonneau@linuxfr.eu>\n * @copyright © 2016 Alexandre Bonneau\n *\n * The MIT License (http://www.opensource.org/licenses/mit-license.php)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sub license, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\nObject.defineProperty(_AutoNumeric2.default, 'defaultSettings', {\n    get: function get() {\n        return {\n            allowDecimalPadding: _AutoNumeric2.default.options.allowDecimalPadding.always,\n            caretPositionOnFocus: _AutoNumeric2.default.options.caretPositionOnFocus.doNoForceCaretPosition,\n            createLocalList: _AutoNumeric2.default.options.createLocalList.createList,\n            currencySymbol: _AutoNumeric2.default.options.currencySymbol.none,\n            currencySymbolPlacement: _AutoNumeric2.default.options.currencySymbolPlacement.prefix,\n            decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.dot,\n            decimalCharacterAlternative: _AutoNumeric2.default.options.decimalCharacterAlternative.none,\n            decimalPlaces: _AutoNumeric2.default.options.decimalPlaces.two,\n            decimalPlacesRawValue: _AutoNumeric2.default.options.decimalPlacesRawValue.useDefault,\n            decimalPlacesShownOnBlur: _AutoNumeric2.default.options.decimalPlacesShownOnBlur.useDefault,\n            decimalPlacesShownOnFocus: _AutoNumeric2.default.options.decimalPlacesShownOnFocus.useDefault,\n            defaultValueOverride: _AutoNumeric2.default.options.defaultValueOverride.doNotOverride,\n            digitalGroupSpacing: _AutoNumeric2.default.options.digitalGroupSpacing.three,\n            digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.comma,\n            divisorWhenUnfocused: _AutoNumeric2.default.options.divisorWhenUnfocused.none,\n            emptyInputBehavior: _AutoNumeric2.default.options.emptyInputBehavior.focus,\n            failOnUnknownOption: _AutoNumeric2.default.options.failOnUnknownOption.ignore,\n            formatOnPageLoad: _AutoNumeric2.default.options.formatOnPageLoad.format,\n            historySize: _AutoNumeric2.default.options.historySize.medium,\n            isCancellable: _AutoNumeric2.default.options.isCancellable.cancellable,\n            leadingZero: _AutoNumeric2.default.options.leadingZero.deny,\n            maximumValue: _AutoNumeric2.default.options.maximumValue.tenTrillions,\n            minimumValue: _AutoNumeric2.default.options.minimumValue.tenTrillions,\n            modifyValueOnWheel: _AutoNumeric2.default.options.modifyValueOnWheel.modifyValue,\n            negativeBracketsTypeOnBlur: _AutoNumeric2.default.options.negativeBracketsTypeOnBlur.none,\n            negativePositiveSignPlacement: _AutoNumeric2.default.options.negativePositiveSignPlacement.none,\n            noEventListeners: _AutoNumeric2.default.options.noEventListeners.addEvents,\n            //TODO Shouldn't we use `truncate` as the default value?\n            onInvalidPaste: _AutoNumeric2.default.options.onInvalidPaste.error,\n            outputFormat: _AutoNumeric2.default.options.outputFormat.none,\n            overrideMinMaxLimits: _AutoNumeric2.default.options.overrideMinMaxLimits.doNotOverride,\n            rawValueDivisor: _AutoNumeric2.default.options.rawValueDivisor.none,\n            readOnly: _AutoNumeric2.default.options.readOnly.readWrite,\n            roundingMethod: _AutoNumeric2.default.options.roundingMethod.halfUpSymmetric,\n            saveValueToSessionStorage: _AutoNumeric2.default.options.saveValueToSessionStorage.doNotSave,\n            selectNumberOnly: _AutoNumeric2.default.options.selectNumberOnly.selectNumbersOnly,\n            selectOnFocus: _AutoNumeric2.default.options.selectOnFocus.select,\n            serializeSpaces: _AutoNumeric2.default.options.serializeSpaces.plus,\n            showOnlyNumbersOnFocus: _AutoNumeric2.default.options.showOnlyNumbersOnFocus.showAll,\n            showPositiveSign: _AutoNumeric2.default.options.showPositiveSign.hide,\n            showWarnings: _AutoNumeric2.default.options.showWarnings.show,\n            styleRules: _AutoNumeric2.default.options.styleRules.none,\n            suffixText: _AutoNumeric2.default.options.suffixText.none,\n            symbolWhenUnfocused: _AutoNumeric2.default.options.symbolWhenUnfocused.none,\n            unformatOnHover: _AutoNumeric2.default.options.unformatOnHover.unformat,\n            unformatOnSubmit: _AutoNumeric2.default.options.unformatOnSubmit.keepCurrentValue,\n            valuesToStrings: _AutoNumeric2.default.options.valuesToStrings.none,\n            wheelStep: _AutoNumeric2.default.options.wheelStep.progressive\n        };\n    }\n});\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXV0b051bWVyaWNEZWZhdWx0U2V0dGluZ3MuanM/ZTg2YiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImFsbG93RGVjaW1hbFBhZGRpbmciLCJvcHRpb25zIiwiYWx3YXlzIiwiY2FyZXRQb3NpdGlvbk9uRm9jdXMiLCJkb05vRm9yY2VDYXJldFBvc2l0aW9uIiwiY3JlYXRlTG9jYWxMaXN0IiwiY3JlYXRlTGlzdCIsImN1cnJlbmN5U3ltYm9sIiwibm9uZSIsImN1cnJlbmN5U3ltYm9sUGxhY2VtZW50IiwicHJlZml4IiwiZGVjaW1hbENoYXJhY3RlciIsImRvdCIsImRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSIsImRlY2ltYWxQbGFjZXMiLCJ0d28iLCJkZWNpbWFsUGxhY2VzUmF3VmFsdWUiLCJ1c2VEZWZhdWx0IiwiZGVjaW1hbFBsYWNlc1Nob3duT25CbHVyIiwiZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyIsImRlZmF1bHRWYWx1ZU92ZXJyaWRlIiwiZG9Ob3RPdmVycmlkZSIsImRpZ2l0YWxHcm91cFNwYWNpbmciLCJ0aHJlZSIsImRpZ2l0R3JvdXBTZXBhcmF0b3IiLCJjb21tYSIsImRpdmlzb3JXaGVuVW5mb2N1c2VkIiwiZW1wdHlJbnB1dEJlaGF2aW9yIiwiZm9jdXMiLCJmYWlsT25Vbmtub3duT3B0aW9uIiwiaWdub3JlIiwiZm9ybWF0T25QYWdlTG9hZCIsImZvcm1hdCIsImhpc3RvcnlTaXplIiwibWVkaXVtIiwiaXNDYW5jZWxsYWJsZSIsImNhbmNlbGxhYmxlIiwibGVhZGluZ1plcm8iLCJkZW55IiwibWF4aW11bVZhbHVlIiwidGVuVHJpbGxpb25zIiwibWluaW11bVZhbHVlIiwibW9kaWZ5VmFsdWVPbldoZWVsIiwibW9kaWZ5VmFsdWUiLCJuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciIsIm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50Iiwibm9FdmVudExpc3RlbmVycyIsImFkZEV2ZW50cyIsIm9uSW52YWxpZFBhc3RlIiwiZXJyb3IiLCJvdXRwdXRGb3JtYXQiLCJvdmVycmlkZU1pbk1heExpbWl0cyIsInJhd1ZhbHVlRGl2aXNvciIsInJlYWRPbmx5IiwicmVhZFdyaXRlIiwicm91bmRpbmdNZXRob2QiLCJoYWxmVXBTeW1tZXRyaWMiLCJzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlIiwiZG9Ob3RTYXZlIiwic2VsZWN0TnVtYmVyT25seSIsInNlbGVjdE51bWJlcnNPbmx5Iiwic2VsZWN0T25Gb2N1cyIsInNlbGVjdCIsInNlcmlhbGl6ZVNwYWNlcyIsInBsdXMiLCJzaG93T25seU51bWJlcnNPbkZvY3VzIiwic2hvd0FsbCIsInNob3dQb3NpdGl2ZVNpZ24iLCJoaWRlIiwic2hvd1dhcm5pbmdzIiwic2hvdyIsInN0eWxlUnVsZXMiLCJzdWZmaXhUZXh0Iiwic3ltYm9sV2hlblVuZm9jdXNlZCIsInVuZm9ybWF0T25Ib3ZlciIsInVuZm9ybWF0IiwidW5mb3JtYXRPblN1Ym1pdCIsImtlZXBDdXJyZW50VmFsdWUiLCJ2YWx1ZXNUb1N0cmluZ3MiLCJ3aGVlbFN0ZXAiLCJwcm9ncmVzc2l2ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUE2QkE7Ozs7QUFDQTs7Ozs7O0FBRUE7O0FBRUE7Ozs7OztBQWxDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3Q0FBLE9BQU9DLGNBQVAsd0JBQW1DLGlCQUFuQyxFQUFzRDtBQUNsREMsT0FEa0QsaUJBQzVDO0FBQ0YsZUFBTztBQUNIQyxpQ0FBK0Isc0JBQVlDLE9BQVosQ0FBb0JELG1CQUFwQixDQUF3Q0UsTUFEcEU7QUFFSEMsa0NBQStCLHNCQUFZRixPQUFaLENBQW9CRSxvQkFBcEIsQ0FBeUNDLHNCQUZyRTtBQUdIQyw2QkFBK0Isc0JBQVlKLE9BQVosQ0FBb0JJLGVBQXBCLENBQW9DQyxVQUhoRTtBQUlIQyw0QkFBK0Isc0JBQVlOLE9BQVosQ0FBb0JNLGNBQXBCLENBQW1DQyxJQUovRDtBQUtI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cEIsQ0FBb0NDLElBdENoRTtBQXVDSEMsb0NBQStCLHNCQUFZaEUsT0FBWixDQUFvQmdFLHNCQUFwQixDQUEyQ0MsT0F2Q3ZFO0FBd0NIQyw4QkFBK0Isc0JBQVlsRSxPQUFaLENBQW9Ca0UsZ0JBQXBCLENBQXFDQyxJQXhDakU7QUF5Q0hDLDBCQUErQixzQkFBWXBFLE9BQVosQ0FBb0JvRSxZQUFwQixDQUFpQ0MsSUF6QzdEO0FBMENIQyx3QkFBK0Isc0JBQVl0RSxPQUFaLENBQW9Cc0UsVUFBcEIsQ0FBK0IvRCxJQTFDM0Q7QUEyQ0hnRSx3QkFBK0Isc0JBQVl2RSxPQUFaLENBQW9CdUUsVUFBcEIsQ0FBK0JoRSxJQTNDM0Q7QUE0Q0hpRSxpQ0FBK0Isc0JBQVl4RSxPQUFaLENBQW9Cd0UsbUJBQXBCLENBQXdDakUsSUE1Q3BFO0FBNkNIa0UsNkJBQStCLHNCQUFZekUsT0FBWixDQUFvQnlFLGVBQXBCLENBQW9DQyxRQTdDaEU7QUE4Q0hDLDhCQUErQixzQkFBWTNFLE9BQVosQ0FBb0IyRSxnQkFBcEIsQ0FBcUNDLGdCQTlDakU7QUErQ0hDLDZCQUErQixzQkFBWTdFLE9BQVosQ0FBb0I2RSxlQUFwQixDQUFvQ3RFLElBL0NoRTtBQWdESHVFLHVCQUErQixzQkFBWTlFLE9BQVosQ0FBb0I4RSxTQUFwQixDQUE4QkM7QUFoRDFELFNBQVA7QUFrREg7QUFwRGlELENBQXRELEUiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgYXV0b051bWVyaWMuanNcbiAqIEBhdXRob3IgQWxleGFuZHJlIEJvbm5lYXUgPGFsZXhhbmRyZS5ib25uZWF1QGxpbnV4ZnIuZXU+XG4gKiBAY29weXJpZ2h0IMKpIDIwMTYgQWxleGFuZHJlIEJvbm5lYXVcbiAqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwKVxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAqIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YiBsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBBdXRvTnVtZXJpYyBmcm9tICcuL0F1dG9OdW1lcmljJztcbmltcG9ydCBBdXRvTnVtZXJpY09wdGlvbnMgZnJvbSAnLi9BdXRvTnVtZXJpY09wdGlvbnMnO1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IDAgKi9cblxuLyoqXG4gKiBUaGUgZGVmYXVsdHMgb3B0aW9ucy5cbiAqIFRoZXNlIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcbiAqIC0gSFRNTDUgZGF0YSBhdHRyaWJ1dGVzIChpZS4gYDxpbnB1dCB0eXBlPVwidGV4dFwiIGRhdGEtY3VycmVuY3ktc3ltYm9sPVwiIOKCrFwiPmApXG4gKiAtIE9wdGlvbnMgcGFzc2VkIHRvIHRoZSBgdXBkYXRlYCBtZXRob2QgKGllLiBgYW5FbGVtZW50LnVwZGF0ZSh7IGN1cnJlbmN5U3ltYm9sOiAnIOKCrCcgfSk7YCksIG9yIHNpbXBseSBkdXJpbmcgdGhlIGluaXRpYWxpemF0aW9uIChpZS4gYG5ldyBBdXRvTnVtZXJpYyhkb21FbGVtZW50LCB7b3B0aW9uc30pO2ApXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdXRvTnVtZXJpYywgJ2RlZmF1bHRTZXR0aW5ncycsIHtcbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbGxvd0RlY2ltYWxQYWRkaW5nICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nLmFsd2F5cyxcbiAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkZvY3VzICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmNhcmV0UG9zaXRpb25PbkZvY3VzLmRvTm9Gb3JjZUNhcmV0UG9zaXRpb24sXG4gICAgICAgICAgICBjcmVhdGVMb2NhbExpc3QgICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5jcmVhdGVMb2NhbExpc3QuY3JlYXRlTGlzdCxcbiAgICAgICAgICAgIGN1cnJlbmN5U3ltYm9sICAgICAgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sLm5vbmUsXG4gICAgICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5wcmVmaXgsXG4gICAgICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyLmRvdCxcbiAgICAgICAgICAgIGRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZS5ub25lLFxuICAgICAgICAgICAgZGVjaW1hbFBsYWNlcyAgICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbFBsYWNlcy50d28sXG4gICAgICAgICAgICBkZWNpbWFsUGxhY2VzUmF3VmFsdWUgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5kZWNpbWFsUGxhY2VzUmF3VmFsdWUudXNlRGVmYXVsdCxcbiAgICAgICAgICAgIGRlY2ltYWxQbGFjZXNTaG93bk9uQmx1ciAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uQmx1ci51c2VEZWZhdWx0LFxuICAgICAgICAgICAgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cy51c2VEZWZhdWx0LFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlT3ZlcnJpZGUgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGVmYXVsdFZhbHVlT3ZlcnJpZGUuZG9Ob3RPdmVycmlkZSxcbiAgICAgICAgICAgIGRpZ2l0YWxHcm91cFNwYWNpbmcgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmRpZ2l0YWxHcm91cFNwYWNpbmcudGhyZWUsXG4gICAgICAgICAgICBkaWdpdEdyb3VwU2VwYXJhdG9yICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLmNvbW1hLFxuICAgICAgICAgICAgZGl2aXNvcldoZW5VbmZvY3VzZWQgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGl2aXNvcldoZW5VbmZvY3VzZWQubm9uZSxcbiAgICAgICAgICAgIGVtcHR5SW5wdXRCZWhhdmlvciAgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvci5mb2N1cyxcbiAgICAgICAgICAgIGZhaWxPblVua25vd25PcHRpb24gICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmZhaWxPblVua25vd25PcHRpb24uaWdub3JlLFxuICAgICAgICAgICAgZm9ybWF0T25QYWdlTG9hZCAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZm9ybWF0T25QYWdlTG9hZC5mb3JtYXQsXG4gICAgICAgICAgICBoaXN0b3J5U2l6ZSAgICAgICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5oaXN0b3J5U2l6ZS5tZWRpdW0sXG4gICAgICAgICAgICBpc0NhbmNlbGxhYmxlICAgICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5pc0NhbmNlbGxhYmxlLmNhbmNlbGxhYmxlLFxuICAgICAgICAgICAgbGVhZGluZ1plcm8gICAgICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMubGVhZGluZ1plcm8uZGVueSxcbiAgICAgICAgICAgIG1heGltdW1WYWx1ZSAgICAgICAgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLm1heGltdW1WYWx1ZS50ZW5UcmlsbGlvbnMsXG4gICAgICAgICAgICBtaW5pbXVtVmFsdWUgICAgICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5taW5pbXVtVmFsdWUudGVuVHJpbGxpb25zLFxuICAgICAgICAgICAgbW9kaWZ5VmFsdWVPbldoZWVsICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMubW9kaWZ5VmFsdWVPbldoZWVsLm1vZGlmeVZhbHVlLFxuICAgICAgICAgICAgbmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIubm9uZSxcbiAgICAgICAgICAgIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50Lm5vbmUsXG4gICAgICAgICAgICBub0V2ZW50TGlzdGVuZXJzICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5ub0V2ZW50TGlzdGVuZXJzLmFkZEV2ZW50cyxcbiAgICAgICAgICAgIC8vVE9ETyBTaG91bGRuJ3Qgd2UgdXNlIGB0cnVuY2F0ZWAgYXMgdGhlIGRlZmF1bHQgdmFsdWU/XG4gICAgICAgICAgICBvbkludmFsaWRQYXN0ZSAgICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5vbkludmFsaWRQYXN0ZS5lcnJvcixcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdCAgICAgICAgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLm91dHB1dEZvcm1hdC5ub25lLFxuICAgICAgICAgICAgb3ZlcnJpZGVNaW5NYXhMaW1pdHMgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMub3ZlcnJpZGVNaW5NYXhMaW1pdHMuZG9Ob3RPdmVycmlkZSxcbiAgICAgICAgICAgIHJhd1ZhbHVlRGl2aXNvciAgICAgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLnJhd1ZhbHVlRGl2aXNvci5ub25lLFxuICAgICAgICAgICAgcmVhZE9ubHkgICAgICAgICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMucmVhZE9ubHkucmVhZFdyaXRlLFxuICAgICAgICAgICAgcm91bmRpbmdNZXRob2QgICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMucm91bmRpbmdNZXRob2QuaGFsZlVwU3ltbWV0cmljLFxuICAgICAgICAgICAgc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZS5kb05vdFNhdmUsXG4gICAgICAgICAgICBzZWxlY3ROdW1iZXJPbmx5ICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5zZWxlY3ROdW1iZXJPbmx5LnNlbGVjdE51bWJlcnNPbmx5LFxuICAgICAgICAgICAgc2VsZWN0T25Gb2N1cyAgICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuc2VsZWN0T25Gb2N1cy5zZWxlY3QsXG4gICAgICAgICAgICBzZXJpYWxpemVTcGFjZXMgICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5zZXJpYWxpemVTcGFjZXMucGx1cyxcbiAgICAgICAgICAgIHNob3dPbmx5TnVtYmVyc09uRm9jdXMgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLnNob3dPbmx5TnVtYmVyc09uRm9jdXMuc2hvd0FsbCxcbiAgICAgICAgICAgIHNob3dQb3NpdGl2ZVNpZ24gICAgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLnNob3dQb3NpdGl2ZVNpZ24uaGlkZSxcbiAgICAgICAgICAgIHNob3dXYXJuaW5ncyAgICAgICAgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLnNob3dXYXJuaW5ncy5zaG93LFxuICAgICAgICAgICAgc3R5bGVSdWxlcyAgICAgICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuc3R5bGVSdWxlcy5ub25lLFxuICAgICAgICAgICAgc3VmZml4VGV4dCAgICAgICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuc3VmZml4VGV4dC5ub25lLFxuICAgICAgICAgICAgc3ltYm9sV2hlblVuZm9jdXNlZCAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuc3ltYm9sV2hlblVuZm9jdXNlZC5ub25lLFxuICAgICAgICAgICAgdW5mb3JtYXRPbkhvdmVyICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMudW5mb3JtYXRPbkhvdmVyLnVuZm9ybWF0LFxuICAgICAgICAgICAgdW5mb3JtYXRPblN1Ym1pdCAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMudW5mb3JtYXRPblN1Ym1pdC5rZWVwQ3VycmVudFZhbHVlLFxuICAgICAgICAgICAgdmFsdWVzVG9TdHJpbmdzICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMudmFsdWVzVG9TdHJpbmdzLm5vbmUsXG4gICAgICAgICAgICB3aGVlbFN0ZXAgICAgICAgICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy53aGVlbFN0ZXAucHJvZ3Jlc3NpdmUsXG4gICAgICAgIH07XG4gICAgfSxcbn0pO1xuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQXV0b051bWVyaWNEZWZhdWx0U2V0dGluZ3MuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n'use strict';\n\nvar _AutoNumeric = __webpack_require__(1);\n\nvar _AutoNumeric2 = _interopRequireDefault(_AutoNumeric);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Event list managed by AutoNumeric\n *\n * @type {{formatted: string, minRangeExceeded: string, maxRangeExceeded: string, native: {input: string, change: string}}}\n */\nObject.defineProperty(_AutoNumeric2.default, 'events', {\n    get: function get() {\n        return {\n            formatted: 'autoNumeric:formatted',\n            minRangeExceeded: 'autoNumeric:minExceeded',\n            maxRangeExceeded: 'autoNumeric:maxExceeded',\n            native: {\n                input: 'input',\n                change: 'change'\n            }\n        };\n    }\n}); /**\n     * Options for autoNumeric.js\n     * @author Alexandre Bonneau <alexandre.bonneau@linuxfr.eu>\n     * @copyright © 2017 Alexandre Bonneau\n     *\n     * The MIT License (http://www.opensource.org/licenses/mit-license.php)\n     *\n     * Permission is hereby granted, free of charge, to any person\n     * obtaining a copy of this software and associated documentation\n     * files (the \"Software\"), to deal in the Software without\n     * restriction, including without limitation the rights to use,\n     * copy, modify, merge, publish, distribute, sub license, and/or sell\n     * copies of the Software, and to permit persons to whom the\n     * Software is furnished to do so, subject to the following\n     * conditions:\n     *\n     * The above copyright notice and this permission notice shall be\n     * included in all copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n     * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n     * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n     * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n     * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n     * OTHER DEALINGS IN THE SOFTWARE.\n     */\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXV0b051bWVyaWNFdmVudHMuanM/N2JkMyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImZvcm1hdHRlZCIsIm1pblJhbmdlRXhjZWVkZWQiLCJtYXhSYW5nZUV4Y2VlZGVkIiwibmF0aXZlIiwiaW5wdXQiLCJjaGFuZ2UiXSwibWFwcGluZ3MiOiI7Ozs7O0FBNkJBOzs7Ozs7QUFFQTs7Ozs7QUFLQUEsT0FBT0MsY0FBUCx3QkFBbUMsUUFBbkMsRUFBNkM7QUFDekNDLE9BRHlDLGlCQUNuQztBQUNGLGVBQU87QUFDSEMsdUJBQWtCLHVCQURmO0FBRUhDLDhCQUFrQix5QkFGZjtBQUdIQyw4QkFBa0IseUJBSGY7QUFJSEMsb0JBQWtCO0FBQ2RDLHVCQUFRLE9BRE07QUFFZEMsd0JBQVE7QUFGTTtBQUpmLFNBQVA7QUFTSDtBQVh3QyxDQUE3QyxFLENBcENBIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE9wdGlvbnMgZm9yIGF1dG9OdW1lcmljLmpzXG4gKiBAYXV0aG9yIEFsZXhhbmRyZSBCb25uZWF1IDxhbGV4YW5kcmUuYm9ubmVhdUBsaW51eGZyLmV1PlxuICogQGNvcHlyaWdodCDCqSAyMDE3IEFsZXhhbmRyZSBCb25uZWF1XG4gKlxuICogVGhlIE1JVCBMaWNlbnNlIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWIgbGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgQXV0b051bWVyaWMgZnJvbSAnLi9BdXRvTnVtZXJpYyc7XG5cbi8qKlxuICogRXZlbnQgbGlzdCBtYW5hZ2VkIGJ5IEF1dG9OdW1lcmljXG4gKlxuICogQHR5cGUge3tmb3JtYXR0ZWQ6IHN0cmluZywgbWluUmFuZ2VFeGNlZWRlZDogc3RyaW5nLCBtYXhSYW5nZUV4Y2VlZGVkOiBzdHJpbmcsIG5hdGl2ZToge2lucHV0OiBzdHJpbmcsIGNoYW5nZTogc3RyaW5nfX19XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdXRvTnVtZXJpYywgJ2V2ZW50cycsIHtcbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXR0ZWQgICAgICAgOiAnYXV0b051bWVyaWM6Zm9ybWF0dGVkJyxcbiAgICAgICAgICAgIG1pblJhbmdlRXhjZWVkZWQ6ICdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcsXG4gICAgICAgICAgICBtYXhSYW5nZUV4Y2VlZGVkOiAnYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnLFxuICAgICAgICAgICAgbmF0aXZlICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGlucHV0IDogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICBjaGFuZ2U6ICdjaGFuZ2UnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQXV0b051bWVyaWNFdmVudHMuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n'use strict';\n\nvar _AutoNumeric = __webpack_require__(1);\n\nvar _AutoNumeric2 = _interopRequireDefault(_AutoNumeric);\n\nvar _AutoNumericHelper = __webpack_require__(3);\n\nvar _AutoNumericHelper2 = _interopRequireDefault(_AutoNumericHelper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Pre-defined options for autoNumeric.js\n * @author Alexandre Bonneau <alexandre.bonneau@linuxfr.eu>\n * @copyright © 2016 Alexandre Bonneau\n *\n * The MIT License (http://www.opensource.org/licenses/mit-license.php)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sub license, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\nvar euro = { // Français\n    digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.dot, // or '\\u202f'\n    decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.comma,\n    decimalCharacterAlternative: _AutoNumeric2.default.options.decimalCharacterAlternative.dot,\n    currencySymbol: '\\u202F\\u20AC',\n    currencySymbolPlacement: _AutoNumeric2.default.options.currencySymbolPlacement.suffix,\n    negativePositiveSignPlacement: _AutoNumeric2.default.options.negativePositiveSignPlacement.prefix\n};\n\nvar dollar = {\n    digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.comma,\n    decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.dot,\n    currencySymbol: _AutoNumeric2.default.options.currencySymbol.dollar,\n    currencySymbolPlacement: _AutoNumeric2.default.options.currencySymbolPlacement.prefix,\n    negativePositiveSignPlacement: _AutoNumeric2.default.options.negativePositiveSignPlacement.right\n};\n\nvar japanese = { // 日本語\n    digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.comma,\n    decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.dot,\n    currencySymbol: _AutoNumeric2.default.options.currencySymbol.yen,\n    currencySymbolPlacement: _AutoNumeric2.default.options.currencySymbolPlacement.prefix,\n    negativePositiveSignPlacement: _AutoNumeric2.default.options.negativePositiveSignPlacement.right\n};\n\n// Here we need to clone the initial objects in order to be able to edit it without affecting it\nvar euroPos = _AutoNumericHelper2.default.cloneObject(euro);\neuroPos.minimumValue = 0;\nvar euroNeg = _AutoNumericHelper2.default.cloneObject(euro);\neuroNeg.maximumValue = 0;\neuroNeg.negativePositiveSignPlacement = _AutoNumeric2.default.options.negativePositiveSignPlacement.prefix;\n\nvar euroSpace = _AutoNumericHelper2.default.cloneObject(euro);\neuroSpace.digitGroupSeparator = _AutoNumeric2.default.options.digitGroupSeparator.normalSpace;\nvar euroSpacePos = _AutoNumericHelper2.default.cloneObject(euroSpace);\neuroSpacePos.minimumValue = 0;\nvar euroSpaceNeg = _AutoNumericHelper2.default.cloneObject(euroSpace);\neuroSpaceNeg.maximumValue = 0;\neuroSpaceNeg.negativePositiveSignPlacement = _AutoNumeric2.default.options.negativePositiveSignPlacement.prefix;\n\nvar percentageEU2dec = _AutoNumericHelper2.default.cloneObject(euro);\npercentageEU2dec.currencySymbol = _AutoNumeric2.default.options.currencySymbol.none;\npercentageEU2dec.suffixText = '\\u202F' + _AutoNumeric2.default.options.suffixText.percentage;\npercentageEU2dec.wheelStep = 0.0001; // This targets the `rawValue`, not the formatted one\npercentageEU2dec.rawValueDivisor = _AutoNumeric2.default.options.rawValueDivisor.percentage;\nvar percentageEU2decPos = _AutoNumericHelper2.default.cloneObject(percentageEU2dec);\npercentageEU2decPos.minimumValue = 0;\nvar percentageEU2decNeg = _AutoNumericHelper2.default.cloneObject(percentageEU2dec);\npercentageEU2decNeg.maximumValue = 0;\npercentageEU2decNeg.negativePositiveSignPlacement = _AutoNumeric2.default.options.negativePositiveSignPlacement.prefix;\n\nvar percentageEU3dec = _AutoNumericHelper2.default.cloneObject(percentageEU2dec);\npercentageEU3dec.decimalPlaces = 3;\nvar percentageEU3decPos = _AutoNumericHelper2.default.cloneObject(percentageEU2decPos);\npercentageEU3decPos.decimalPlaces = 3;\nvar percentageEU3decNeg = _AutoNumericHelper2.default.cloneObject(percentageEU2decNeg);\npercentageEU3decNeg.decimalPlaces = 3;\n\nvar dollarPos = _AutoNumericHelper2.default.cloneObject(dollar);\ndollarPos.minimumValue = 0;\nvar dollarNeg = _AutoNumericHelper2.default.cloneObject(dollar);\ndollarNeg.maximumValue = 0;\ndollarNeg.negativePositiveSignPlacement = _AutoNumeric2.default.options.negativePositiveSignPlacement.prefix;\nvar dollarNegBrackets = _AutoNumericHelper2.default.cloneObject(dollarNeg);\ndollarNegBrackets.negativeBracketsTypeOnBlur = _AutoNumeric2.default.options.negativeBracketsTypeOnBlur.parentheses;\n\nvar percentageUS2dec = _AutoNumericHelper2.default.cloneObject(dollar);\npercentageUS2dec.currencySymbol = _AutoNumeric2.default.options.currencySymbol.none;\npercentageUS2dec.suffixText = _AutoNumeric2.default.options.suffixText.percentage;\npercentageUS2dec.wheelStep = 0.0001;\npercentageEU2dec.rawValueDivisor = _AutoNumeric2.default.options.rawValueDivisor.percentage;\nvar percentageUS2decPos = _AutoNumericHelper2.default.cloneObject(percentageUS2dec);\npercentageUS2decPos.minimumValue = 0;\nvar percentageUS2decNeg = _AutoNumericHelper2.default.cloneObject(percentageUS2dec);\npercentageUS2decNeg.maximumValue = 0;\npercentageUS2decNeg.negativePositiveSignPlacement = _AutoNumeric2.default.options.negativePositiveSignPlacement.prefix;\n\nvar percentageUS3dec = _AutoNumericHelper2.default.cloneObject(percentageUS2dec);\npercentageUS3dec.decimalPlaces = 3;\nvar percentageUS3decPos = _AutoNumericHelper2.default.cloneObject(percentageUS2decPos);\npercentageUS3decPos.decimalPlaces = 3;\nvar percentageUS3decNeg = _AutoNumericHelper2.default.cloneObject(percentageUS2decNeg);\npercentageUS3decNeg.decimalPlaces = 3;\n\n/**\n * Predefined options for the most common languages\n */\nObject.defineProperty(_AutoNumeric2.default, 'predefinedOptions', {\n    get: function get() {\n        return {\n            euro: euro,\n            euroPos: euroPos,\n            euroNeg: euroNeg,\n            euroSpace: euroSpace,\n            euroSpacePos: euroSpacePos,\n            euroSpaceNeg: euroSpaceNeg,\n            percentageEU2dec: percentageEU2dec,\n            percentageEU2decPos: percentageEU2decPos,\n            percentageEU2decNeg: percentageEU2decNeg,\n            percentageEU3dec: percentageEU3dec,\n            percentageEU3decPos: percentageEU3decPos,\n            percentageEU3decNeg: percentageEU3decNeg,\n            dollar: dollar,\n            dollarPos: dollarPos,\n            dollarNeg: dollarNeg,\n            dollarNegBrackets: dollarNegBrackets,\n            percentageUS2dec: percentageUS2dec,\n            percentageUS2decPos: percentageUS2decPos,\n            percentageUS2decNeg: percentageUS2decNeg,\n            percentageUS3dec: percentageUS3dec,\n            percentageUS3decPos: percentageUS3decPos,\n            percentageUS3decNeg: percentageUS3decNeg,\n            French: euro, // Français\n            Spanish: euro, // Español\n            NorthAmerican: dollar,\n            British: {\n                digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.comma,\n                decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.dot,\n                currencySymbol: _AutoNumeric2.default.options.currencySymbol.pound,\n                currencySymbolPlacement: _AutoNumeric2.default.options.currencySymbolPlacement.prefix,\n                negativePositiveSignPlacement: _AutoNumeric2.default.options.negativePositiveSignPlacement.right\n            },\n            Swiss: { // Suisse\n                digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.apostrophe,\n                decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.dot,\n                currencySymbol: '\\u202FCHF',\n                currencySymbolPlacement: _AutoNumeric2.default.options.currencySymbolPlacement.suffix,\n                negativePositiveSignPlacement: _AutoNumeric2.default.options.negativePositiveSignPlacement.prefix\n            },\n            Japanese: japanese, // 日本語\n            Chinese: japanese, // 中国語 (Chinese)\n            Brazilian: {\n                digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.dot,\n                decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.comma,\n                currencySymbol: _AutoNumeric2.default.options.currencySymbol.real,\n                currencySymbolPlacement: _AutoNumeric2.default.options.currencySymbolPlacement.prefix,\n                negativePositiveSignPlacement: _AutoNumeric2.default.options.negativePositiveSignPlacement.right\n            },\n            dotDecimalCharCommaSeparator: {\n                digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.comma,\n                decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.dot\n            },\n            commaDecimalCharDotSeparator: {\n                digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.dot,\n                decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.comma,\n                decimalCharacterAlternative: _AutoNumeric2.default.options.decimalCharacterAlternative.dot\n            },\n            integer: {\n                decimalPlaces: 0\n            },\n            integerPos: {\n                minimumValue: _AutoNumeric2.default.options.minimumValue.zero,\n                decimalPlaces: 0\n            },\n            integerNeg: {\n                maximumValue: _AutoNumeric2.default.options.maximumValue.zero,\n                decimalPlaces: 0\n            },\n            float: {\n                allowDecimalPadding: _AutoNumeric2.default.options.allowDecimalPadding.never\n            },\n            floatPos: {\n                allowDecimalPadding: _AutoNumeric2.default.options.allowDecimalPadding.never,\n                minimumValue: _AutoNumeric2.default.options.minimumValue.zero,\n                maximumValue: _AutoNumeric2.default.options.maximumValue.tenTrillions\n            },\n            floatNeg: {\n                allowDecimalPadding: _AutoNumeric2.default.options.allowDecimalPadding.never,\n                minimumValue: _AutoNumeric2.default.options.minimumValue.tenTrillions,\n                maximumValue: _AutoNumeric2.default.options.maximumValue.zero\n            },\n            numeric: {\n                digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.noSeparator,\n                decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.dot,\n                currencySymbol: _AutoNumeric2.default.options.currencySymbol.none\n            },\n            numericPos: {\n                digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.noSeparator,\n                decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.dot,\n                currencySymbol: _AutoNumeric2.default.options.currencySymbol.none,\n                minimumValue: _AutoNumeric2.default.options.minimumValue.zero,\n                maximumValue: _AutoNumeric2.default.options.maximumValue.tenTrillions\n            },\n            numericNeg: {\n                digitGroupSeparator: _AutoNumeric2.default.options.digitGroupSeparator.noSeparator,\n                decimalCharacter: _AutoNumeric2.default.options.decimalCharacter.dot,\n                currencySymbol: _AutoNumeric2.default.options.currencySymbol.none,\n                minimumValue: _AutoNumeric2.default.options.minimumValue.tenTrillions,\n                maximumValue: _AutoNumeric2.default.options.maximumValue.zero\n            }\n        };\n    }\n});\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXV0b051bWVyaWNQcmVkZWZpbmVkT3B0aW9ucy5qcz84ZWM5Il0sIm5hbWVzIjpbImV1cm8iLCJkaWdpdEdyb3VwU2VwYXJhdG9yIiwib3B0aW9ucyIsImRvdCIsImRlY2ltYWxDaGFyYWN0ZXIiLCJjb21tYSIsImRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSIsImN1cnJlbmN5U3ltYm9sIiwiY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQiLCJzdWZmaXgiLCJuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCIsInByZWZpeCIsImRvbGxhciIsInJpZ2h0IiwiamFwYW5lc2UiLCJ5ZW4iLCJldXJvUG9zIiwiY2xvbmVPYmplY3QiLCJtaW5pbXVtVmFsdWUiLCJldXJvTmVnIiwibWF4aW11bVZhbHVlIiwiZXVyb1NwYWNlIiwibm9ybWFsU3BhY2UiLCJldXJvU3BhY2VQb3MiLCJldXJvU3BhY2VOZWciLCJwZXJjZW50YWdlRVUyZGVjIiwibm9uZSIsInN1ZmZpeFRleHQiLCJwZXJjZW50YWdlIiwid2hlZWxTdGVwIiwicmF3VmFsdWVEaXZpc29yIiwicGVyY2VudGFnZUVVMmRlY1BvcyIsInBlcmNlbnRhZ2VFVTJkZWNOZWciLCJwZXJjZW50YWdlRVUzZGVjIiwiZGVjaW1hbFBsYWNlcyIsInBlcmNlbnRhZ2VFVTNkZWNQb3MiLCJwZXJjZW50YWdlRVUzZGVjTmVnIiwiZG9sbGFyUG9zIiwiZG9sbGFyTmVnIiwiZG9sbGFyTmVnQnJhY2tldHMiLCJuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciIsInBhcmVudGhlc2VzIiwicGVyY2VudGFnZVVTMmRlYyIsInBlcmNlbnRhZ2VVUzJkZWNQb3MiLCJwZXJjZW50YWdlVVMyZGVjTmVnIiwicGVyY2VudGFnZVVTM2RlYyIsInBlcmNlbnRhZ2VVUzNkZWNQb3MiLCJwZXJjZW50YWdlVVMzZGVjTmVnIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJGcmVuY2giLCJTcGFuaXNoIiwiTm9ydGhBbWVyaWNhbiIsIkJyaXRpc2giLCJwb3VuZCIsIlN3aXNzIiwiYXBvc3Ryb3BoZSIsIkphcGFuZXNlIiwiQ2hpbmVzZSIsIkJyYXppbGlhbiIsInJlYWwiLCJkb3REZWNpbWFsQ2hhckNvbW1hU2VwYXJhdG9yIiwiY29tbWFEZWNpbWFsQ2hhckRvdFNlcGFyYXRvciIsImludGVnZXIiLCJpbnRlZ2VyUG9zIiwiemVybyIsImludGVnZXJOZWciLCJmbG9hdCIsImFsbG93RGVjaW1hbFBhZGRpbmciLCJuZXZlciIsImZsb2F0UG9zIiwidGVuVHJpbGxpb25zIiwiZmxvYXROZWciLCJudW1lcmljIiwibm9TZXBhcmF0b3IiLCJudW1lcmljUG9zIiwibnVtZXJpY05lZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUE2QkE7Ozs7QUFDQTs7Ozs7O0FBOUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdDQSxJQUFNQSxPQUFPLEVBQUU7QUFDWEMseUJBQStCLHNCQUFZQyxPQUFaLENBQW9CRCxtQkFBcEIsQ0FBd0NFLEdBRDlELEVBQ21FO0FBQzVFQyxzQkFBK0Isc0JBQVlGLE9BQVosQ0FBb0JFLGdCQUFwQixDQUFxQ0MsS0FGM0Q7QUFHVEMsaUNBQStCLHNCQUFZSixPQUFaLENBQW9CSSwyQkFBcEIsQ0FBZ0RILEdBSHRFO0FBSVRJLG9CQUErQixjQUp0QjtBQUtUQyw2QkFBK0Isc0JBQVlOLE9BQVosQ0FBb0JNLHVCQUFwQixDQUE0Q0MsTUFMbEU7QUFNVEMsbUNBQStCLHNCQUFZUixPQUFaLENBQW9CUSw2QkFBcEIsQ0FBa0RDO0FBTnhFLENBQWI7O0FBU0EsSUFBTUMsU0FBUztBQUNYWCx5QkFBK0Isc0JBQVlDLE9BQVosQ0FBb0JELG1CQUFwQixDQUF3Q0ksS0FENUQ7QUFFWEQsc0JBQStCLHNCQUFZRixPQUFaLENBQW9CRSxnQkFBcEIsQ0FBcUNELEdBRnpEO0FBR1hJLG9CQUErQixzQkFBWUwsT0FBWixDQUFvQkssY0FBcEIsQ0FBbUNLLE1BSHZEO0FBSVhKLDZCQUEr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RjNCO0FBdUZIa0Qsd0JBQThCO0FBQzFCM0UscUNBQXFCLHNCQUFZQyxPQUFaLENBQW9CRCxtQkFBcEIsQ0FBd0MwRSxXQURuQztBQUUxQnZFLGtDQUFxQixzQkFBWUYsT0FBWixDQUFvQkUsZ0JBQXBCLENBQXFDRCxHQUZoQztBQUcxQkksZ0NBQXFCLHNCQUFZTCxPQUFaLENBQW9CSyxjQUFwQixDQUFtQ21CLElBSDlCO0FBSTFCUiw4QkFBcUIsc0JBQVloQixPQUFaLENBQW9CZ0IsWUFBcEIsQ0FBaUNnRCxJQUo1QjtBQUsxQjlDLDhCQUFxQixzQkFBWWxCLE9BQVosQ0FBb0JrQixZQUFwQixDQUFpQ29EO0FBTDVCLGFBdkYzQjtBQThGSEssd0JBQThCO0FBQzFCNUUscUNBQXFCLHNCQUFZQyxPQUFaLENBQW9CRCxtQkFBcEIsQ0FBd0MwRSxXQURuQztBQUUxQnZFLGtDQUFxQixzQkFBWUYsT0FBWixDQUFvQkUsZ0JBQXBCLENBQXFDRCxHQUZoQztBQUcxQkksZ0NBQXFCLHNCQUFZTCxPQUFaLENBQW9CSyxjQUFwQixDQUFtQ21CLElBSDlCO0FBSTFCUiw4QkFBcUIsc0JBQVloQixPQUFaLENBQW9CZ0IsWUFBcEIsQ0FBaUNzRCxZQUo1QjtBQUsxQnBELDhCQUFxQixzQkFBWWxCLE9BQVosQ0FBb0JrQixZQUFwQixDQUFpQzhDO0FBTDVCO0FBOUYzQixTQUFQO0FBc0dIO0FBeEdtRCxDQUF4RCxFIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFByZS1kZWZpbmVkIG9wdGlvbnMgZm9yIGF1dG9OdW1lcmljLmpzXG4gKiBAYXV0aG9yIEFsZXhhbmRyZSBCb25uZWF1IDxhbGV4YW5kcmUuYm9ubmVhdUBsaW51eGZyLmV1PlxuICogQGNvcHlyaWdodCDCqSAyMDE2IEFsZXhhbmRyZSBCb25uZWF1XG4gKlxuICogVGhlIE1JVCBMaWNlbnNlIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWIgbGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAqIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAqIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAqIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgQXV0b051bWVyaWMgZnJvbSAnLi9BdXRvTnVtZXJpYyc7XG5pbXBvcnQgQXV0b051bWVyaWNIZWxwZXIgZnJvbSAnLi9BdXRvTnVtZXJpY0hlbHBlcic7XG5cbmNvbnN0IGV1cm8gPSB7IC8vIEZyYW7Dp2Fpc1xuICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3IgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3IuZG90LCAvLyBvciAnXFx1MjAyZidcbiAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyLmNvbW1hLFxuICAgIGRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZS5kb3QsXG4gICAgY3VycmVuY3lTeW1ib2wgICAgICAgICAgICAgICA6ICdcXHUyMDJm4oKsJyxcbiAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5zdWZmaXgsXG4gICAgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucHJlZml4LFxufTtcblxuY29uc3QgZG9sbGFyID0ge1xuICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3IgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3IuY29tbWEsXG4gICAgZGVjaW1hbENoYXJhY3RlciAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbENoYXJhY3Rlci5kb3QsXG4gICAgY3VycmVuY3lTeW1ib2wgICAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2wuZG9sbGFyLFxuICAgIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnByZWZpeCxcbiAgICBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5yaWdodCxcbn07XG5cbmNvbnN0IGphcGFuZXNlID0geyAvLyDml6XmnKzoqp5cbiAgICBkaWdpdEdyb3VwU2VwYXJhdG9yICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLmNvbW1hLFxuICAgIGRlY2ltYWxDaGFyYWN0ZXIgICAgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXIuZG90LFxuICAgIGN1cnJlbmN5U3ltYm9sICAgICAgICAgICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sLnllbixcbiAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5wcmVmaXgsXG4gICAgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucmlnaHQsXG59O1xuXG5cbi8vIEhlcmUgd2UgbmVlZCB0byBjbG9uZSB0aGUgaW5pdGlhbCBvYmplY3RzIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gZWRpdCBpdCB3aXRob3V0IGFmZmVjdGluZyBpdFxuY29uc3QgZXVyb1BvcyAgICAgICAgICAgICAgICAgICAgICAgICA9IEF1dG9OdW1lcmljSGVscGVyLmNsb25lT2JqZWN0KGV1cm8pO1xuZXVyb1Bvcy5taW5pbXVtVmFsdWUgICAgICAgICAgICAgICAgICA9IDA7XG5jb25zdCBldXJvTmVnICAgICAgICAgICAgICAgICAgICAgICAgID0gQXV0b051bWVyaWNIZWxwZXIuY2xvbmVPYmplY3QoZXVybyk7XG5ldXJvTmVnLm1heGltdW1WYWx1ZSAgICAgICAgICAgICAgICAgID0gMDtcbmV1cm9OZWcubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPSBBdXRvTnVtZXJpYy5vcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LnByZWZpeDtcblxuY29uc3QgZXVyb1NwYWNlICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gQXV0b051bWVyaWNIZWxwZXIuY2xvbmVPYmplY3QoZXVybyk7XG5ldXJvU3BhY2UuZGlnaXRHcm91cFNlcGFyYXRvciAgICAgICAgICAgICAgPSBBdXRvTnVtZXJpYy5vcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3Iubm9ybWFsU3BhY2U7XG5jb25zdCBldXJvU3BhY2VQb3MgICAgICAgICAgICAgICAgICAgICAgICAgPSBBdXRvTnVtZXJpY0hlbHBlci5jbG9uZU9iamVjdChldXJvU3BhY2UpO1xuZXVyb1NwYWNlUG9zLm1pbmltdW1WYWx1ZSAgICAgICAgICAgICAgICAgID0gMDtcbmNvbnN0IGV1cm9TcGFjZU5lZyAgICAgICAgICAgICAgICAgICAgICAgICA9IEF1dG9OdW1lcmljSGVscGVyLmNsb25lT2JqZWN0KGV1cm9TcGFjZSk7XG5ldXJvU3BhY2VOZWcubWF4aW11bVZhbHVlICAgICAgICAgICAgICAgICAgPSAwO1xuZXVyb1NwYWNlTmVnLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5wcmVmaXg7XG5cbmNvbnN0IHBlcmNlbnRhZ2VFVTJkZWMgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBBdXRvTnVtZXJpY0hlbHBlci5jbG9uZU9iamVjdChldXJvKTtcbnBlcmNlbnRhZ2VFVTJkZWMuY3VycmVuY3lTeW1ib2wgICAgICAgICAgICAgICAgICAgPSBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sLm5vbmU7XG5wZXJjZW50YWdlRVUyZGVjLnN1ZmZpeFRleHQgICAgICAgICAgICAgICAgICAgICAgID0gYFxcdTIwMmYke0F1dG9OdW1lcmljLm9wdGlvbnMuc3VmZml4VGV4dC5wZXJjZW50YWdlfWA7XG5wZXJjZW50YWdlRVUyZGVjLndoZWVsU3RlcCAgICAgICAgICAgICAgICAgICAgICAgID0gMC4wMDAxOyAvLyBUaGlzIHRhcmdldHMgdGhlIGByYXdWYWx1ZWAsIG5vdCB0aGUgZm9ybWF0dGVkIG9uZVxucGVyY2VudGFnZUVVMmRlYy5yYXdWYWx1ZURpdmlzb3IgICAgICAgICAgICAgICAgICA9IEF1dG9OdW1lcmljLm9wdGlvbnMucmF3VmFsdWVEaXZpc29yLnBlcmNlbnRhZ2U7XG5jb25zdCBwZXJjZW50YWdlRVUyZGVjUG9zICAgICAgICAgICAgICAgICAgICAgICAgID0gQXV0b051bWVyaWNIZWxwZXIuY2xvbmVPYmplY3QocGVyY2VudGFnZUVVMmRlYyk7XG5wZXJjZW50YWdlRVUyZGVjUG9zLm1pbmltdW1WYWx1ZSAgICAgICAgICAgICAgICAgID0gMDtcbmNvbnN0IHBlcmNlbnRhZ2VFVTJkZWNOZWcgICAgICAgICAgICAgICAgICAgICAgICAgPSBBdXRvTnVtZXJpY0hlbHBlci5jbG9uZU9iamVjdChwZXJjZW50YWdlRVUyZGVjKTtcbnBlcmNlbnRhZ2VFVTJkZWNOZWcubWF4aW11bVZhbHVlICAgICAgICAgICAgICAgICAgPSAwO1xucGVyY2VudGFnZUVVMmRlY05lZy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucHJlZml4O1xuXG5jb25zdCBwZXJjZW50YWdlRVUzZGVjICAgICAgICAgICAgPSBBdXRvTnVtZXJpY0hlbHBlci5jbG9uZU9iamVjdChwZXJjZW50YWdlRVUyZGVjKTtcbnBlcmNlbnRhZ2VFVTNkZWMuZGVjaW1hbFBsYWNlcyAgICA9IDM7XG5jb25zdCBwZXJjZW50YWdlRVUzZGVjUG9zICAgICAgICAgPSBBdXRvTnVtZXJpY0hlbHBlci5jbG9uZU9iamVjdChwZXJjZW50YWdlRVUyZGVjUG9zKTtcbnBlcmNlbnRhZ2VFVTNkZWNQb3MuZGVjaW1hbFBsYWNlcyA9IDM7XG5jb25zdCBwZXJjZW50YWdlRVUzZGVjTmVnICAgICAgICAgPSBBdXRvTnVtZXJpY0hlbHBlci5jbG9uZU9iamVjdChwZXJjZW50YWdlRVUyZGVjTmVnKTtcbnBlcmNlbnRhZ2VFVTNkZWNOZWcuZGVjaW1hbFBsYWNlcyA9IDM7XG5cbmNvbnN0IGRvbGxhclBvcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gQXV0b051bWVyaWNIZWxwZXIuY2xvbmVPYmplY3QoZG9sbGFyKTtcbmRvbGxhclBvcy5taW5pbXVtVmFsdWUgICAgICAgICAgICAgICAgICAgICAgID0gMDtcbmNvbnN0IGRvbGxhck5lZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gQXV0b051bWVyaWNIZWxwZXIuY2xvbmVPYmplY3QoZG9sbGFyKTtcbmRvbGxhck5lZy5tYXhpbXVtVmFsdWUgICAgICAgICAgICAgICAgICAgICAgID0gMDtcbmRvbGxhck5lZy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCAgICAgID0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5wcmVmaXg7XG5jb25zdCBkb2xsYXJOZWdCcmFja2V0cyAgICAgICAgICAgICAgICAgICAgICA9IEF1dG9OdW1lcmljSGVscGVyLmNsb25lT2JqZWN0KGRvbGxhck5lZyk7XG5kb2xsYXJOZWdCcmFja2V0cy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciA9IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIucGFyZW50aGVzZXM7XG5cbmNvbnN0IHBlcmNlbnRhZ2VVUzJkZWMgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBBdXRvTnVtZXJpY0hlbHBlci5jbG9uZU9iamVjdChkb2xsYXIpO1xucGVyY2VudGFnZVVTMmRlYy5jdXJyZW5jeVN5bWJvbCAgICAgICAgICAgICAgICAgICA9IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2wubm9uZTtcbnBlcmNlbnRhZ2VVUzJkZWMuc3VmZml4VGV4dCAgICAgICAgICAgICAgICAgICAgICAgPSBBdXRvTnVtZXJpYy5vcHRpb25zLnN1ZmZpeFRleHQucGVyY2VudGFnZTtcbnBlcmNlbnRhZ2VVUzJkZWMud2hlZWxTdGVwICAgICAgICAgICAgICAgICAgICAgICAgPSAwLjAwMDE7XG5wZXJjZW50YWdlRVUyZGVjLnJhd1ZhbHVlRGl2aXNvciAgICAgICAgICAgICAgICAgID0gQXV0b051bWVyaWMub3B0aW9ucy5yYXdWYWx1ZURpdmlzb3IucGVyY2VudGFnZTtcbmNvbnN0IHBlcmNlbnRhZ2VVUzJkZWNQb3MgICAgICAgICAgICAgICAgICAgICAgICAgPSBBdXRvTnVtZXJpY0hlbHBlci5jbG9uZU9iamVjdChwZXJjZW50YWdlVVMyZGVjKTtcbnBlcmNlbnRhZ2VVUzJkZWNQb3MubWluaW11bVZhbHVlICAgICAgICAgICAgICAgICAgPSAwO1xuY29uc3QgcGVyY2VudGFnZVVTMmRlY05lZyAgICAgICAgICAgICAgICAgICAgICAgICA9IEF1dG9OdW1lcmljSGVscGVyLmNsb25lT2JqZWN0KHBlcmNlbnRhZ2VVUzJkZWMpO1xucGVyY2VudGFnZVVTMmRlY05lZy5tYXhpbXVtVmFsdWUgICAgICAgICAgICAgICAgICA9IDA7XG5wZXJjZW50YWdlVVMyZGVjTmVnLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID0gQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5wcmVmaXg7XG5cbmNvbnN0IHBlcmNlbnRhZ2VVUzNkZWMgICAgICAgICAgICA9IEF1dG9OdW1lcmljSGVscGVyLmNsb25lT2JqZWN0KHBlcmNlbnRhZ2VVUzJkZWMpO1xucGVyY2VudGFnZVVTM2RlYy5kZWNpbWFsUGxhY2VzICAgID0gMztcbmNvbnN0IHBlcmNlbnRhZ2VVUzNkZWNQb3MgICAgICAgICA9IEF1dG9OdW1lcmljSGVscGVyLmNsb25lT2JqZWN0KHBlcmNlbnRhZ2VVUzJkZWNQb3MpO1xucGVyY2VudGFnZVVTM2RlY1Bvcy5kZWNpbWFsUGxhY2VzID0gMztcbmNvbnN0IHBlcmNlbnRhZ2VVUzNkZWNOZWcgICAgICAgICA9IEF1dG9OdW1lcmljSGVscGVyLmNsb25lT2JqZWN0KHBlcmNlbnRhZ2VVUzJkZWNOZWcpO1xucGVyY2VudGFnZVVTM2RlY05lZy5kZWNpbWFsUGxhY2VzID0gMztcblxuLyoqXG4gKiBQcmVkZWZpbmVkIG9wdGlvbnMgZm9yIHRoZSBtb3N0IGNvbW1vbiBsYW5ndWFnZXNcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEF1dG9OdW1lcmljLCAncHJlZGVmaW5lZE9wdGlvbnMnLCB7XG4gICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXVybyxcbiAgICAgICAgICAgIGV1cm9Qb3MsXG4gICAgICAgICAgICBldXJvTmVnLFxuICAgICAgICAgICAgZXVyb1NwYWNlLFxuICAgICAgICAgICAgZXVyb1NwYWNlUG9zLFxuICAgICAgICAgICAgZXVyb1NwYWNlTmVnLFxuICAgICAgICAgICAgcGVyY2VudGFnZUVVMmRlYyxcbiAgICAgICAgICAgIHBlcmNlbnRhZ2VFVTJkZWNQb3MsXG4gICAgICAgICAgICBwZXJjZW50YWdlRVUyZGVjTmVnLFxuICAgICAgICAgICAgcGVyY2VudGFnZUVVM2RlYyxcbiAgICAgICAgICAgIHBlcmNlbnRhZ2VFVTNkZWNQb3MsXG4gICAgICAgICAgICBwZXJjZW50YWdlRVUzZGVjTmVnLFxuICAgICAgICAgICAgZG9sbGFyLFxuICAgICAgICAgICAgZG9sbGFyUG9zLFxuICAgICAgICAgICAgZG9sbGFyTmVnLFxuICAgICAgICAgICAgZG9sbGFyTmVnQnJhY2tldHMsXG4gICAgICAgICAgICBwZXJjZW50YWdlVVMyZGVjLFxuICAgICAgICAgICAgcGVyY2VudGFnZVVTMmRlY1BvcyxcbiAgICAgICAgICAgIHBlcmNlbnRhZ2VVUzJkZWNOZWcsXG4gICAgICAgICAgICBwZXJjZW50YWdlVVMzZGVjLFxuICAgICAgICAgICAgcGVyY2VudGFnZVVTM2RlY1BvcyxcbiAgICAgICAgICAgIHBlcmNlbnRhZ2VVUzNkZWNOZWcsXG4gICAgICAgICAgICBGcmVuY2ggICAgICAgICAgICAgICAgICAgICAgOiBldXJvLCAvLyBGcmFuw6dhaXNcbiAgICAgICAgICAgIFNwYW5pc2ggICAgICAgICAgICAgICAgICAgICA6IGV1cm8sIC8vIEVzcGHDsW9sXG4gICAgICAgICAgICBOb3J0aEFtZXJpY2FuICAgICAgICAgICAgICAgOiBkb2xsYXIsXG4gICAgICAgICAgICBCcml0aXNoICAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvci5jb21tYSxcbiAgICAgICAgICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyLmRvdCxcbiAgICAgICAgICAgICAgICBjdXJyZW5jeVN5bWJvbCAgICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbC5wb3VuZCxcbiAgICAgICAgICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5wcmVmaXgsXG4gICAgICAgICAgICAgICAgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucmlnaHQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgU3dpc3MgICAgICAgICAgICAgICAgICAgICAgIDogeyAvLyBTdWlzc2VcbiAgICAgICAgICAgICAgICBkaWdpdEdyb3VwU2VwYXJhdG9yICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLmFwb3N0cm9waGUsXG4gICAgICAgICAgICAgICAgZGVjaW1hbENoYXJhY3RlciAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbENoYXJhY3Rlci5kb3QsXG4gICAgICAgICAgICAgICAgY3VycmVuY3lTeW1ib2wgICAgICAgICAgICAgICA6ICdcXHUyMDJmQ0hGJyxcbiAgICAgICAgICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudC5zdWZmaXgsXG4gICAgICAgICAgICAgICAgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IEF1dG9OdW1lcmljLm9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQucHJlZml4LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEphcGFuZXNlICAgICAgICAgICAgICAgICAgICA6IGphcGFuZXNlLCAvLyDml6XmnKzoqp5cbiAgICAgICAgICAgIENoaW5lc2UgICAgICAgICAgICAgICAgICAgICA6IGphcGFuZXNlLCAvLyDkuK3lm73oqp4gKENoaW5lc2UpXG4gICAgICAgICAgICBCcmF6aWxpYW4gICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvci5kb3QsXG4gICAgICAgICAgICAgICAgZGVjaW1hbENoYXJhY3RlciAgICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbENoYXJhY3Rlci5jb21tYSxcbiAgICAgICAgICAgICAgICBjdXJyZW5jeVN5bWJvbCAgICAgICAgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbC5yZWFsLFxuICAgICAgICAgICAgICAgIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ICAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LnByZWZpeCxcbiAgICAgICAgICAgICAgICBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogQXV0b051bWVyaWMub3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudC5yaWdodCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb3REZWNpbWFsQ2hhckNvbW1hU2VwYXJhdG9yOiB7XG4gICAgICAgICAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvcjogQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLmNvbW1hLFxuICAgICAgICAgICAgICAgIGRlY2ltYWxDaGFyYWN0ZXIgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbENoYXJhY3Rlci5kb3QsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tbWFEZWNpbWFsQ2hhckRvdFNlcGFyYXRvcjoge1xuICAgICAgICAgICAgICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3IgICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLmRvdCxcbiAgICAgICAgICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbENoYXJhY3Rlci5jb21tYSxcbiAgICAgICAgICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmU6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlLmRvdCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnRlZ2VyICAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbFBsYWNlczogMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnRlZ2VyUG9zICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgbWluaW11bVZhbHVlIDogQXV0b051bWVyaWMub3B0aW9ucy5taW5pbXVtVmFsdWUuemVybyxcbiAgICAgICAgICAgICAgICBkZWNpbWFsUGxhY2VzOiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGludGVnZXJOZWcgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBtYXhpbXVtVmFsdWUgOiBBdXRvTnVtZXJpYy5vcHRpb25zLm1heGltdW1WYWx1ZS56ZXJvLFxuICAgICAgICAgICAgICAgIGRlY2ltYWxQbGFjZXM6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmxvYXQgICAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGFsbG93RGVjaW1hbFBhZGRpbmc6IEF1dG9OdW1lcmljLm9wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZy5uZXZlcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmbG9hdFBvcyAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgYWxsb3dEZWNpbWFsUGFkZGluZzogQXV0b051bWVyaWMub3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nLm5ldmVyLFxuICAgICAgICAgICAgICAgIG1pbmltdW1WYWx1ZSAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMubWluaW11bVZhbHVlLnplcm8sXG4gICAgICAgICAgICAgICAgbWF4aW11bVZhbHVlICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5tYXhpbXVtVmFsdWUudGVuVHJpbGxpb25zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZsb2F0TmVnICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBhbGxvd0RlY2ltYWxQYWRkaW5nOiBBdXRvTnVtZXJpYy5vcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmcubmV2ZXIsXG4gICAgICAgICAgICAgICAgbWluaW11bVZhbHVlICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5taW5pbXVtVmFsdWUudGVuVHJpbGxpb25zLFxuICAgICAgICAgICAgICAgIG1heGltdW1WYWx1ZSAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMubWF4aW11bVZhbHVlLnplcm8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbnVtZXJpYyAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3I6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvci5ub1NlcGFyYXRvcixcbiAgICAgICAgICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXIuZG90LFxuICAgICAgICAgICAgICAgIGN1cnJlbmN5U3ltYm9sICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuY3VycmVuY3lTeW1ib2wubm9uZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudW1lcmljUG9zICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvcjogQXV0b051bWVyaWMub3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLm5vU2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgIGRlY2ltYWxDaGFyYWN0ZXIgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMuZGVjaW1hbENoYXJhY3Rlci5kb3QsXG4gICAgICAgICAgICAgICAgY3VycmVuY3lTeW1ib2wgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5jdXJyZW5jeVN5bWJvbC5ub25lLFxuICAgICAgICAgICAgICAgIG1pbmltdW1WYWx1ZSAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMubWluaW11bVZhbHVlLnplcm8sXG4gICAgICAgICAgICAgICAgbWF4aW11bVZhbHVlICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5tYXhpbXVtVmFsdWUudGVuVHJpbGxpb25zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG51bWVyaWNOZWcgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBkaWdpdEdyb3VwU2VwYXJhdG9yOiBBdXRvTnVtZXJpYy5vcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3Iubm9TZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgZGVjaW1hbENoYXJhY3RlciAgIDogQXV0b051bWVyaWMub3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyLmRvdCxcbiAgICAgICAgICAgICAgICBjdXJyZW5jeVN5bWJvbCAgICAgOiBBdXRvTnVtZXJpYy5vcHRpb25zLmN1cnJlbmN5U3ltYm9sLm5vbmUsXG4gICAgICAgICAgICAgICAgbWluaW11bVZhbHVlICAgICAgIDogQXV0b051bWVyaWMub3B0aW9ucy5taW5pbXVtVmFsdWUudGVuVHJpbGxpb25zLFxuICAgICAgICAgICAgICAgIG1heGltdW1WYWx1ZSAgICAgICA6IEF1dG9OdW1lcmljLm9wdGlvbnMubWF4aW11bVZhbHVlLnplcm8sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9BdXRvTnVtZXJpY1ByZWRlZmluZWRPcHRpb25zLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n'use strict';\n\nvar _AutoNumeric = __webpack_require__(1);\n\nvar _AutoNumeric2 = _interopRequireDefault(_AutoNumeric);\n\nvar _AutoNumericEvents = __webpack_require__(6);\n\nvar _AutoNumericEvents2 = _interopRequireDefault(_AutoNumericEvents);\n\nvar _AutoNumericOptions = __webpack_require__(4);\n\nvar _AutoNumericOptions2 = _interopRequireDefault(_AutoNumericOptions);\n\nvar _AutoNumericDefaultSettings = __webpack_require__(5);\n\nvar _AutoNumericDefaultSettings2 = _interopRequireDefault(_AutoNumericDefaultSettings);\n\nvar _AutoNumericPredefinedOptions = __webpack_require__(7);\n\nvar _AutoNumericPredefinedOptions2 = _interopRequireDefault(_AutoNumericPredefinedOptions);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint no-unused-vars: 0 */\n\n/**\n * This file serve as the main entry point to the library.\n * cf. workaround detailed here http://stackoverflow.com/a/33683495/2834898\n *\n * @type {AutoNumeric}\n */\nmodule.exports = _AutoNumeric2.default;\n//TODO Also export the AutoNumericEnum module\n/**\n * Babel + Webpack workaround for autoNumeric\n *\n * @author Alexandre Bonneau <alexandre.bonneau@linuxfr.eu>\n * @copyright © 2017 Alexandre Bonneau\n *\n * The MIT License (http://www.opensource.org/licenses/mit-license.php)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sub license, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/* global module */\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz8zNDc5Il0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBZ0NBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBOztBQUVBOzs7Ozs7QUFNQUEsT0FBT0MsT0FBUDtBQUNBO0FBL0NBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4QkEsbUIiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQmFiZWwgKyBXZWJwYWNrIHdvcmthcm91bmQgZm9yIGF1dG9OdW1lcmljXG4gKlxuICogQGF1dGhvciBBbGV4YW5kcmUgQm9ubmVhdSA8YWxleGFuZHJlLmJvbm5lYXVAbGludXhmci5ldT5cbiAqIEBjb3B5cmlnaHQgwqkgMjAxNyBBbGV4YW5kcmUgQm9ubmVhdVxuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHApXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3ViIGxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gKiBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAqIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuICogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZ2xvYmFsIG1vZHVsZSAqL1xuXG5pbXBvcnQgQXV0b051bWVyaWMgZnJvbSAnLi9BdXRvTnVtZXJpYyc7XG5pbXBvcnQgQXV0b051bWVyaWNFdmVudHMgZnJvbSAnLi9BdXRvTnVtZXJpY0V2ZW50cyc7XG5pbXBvcnQgQXV0b051bWVyaWNPcHRpb25zIGZyb20gJy4vQXV0b051bWVyaWNPcHRpb25zJztcbmltcG9ydCBBdXRvTnVtZXJpY0RlZmF1bHRTZXR0aW5ncyBmcm9tICcuL0F1dG9OdW1lcmljRGVmYXVsdFNldHRpbmdzJztcbmltcG9ydCBBdXRvTnVtZXJpY1ByZWRlZmluZWRPcHRpb25zIGZyb20gJy4vQXV0b051bWVyaWNQcmVkZWZpbmVkT3B0aW9ucyc7XG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogMCAqL1xuXG4vKipcbiAqIFRoaXMgZmlsZSBzZXJ2ZSBhcyB0aGUgbWFpbiBlbnRyeSBwb2ludCB0byB0aGUgbGlicmFyeS5cbiAqIGNmLiB3b3JrYXJvdW5kIGRldGFpbGVkIGhlcmUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzM2ODM0OTUvMjgzNDg5OFxuICpcbiAqIEB0eXBlIHtBdXRvTnVtZXJpY31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBdXRvTnVtZXJpYztcbi8vVE9ETyBBbHNvIGV4cG9ydCB0aGUgQXV0b051bWVyaWNFbnVtIG1vZHVsZVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21haW4uanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;